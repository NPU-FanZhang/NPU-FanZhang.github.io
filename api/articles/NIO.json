{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"content":"<h2 id=\"1-NIO基础\"><a href=\"#1-NIO基础\" class=\"headerlink\" title=\"1. NIO基础\"></a>1. NIO基础</h2><p><strong>NIO - Non-blocking IO</strong> 或 <strong>New IO</strong></p>\n<h3 id=\"a-NIO的三大核心-Channel、Buffer、Selector\"><a href=\"#a-NIO的三大核心-Channel、Buffer、Selector\" class=\"headerlink\" title=\"a. NIO的三大核心-Channel、Buffer、Selector\"></a>a. NIO的三大核心-Channel、Buffer、Selector</h3><h4 id=\"1-Channel-与-Buffer\"><a href=\"#1-Channel-与-Buffer\" class=\"headerlink\" title=\"1. Channel 与 Buffer\"></a>1. Channel 与 Buffer</h4><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)。</strong></p>\n<p>通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于<strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理。简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p>\n<p><strong>常见的Channel有以下四种</strong></p>\n<ul>\n<li><code>FileChannel</code>    主要用于文件传输</li>\n<li><code>DatagramChannel</code>   </li>\n<li><code>SocketChannel</code></li>\n<li><code>ServerSocketChannel</code></li>\n</ul>\n<p>其中FileChannel主要用于文件传输，其余三种用于网络通信</p>\n<p><strong>Buffer有以下几种</strong>，其中使用较多的是<strong>ByteBuffer</strong></p>\n<ul>\n<li><code>ByteBuffer</code>  常用<ul>\n<li>MappedByteBuffer</li>\n<li>DirectByteBuffer</li>\n<li>HeapByteBuffer</li>\n</ul>\n</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>CharBuffer</li>\n</ul>\n<h4 id=\"2-Selector\"><a href=\"#2-Selector\" class=\"headerlink\" title=\"2. Selector\"></a>2. Selector</h4><p>在使用Selector之前，服务器处理socket连接还有以下两种方法</p>\n<p><strong>a. 服务器使用多线程技术</strong></p>\n<p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p>\n<img src=\"/post/NIO/20210418181918.png\" class=\"\" title=\"img\">\n\n<p>这种方法存在以下几个问题</p>\n<ul>\n<li>内存占用高<ul>\n<li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li>\n</ul>\n</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景<ul>\n<li>连接数过多，会导致创建很多线程，从而出现问题</li>\n</ul>\n</li>\n</ul>\n<p><strong>b. 服务器使用线程池技术</strong></p>\n<p>使用线程池，让线程池中的线程去处理连接</p>\n<img src=\"/post/NIO/20210418181933.png\" class=\"\" title=\"img\">\n\n<p>这种方法存在以下几个问题</p>\n<ul>\n<li><strong>阻塞模式下，线程仅能处理一个连接</strong><ul>\n<li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li>\n<li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li>\n</ul>\n</li>\n<li>仅适合<strong>短连接</strong>场景<ul>\n<li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li>\n</ul>\n</li>\n</ul>\n<p><strong>c.服务器使用selector技术</strong></p>\n<p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p>\n<p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理。</p>\n<img src=\"/post/NIO/20210418181947.png\" class=\"\" title=\"img\">\n\n<h3 id=\"b-ByteBuffer\"><a href=\"#b-ByteBuffer\" class=\"headerlink\" title=\"b. ByteBuffer\"></a>b. ByteBuffer</h3><h4 id=\"1-使用方式\"><a href=\"#1-使用方式\" class=\"headerlink\" title=\"1. 使用方式\"></a>1. 使用方式</h4><ul>\n<li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p>\n</li>\n<li><p>调用 flip() 切换至读模式</p>\n<ul>\n<li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li>\n</ul>\n</li>\n<li><p>从 buffer 读取数据，例如调用 buffer.get()</p>\n</li>\n<li><p>调用 clear() 或者compact()切换至</p>\n<p>写模式</p>\n<ul>\n<li>调用clear()方法时<strong>position&#x3D;0，limit变为capacity</strong></li>\n<li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li>\n</ul>\n</li>\n<li><p>重复以上步骤</p>\n</li>\n</ul>\n<p><strong>使用ByteBuffer读取文件中的内容</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; FileChannel\n    &#x2F;&#x2F; 1. 使用输入输出流来获取 2. RandomAccessFile\n    try &#123;\n        &#x2F;&#x2F; 获取通道\n        FileChannel channel &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel();\n        &#x2F;&#x2F; 准备缓冲区\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);\n        &#x2F;&#x2F; 从channel 读取数据,向buffer写入\n        &#x2F;&#x2F; return : The number of bytes read, possibly zero, or -1 if the channel has reached\n        &#x2F;&#x2F; end-of-stream\n        int len &#x3D; channel.read(buffer);\n        &#x2F;&#x2F; 每次读缓冲区大小的数据,循环读,知道文件读完\n        while (len !&#x3D; -1)&#123;\n            &#x2F;&#x2F; 打印验证\n            buffer.flip(); &#x2F;&#x2F; 切换至读模式\n            while (buffer.hasRemaining()) &#123;\n                byte b &#x3D; buffer.get();&#x2F;&#x2F; 无参代表一次读一个字节\n                System.out.print((char) b);\n            &#125;\n            buffer.clear();&#x2F;&#x2F; 切换为写模式 不加会死循环,一直循环读前是个字节\n            len &#x3D; channel.read(buffer);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-ByteBuffer-结构\"><a href=\"#2-ByteBuffer-结构\" class=\"headerlink\" title=\"2. ByteBuffer 结构\"></a>2. ByteBuffer 结构</h4><h5 id=\"a-核心属性\"><a href=\"#a-核心属性\" class=\"headerlink\" title=\"a. 核心属性\"></a>a. 核心属性</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity\nprivate int mark &#x3D; -1;\nprivate int position &#x3D; 0;\nprivate int limit;\nprivate int capacity;</code></pre>\n\n<ul>\n<li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>\n<li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li>\n<li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li>\n<li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li>\n</ul>\n<p>以上四个属性必须满足以下要求</p>\n<ul>\n<li><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></li>\n</ul>\n<h5 id=\"b-核心方法\"><a href=\"#b-核心方法\" class=\"headerlink\" title=\"b. 核心方法\"></a>b. 核心方法</h5><p><strong>put()方法</strong></p>\n<ul>\n<li>put()方法可以将一个数据放入到缓冲区中。</li>\n<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>\n</ul>\n<img src=\"NIO/20201109145709.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n<p><strong>flip()方法</strong></p>\n<ul>\n<li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写</li>\n<li>进行该操作后<ul>\n<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li>\n<li>如果是读-&gt;写，则恢复为put()方法中的值</li>\n</ul>\n</li>\n</ul>\n<img src=\"NIO/20201109145753.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>get()方法</strong></p>\n<ul>\n<li>get()方法会读取缓冲区中的一个值</li>\n<li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li>\n<li><strong>注意：get(i)方法不会改变position的值</strong></li>\n</ul>\n<img src=\"NIO/20201109145822.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>rewind()方法</strong></p>\n<ul>\n<li>该方法<strong>只能在读模式下使用</strong></li>\n<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li>\n</ul>\n<img src=\"NIO/20201109145852.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<p><strong>clean()方法</strong></p>\n<ul>\n<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li>\n<li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li>\n</ul>\n<img src=\"NIO/20201109145905.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>mark()和reset()方法</strong></p>\n<ul>\n<li>mark()方法会将postion的值保存到mark属性中</li>\n<li>reset()方法会将position的值改为mark中保存的值</li>\n</ul>\n<p><strong>compact()方法</strong></p>\n<p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p>\n<ul>\n<li>compact会把未读完的数据向前压缩，然后切换到写模式</li>\n<li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li>\n</ul>\n<img src=\"NIO/20210412155726.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n<p><strong>clear() VS compact()</strong></p>\n<p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>\n<p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p>\n<h4 id=\"3-字符串和-ByteBuffer-之间的转换\"><a href=\"#3-字符串和-ByteBuffer-之间的转换\" class=\"headerlink\" title=\"3. 字符串和 ByteBuffer 之间的转换\"></a>3. 字符串和 ByteBuffer 之间的转换</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 字符串和 ByteBuffer 之间的转换\npublic static void testByteBufferString() &#123;\n    &#x2F;&#x2F; 字符串转为 byteBuffer\n    &#x2F;&#x2F; 1. String 的 getBytes方法\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    buffer.put(&quot;hello&quot;.getBytes());\n    &#x2F;&#x2F; 2. StandardCharsets.UTF_8.encode 方法\n    ByteBuffer buffer2 &#x3D; StandardCharsets.UTF_8.encode(&quot;输出Hell&quot;);\n    &#x2F;&#x2F; 3. ByteBuffer.wrap\n    ByteBuffer buffer3 &#x3D; ByteBuffer.wrap(&quot;hello&quot;.getBytes());\n\n    &#x2F;&#x2F; byteBuffer转为字符串\n    String string &#x3D; StandardCharsets.UTF_8.decode(buffer2).toString();\n    &#x2F;&#x2F; buffer2的pos指针已经在第一个位置,可以直接转换\n    System.out.println(string);\n    buffer.flip();\n    String string2 &#x3D; StandardCharsets.UTF_8.decode(buffer).toString();\n    &#x2F;&#x2F; buffer1的pos指针不在第一个位置,要先转换模式\n    System.out.println(string2);\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-粘包半包处理\"><a href=\"#4-粘包半包处理\" class=\"headerlink\" title=\"4. 粘包半包处理\"></a>4. 粘包半包处理</h4><p><strong>现象</strong></p>\n<p>网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>\n<ul>\n<li>Hello,world\\n</li>\n<li>I’m Nyima\\n</li>\n<li>How are you?\\n</li>\n</ul>\n<p>变成了下面的两个 byteBuffer (粘包，半包)</p>\n<ul>\n<li>Hello,world\\nI’m Nyima\\nHo</li>\n<li>w are you?\\n</li>\n</ul>\n<p><strong>出现原因</strong></p>\n<ul>\n<li><p><strong>粘包</strong>:发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p>\n</li>\n<li><p><strong>半包</strong>:接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p>\n</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p>\n<p>注意</p>\n<p>：get(index)不会改变position的值</p>\n<ul>\n<li>记录该段数据长度，以便于申请对应大小的缓冲区</li>\n<li>将缓冲区的数据通过get()方法写入到target中</li>\n</ul>\n</li>\n<li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void testByteBufferExam() &#123;\n    &#x2F;*\n\t\t网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n\t\t但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\t\tHello,world\\n\n\t\tI’m Nyima\\n\n\t\tHow are you?\\n\n\t\t变成了下面的两个 byteBuffer (粘包，半包)\n\t\tHello,world\\nI’m Nyima\\nHo\n\t\tw are you?\\n\n    *&#x2F;\n    &#x2F;&#x2F; 接收到被分割的信息\n    ByteBuffer source &#x3D; ByteBuffer.allocate(32);\n    source.put(&quot;Hello,world\\nI’m Nyima\\nHo&quot;.getBytes());\n    &#x2F;&#x2F; 进行分割\n    split(source);\n    source.put(&quot;w are you?\\n&quot;.getBytes());\n    split(source);\n&#125;\n\npublic static void split(ByteBuffer source) &#123;\n    &#x2F;&#x2F; 切换读模式\n    source.flip();\n    for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n        &#x2F;&#x2F; 找到一个换行符则有一条消息\n        if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n            &#x2F;&#x2F; 把消息存入新的ByteBuffer\n            int len &#x3D; i + 1 - source.position(); &#x2F;&#x2F; 计算两个 \\n 之间内容的长度\n            ByteBuffer tar &#x3D; ByteBuffer.allocate(len);\n            for (int j &#x3D; 0; j &lt; len; j++) &#123;\n                tar.put(source.get());\n            &#125;\n            tar.flip(); &#x2F;&#x2F; 切换模式,让指针指向起始\n             System.out.print(StandardCharsets.UTF_8.decode(tar).toString());\n            tar.flip();\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 没读完,前推\n    source.compact();\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">+--------+-------------------- all ------------------------+----------------+\nposition: [12], limit: [12]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [10], limit: [10]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#39;m Nyima.      |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [13], limit: [13]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h3 id=\"c-文件编程\"><a href=\"#c-文件编程\" class=\"headerlink\" title=\"c. 文件编程\"></a>c. 文件编程</h3><h4 id=\"1-FileChannel\"><a href=\"#1-FileChannel\" class=\"headerlink\" title=\"1. FileChannel\"></a>1. FileChannel</h4><blockquote><p><strong>FileChannel只能工作在阻塞模式</strong>下，所以无法搭配Selector</p></blockquote>\n<h5 id=\"a-获取\"><a href=\"#a-获取\" class=\"headerlink\" title=\"a. 获取\"></a>a. 获取</h5><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li>\n<li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li>\n<li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li>\n</ul>\n<h5 id=\"b-读取\"><a href=\"#b-读取\" class=\"headerlink\" title=\"b. 读取\"></a>b. 读取</h5><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p>\n<p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int readBytes &#x3D; channel.read(buffer);</code></pre>\n\n<p><strong>可根据返回值判断是否读取完毕</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while(channel.read(buffer) &gt; 0) &#123;\n    &#x2F;&#x2F; 进行对应操作\n    ...\n&#125;</code></pre>\n\n\n\n<h5 id=\"c-写入\"><a href=\"#c-写入\" class=\"headerlink\" title=\"c. 写入\"></a>c. 写入</h5><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中\nwhile(buffer.hasRemaining()) &#123;\n\tchannel.write(buffer);\n&#125;</code></pre>\n\n\n\n<h5 id=\"d-关闭\"><a href=\"#d-关闭\" class=\"headerlink\" title=\"d. 关闭\"></a>d. 关闭</h5><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 执行对应操作\n            ...\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"e-位置-position\"><a href=\"#e-位置-position\" class=\"headerlink\" title=\"e.位置 position\"></a>e.位置 position</h5><p>channel也拥有一个保存读取数据位置的属性，即position</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long pos &#x3D; channel.position();</code></pre>\n\n<p>可以通过position(int pos)设置channel中position的值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long newPos &#x3D; ...;\nchannel.position(newPos);</code></pre>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1</li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h5 id=\"f-强制写入\"><a href=\"#f-强制写入\" class=\"headerlink\" title=\"f. 强制写入\"></a>f. 强制写入</h5><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>\n<h4 id=\"2-两个Channel传输数据\"><a href=\"#2-两个Channel传输数据\" class=\"headerlink\" title=\"2. 两个Channel传输数据\"></a>2. 两个Channel传输数据</h4><p><strong>transferTo方法</strong></p>\n<p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p>\n<p><strong>transferTo底层使用了零拷贝技术</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 参数：inputChannel的起始位置，传输数据的大小，目的channel\n            &#x2F;&#x2F; 返回值为传输的数据的字节数\n            &#x2F;&#x2F; transferTo一次只能传输2G的数据\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            long size &#x3D; inputChannel.size();\n            long capacity &#x3D; inputChannel.size();\n            &#x2F;&#x2F; 分多次传输\n            while (capacity &gt; 0) &#123;\n                &#x2F;&#x2F; transferTo返回值为传输了的字节数\n                capacity -&#x3D; inputChannel.transferTo(size-capacity, capacity, outputChannel);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Path\"><a href=\"#3-Path\" class=\"headerlink\" title=\"3. Path\"></a>3. Path</h4><ul>\n<li>Path 用来表示文件路径</li>\n<li>Paths 是工具类，用来获取 Path 实例</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt\n\nPath source &#x3D; Paths.get(&quot;d:\\\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\\1.txt 反斜杠需要转义\n\nPath source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\\1.txt\n\nPath projects &#x3D; Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\\data\\projects</code></pre>\n\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">d:\n|- data\n\t|- projects\n\t\t|- a\n\t\t|- bCopy</code></pre>\n\n<p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);\nSystem.out.println(path);\nSystem.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径 会去除 . 以及 ..</code></pre>\n\n<p>输出结果为</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">d:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b</code></pre>\n\n<h4 id=\"4-Files\"><a href=\"#4-Files\" class=\"headerlink\" title=\"4. Files\"></a>4. Files</h4><h5 id=\"a-查找\"><a href=\"#a-查找\" class=\"headerlink\" title=\"a. 查找\"></a>a. 查找</h5><p>检查文件是否存在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nSystem.out.println(Files.exists(path));</code></pre>\n\n<h5 id=\"b-创建\"><a href=\"#b-创建\" class=\"headerlink\" title=\"b. 创建\"></a>b. 创建</h5><p>创建<strong>一级目录</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.createDirectory(path);</code></pre>\n\n<ul>\n<li>如果目录已存在，会抛异常 <code>FileAlreadyExistsException</code></li>\n<li>不能一次创建多级目录，否则会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n<p>创建<strong>多级目录用</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);\nFiles.createDirectories(path);</code></pre>\n\n<h5 id=\"c-拷贝及移动\"><a href=\"#c-拷贝及移动\" class=\"headerlink\" title=\"c. 拷贝及移动\"></a>c. 拷贝及移动</h5><p><strong>拷贝文件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.copy(source, target);</code></pre>\n\n<ul>\n<li>如果文件已存在，会抛异常 <code>FileAlreadyExistsException</code></li>\n</ul>\n<p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 <code>StandardCopyOption</code> 来控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre>\n\n<p>移动文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code></pre>\n\n<ul>\n<li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li>\n</ul>\n<h5 id=\"d-删除\"><a href=\"#d-删除\" class=\"headerlink\" title=\"d. 删除\"></a>d. 删除</h5><p>删除文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果文件不存在，会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n<p>删除目录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果<strong>目录还有内容</strong>，会抛异常 <code>DirectoryNotEmptyException</code></li>\n<li>只能删除空目录</li>\n</ul>\n<h5 id=\"e-遍历目录\"><a href=\"#e-遍历目录\" class=\"headerlink\" title=\"e. 遍历目录\"></a>e. 遍历目录</h5><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p>\n<ul>\n<li><p>Path：文件起始路径</p>\n</li>\n<li><p><code>FileVisitor</code>：文件访问器，</p>\n<p>使用访问者模式</p>\n<ul>\n<li>接口的实现类<code>SimpleFileVisitor</code>有四个方法<ul>\n<li><code>preVisitDirectory</code>：访问目录前的操作</li>\n<li><code>visitFile</code>：访问文件的操作</li>\n<li><code>visitFileFailed</code>：访问文件失败时的操作</li>\n<li><code>postVisitDirectory</code>：访问目录后的操作</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void testFilesWalkFileTree() throws IOException &#123;\n    final AtomicInteger dirCnt &#x3D; new AtomicInteger();\n    final AtomicInteger fileCnt &#x3D; new AtomicInteger();\n    Files.walkFileTree(Paths.get(&quot;C:\\\\Users\\\\Lenovo\\\\.jdks\\\\corretto-1.8.0_302&quot;), new SimpleFileVisitor&lt;Path&gt;() &#123;\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&gt;&quot; + dir);\n            dirCnt.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        &#125;\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(file);\n            fileCnt.incrementAndGet();\n            return super.visitFile(file, attrs);\n        &#125;\n    &#125;);\n    System.out.println(&quot;dir count &quot; + dirCnt);\n    System.out.println(&quot;file count &quot; + fileCnt);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">...\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\index.html\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\CustomAutoCloseableSample.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\Unzip.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\ZipCat.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\src.zip\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\THIRD_PARTY_README\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\version.txt\ndir count 166\nfile count 701</code></pre>\n\n\n\n<h2 id=\"2-网络编程\"><a href=\"#2-网络编程\" class=\"headerlink\" title=\"2. 网络编程\"></a>2. 网络编程</h2><h3 id=\"a-阻塞模式\"><a href=\"#a-阻塞模式\" class=\"headerlink\" title=\"a. 阻塞模式\"></a>a. 阻塞模式</h3><ul>\n<li>阻塞模式下，相关方法都会导致线程暂停<ul>\n<li><code>ServerSocketChannel.accept</code> 会在<strong>没有连接建立时</strong>让线程暂停</li>\n<li><code>SocketChannel.read</code> 会在<strong>通道中没有数据可读时</strong>让线程暂停</li>\n<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>\n</ul>\n</li>\n<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>\n<li>但多线程下，有新的问题，体现在以下方面<ul>\n<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 <code>OOM</code>，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>\n<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>\n</ul>\n</li>\n</ul>\n<p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 使用NIO来理解阻塞模式\npublic static void testBlocking() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建服务器\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n    &#x2F;&#x2F; 2. 绑定监听端口\n    ssc.bind(new InetSocketAddress(8080));\n\n    &#x2F;&#x2F; 3. 建立客户端连接,可能有多个连接\n    List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 保存连接集合\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    while (true) &#123;\n        &#x2F;&#x2F; 4. SocketChannel用来与客户端通信\n        System.out.println(&quot;connecting..&quot;);\n        SocketChannel sc &#x3D; ssc.accept();\n        System.out.println(&quot;connected..&quot; + sc.toString());\n        channels.add(sc);\n        &#x2F;&#x2F; 5.接收客户端发送的数据\n        for (SocketChannel channel : channels) &#123;\n            System.out.println(&quot;Before read&quot;);\n            channel.read(buffer); &#x2F;&#x2F; 阻塞方法,如果没有数据可读会一直等待\n            buffer.flip();&#x2F;&#x2F; 切换读模式\n            System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n            buffer.clear();\n            System.out.println(&quot;After read&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        System.out.println(&quot;waiting&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<ul>\n<li><p>客户端-服务器建立连接前：服务器端因accept阻塞</p>\n<img src=\"/post/NIO/20210413213318.png\" class=\"\" title=\"img\">\n\n\n</li>\n<li><p>客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞</p>\n<img src=\"/post/NIO/20210413213446.png\" class=\"\" title=\"img\">\n</li>\n<li><p>客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞</p>\n<img src=\"/post/NIO/20210413214109.png\" class=\"\" title=\"img\">\n\n\n</li>\n<li><p>之前的客户端再次发送消息<strong>，服务器端因为被accept阻塞</strong>，无法处理之前客户端发送到通道中的信息</p>\n<img src=\"/post/NIO/20210413214505.png\" class=\"\" title=\"img\"></li>\n</ul>\n<h3 id=\"b-非阻塞模式\"><a href=\"#b-非阻塞模式\" class=\"headerlink\" title=\"b. 非阻塞模式\"></a>b. 非阻塞模式</h3><ul>\n<li>可以通过<code>ServerSocketChannel</code>的<code>configureBlocking(false)</code>方法将<strong>获得连接设置为非阻塞的</strong>。此时若没有连接，accept会返回null</li>\n<li>可以通过<code>SocketChannel</code>的<code>configureBlocking(false)</code>方法将从通道中<strong>读取数据设置为非阻塞的</strong>。若此时通道中没有数据可读，read会返回-1</li>\n</ul>\n<p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 理解非阻塞模式\npublic static void testNonBlocking() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建服务器\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n    &#x2F;&#x2F; 2. 绑定监听端口\n    ssc.bind(new InetSocketAddress(8080));\n    ssc.configureBlocking(false);\n\n    &#x2F;&#x2F; 3. 建立客户端连接,可能有多个连接\n    List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 保存连接集合\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    while (true) &#123;\n        &#x2F;&#x2F; 4. SocketChannel用来与客户端通信\n        &#x2F;&#x2F;System.out.println(&quot;connecting..&quot;);\n        SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 如果非阻塞,返回的是null\n        if (sc !&#x3D; null) &#123;\n            System.out.println(&quot;connected..&quot; + sc.toString());\n            sc.configureBlocking(false); &#x2F;&#x2F; 将SocketChannel设置为非阻塞\n            channels.add(sc);\n        &#125;\n        &#x2F;&#x2F; 5.接收客户端发送的数据\n        for (SocketChannel channel : channels) &#123;\n            &#x2F;&#x2F;System.out.println(&quot;Before read&quot;);\n            int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 阻塞方法,如果没有数据可读会一直等待\n            if (read &gt; 0) &#123;\n                buffer.flip();&#x2F;&#x2F; 切换读模式\n                System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n                buffer.clear();\n                System.out.println(&quot;After read&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 客户端不变\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        System.out.println(&quot;waiting&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求</strong></p>\n<img src=\"/post/NIO/image-20220413135220831.png\" class=\"\" title=\"image-20220413135220831\">\n\n\n\n<h3 id=\"c-Selector模式\"><a href=\"#c-Selector模式\" class=\"headerlink\" title=\"c. Selector模式\"></a>c. Selector模式</h3><h4 id=\"1-多路复用\"><a href=\"#1-多路复用\" class=\"headerlink\" title=\"1. 多路复用\"></a>1. 多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>\n<ul>\n<li><strong>多路复用仅针对网络 IO</strong>，普通文件 IO <strong>无法</strong>利用多路复用</li>\n<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>\n<li>有可连接事件时才去连接</li>\n<li>有可读事件才去读取</li>\n<li>有可写事件才去写入<ul>\n<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>要<strong>使用Selector实现多路复用</strong>，服务端代码如下改进</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Selector进行网络编程\npublic static void testSelector() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建Selector,管理多个Channel\n    Selector selector &#x3D; Selector.open();\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    &#x2F;&#x2F; 2. 建立selector和 channel之间的联系 (注册)\n    &#x2F;&#x2F; 将 channel注册到 选择器, 当有事件发生时,会返回一个selectionKey来告知是哪个channel发生的事件\n    SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n    &#x2F;&#x2F; 声明只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    System.out.println(&quot;sscKey -&gt; &quot;+sscKey);\n\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) &#123;\n        &#x2F;&#x2F; 3. 如何知道有没有发生事件\n        &#x2F;&#x2F; 选择器进行选择,如果没有 事件发生,则进行阻塞;有事件发生,程序继续向下运行\n        selector.select();\n\n        &#x2F;&#x2F; 4. 处理事件\n        &#x2F;&#x2F; selectedKeys包含了所有发生的事件\n        Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n        while (it.hasNext()) &#123;\n            SelectionKey key &#x3D; it.next();\n            System.out.println(&quot;key -&gt; &quot;+key);\n            &#x2F;&#x2F; 如果获取事件后不处理,会重复加入事件列表,不断循环\n            ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n            SocketChannel sc &#x3D; channel.accept();\n            System.out.println(&quot;sc -&gt; &quot;+sc);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>步骤解析:</strong></p>\n<ul>\n<li><p>获得选择器Selector</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Selector selector &#x3D; Selector.open();</code></pre>\n</li>\n<li><p>将<strong>通道设置为非阻塞模式</strong>，并注册到选择器中，并设置感兴趣的事件</p>\n<ul>\n<li>channel 必须工作在非阻塞模式</li>\n<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>\n<li>绑定的<code>事件类型</code>可以有<ul>\n<li>connect - 客户端连接成功时触发</li>\n<li>accept - 服务器端成功接受连接时触发</li>\n<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>\n<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\nssc.configureBlocking(false);\n&#x2F;&#x2F; 2. 建立selector和 channel之间的联系 (注册)\n&#x2F;&#x2F; 将 channel注册到 选择器, 当有事件发生时,会返回一个selectionKey来告知是哪个channel发生的事件\nSelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n&#x2F;&#x2F; 声明只关注 accept 事件\nsscKey.interestOps(SelectionKey.OP_ACCEPT);\nSystem.out.println(&quot;sscKey -&gt; &quot;+sscKey);</code></pre>\n</li>\n<li><p>通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞</p>\n<ul>\n<li>阻塞直到绑定事件发生</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int id &#x3D; selector.select();</code></pre>\n\n<ul>\n<li>阻塞直到绑定事件发生，<strong>或是超时</strong>（时间单位为 ms）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int id &#x3D; selector.select(long timeout);</code></pre>\n\n<ul>\n<li><strong>不会阻塞</strong>，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int id &#x3D; selector.selectNow();</code></pre>\n</li>\n<li><p>获取就绪事件并<strong>得到对应的通道</strong>，然后进行处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 4. 处理事件\n&#x2F;&#x2F; selectedKeys包含了所有发生的事件\nIterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\nwhile (it.hasNext()) &#123;\n    SelectionKey key &#x3D; it.next();\n    System.out.println(&quot;key -&gt; &quot;+key);\n    &#x2F;&#x2F; 如果获取事件后不处理,会重复加入事件列表,不断循环\n    ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n    SocketChannel sc &#x3D; channel.accept();\n    System.out.println(&quot;sc -&gt; &quot;+sc);\n&#125;</code></pre>\n</li>\n<li><p><strong>事件发生后能否不处理</strong></p>\n<p>事件发生后，<strong>要么处理，要么取消（cancel）</strong>，不能什么都不做，<strong>否则下次该事件仍会触发</strong>，这是因为 nio 底层使用的是水平触发</p>\n</li>\n</ul>\n<h4 id=\"2-Read事件\"><a href=\"#2-Read事件\" class=\"headerlink\" title=\"2. Read事件\"></a>2. Read事件</h4><ul>\n<li>在Accept事件中，若有客户端与服务器端建立了连接，<strong>需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中</strong></li>\n<li>添加Read事件，触发后进行读取操作</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> &#x2F;&#x2F; 4. 处理事件\n&#x2F;&#x2F; selectedKeys包含了所有发生的事件\nIterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\nwhile (it.hasNext()) &#123;\n    SelectionKey key &#x3D; it.next();\n    &#x2F;&#x2F; 如果这里不删除,下次进入响应事件后,还会访问,但实际上他的事件已经在上次处理结束\n    it.remove();\n    System.out.println(&quot;key -&gt; &quot; + key);\n    &#x2F;&#x2F; key就代表一个事件,可以获得事件是那个channel触发的\n    &#x2F;&#x2F; 可以区分这些事件进行处理\n    if (key.isAcceptable()) &#123;\n        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n        SocketChannel sc &#x3D; channel.accept();\n        System.out.println(&quot;sc-&gt; &quot;+sc);\n        sc.configureBlocking(false);\n        SelectionKey scKey &#x3D; sc.register(selector, 0, null);\n        scKey.interestOps(SelectionKey.OP_READ);\n\n    &#125; else if (key.isReadable()) &#123;\n        SocketChannel channel &#x3D; (SocketChannel) key.channel();\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n        channel.read(buffer);\n        buffer.flip();\n        System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>删除事件</strong></p>\n<p><strong>当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误</strong>。</p>\n<ul>\n<li><p>当调用了 <code>server.register(selector, SelectionKey.OP_ACCEPT)</code>后，Selector中维护了一个集合，<strong>用于存放SelectionKey以及其对应的通道</strong></p>\n</li>\n<li><p>当<strong>选择器中的通道对应的事件发生后</strong>，selecionKey会被放到另一个集合中，但是<strong>selecionKey不会自动移除</strong>，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误</p>\n</li>\n</ul>\n<h4 id=\"3-客户端关闭异常\"><a href=\"#3-客户端关闭异常\" class=\"headerlink\" title=\"3. 客户端关闭异常\"></a>3. 客户端关闭异常</h4><p>当客户端与服务器之间的连接<strong>断开时，会给服务器端发送一个读事件</strong>，对异常断开和正常断开需要加以不同的方式进行处理</p>\n<img src=\"NIO/image-20220413154148604.png\" alt=\"image-20220413154148604\" style=\"zoom:67%;\" />\n\n<ul>\n<li><p><strong>正常断开</strong>时，服务器端的channel.read(buffer)方法的返回值为-1，<strong>所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int read &#x3D; channel.read(buffer);\n&#x2F;&#x2F; 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1\nif(read &#x3D;&#x3D; -1) &#123;\n    &#x2F;&#x2F; 取消该事件的处理\n\tkey.cancel();\n    channel.close();\n&#125; else &#123;\n    ...\n&#125;\n&#x2F;&#x2F; 取消或者处理，都需要移除key\niterator.remove();</code></pre>\n</li>\n<li><p>异常断开</p>\n<ul>\n<li>异常断开时，会抛出IOException异常， 在try-catch的<strong>catch块中捕获异常并调用key的cancel方法即可</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"4-消息边界的处理\"><a href=\"#4-消息边界的处理\" class=\"headerlink\" title=\"4. 消息边界的处理\"></a>4. 消息边界的处理</h4><p>当客户端发送中文时:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">sc.write(Charset.defaultCharset().encode(&quot;这他妈是八岁?三岁和他妈一样高,五岁就&quot;))</code></pre>\n\n<p>服务器端由于缓冲区大小,可能会导致一个汉字编码被切割的情况</p>\n<p>这是因为UTF-8字符集下，1个汉字占用3个字节，<strong>此时缓冲区可能一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件</strong>。这就导致 <code>你好</code> 的 <code>好</code> 字被拆分为了前半部分和后半部分发送，解码时就会出现问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">key -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n这他妈是八�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��?三岁和他�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��一样高,五�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��就</code></pre>\n\n<p>传输的文本可能有以下三种情况</p>\n<ul>\n<li>文本大于缓冲区大小<ul>\n<li>此时需要将缓冲区进行扩容</li>\n</ul>\n</li>\n<li>发生半包现象</li>\n<li>发生粘包现象</li>\n</ul>\n<img src=\"/post/NIO/20210415103442.png\" class=\"\" title=\"img\">\n\n<p>解决思路大致有以下三种</p>\n<ul>\n<li><strong>固定消息长度</strong>，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽</li>\n<li>另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符</li>\n<li>TLV 格式，即 Type 类型、Length 长度、Value 数据（也就是在消息开头用一些空间存放后面数据的长度），如HTTP请求头中的Content-Type与Content-Length。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>\n<li>Http 1.1 是 TLV 格式</li>\n<li>Http 2.0 是 LTV 格式<img src=\"NIO/20210415103926.png\" alt=\"img\" style=\"zoom:67%;\" /></li>\n</ul>\n</li>\n</ul>\n<p><strong>附件与扩容</strong></p>\n<p>Channel的register方法还有<strong>第三个参数</strong>：<code>附件</code>，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final SelectionKey register(Selector sel, int ops, Object att)</code></pre>\n\n<p>可通过SelectionKey的<strong>attachment()方法获得附件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();</code></pre>\n\n<p>我们需要在Accept事件发生后，将通道注册到Selector中时，<strong>对每个通道添加一个ByteBuffer附件</strong>，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件\nsocketChannel.configureBlocking(false);\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 添加通道对应的Buffer附件\nsocketChannel.register(selector, SelectionKey.OP_READ, buffer);</code></pre>\n\n<p>当Channel中的数据大于缓冲区时，需要对缓冲区进行<strong>扩容</strong>操作。此代码中的扩容的判定方法：<strong>Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 如果缓冲区太小，就进行扩容\nif (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;\n    ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);\n    &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中\n    ewBuffer.put(buffer);\n    &#x2F;&#x2F; 将新buffer作为附件放到key中\n    key.attach(newBuffer);\n&#125;</code></pre>\n\n\n\n\n\n<p><strong>ByteBuffer的大小分配</strong></p>\n<ul>\n<li>每个 channel 都需要记录可能被切分的消息，因为 <strong>ByteBuffer 不能被多个 channel 共同使用</strong>，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>\n<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer</li>\n<li>分配思路可以参考<ul>\n<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能<ul>\n<li>参考实现 <a href=\"http://tutorials.jenkov.com/java-performance/resizable-array.html\">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>\n</ul>\n</li>\n<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-Write事件\"><a href=\"#5-Write事件\" class=\"headerlink\" title=\"5. Write事件\"></a>5. Write事件</h4><p>服务器通过Buffer向通道中写入数据时，<strong>可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入</strong>，具体步骤如下</p>\n<ul>\n<li>执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据</li>\n<li>若Buffer中还有数据，则<strong>需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int write &#x3D; sc.write(buffer);\nif (buffer.hasRemaining()) &#123;\n    &#x2F;&#x2F; 一次写不完,关注可写事件\n    sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n    sckey.attach(buffer);\n&#125;</code></pre>\n\n<ul>\n<li>添加写事件的相关操作<code>key.isWritable()</code>，对Buffer再次进行写操作<ul>\n<li>每次写后需要判断Buffer中是否还有数据（是否写完）。<strong>若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (selectionKey.isWritable()) &#123;\n    ByteBuffer attachment &#x3D; (ByteBuffer) selectionKey.attachment();\n    SocketChannel sc &#x3D; (SocketChannel) selectionKey.channel();\n    int write &#x3D; sc.write(attachment);\n    System.out.println(write);\n    &#x2F;&#x2F; 清理一下buffer\n    if (!attachment.hasRemaining()) &#123;\n        selectionKey.attach(null); &#x2F;&#x2F; 清理buffer\n        &#x2F;&#x2F; 不再关注可写事件\n        selectionKey.interestOps(selectionKey.interestOps() - SelectionKey.OP_WRITE);\n    &#125;\n&#125;</code></pre>\n\n<p>整体的代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class WriteServe &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector selector &#x3D; Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n        while (true) &#123;\n            selector.select();\n            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n            while (it.hasNext()) &#123;\n                SelectionKey selectionKey &#x3D; it.next();\n                it.remove();\n                if (selectionKey.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n\n                    SelectionKey sckey &#x3D; sc.register(selector, 0, null);\n                    System.out.println(sckey);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    &#x2F;&#x2F; 向客户端发送大量数据\n                    StringBuilder sb &#x3D; new StringBuilder();\n                    for (int i &#x3D; 0; i &lt; 30000000; i++) &#123;\n                        sb.append(&quot;a&quot;);\n                    &#125;\n                    ByteBuffer buffer &#x3D; Charset.defaultCharset().encode(sb.toString());\n                    int write &#x3D; sc.write(buffer);\n                    System.out.println(write);\n                    if (buffer.hasRemaining()) &#123;\n                        &#x2F;&#x2F; 一次写不完,关注可写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        sckey.attach(buffer);\n                    &#125;\n                &#125; else if (selectionKey.isWritable()) &#123;\n                    ByteBuffer attachment &#x3D; (ByteBuffer) selectionKey.attachment();\n                    SocketChannel sc &#x3D; (SocketChannel) selectionKey.channel();\n                    int write &#x3D; sc.write(attachment);\n                    System.out.println(write);\n                    &#x2F;&#x2F; 清理一下buffer\n                    if (!attachment.hasRemaining()) &#123;\n                        selectionKey.attach(null); &#x2F;&#x2F; 清理buffer\n                        &#x2F;&#x2F; 不再关注可写事件\n                        selectionKey.interestOps(selectionKey.interestOps() - SelectionKey.OP_WRITE);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"3-多线程优化\"><a href=\"#3-多线程优化\" class=\"headerlink\" title=\"3. 多线程优化\"></a>3. 多线程优化</h2><p>为了充分利用多核CPU，可以分两组选择器</p>\n<ul>\n<li>单线程配一个选择器（Boss），<strong>专门处理 accept 事件</strong></li>\n<li>创建 cpu 核心数的线程（Worker），<strong>每个线程配一个选择器，轮流处理 read 事件</strong></li>\n</ul>\n<p><strong>实现思路</strong></p>\n<ul>\n<li><p>创建<strong>一个</strong>负责处理Accept事件的Boss线程，与<strong>多个</strong>负责处理Read事件的Worker线程</p>\n</li>\n<li><p><strong>Boss线程</strong>执行的操作</p>\n<ul>\n<li><p>接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要<strong>根据标识robin去判断将任务分配给哪个Worker</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建固定数量的Worker\nWorker[] workers &#x3D; new Worker[4];\n&#x2F;&#x2F; 用于负载均衡的原子整数\nAtomicInteger robin &#x3D; new AtomicInteger(0);\n&#x2F;&#x2F; 负载均衡，轮询分配Worker\nworkers[robin.getAndIncrement()% workers.length].register(socket);</code></pre>\n</li>\n<li><p>register(SocketChannel socket)方法会<strong>通过同步队列完成Boss线程与Worker线程之间的通信</strong>，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void register(final SocketChannel socket) throws IOException &#123;\n    &#x2F;&#x2F; 只启动一次\n    if (!started) &#123;\n       &#x2F;&#x2F; 初始化操作\n    &#125;\n    &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件\n    &#x2F;&#x2F; 在Worker线程中执行注册事件\n    queue.add(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                socket.register(selector, SelectionKey.OP_READ);\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    &#x2F;&#x2F; 唤醒被阻塞的Selector\n    &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark\n    selector.wakeup();\n&#125;</code></pre></li>\n</ul>\n</li>\n<li><p><strong>Worker线程执行</strong>的操作</p>\n<ul>\n<li><strong>从同步队列中获取注册任务，并处理Read事件</strong></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class testMultiThreadServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Thread.currentThread().setName(&quot;BOSS&quot;);\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector boss &#x3D; Selector.open();\n        SelectionKey bossKey &#x3D; ssc.register(boss, 0, null);\n        bossKey.interestOps(SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n        &#x2F;&#x2F;  创建固定数量的Worker\n        Worker[] workers &#x3D; new Worker[2];\n        for (int i &#x3D; 0; i &lt; 2; i++) &#123;\n            workers[i] &#x3D; new Worker(&quot;Worker-&quot; + i);\n        &#125;\n        AtomicInteger idx &#x3D; new AtomicInteger();\n        while (true) &#123;\n            boss.select();\n            Iterator&lt;SelectionKey&gt; it &#x3D; boss.selectedKeys().iterator();\n            while (it.hasNext()) &#123;\n                SelectionKey key &#x3D; it.next();\n                it.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n                    System.out.println(&quot;sc --&gt; &quot; + sc);\n                    workers[idx.getAndIncrement() % workers.length].register(sc);\n                    &#x2F;&#x2F; 因为是内部类,所以可以直接访问属性\n&#x2F;&#x2F;                    sc.register(worker.selector, SelectionKey.OP_READ, null);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    static class Worker implements Runnable &#123;\n        private Thread thread;\n        private Selector selector;\n        private String name;\n        private volatile boolean flag &#x3D; false;\n        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n        public Worker(String name) &#123;\n            this.name &#x3D; name;\n        &#125;\n\n        &#x2F;&#x2F; 初始化线程和Selector\n        public void register(SocketChannel sc) throws IOException &#123;\n            if (!flag) &#123;\n                selector &#x3D; Selector.open();\n                thread &#x3D; new Thread(this, name);\n                thread.start();\n                flag &#x3D; true;\n            &#125;\n\n            queue.add(() -&gt; &#123;\n                try &#123;\n                    sc.register(selector, SelectionKey.OP_READ, null);\n                &#125; catch (ClosedChannelException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;);\n            selector.wakeup();\n        &#125;\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    selector.select();\n                    Runnable task &#x3D; queue.poll();\n                    if (task !&#x3D; null) task.run();\n                    Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n                    while (it.hasNext()) &#123;\n                        SelectionKey key &#x3D; it.next();\n                        it.remove();\n                        if (key.isReadable()) &#123;\n                            System.out.println(&quot;Read...&quot;);\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n                            channel.read(buffer);\n                            buffer.flip();\n                            System.out.println(Charset.defaultCharset().decode(buffer).toString());\n                            buffer.clear();\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"4-NIO-vs-BIO\"><a href=\"#4-NIO-vs-BIO\" class=\"headerlink\" title=\"4. NIO vs BIO\"></a>4. NIO vs BIO</h2><h3 id=\"a-Stream-vs-Channel\"><a href=\"#a-Stream-vs-Channel\" class=\"headerlink\" title=\"a. Stream vs Channel\"></a>a. Stream vs Channel</h3><ul>\n<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>\n<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，<strong>网络 channel 可配合 selector 实现多路复用</strong></li>\n<li><strong>二者均为全双工</strong>，即读写可以同时进行<ul>\n<li>虽然Stream是单向流动的，但是它也是全双工的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"b-IO模型\"><a href=\"#b-IO模型\" class=\"headerlink\" title=\"b. IO模型\"></a>b. IO模型</h3><p>五种IO模型</p>\n<ul>\n<li>同步阻塞</li>\n<li>同步非阻塞</li>\n<li>同步多路复用</li>\n<li>异步非阻塞(异步没有阻塞的情况)</li>\n</ul>\n<p>同步和异步:</p>\n<ul>\n<li><strong>同步：线程自己去获取结果（一个线程）</strong><ul>\n<li>例如：线程调用一个方法后，需要等待方法返回结果</li>\n</ul>\n</li>\n<li><strong>异步：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）</strong><ul>\n<li>例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回</li>\n</ul>\n</li>\n</ul>\n<p>当调用一次 <code>channel.read</code> 或 <code>stream.read</code> 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>\n<ul>\n<li>等待数据阶段</li>\n<li>复制数据阶段</li>\n</ul>\n<h4 id=\"1-阻塞IO\"><a href=\"#1-阻塞IO\" class=\"headerlink\" title=\"1.阻塞IO\"></a>1.阻塞IO</h4><img src=\"/post/NIO/20210418151605.png\" class=\"\" title=\"img\">\n\n<ul>\n<li>用户线程进行read操作时，<strong>需要等待操作系统执行实际的read操作</strong>，此期间用户线程是被阻塞的，无法执行其他操作</li>\n</ul>\n<h4 id=\"2-非阻塞IO\"><a href=\"#2-非阻塞IO\" class=\"headerlink\" title=\"2.非阻塞IO\"></a>2.非阻塞IO</h4><img src=\"/post/NIO/20210418152137.png\" class=\"\" title=\"img\">\n\n<ul>\n<li><p>用户线程</p>\n<p>在一个循环中一直调用read方法，若内核空间中还没有数据可读，立即返回</p>\n<ul>\n<li><strong>只是在等待阶段非阻塞</strong></li>\n</ul>\n</li>\n<li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p>\n</li>\n</ul>\n<h4 id=\"3-多路复用\"><a href=\"#3-多路复用\" class=\"headerlink\" title=\"3.多路复用\"></a>3.多路复用</h4><img src=\"/post/NIO/20210418154208.png\" class=\"\" title=\"img\">\n\n<p><strong>Java中通过Selector实现多路复用</strong></p>\n<ul>\n<li>当没有事件是，调用select方法会被阻塞住</li>\n<li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li>\n</ul>\n<p><strong>多路复用与阻塞IO的区别</strong></p>\n<ul>\n<li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li>\n<li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行</li>\n</ul>\n<h4 id=\"4-异步IO\"><a href=\"#4-异步IO\" class=\"headerlink\" title=\"4.异步IO\"></a>4.异步IO</h4><img src=\"/post/NIO/20210418160106.png\" class=\"\" title=\"img\">\n\n<ul>\n<li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li>\n<li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li>\n</ul>\n<h3 id=\"c-零拷贝\"><a href=\"#c-零拷贝\" class=\"headerlink\" title=\"c.零拷贝\"></a>c.零拷贝</h3><p><strong>零拷贝指的是数据无需拷贝到 JVM 内存中</strong>，同时具有以下三个优点</p>\n<ul>\n<li>更少的用户态与内核态的切换</li>\n<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>\n<li>零拷贝适合小文件传输</li>\n</ul>\n<h4 id=\"1-传统-IO-问题\"><a href=\"#1-传统-IO-问题\" class=\"headerlink\" title=\"1. 传统 IO 问题\"></a>1. 传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">File f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);\nRandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);\n\nbyte[] buf &#x3D; new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket &#x3D; ...;\nsocket.getOutputStream().write(buf);</code></pre>\n\n<p><strong>内部工作流如下</strong></p>\n<img src=\"/post/NIO/20210418162306.png\" class=\"\" title=\"img\">\n\n<ul>\n<li><p>Java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的<strong>用户态切换至内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU。</p>\n<p><code>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</code></p>\n</li>\n<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 <strong>CPU 会参与拷贝</strong>，无法利用 DMA</p>\n</li>\n<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区，CPU 会参与拷贝</strong></p>\n</li>\n<li><p>接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</p>\n</li>\n</ul>\n<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>\n<ul>\n<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>\n<li>数据拷贝了共 4 次</li>\n</ul>\n<h4 id=\"2-NIO-优化\"><a href=\"#2-NIO-优化\" class=\"headerlink\" title=\"2. NIO 优化\"></a>2. NIO 优化</h4><p>通过 <strong>DirectByteBuf</strong></p>\n<ul>\n<li><p>ByteBuffer.allocate(10)</p>\n<ul>\n<li>底层对应 HeapByteBuffer，使用的还是 Java 内存</li>\n</ul>\n</li>\n<li><p>ByteBuffer.</p>\n<p>allocateDirect</p>\n<p>(10)</p>\n<ul>\n<li>底层对应DirectByteBuffer，<strong>使用的是操作系统内存</strong></li>\n</ul>\n</li>\n</ul>\n<img src=\"/post/NIO/20210418162410.png\" class=\"\" title=\"img\">\n\n<p>大部分步骤与优化前相同，唯有一点：<strong>Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用</strong></p>\n<ul>\n<li>这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>\n<li>Java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>\n<li>DirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列<ul>\n<li>当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li>\n<li>DirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法</li>\n</ul>\n</li>\n<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>\n</ul>\n</li>\n<li><strong>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</strong></li>\n</ul>\n<h4 id=\"3-进一步优化1\"><a href=\"#3-进一步优化1\" class=\"headerlink\" title=\"3. 进一步优化1\"></a>3. 进一步优化1</h4><p><strong>以下两种方式都是零拷贝</strong>，即无需将数据拷贝到用户缓冲区中（JVM内存中）</p>\n<p>底层采用了 <strong>linux 2.1</strong> 后提供的 <strong>sendFile</strong> 方法，Java 中对应着两个 channel 调用 <strong>transferTo&#x2F;transferFrom</strong> 方法拷贝数据</p>\n<img src=\"/post/NIO/20210418162750.png\" class=\"\" title=\"img\">\n\n<ul>\n<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>\n<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，CPU 会参与拷贝</li>\n<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 CPU</li>\n</ul>\n<p>这种方法下</p>\n<ul>\n<li>只发生了1次用户态与内核态的切换</li>\n<li>数据拷贝了 3 次</li>\n</ul>\n<h4 id=\"4-进一步优化2\"><a href=\"#4-进一步优化2\" class=\"headerlink\" title=\"4. 进一步优化2\"></a>4. 进一步优化2</h4><p><strong>linux 2.4</strong> 对上述方法再次进行了优化</p>\n<img src=\"/post/NIO/20210418163033.png\" class=\"\" title=\"img\">\n\n<ul>\n<li>Java 调用 transferTo 方法后，要从 Java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 CPU</li>\n<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>\n<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 CPU</li>\n</ul>\n<p><strong>整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次</strong></p>\n<h4 id=\"5-AIO\"><a href=\"#5-AIO\" class=\"headerlink\" title=\"5. AIO\"></a>5. AIO</h4><p>AIO 用来解决数据复制阶段的阻塞问题</p>\n<ul>\n<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>\n<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>\n</ul>\n<blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p>\n<ul>\n<li>Windows 系统通过 IOCP <strong>实现了真正的异步 IO</strong></li>\n<li>Linux 系统异步 IO 在 2.6 版本引入，但其<strong>底层实现还是用多路复用模拟了异步 IO，性能没有优势</strong></li>\n</ul></blockquote>\n","feature":true,"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-NIO%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">1. NIO基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83-Channel%E3%80%81Buffer%E3%80%81Selector\"><span class=\"toc-text\">a. NIO的三大核心-Channel、Buffer、Selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Channel-%E4%B8%8E-Buffer\"><span class=\"toc-text\">1. Channel 与 Buffer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Selector\"><span class=\"toc-text\">2. Selector</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-ByteBuffer\"><span class=\"toc-text\">b. ByteBuffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1. 使用方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-ByteBuffer-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. ByteBuffer 结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">a. 核心属性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">b. 核心方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C-ByteBuffer-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">3. 字符串和 ByteBuffer 之间的转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4. 粘包半包处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">c. 文件编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-FileChannel\"><span class=\"toc-text\">1. FileChannel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">a. 获取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">b. 读取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-%E5%86%99%E5%85%A5\"><span class=\"toc-text\">c. 写入</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#d-%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">d. 关闭</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#e-%E4%BD%8D%E7%BD%AE-position\"><span class=\"toc-text\">e.位置 position</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#f-%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5\"><span class=\"toc-text\">f. 强制写入</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E4%B8%AAChannel%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2. 两个Channel传输数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Path\"><span class=\"toc-text\">3. Path</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Files\"><span class=\"toc-text\">4. Files</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">a. 查找</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">b. 创建</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-%E6%8B%B7%E8%B4%9D%E5%8F%8A%E7%A7%BB%E5%8A%A8\"><span class=\"toc-text\">c. 拷贝及移动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#d-%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">d. 删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#e-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">e. 遍历目录</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">2. 网络编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">a. 阻塞模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">b. 非阻塞模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Selector%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">c. Selector模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">1. 多路复用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Read%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">2. Read事件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%85%B3%E9%97%AD%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">3. 客户端关闭异常</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E7%9A%84%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4. 消息边界的处理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Write%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">5. Write事件</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">3. 多线程优化</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-NIO-vs-BIO\"><span class=\"toc-text\">4. NIO vs BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-Stream-vs-Channel\"><span class=\"toc-text\">a. Stream vs Channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-IO%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">b. IO模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">1.阻塞IO</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">2.非阻塞IO</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">3.多路复用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%BC%82%E6%AD%A5IO\"><span class=\"toc-text\">4.异步IO</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E9%9B%B6%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">c.零拷贝</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E7%BB%9F-IO-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. 传统 IO 问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-NIO-%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2. NIO 优化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%961\"><span class=\"toc-text\">3. 进一步优化1</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%BF%9B%E4%B8%80%E6%AD%A5%E4%BC%98%E5%8C%962\"><span class=\"toc-text\">4. 进一步优化2</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-AIO\"><span class=\"toc-text\">5. AIO</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-28T13:31:20.367Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"text":"视频教程参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of ma...","link":"","photos":[],"count_time":{"symbolsCount":"129k","symbolsTime":"1:58"},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}