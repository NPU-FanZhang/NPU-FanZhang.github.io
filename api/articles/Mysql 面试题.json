{"title":"Mysql 面试题","uid":"4d0cd99506fa5ed9a6631a984ab7b868","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","updated":"2022-08-31T11:34:26.457Z","comments":true,"path":"api/articles/Mysql 面试题.json","keywords":null,"cover":"/svg/mysql.svg","content":"<h2 id=\"Mysql-面试题\"><a href=\"#Mysql-面试题\" class=\"headerlink\" title=\"Mysql 面试题\"></a>Mysql 面试题</h2><h4 id=\"1-B树和B-树的区别\"><a href=\"#1-B树和B-树的区别\" class=\"headerlink\" title=\"1. B树和B+树的区别?\"></a>1. B树和B+树的区别?</h4><p><strong>相同点:</strong></p>\n<ul>\n<li>都是多路平衡查找树</li>\n<li>一个节点中都有多个元素,且有序</li>\n</ul>\n<p><strong>不同点:</strong></p>\n<ul>\n<li>B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中；</li>\n<li>B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接。</li>\n</ul>\n<h4 id=\"2-InnoDB中B-树有什么特点\"><a href=\"#2-InnoDB中B-树有什么特点\" class=\"headerlink\" title=\"2. InnoDB中B+树有什么特点?\"></a>2. InnoDB中B+树有什么特点?</h4><ul>\n<li>InnoDB中的B+树叶节点之间是由双向指针连接</li>\n<li>InnoDB中的B+树的叶节点都是一个Page</li>\n</ul>\n<h4 id=\"3-什么是InnoDB中的page\"><a href=\"#3-什么是InnoDB中的page\" class=\"headerlink\" title=\"3. 什么是InnoDB中的page?\"></a>3. 什么是InnoDB中的page?</h4><ul>\n<li>一页默认大小 16384B &#x3D; 16KB</li>\n<li>InnoDB的读取、创建、读入都是以页Page为单位的</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">页的结构可以理解为:\nclass Page&#123;\n    Page prev; &#x2F;&#x2F; 前一页指针\n    Page next; &#x2F;&#x2F; 下一页指针\n    PageDirectory; &#x2F;&#x2F; 存放数据的目录\n    List&lt;UserRecord&gt; Data; &#x2F;&#x2F; 用户数据项\n    &#x2F;&#x2F; 其他数据项\n&#125;</code></pre>\n\n<img src=\"Mysql%20%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220808104245046.png\" alt=\"image-20220808104245046\" style=\"zoom:50%;\" />\n\n<p>目的: 如果每次读取都按照一条一条数据取出,那么每次都会产生一次磁盘IO,时间开销太大,但如果按照Page方式取出,则可以一次取出大量数据,减少磁盘IO次数</p>\n<h4 id=\"4-InnoDB中的Page是如何产生的\"><a href=\"#4-InnoDB中的Page是如何产生的\" class=\"headerlink\" title=\"4. InnoDB中的Page是如何产生的?\"></a>4. InnoDB中的Page是如何产生的?</h4><p>Mysql中的Page都保存在磁盘中,所以对Page的访问很慢,应该尽可能减少访问次数</p>\n<p>每次插入,删除数据都会在一页内进行操作包括维护页目录和用户数据区。</p>\n<img src=\"Mysql%20%E9%9D%A2%E8%AF%95%E9%A2%98/v2-684432dd142d9bee687d4dd0cb48e40a_r.jpg\" alt=\"preview\" style=\"zoom:80%;\" />\n\n\n\n<h4 id=\"5-什么是聚簇索引和非聚簇索引\"><a href=\"#5-什么是聚簇索引和非聚簇索引\" class=\"headerlink\" title=\"5. 什么是聚簇索引和非聚簇索引?\"></a>5. 什么是聚簇索引和非聚簇索引?</h4><p><strong>聚集索引：是以主键创建的索引，在叶子节点存储的是表中的数据</strong></p>\n<p>非聚集索引：就是以非主键创建的索引(也叫做二级索引)，在<strong>叶子节点存储的是主键和索引列，需要回表查询</strong></p>\n<ul>\n<li><p>聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个</p>\n</li>\n<li><p>聚集索引中表记录的排列顺序和索引的排列顺序一致；所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。缺点：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。</p>\n</li>\n<li><p>非聚集索引中表记录的排列顺序和索引的排列顺序不一致。</p>\n</li>\n<li><p>聚集索引是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储不连续。</p>\n</li>\n<li><p>聚集索引每张表只能有一个，非聚集索引可以有多个。</p>\n</li>\n</ul>\n<p>各自优势:</p>\n<ul>\n<li>查询聚簇索引可以直接获取数据,非聚簇索引需要回表</li>\n<li>聚簇索引适合用在排序上,非聚簇索引要回表则不合适</li>\n</ul>\n<p>各自劣势:</p>\n<ul>\n<li><p>聚簇索引维护非常昂贵</p>\n</li>\n<li><p>主键如果不是连续自增例如UUID,可能会让索引很慢,甚至比</p>\n</li>\n<li><p>主键空间较大的话,辅助索引会非常大,因为辅助索引要保存主键值</p>\n</li>\n</ul>\n<h4 id=\"6-InnoDB是如何支持范围查找走索引的\"><a href=\"#6-InnoDB是如何支持范围查找走索引的\" class=\"headerlink\" title=\"6. InnoDB是如何支持范围查找走索引的?\"></a>6. InnoDB是如何支持范围查找走索引的?</h4><p>对于范围查找,InnoDB会先通过索引查找搜索范围的边界值,然后再在叶子结点上通过链表进行顺序查找。</p>\n<h4 id=\"7-什么是联合索引-对应的B-树时如何生成的\"><a href=\"#7-什么是联合索引-对应的B-树时如何生成的\" class=\"headerlink\" title=\"7. 什么是联合索引?对应的B+树时如何生成的?\"></a>7. 什么是联合索引?对应的B+树时如何生成的?</h4><p>联合索引结构上的叶子节点包含了多个索引列。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">create index idx_name on t1(a,b,c); -- 在表t1的a,b,c字段上创建联合索引</code></pre>\n\n<p>在创建对应的索引树时，按照优先级 第一个字段 &gt; 第二个字段 &gt; 第三个字段 … 以此类推来创建索引。</p>\n<p><strong>叶子结点保存的是主键值，然后再回表在聚簇索引中查找对应的数据。</strong></p>\n<p>在联合索引匹配过程中，首先会将联合索引中的第一个索引条件和节点中的第一个索引列进行匹配。<br>如果匹配成功，那么接着匹配第二个索引条件和第二个索引列。依次类推，直到所有的索引条件都完成匹配。</p>\n<h4 id=\"8-什么是最左前缀原则-为什么要遵循最左前缀原则才能利用索引\"><a href=\"#8-什么是最左前缀原则-为什么要遵循最左前缀原则才能利用索引\" class=\"headerlink\" title=\"8. 什么是最左前缀原则?为什么要遵循最左前缀原则才能利用索引?\"></a>8. 什么是最左前缀原则?为什么要遵循最左前缀原则才能利用索引?</h4><p>​    当b+树的索引是联合索引的数据结构，⽐如(name,age,sex)的时候，b+树是按照从左到右的顺序来建⽴搜索树的，⽐如当(张三,20,F)这样的数据来检索的时候，b+树会优先⽐较name来确定下⼀步的所搜⽅向，如果name相同再依次⽐较age和sex，最后得到检索的数据；</p>\n<p>​    但当(20,F)这样的没有name的数据来的时候，b+树就不知道下⼀步该查哪个节点，因为建⽴搜索树的时候name就是第一个比较因子,必须要先根据name来搜索才知道下一步去哪里查询。⽐如当(张三,F)这样的数据来检索时，b+树可以⽤name来指定搜索⽅向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，在匹配性别是F的数据了，这便是最左前缀原则。如果给的查询条件中，无左侧字段，只有右边的字段，而只看右边的字段的话在索引中的分布是无序的，所以无法走索引。</p>\n<h4 id=\"9-Mysql中字符串和数字的类型转换问题\"><a href=\"#9-Mysql中字符串和数字的类型转换问题\" class=\"headerlink\" title=\"9. Mysql中字符串和数字的类型转换问题\"></a>9. Mysql中字符串和数字的类型转换问题</h4><p>字符串转数字 -&gt; 统统转换为数字 0   ‘123’ &#x3D;&#x3D; 0 为真</p>\n<p>数字转字符串 -&gt; 转换为数字对应的字符串  123 &#x3D;&#x3D; ‘123’为真</p>\n<h4 id=\"10-什么是索引条件的下推\"><a href=\"#10-什么是索引条件的下推\" class=\"headerlink\" title=\"10. 什么是索引条件的下推?\"></a>10. 什么是索引条件的下推?</h4><h4 id=\"11-什么是覆盖索引\"><a href=\"#11-什么是覆盖索引\" class=\"headerlink\" title=\"11. 什么是覆盖索引?\"></a>11. 什么是覆盖索引?</h4><p>查询的字段包括在了索引之中,则不需要回表,这种查询情况叫做覆盖索引.</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">select b from t1; \t\t\t -- 在b字段上创建了索引,查询完成不需要回表\nselect b from t1 where b &#x3D; 1; -- 在b字段上创建了索引,查询完成不需要回表</code></pre>\n\n\n\n<h4 id=\"12-有哪些情况会导致索引失效\"><a href=\"#12-有哪些情况会导致索引失效\" class=\"headerlink\" title=\"12. 有哪些情况会导致索引失效?\"></a>12. 有哪些情况会导致索引失效?</h4><ul>\n<li><p>范围查找可能会导致索引失效，因为在非聚簇索引上的范围查找后的结果还需要回表，可能导致时间大于全扫描，所以可能失效。所以范围越小越容易走索引，引擎会根据综合情况决定是否走索引.</p>\n</li>\n<li><p><code>order by</code> 可能会导致失效。 </p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">-- t1表上 b字段存在索引\nselect * from t1 order by b; -- 不会走索引,虽然走索引不用排序,但是需要多次回表\nselect b from t1 order by b; -- 走索引,因为查询的字段都是索引字段</code></pre>\n</li>\n<li><p>条件语句中 存在类型转换,会导致索引失效</p>\n<ul>\n<li>类型转换可能导致索引顺序错误 例如 字符’12’ &lt; 数字1，转换后 ‘1’ 转换为0</li>\n<li>硬走索引会需要对索引上的每个值进行类型转换,开销巨大</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"13-Mysql有哪些存储引擎\"><a href=\"#13-Mysql有哪些存储引擎\" class=\"headerlink\" title=\"13. Mysql有哪些存储引擎?\"></a>13. Mysql有哪些存储引擎?</h4><p>MySQL给用户提供了这么多存储引擎，包括处理事务安全表的引擎和出来了非事物安全表的引擎。主要的有以下三种:</p>\n<ul>\n<li><p><code>InnoDB</code> ：MySql 5.6 版本默认的存储引擎。InnoDB 是一个事务安全的存储引擎，它具备提交、回滚以及崩溃恢复的功能以保护用户数据。InnoDB 的行级别锁定以及 Oracle 风格的一致性无锁读提升了它的多用户并发数以及性能。InnoDB 将用户数据存储在聚集索引中以减少基于主键的普通查询所带来的 I&#x2F;O 开销。为了保证数据的完整性，InnoDB 还支持外键约束。</p>\n</li>\n<li><p><code>MyISAM</code> ：MyISAM既不支持事务、也不支持外键、其优势是访问速度快，但是表级别的锁定限制了它在读写负载方面的性能，因此它经常应用于只读或者以读为主的数据场景。</p>\n</li>\n<li><p><code>Memory</code>：在内存中存储所有数据，应用于对非关键数据由快速查找的场景。Memory类型的表访问数据非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失</p>\n</li>\n</ul>\n<h4 id=\"14-InnoDB-和-MyISAM-的主要区别\"><a href=\"#14-InnoDB-和-MyISAM-的主要区别\" class=\"headerlink\" title=\"14. InnoDB 和 MyISAM 的主要区别?\"></a>14. InnoDB 和 MyISAM 的主要区别?</h4><ul>\n<li>InnoDB支持事务 MyISAM不支持事务(但每个操作都是原子的)</li>\n<li>InnoDB支持外键 MyISAM不支持外键<ul>\n<li>InnoDB中包含外键的表转为MyISAM的表会失败。</li>\n</ul>\n</li>\n<li>InnoDB是聚簇索引 MyISAM是非聚簇索引<ul>\n<li>聚簇索引的文件放在主键索引的叶子结点上,因此InnoDB必须有主键。但辅助索引会需要回表</li>\n<li>MyISAM是非聚簇索引,数据文件是分离的,索引文件保存数据文件的指针。</li>\n</ul>\n</li>\n<li>InnoDB最小锁粒度是行锁，MyISAM最小锁粒度为表锁</li>\n<li>MyISAM用变量保存了表的具体行数 <code>select count(*) from table;</code>会直接拿出变量值,InnoDB需要全表扫描</li>\n</ul>\n<h4 id=\"15-Mysql-中Varchar-M-最多能存储多少数据\"><a href=\"#15-Mysql-中Varchar-M-最多能存储多少数据\" class=\"headerlink\" title=\"15. Mysql 中Varchar(M)最多能存储多少数据?\"></a>15. Mysql 中Varchar(M)最多能存储多少数据?</h4><p>对于varchar(m)类型的列最多可以定义为65535个字节。其中m代表该类型最多存储最多的字符量,但实际存储并不能放这么多。</p>\n<p>Mysql对一条记录占用的最大存储空间有限制,出了BLOG和TEXT类型之外,其他的占用字节长度不得超过65535字节。</p>\n<h4 id=\"16-事务的基本特性？\"><a href=\"#16-事务的基本特性？\" class=\"headerlink\" title=\"16. 事务的基本特性？\"></a>16. 事务的基本特性？</h4><p><strong>ACID</strong>：原子性、一致性、隔离性、持久性。</p>\n<p>原子性：一个事务中的操作要么全部成功,要么全部失败。</p>\n<p>一致性：数据库总是从一个一致性状态转换到另外一个一致性状态。</p>\n<p>隔离性：一个事务的修改在最终提交前，对其他事务不可见。</p>\n<p>持久性：一旦事务提交，所做的修改就会永久保存在数据库中（落盘）。</p>\n<h4 id=\"17-事务并发会引发什么问题？\"><a href=\"#17-事务并发会引发什么问题？\" class=\"headerlink\" title=\"17. 事务并发会引发什么问题？\"></a>17. 事务并发会引发什么问题？</h4><p><strong>脏读</strong>: 读取到另外一个事务未提交的数据的现象就叫脏读。</p>\n<p><strong>不可重复读</strong>: 事务B读取了两次数据,在两次读取过程中事务A修改了数据,导致事务B两次读取出来的数据不一致。在同一事务中，前后两次读取的数据不一致现象就称为不可重复读。</p>\n<p><strong>幻读</strong>：事务B前后读取同一个范围的数据，在事务两次读取过程中A增加了数据，导致事务B后一次读取到前一次查询没有看到的行。<code>幻读和不可重复读有些类似，但幻读强调的是集合的增减，而不是单个数据的更新。</code></p>\n<h4 id=\"18-Mysql有哪些索引\"><a href=\"#18-Mysql有哪些索引\" class=\"headerlink\" title=\"18. Mysql有哪些索引?\"></a>18. Mysql有哪些索引?</h4><p>常见的索引可以分为四类: 主键索引、唯一索引、普通索引、前缀索引。</p>\n<p>主键索引：建立在主键上的索引,一张表只能由一个主键索引,不允许有空值。</p>\n<p>唯一索引：建立在<code>UNIQUE</code>字段上的索引被称为唯一索引,一张表可以有多个唯一索引,索引允许列值为空,多个空值不会发生冲突。</p>\n<p>普通索引：建立在普通字段上的索引被称为评估索引。</p>\n<p>前缀索引：建立在字符类型字段的前几个字符建立的索引，而不是整个字段上建索引，减少索引占用空间，提高查询效率。</p>\n<h4 id=\"19-如何提高insert性能\"><a href=\"#19-如何提高insert性能\" class=\"headerlink\" title=\"19. 如何提高insert性能?\"></a>19. 如何提高insert性能?</h4><ul>\n<li>多个inset合并为一条<ul>\n<li>减少了日志量,减少了解析开销</li>\n</ul>\n</li>\n<li>修改参数 <code>bulk_insert_buffer_size</code> 调大批量插入缓存</li>\n<li>设置 <code>innodb_flush_log_at_trx_commit = 0</code><ul>\n<li>0 代表<code>log buffer</code>中的数据以每秒一次的频率写入<code>log file</code>中,同时会进行文件系统到磁盘的同步操作,但每个事务commit不会触发任何<code>log buffer</code>到<code>log file</code>的刷新</li>\n<li>1 代表每次事务提交的时候将<code>log buffer</code>中的数据写入到<code>log file</code>,同时触发磁盘同步</li>\n<li>2 代表事务提交会触发<code>log buffer</code> 到 <code>log file</code> 的刷新,并不触发同步,此外,每秒会有一次文件系统到磁盘的同步操作</li>\n</ul>\n</li>\n<li>手动设置事务<ul>\n<li>默认<code>autocommit</code>每插入一条数据会进行一次commit;为了减少创建事务的消耗,可以手动设置事务,一般设置1000条提交一次。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"20-介绍一下数据库中的锁？\"><a href=\"#20-介绍一下数据库中的锁？\" class=\"headerlink\" title=\"20. 介绍一下数据库中的锁？\"></a>20. 介绍一下数据库中的锁？</h4><p>按照锁粒度可以分为：行锁，表锁，页锁，记录锁，间隙锁，临建锁</p>\n<p>按照锁的属性分类：共享锁、排它锁</p>\n<p>按照锁的状态分类：意向共享锁、意向排它锁</p>\n<ul>\n<li>共享锁&#x2F;读锁（Share Lock）</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">共享锁又称读锁,简称S锁,当一个事务为数据加上读锁之后,其他事务只能对该数据加读锁,不能再加写锁。主要是为了支持并发读取。</code></pre>\n\n<ul>\n<li>排它锁&#x2F;写锁(Exclusive Lock)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">排它锁又称为写锁,简称X锁,当一个事务未数据加上写锁时,这个数据便不能再被添加任何锁,只能等写锁释放再添加其他的锁。</code></pre>\n\n<ul>\n<li>表锁</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">表锁是指锁住的表为整个表,下个事务访问该表时只能等前一个事务释放后在进行操作。\n特点：粒度大 加锁简单 容易冲突</code></pre>\n\n<ul>\n<li>行锁</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">行锁是指锁住的是表的某一行或多行记录,其他事务访问一张表时,只有被锁住的记录不能访问,其他的记录可以正常访问\n特点: 粒度小 加锁麻烦 不容易冲突 并发度高\nInnoDB默认行锁</code></pre>\n\n<ul>\n<li>记录锁(Record Lock)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">记录锁属于行锁的一种,只不过只能锁住某一条记录\n精准条件命中,并且锁住的条件字段唯一\n加了记录锁之后的数据可以避免在查询的时候被修改的重复读问题,也避免了读未提交的脏读问题</code></pre>\n\n<ul>\n<li>页锁(Page Lock)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">页锁是Mysql提供的锁粒度介于行级锁和表级锁之间的一种锁，一次锁定相邻的一部分数据。\n特点: 开销和加锁时间介于行锁和表锁之间,可能出现死锁,并发度一般</code></pre>\n\n<ul>\n<li>间隙锁(Gap Lock)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">属于行锁的一种,间隙锁是在事务加锁后的某一个区间,比如锁住的记录中ID属于(a,b]的一个区间的记录。\n比如数据ID 1,3,7 形成区间 (-n , 1] (1,3] (3,7] (7,+n] 几个区间,锁住的正是这些区间,防止幻读问题</code></pre>\n\n<ul>\n<li>临建锁(Next-Key Lock)</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">属于行锁的一种，并且是InnoDB默认的行锁算法，是行锁和间隙锁的结合,临建锁会锁住查询出来的记录,同时会把查询出来的间隙锁住\n特点: 避免了范围查询时出现脏读,幻读,重复读问题,临建锁之后,范围区间内的数据不允许被插入和修改</code></pre>\n\n\n\n<p>意向锁是一种状态,告知其他事务是否有其他事务锁住了这个数据,并不是实际的锁,为了提高加锁效率</p>\n<ul>\n<li><p>意向共享锁,当一个事务视图对整个表加共享锁之前,需要先获取这个意向共享锁</p>\n</li>\n<li><p>意向排它锁,当一个事务视图对整个表加排他锁之前,需要先获取这个意向排他锁</p>\n</li>\n</ul>\n<h4 id=\"21-介绍一下Mysql中的死锁\"><a href=\"#21-介绍一下Mysql中的死锁\" class=\"headerlink\" title=\"21. 介绍一下Mysql中的死锁\"></a>21. 介绍一下Mysql中的死锁</h4><p>死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待且都无法推进下去的情况。</p>\n<p><strong>如何查看死锁</strong></p>\n<ul>\n<li>使用 <code>show engine innodb status</code> 查看最近一次的死锁</li>\n<li>使用 <code>InnoDB Lock Monitor</code> 打开锁监控, 每15s输出一次日志,查看死锁，完毕后记得关闭。</li>\n</ul>\n<p><strong>解决死锁的两种常见策略</strong></p>\n<ul>\n<li>通过 <code>innodblockwait_timeout</code>来设置超时时间,一直等待到超时而结束</li>\n<li>发起死锁检测,发现死锁后,主动回滚死锁中某一事务,让其他事务继续进行</li>\n</ul>\n<h4 id=\"22-Mysql中主从同步中实现的读写分离原理\"><a href=\"#22-Mysql中主从同步中实现的读写分离原理\" class=\"headerlink\" title=\"22. Mysql中主从同步中实现的读写分离原理\"></a>22. Mysql中主从同步中实现的读写分离原理</h4><p>基于主从复制的读写分离，是我们在单机环境下，数据库的性能到瓶颈了，可以通过读写分离，提高后台服务。存储这一块的增删改查的并发的处理能力，<strong>主库专门负责写操作，从库专门负责读操作，主库的数据更改通过主从复制同步到从库</strong></p>\n<img src=\"Mysql%20%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220808191920419.png\" alt=\"image-20220808191920419\" style=\"zoom: 80%;\" />\n\n<p>主从同步的核心就是其中的 <code>bin log</code>,其中主从复制的过程如下:</p>\n<ul>\n<li>在每个事务更新数据完成之前，master在<code>bin log</code>记录这些改变。写入<code>bin log</code>完成后，master通知存储引擎提交事务。</li>\n<li>主节点在 <code>bin log</code> 有变动时, 启动<code>dump process</code>,将变动内容发送给从节点。</li>\n<li>从节点I&#x2F;O线程接收 <code>binlog</code>内容,并将其写入自己的 <code>relay log</code>中。</li>\n<li>从节点启动 <code>sql thread</code> 从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I&#x2F;O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。</li>\n</ul>\n<p>由于mysql默认的复制方式是<strong>异步</strong>的，主库把日志发送给从库后就不关心从库处理情况，可能会导致主库挂了，从库处理失败，这时候从库升级为主库后，日志丢失的问题，为解决这个问题，产生两个概念：</p>\n<ul>\n<li><p>全同步方式</p>\n<p>主库写入binlog后强制同步到从库,所有从库同步完成后才返回客户端,很显然这种方式性能会产生严重影响</p>\n</li>\n<li><p>半同步方式</p>\n<p>和全同步不同的是,半同步方式在从库写入成功后返回ACK给主库,主库至少接收到一个ACK的确认就认为写操作完成.</p>\n</li>\n</ul>\n<h4 id=\"23-Mysql如何实现分库分表\"><a href=\"#23-Mysql如何实现分库分表\" class=\"headerlink\" title=\"23. Mysql如何实现分库分表?\"></a>23. Mysql如何实现分库分表?</h4><p>分库分表分为两类:<strong>垂直拆分</strong>和<strong>水平拆分</strong></p>\n<ul>\n<li><code>垂直拆分</code>主要关注于业务,对吞吐量并没有效果</li>\n<li><code>水平拆分</code>主要关注于数据本身的特点(如按照<code>userID</code>将同一表中数据分到不同的表中)</li>\n</ul>\n<p>我们主要分析的是水平拆分,水平拆分避免不了需要选定一个或几个拆分字段,如时间,id等</p>\n<ul>\n<li><code>hash(userID)</code>拆分</li>\n<li>逻辑拆分(例如按月存储,按年存储等等)</li>\n</ul>\n<p>缺点是:</p>\n<ul>\n<li><p>每次查询都需要带上拆分字段</p>\n</li>\n<li><p>数据统计会很麻烦</p>\n</li>\n</ul>\n<h4 id=\"24-索引的设计原则\"><a href=\"#24-索引的设计原则\" class=\"headerlink\" title=\"24. 索引的设计原则\"></a>24. 索引的设计原则</h4><ul>\n<li>出现在<code>where</code>子句中的列才有建立索引的价值</li>\n<li>基数比较小的列没有创建索引的必要,比如性别</li>\n<li>特别长的字段,可以只使用前缀来作为索引,减小索引长度和空间大小</li>\n<li>不要过度索引,索引维护是有代价的</li>\n<li>定义有外键的数据列一定要建索引</li>\n<li>频繁更新的字段不适合建索引</li>\n<li>尽量扩展索引而不是新建索引,比如已有a的索引,要添加(a,b)的索引,只需要在原来基础上新建</li>\n<li>对于超长的数据类型比如 text、image、bit 不适合创建索引</li>\n</ul>\n<h4 id=\"25-Mysql执行计划怎么看\"><a href=\"#25-Mysql执行计划怎么看\" class=\"headerlink\" title=\"25. Mysql执行计划怎么看?\"></a>25. Mysql执行计划怎么看?</h4><p>使用<code>EXPLAIN</code>关键字来查看执行计划</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+-------+\n- id\t查询标识符。在所有组中，id值越大，优先级越高，越先执行，id如果相同，可以认为是一组，从上往下顺序执行；\n- select_type \t表示查询语句中,每个select语句的类型,包括 simple primary subquery等等\n- table\t该语句查询的表\n- partitions\t该参数用于记录使用的分区信息，NULL表示该表不是分区表\n- type\t连接类型，见后面&quot;执行计划连接类型type&quot;. 索引查询的类型（ALL、index、range、ref、eq_ref、const(system)、NULL）\n- possible_keys\t在该查询中，MySQL可能使用的索引，如果此列是NULL，则没有相关的索引\n- key\tMySQL实际使用的索引。在大多数情况下，key中的值都在possible_key里面\n- key_len\t该列指MySQL决定使用的索引长度。该值体现了在使用复合索引的时候，使用了复合索引的前面哪几个列\n- ref\t列显示哪些列或者常量与key中的索引进行比较,即就是命中的索引名\n- rows\t按照当前执行计划,会读取的行数\n- filtered\t被条件过滤的行数百分比。最大值为100，表示没有行过滤，值从100减小表示过滤增加。 越高越好\n- Extra\t执行计划的额外信息</code></pre>\n\n\n\n<h4 id=\"26-事务的隔离级别\"><a href=\"#26-事务的隔离级别\" class=\"headerlink\" title=\"26. 事务的隔离级别\"></a>26. 事务的隔离级别</h4><p>事务的隔离级别有4个,分别是:</p>\n<ul>\n<li><p>读未提交,read uncommit,可能会读到其他事务未提交的数据,也叫作 <strong>脏读</strong></p>\n</li>\n<li><p>读已提交,read commit,只能读到已经提交的数据,但是可能两次读取结果不一致,叫做 <strong>不可重复读</strong> oracle的默认级别</p>\n</li>\n<li><p>可重复读,repeatable read,这是mysql的默认隔离级别,就是每次读取结果一致,但会导致 <strong>幻读</strong> </p>\n</li>\n<li><p>串行化 serializable, 一般不会使用,会给每一行数据加锁 ,会导致大量的超时和锁竞争问题</p>\n</li>\n</ul>\n<h4 id=\"27-什么是MVCC\"><a href=\"#27-什么是MVCC\" class=\"headerlink\" title=\"27. 什么是MVCC?\"></a>27. 什么是MVCC?</h4><p>MVCC即多版本并发控制，MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问</p>\n<p>MVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式去处理读-写冲突，做到&#x3D;&#x3D;即使有读写冲突时，也能做到不加锁，非阻塞并发读&#x3D;&#x3D;。</p>\n<p>MVCC保证数据读已提交和可重复读的流程如下:</p>\n<ul>\n<li><p>InnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。</p>\n</li>\n<li><p>&#x3D;&#x3D;在每开启一个事务时，会生成一个事务的版本号&#x3D;&#x3D;，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。</p>\n</li>\n<li><p><strong>Read View</strong> : 创建一个新事务时，复制一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">例如当前系统中的事务包括 3 4 5 [6 7 8] 9 几个事务其中6,7,8是活动的事务, 3,4,5是已提交的事务,9是未执行的事务 \n这个数组就是一个Read View</code></pre>\n</li>\n<li><p>当有一个事务要执行时,会查询该事务的Read View,如果自己的事务id在活动事务之前,那么就说明自己访问的数据之前的事务都已经提交,可以访问;如果自己的事务id在活动事务之后,则需要获取上一个版本重新对比,等待之前必要的事务完成才能访问</p>\n</li>\n</ul>\n<p>对于Read View快照的生成时机，也非常关键，正是因为生成时机的不同，造成了RC，RR两种隔离级别的不同可见性；</p>\n<ul>\n<li>在innodb中(默认repeatable read级别)，事务在begin&#x2F;start transaction之后的第一条select读操作后，会创建一个快照(Read View)，将当前系统中活跃的其他事务记录记录起来</li>\n<li>在innodb中(read committed级别)，事务中每条select语句都会创建一个快照(Read View)</li>\n</ul>\n<h4 id=\"28-ACID分别靠什么保证\"><a href=\"#28-ACID分别靠什么保证\" class=\"headerlink\" title=\"28. ACID分别靠什么保证?\"></a>28. ACID分别靠什么保证?</h4><ul>\n<li><p>A原子性: 由<code>undo log</code>保证,它记录了需要回滚的日志信息,用来撤销已经执行的sql</p>\n</li>\n<li><p>C一致性: 一致性是业务级别的特性,由其他三个特性共同保证。</p>\n</li>\n<li><p>I隔离性: 由MVCC来保证</p>\n</li>\n<li><p>D持久性: 由内存和<code>redo log</code>来保证,mysql修改数据的同时在内存和<code>redo log</code>记录这次记录,宕机是从<code>redo log</code>中恢复数据。并且在空闲时间，会根据<code>redo log</code>来进行数据落盘</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">innoDB 的redo log写盘时,事务进入prepare状态,如果prepare成功,binlog写盘,在继续将事务持久化到binlog,持久化成功后,事务进入commit状态,完成事务,后续在系统空闲时落盘</code></pre></li>\n</ul>\n<h4 id=\"29-Mysql的日志系统\"><a href=\"#29-Mysql的日志系统\" class=\"headerlink\" title=\"29. Mysql的日志系统\"></a>29. Mysql的日志系统</h4><p>Mysql的日志有六种:</p>\n<p>重写日志（redo log）、回滚日志（undo log）、二进制日志（bin log）、</p>\n<p>错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log）</p>\n<p>前三个日志比较重要</p>\n<ul>\n<li><p>undo log 记录的是修改之前的数据,undo log主要用来回滚到某一个版本，是一种逻辑日志。还可以提供多版本并发控制下的读取（MVCC）。undo log 有两个作用：提供回滚和多版本并发控制下的读(MVCC)，也即非锁定读</p>\n<p>在数据修改的时候，不仅记录了redo，还记录了相对应的 undo，如果因为某些原因导致事务失败或回滚了，可以借助该 undo 进行回滚。</p>\n</li>\n<li><p>redo log 物理格式的日志，记录的是物理数据页面的修改信息（在某个数据页上做了什么修改）和大多数关系型数据库一样，InnoDB 记录了对数据文件的物理更改，并保证总是日志先行，也就是所谓的 WAL，即在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。由于 redo log 是顺序整块写入，所以性能要更好。</p>\n</li>\n<li><p>bin log 二进制日志（BINLOG日志）记录了所有DDL（数据库定义语言）语句和DML（数据操纵语言）语句，但是不包括查询语句，此日志对于灾难时的数据恢复有非常重要的作用，MySQL的主从复制，就是通过该日志实现的。</p>\n<p>binlog 是 没有 MySQL sever 层维护的一种二进制日志，与 innodb 引擎中的 redo&#x2F;undo log 是完全不同的日志。其主要是用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句</p>\n</li>\n</ul>\n<h4 id=\"30-如何处理-脏读、不可重复读、幻读问题？\"><a href=\"#30-如何处理-脏读、不可重复读、幻读问题？\" class=\"headerlink\" title=\"30. 如何处理 脏读、不可重复读、幻读问题？\"></a>30. 如何处理 脏读、不可重复读、幻读问题？</h4><p>各个隔离级别会导致的问题：</p>\n<p>读未提交–&gt;脏读</p>\n<p>读已提交–&gt;不可重复读</p>\n<p>可重复读–&gt;幻读</p>\n<p>解决策略一  加锁</p>\n<ul>\n<li><p>脏读: 写加排它锁,读加共享锁。 当某个事务写的时候，其他事务不能读，就不会读到脏数据</p>\n</li>\n<li><p>不可重复读： 读数据时加读锁，写数据时加写锁。 保证读的过程中没有更新操作，写的过程中没有读操作</p>\n</li>\n<li><p>幻读: 加间隙锁+行锁</p>\n</li>\n</ul>\n<p>解决策略二 事务隔离</p>\n<ul>\n<li><p>脏读: 设置读已提交隔离级别</p>\n</li>\n<li><p>不可重复读： 可重复读级别</p>\n</li>\n<li><p>幻读: 串行</p>\n</li>\n</ul>\n","text":"Mysql 面试题1. B树和B+树的区别?相同点: 都是多路平衡查找树 一个节点中都有多个元素,且有序 不同点: B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中； B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"},{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Mysql-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">Mysql 面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1. B树和B+树的区别?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-InnoDB%E4%B8%ADB-%E6%A0%91%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">2. InnoDB中B+树有什么特点?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E4%BB%80%E4%B9%88%E6%98%AFInnoDB%E4%B8%AD%E7%9A%84page\"><span class=\"toc-text\">3. 什么是InnoDB中的page?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-InnoDB%E4%B8%AD%E7%9A%84Page%E6%98%AF%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F%E7%9A%84\"><span class=\"toc-text\">4. InnoDB中的Page是如何产生的?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">5. 什么是聚簇索引和非聚簇索引?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE%E8%B5%B0%E7%B4%A2%E5%BC%95%E7%9A%84\"><span class=\"toc-text\">6. InnoDB是如何支持范围查找走索引的?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95-%E5%AF%B9%E5%BA%94%E7%9A%84B-%E6%A0%91%E6%97%B6%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E7%9A%84\"><span class=\"toc-text\">7. 什么是联合索引?对应的B+树时如何生成的?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E6%89%8D%E8%83%BD%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">8. 什么是最左前缀原则?为什么要遵循最左前缀原则才能利用索引?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-Mysql%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E5%AD%97%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">9. Mysql中字符串和数字的类型转换问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E7%9A%84%E4%B8%8B%E6%8E%A8\"><span class=\"toc-text\">10. 什么是索引条件的下推?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">11. 什么是覆盖索引?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">12. 有哪些情况会导致索引失效?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#13-Mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E\"><span class=\"toc-text\">13. Mysql有哪些存储引擎?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#14-InnoDB-%E5%92%8C-MyISAM-%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">14. InnoDB 和 MyISAM 的主要区别?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#15-Mysql-%E4%B8%ADVarchar-M-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AD%98%E5%82%A8%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">15. Mysql 中Varchar(M)最多能存储多少数据?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#16-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">16. 事务的基本特性？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#17-%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E4%BC%9A%E5%BC%95%E5%8F%91%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">17. 事务并发会引发什么问题？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#18-Mysql%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">18. Mysql有哪些索引?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#19-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98insert%E6%80%A7%E8%83%BD\"><span class=\"toc-text\">19. 如何提高insert性能?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#20-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E9%94%81%EF%BC%9F\"><span class=\"toc-text\">20. 介绍一下数据库中的锁？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#21-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BMysql%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">21. 介绍一下Mysql中的死锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#22-Mysql%E4%B8%AD%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">22. Mysql中主从同步中实现的读写分离原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#23-Mysql%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">23. Mysql如何实现分库分表?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#24-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">24. 索引的设计原则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#25-Mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E6%80%8E%E4%B9%88%E7%9C%8B\"><span class=\"toc-text\">25. Mysql执行计划怎么看?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#26-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB\"><span class=\"toc-text\">26. 事务的隔离级别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#27-%E4%BB%80%E4%B9%88%E6%98%AFMVCC\"><span class=\"toc-text\">27. 什么是MVCC?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#28-ACID%E5%88%86%E5%88%AB%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81\"><span class=\"toc-text\">28. ACID分别靠什么保证?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#29-Mysql%E7%9A%84%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F\"><span class=\"toc-text\">29. Mysql的日志系统</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#30-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E3%80%81%E5%B9%BB%E8%AF%BB%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">30. 如何处理 脏读、不可重复读、幻读问题？</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Java面试题","uid":"e551e8b61cca027580338cf7a83d4c1a","slug":"Java面试题","date":"2022-08-30T08:08:03.000Z","updated":"2022-09-05T09:12:42.461Z","comments":true,"path":"api/articles/Java面试题.json","keywords":null,"cover":"/svg/java.svg","text":"JAVA面试题 1. finalize()方法有什么特点?finalize()方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。如...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"TCP/IP面试题","uid":"c975c593c9f6a4e28b749c03dfbcdd4c","slug":"TCP-IP面试题","date":"2022-08-10T03:00:16.000Z","updated":"2022-08-30T09:09:14.815Z","comments":true,"path":"api/articles/TCP-IP面试题.json","keywords":null,"cover":"svg/IP.svg","text":"TCP&#x2F;IP面试题1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?网络为什么要分层？因为，是个复杂的程序都要分层。 OSI网络模型包括7层: 物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"},{"name":"TCP/IP","slug":"TCP-IP","count":1,"path":"api/tags/TCP-IP.json"},{"name":"HTTP","slug":"HTTP","count":1,"path":"api/tags/HTTP.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}