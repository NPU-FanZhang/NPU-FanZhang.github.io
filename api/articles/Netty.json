{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-19T11:30:10.626Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<h2 id=\"1-Netty-概述\"><a href=\"#1-Netty-概述\" class=\"headerlink\" title=\"1. Netty 概述\"></a>1. Netty 概述</h2><blockquote><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p></blockquote>\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>\n<p><strong>优势:</strong></p>\n<p>如果使用传统NIO，其工作量大，bug 多</p>\n<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>\n</ul>\n<p>Netty 对 API 进行增强，使之更易用，如</p>\n<ul>\n<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>\n<li>ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n<h2 id=\"2-入门案例\"><a href=\"#2-入门案例\" class=\"headerlink\" title=\"2. 入门案例\"></a>2. 入门案例</h2><p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行流程:</strong></p>\n<p><strong>左：客户端 右：服务器端</strong></p>\n<img src=\"/post/Netty/20210420132155.png\" class=\"\" title=\"img\">\n\n<p><strong>组件解释</strong></p>\n<ul>\n<li>channel 可以理解为数据的通道</li>\n<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>handler 可以理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>\n<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>\n</ul>\n</li>\n<li>handler 分 Inbound 和 Outbound 两类<ul>\n<li>Inbound 入站</li>\n<li>Outbound 出站</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>eventLoop 可以理解为处理数据的工人<ul>\n<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>\n<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-Netty-组件\"><a href=\"#3-Netty-组件\" class=\"headerlink\" title=\"3. Netty 组件\"></a>3. Netty 组件</h2><h3 id=\"a-EventLoop\"><a href=\"#a-EventLoop\" class=\"headerlink\" title=\"a. EventLoop\"></a>a. EventLoop</h3><p><strong>事件循环对象</strong> EventLoop</p>\n<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>\n<p>它的继承关系如下</p>\n<ul>\n<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>继承自 netty 自己的 OrderedEventExecutor<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件循环组</strong> EventLoopGroup</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-EventLoop处理普通与定时任务\"><a href=\"#1-EventLoop处理普通与定时任务\" class=\"headerlink\" title=\"1. EventLoop处理普通与定时任务\"></a>1. EventLoop处理普通与定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">io.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2</code></pre>\n\n<p><strong>关闭 EventLoopGroup</strong></p>\n<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"2-EventLoop处理IO任务\"><a href=\"#2-EventLoop处理IO任务\" class=\"headerlink\" title=\"2. EventLoop处理IO任务\"></a>2. EventLoop处理IO任务</h4><p><strong>服务器端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        Channel channel &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                .sync()\n                .channel();\n        System.out.println(channel);\n        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>多个EventLoopGroup分工</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n            \t&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n\t\t\t\t...\n    &#125;\n&#125;</code></pre>\n\n<p>多个客户端分别发送 <code>hello</code> 结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nioEventLoopGroup-3-1 hello1\nnioEventLoopGroup-3-2 hello2\nnioEventLoopGroup-3-1 hello3\nnioEventLoopGroup-3-2 hello4\nnioEventLoopGroup-3-2 hello4Copy</code></pre>\n\n<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png\"><img src=\"/Netty/20210421103251.png\" alt=\"img\"></a></p>\n<h4 id=\"3-增加自定义EventLoopGroup\"><a href=\"#3-增加自定义EventLoopGroup\" class=\"headerlink\" title=\"3. 增加自定义EventLoopGroup\"></a>3. 增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        \n        new ServerBootstrap()\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理\n                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                                &#x2F;&#x2F; 调用下一个handler\n                                ctx.fireChannelRead(msg);\n                            &#125;\n                        &#125;)\n                        &#x2F;&#x2F; 该handler绑定自定义的Group\n                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p>启动四个客户端发送数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-4-1 hello1\ndefaultEventLoopGroup-2-1 hello1\nnioEventLoopGroup-4-2 hello2\ndefaultEventLoopGroup-2-2 hello2\nnioEventLoopGroup-4-1 hello3\ndefaultEventLoopGroup-2-3 hello3\nnioEventLoopGroup-4-2 hello4\ndefaultEventLoopGroup-2-4 hello4</code></pre>\n\n<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>\n<img src=\"/post/Netty/20210421103607.png\" class=\"\" title=\"img\">\n\n<h4 id=\"4-切换的实现\"><a href=\"#4-切换的实现\" class=\"headerlink\" title=\"4. 切换的实现\"></a>4. 切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>\n<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中\n    if (executor.inEventLoop()) &#123;\n        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务\n        next.invokeChannelRead(m);\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行\n        executor.execute(new Runnable() &#123;\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>\n</ul>\n<h3 id=\"b-Channel\"><a href=\"#b-Channel\" class=\"headerlink\" title=\"b. Channel\"></a>b. Channel</h3><p>Channel 的常用方法</p>\n<ul>\n<li>close() 可以用来关闭Channel</li>\n<li>closeFuture() 用来处理 Channel 的关闭<ul>\n<li>sync 方法作用是同步等待 Channel 关闭</li>\n<li>而 addListener 方法是异步等待 Channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法用于添加处理器</li>\n<li>write() 方法将数据写入<ul>\n<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>\n<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>\n</ul>\n</li>\n<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>\n</ul>\n<h4 id=\"1-ChannelFuture连接问题\"><a href=\"#1-ChannelFuture连接问题\" class=\"headerlink\" title=\"1. ChannelFuture连接问题\"></a>1. ChannelFuture连接问题</h4><p><strong>拆分客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n            \t&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n        &#x2F;&#x2F; 该方法用于等待连接真正建立\n        channelFuture.sync();\n        \n        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象\n        Channel channel &#x3D; channelFuture.channel();\n        channel.writeAndFlush(&quot;hello world&quot;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>\n<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>\n<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>\n<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>\n<p><strong>addListener方法</strong></p>\n<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n\t\t&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后\n        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法\n        channelFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n                Channel channel &#x3D; channelFuture.channel();\n                channel.writeAndFlush(&quot;hello world&quot;);\n            &#125;\n        &#125;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-处理关闭\"><a href=\"#2-处理关闭\" class=\"headerlink\" title=\"2.处理关闭\"></a>2.处理关闭</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReadClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        \n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        channelFuture.sync();\n\n        Channel channel &#x3D; channelFuture.channel();\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送\n        new Thread(()-&gt;&#123;\n            while (true) &#123;\n                String msg &#x3D; scanner.next();\n                if (&quot;q&quot;.equals(msg)) &#123;\n                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行\n                    channel.close();\n                    break;\n                &#125;\n                channel.writeAndFlush(msg);\n            &#125;\n        &#125;, &quot;inputThread&quot;).start();\n\n        &#x2F;&#x2F; 获得closeFuture对象\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        System.out.println(&quot;waiting close...&quot;);\n        \n        &#x2F;&#x2F; 同步等待NIO线程执行完close操作\n        closeFuture.sync();\n        \n        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        \n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>关闭channel</strong></p>\n<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>\n<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>\n<ul>\n<li><p>通过<code>channel.closeFuture()</code>方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得closeFuture对象\nChannelFuture closeFuture &#x3D; channel.closeFuture();\n\n&#x2F;&#x2F; 同步等待NIO线程执行完close操作\ncloseFuture.sync();</code></pre>\n</li>\n<li><p>调用<code>closeFuture.addListener</code>方法，添加close的后续操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">closeFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n        &#x2F;&#x2F; 等待channel关闭后才执行的操作\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;);</code></pre></li>\n</ul>\n<h3 id=\"c-Future-amp-Promise\"><a href=\"#c-Future-amp-Promise\" class=\"headerlink\" title=\"c. Future &amp; Promise\"></a>c. Future &amp; Promise</h3><h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>\n<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-JDK-Future\"><a href=\"#2-JDK-Future\" class=\"headerlink\" title=\"2. JDK Future\"></a>2. JDK Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ThreadFactory factory &#x3D; new ThreadFactory() &#123;\n            @Override\n            public Thread newThread(Runnable r) &#123;\n                return new Thread(r, &quot;JdkFuture&quot;);\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 创建线程池\n        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);\n\n        &#x2F;&#x2F; 获得Future对象\n        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;\n\n            @Override\n            public Integer call() throws Exception &#123;\n                TimeUnit.SECONDS.sleep(1);\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果\n        System.out.println(future.get());\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Netty-Future\"><a href=\"#3-Netty-Future\" class=\"headerlink\" title=\"3.Netty Future\"></a>3.Netty Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n\n        &#x2F;&#x2F; 获得 EventLoop 对象\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 主线程中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n        System.out.println(&quot;getNow &quot; + future.getNow());\n        System.out.println(&quot;get &quot; + future.get());\n\n        &#x2F;&#x2F; NIO线程中异步获取结果\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n                System.out.println(&quot;getNow &quot; + future.getNow());\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">main 获取结果\ngetNow null\nget 50\nnioEventLoopGroup-2-1 获取结果\ngetNow 50</code></pre>\n\n<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>\n<ul>\n<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>\n<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>\n<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>\n</ul>\n<h4 id=\"4-Netty-Promise\"><a href=\"#4-Netty-Promise\" class=\"headerlink\" title=\"4.Netty Promise\"></a>4.Netty Promise</h4><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoop\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n\n        &#x2F;&#x2F; 创建Promise对象，用于存放结果\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n\n        new Thread(()-&gt;&#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 自定义线程向Promise中存放结果\n            promise.setSuccess(50);\n        &#125;).start();\n\n        &#x2F;&#x2F; 主线程从Promise中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"d-Handler-amp-Pipline\"><a href=\"#d-Handler-amp-Pipline\" class=\"headerlink\" title=\"d. Handler &amp; Pipline\"></a>d. Handler &amp; Pipline</h3><h4 id=\"1-Pipeline\"><a href=\"#1-Pipeline\" class=\"headerlink\" title=\"1. Pipeline\"></a>1. Pipeline</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PipeLineServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler\n                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为\n    \t\t\t\t \t&#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail\n                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法\n                        &#x2F;&#x2F; 入站时，handler是从head向后调用的\n                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);\n                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead\n                                &#x2F;&#x2F; 将数据传递给下一个handler\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);\n                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用\n          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法\n                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的\n                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-2-2 Inbound handler 1\nnioEventLoopGroup-2-2 Inbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 1</code></pre>\n\n<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>\n<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>\n<ul>\n<li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul>\n<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>\n</ul>\n</li>\n<li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li>\n<li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li>\n</ul>\n<p><strong>具体结构如下</strong></p>\n<img src=\"/post/Netty/20210423102354.png\" class=\"\" title=\"img\">\n\n<p><strong>调用顺序如下</strong></p>\n<img src=\"/post/Netty/20210423105200.png\" class=\"\" title=\"img\">\n\n<h4 id=\"2-OutboundHandler\"><a href=\"#2-OutboundHandler\" class=\"headerlink\" title=\"2. OutboundHandler\"></a>2. OutboundHandler</h4><h5 id=\"a-socketChannel-writeAndFlush\"><a href=\"#a-socketChannel-writeAndFlush\" class=\"headerlink\" title=\"a. socketChannel.writeAndFlush()\"></a>a. socketChannel.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122010.png\" class=\"\" title=\"img\">\n\n<h5 id=\"b-ctx-writeAndFlush\"><a href=\"#b-ctx-writeAndFlush\" class=\"headerlink\" title=\"b. ctx.writeAndFlush()\"></a>b. ctx.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122050.png\" class=\"\" title=\"img\">\n\n<h4 id=\"3-EmbeddedChannel\"><a href=\"#3-EmbeddedChannel\" class=\"headerlink\" title=\"3. EmbeddedChannel\"></a>3. EmbeddedChannel</h4><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEmbeddedChannel &#123;\n    public static void main(String[] args) &#123;\n        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;1&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;2&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;3&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;4&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F; 用于测试Handler的Channel\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);\n        \n        &#x2F;&#x2F; 执行Inbound操作 \n        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n        &#x2F;&#x2F; 执行Outbound操作\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"e-ByteBuf\"><a href=\"#e-ByteBuf\" class=\"headerlink\" title=\"e. ByteBuf\"></a>e. ByteBuf</h3><h4 id=\"1-创建\"><a href=\"#1-创建\" class=\"headerlink\" title=\"1.创建\"></a>1.创建</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        StringBuilder sb &#x3D; new StringBuilder();\n        for(int i &#x3D; 0; i &lt; 20; i++) &#123;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        &#x2F;&#x2F; 查看写入结果\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:20 capacity:64\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|\n|00000010| 61 61 61 61                                     |aaaa            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>\n<p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p>\n<p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>\n<h4 id=\"2-直接内存与堆内存\"><a href=\"#2-直接内存与堆内存\" class=\"headerlink\" title=\"2.直接内存与堆内存\"></a>2.直接内存与堆内存</h4><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);Copy</code></pre>\n\n<p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);Copy</code></pre>\n\n<p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);Copy</code></pre>\n\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>\n<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<p><strong>验证</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);\n        System.out.println(buffer.getClass());\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用池化的直接内存\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n    \n&#x2F;&#x2F; 使用池化的堆内存    \nclass io.netty.buffer.PooledUnsafeHeapByteBuf\n    \n&#x2F;&#x2F; 使用池化的直接内存    \nclass io.netty.buffer.PooledUnsafeDirectByteBufCopy</code></pre>\n\n<h4 id=\"3-池化与非池化\"><a href=\"#3-池化与非池化\" class=\"headerlink\" title=\"3.池化与非池化\"></a>3.池化与非池化</h4><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p>\n<ul>\n<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>\n<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>\n<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;Copy</code></pre>\n\n<ul>\n<li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<h4 id=\"4-组成\"><a href=\"#4-组成\" class=\"headerlink\" title=\"4.组成\"></a>4.组成</h4><p>ByteBuf主要有以下几个组成部分</p>\n<ul>\n<li><p>最大容量与当前容量</p>\n<ul>\n<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>\n<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>\n</ul>\n</li>\n<li><p>读写操作不同于ByteBuffer只用position进行控制，</p>\n<p>ByteBuf分别由读指针和写指针两个指针控制</p>\n<p>。进行读写操作时，无需进行模式的切换</p>\n<ul>\n<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>\n<li>读指针与写指针之间的空间称为可读部分</li>\n<li>写指针与当前容量之间的空间称为可写部分</li>\n</ul>\n</li>\n</ul>\n<img src=\"/post/Netty/20210423143030.png\" class=\"\" title=\"img\">\n\n<h4 id=\"5-写入\"><a href=\"#5-写入\" class=\"headerlink\" title=\"5.写入\"></a>5.写入</h4><p>常用方法如下</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td><strong>用一字节 01|00 代表 true|false</strong></td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 <strong>ByteBuffer</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td>\n</tr>\n</tbody></table>\n<blockquote><p>注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li>\n<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>\n</ul></blockquote>\n<p><strong>使用方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeInt(5);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeIntLE(6);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeLong(7);\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:4 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p>\n<h4 id=\"6-扩容\"><a href=\"#6-扩容\" class=\"headerlink\" title=\"6.扩容\"></a>6.扩容</h4><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeLong(7);\nByteBufUtil.log(buffer);Copy\n&#x2F;&#x2F; 扩容前\nread index:0 write index:12 capacity:16\n...\n\n&#x2F;&#x2F; 扩容后\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"7-扩容规则\"><a href=\"#7-扩容规则\" class=\"headerlink\" title=\"7.扩容规则\"></a>7.扩容规则</h4><ul>\n<li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p>\n<ul>\n<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>\n</ul>\n</li>\n<li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p>\n<p>n</p>\n<ul>\n<li>例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）</li>\n</ul>\n</li>\n<li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)\n...</code></pre>\n\n<h4 id=\"8-读取\"><a href=\"#8-读取\" class=\"headerlink\" title=\"8.读取\"></a>8.读取</h4><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>\n<p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        buffer.writeInt(5);\n\n        &#x2F;&#x2F; 读取4个字节\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 通过mark与reset实现重复读取\n        buffer.markReaderIndex();\n        System.out.println(buffer.readInt());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 恢复到mark标记处\n        buffer.resetReaderIndex();\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;Copy\n1\n2\n3\n4\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+\n5\nread index:8 write index:8 capacity:16\n\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p>\n<h4 id=\"9-释放\"><a href=\"#9-释放\" class=\"headerlink\" title=\"9.释放\"></a>9.释放</h4><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>\n</ul>\n<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>\n<ul>\n<li>每个 ByteBuf 对象的初始计数为 1</li>\n<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>\n</ul>\n<h4 id=\"10-释放规则\"><a href=\"#10-释放规则\" class=\"headerlink\" title=\"10.释放规则\"></a>10.释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p>\n<ul>\n<li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p>\n</li>\n<li><p>入站 ByteBuf 处理原则</p>\n<ul>\n<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>\n<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>\n<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>\n<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>\n<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>\n</ul>\n</li>\n<li><p>出站 ByteBuf 处理原则</p>\n<ul>\n<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>\n</ul>\n</li>\n<li><p>异常处理原则</p>\n<ul>\n<li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">while (!buffer.release()) &#123;&#125;Copy</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p>\n<p><strong>TailConext中释放ByteBuf的源码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        &#x2F;&#x2F; 具体的释放方法\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;</code></pre>\n\n<p>判断传过来的是否为ByteBuf，是的话才需要释放</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static boolean release(Object msg) &#123;\n\treturn msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;\n&#125;</code></pre>\n\n<h4 id=\"11-切片\"><a href=\"#11-切片\" class=\"headerlink\" title=\"11.切片\"></a>11.切片</h4><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>\n<p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p>\n<p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p>\n<img src=\"/post/Netty/20210423154059.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestSlice &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);\n\n        &#x2F;&#x2F; 将buffer分成两部分\n        ByteBuf slice1 &#x3D; buffer.slice(0, 5);\n        ByteBuf slice2 &#x3D; buffer.slice(5, 5);\n\n        &#x2F;&#x2F; 需要让分片的buffer引用计数加一\n        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用\n        slice1.retain();\n        slice2.retain();\n        \n        ByteBufUtil.log(slice1);\n        ByteBufUtil.log(slice2);\n\n        &#x2F;&#x2F; 更改原始buffer中的值\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        buffer.setByte(0,5);\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        ByteBufUtil.log(slice1);\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 05 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"12-优势\"><a href=\"#12-优势\" class=\"headerlink\" title=\"12.优势\"></a>12.优势</h4><ul>\n<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以<strong>自动扩容</strong></li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如<ul>\n<li>slice、duplicate、CompositeByteBuf</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-黏包半包\"><a href=\"#4-黏包半包\" class=\"headerlink\" title=\"4. 黏包半包\"></a>4. 黏包半包</h2>","feature":true,"text":"1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protoc...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Netty 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Netty-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. Netty 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-EventLoop\"><span class=\"toc-text\">a. EventLoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-EventLoop%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1. EventLoop处理普通与定时任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-EventLoop%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">2. EventLoop处理IO任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup\"><span class=\"toc-text\">3. 增加自定义EventLoopGroup</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 切换的实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Channel\"><span class=\"toc-text\">b. Channel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ChannelFuture%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. ChannelFuture连接问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%84%E7%90%86%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">2.处理关闭</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Future-amp-Promise\"><span class=\"toc-text\">c. Future &amp; Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JDK-Future\"><span class=\"toc-text\">2. JDK Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Netty-Future\"><span class=\"toc-text\">3.Netty Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Netty-Promise\"><span class=\"toc-text\">4.Netty Promise</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-Handler-amp-Pipline\"><span class=\"toc-text\">d. Handler &amp; Pipline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Pipeline\"><span class=\"toc-text\">1. Pipeline</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-OutboundHandler\"><span class=\"toc-text\">2. OutboundHandler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-socketChannel-writeAndFlush\"><span class=\"toc-text\">a. socketChannel.writeAndFlush()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-ctx-writeAndFlush\"><span class=\"toc-text\">b. ctx.writeAndFlush()</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-EmbeddedChannel\"><span class=\"toc-text\">3. EmbeddedChannel</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ByteBuf\"><span class=\"toc-text\">e. ByteBuf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">1.创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\">2.直接内存与堆内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B1%A0%E5%8C%96%E4%B8%8E%E9%9D%9E%E6%B1%A0%E5%8C%96\"><span class=\"toc-text\">3.池化与非池化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">4.组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%86%99%E5%85%A5\"><span class=\"toc-text\">5.写入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">6.扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99\"><span class=\"toc-text\">7.扩容规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">8.读取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">9.释放</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E9%87%8A%E6%94%BE%E8%A7%84%E5%88%99\"><span class=\"toc-text\">10.释放规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E5%88%87%E7%89%87\"><span class=\"toc-text\">11.切片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">12.优势</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">4. 黏包半包</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-11T13:26:52.459Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":null,"text":"1. 环境搭建","link":"","photos":[],"count_time":{"symbolsCount":7,"symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}