{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-18T13:46:19.370Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<h2 id=\"1-Netty-概述\"><a href=\"#1-Netty-概述\" class=\"headerlink\" title=\"1. Netty 概述\"></a>1. Netty 概述</h2><blockquote><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p></blockquote>\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>\n<p><strong>优势:</strong></p>\n<p>如果使用传统NIO，其工作量大，bug 多</p>\n<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>\n</ul>\n<p>Netty 对 API 进行增强，使之更易用，如</p>\n<ul>\n<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>\n<li>ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n<h2 id=\"2-入门案例\"><a href=\"#2-入门案例\" class=\"headerlink\" title=\"2. 入门案例\"></a>2. 入门案例</h2><p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行流程:</strong></p>\n<p><strong>左：客户端 右：服务器端</strong></p>\n<img src=\"/post/Netty/20210420132155.png\" class=\"\" title=\"img\">\n\n<p><strong>组件解释</strong></p>\n<ul>\n<li>channel 可以理解为数据的通道</li>\n<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>handler 可以理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>\n<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>\n</ul>\n</li>\n<li>handler 分 Inbound 和 Outbound 两类<ul>\n<li>Inbound 入站</li>\n<li>Outbound 出站</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>eventLoop 可以理解为处理数据的工人<ul>\n<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>\n<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-Netty-组件\"><a href=\"#3-Netty-组件\" class=\"headerlink\" title=\"3. Netty 组件\"></a>3. Netty 组件</h2><h3 id=\"a-EventLoop\"><a href=\"#a-EventLoop\" class=\"headerlink\" title=\"a. EventLoop\"></a>a. EventLoop</h3><p><strong>事件循环对象</strong> EventLoop</p>\n<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>\n<p>它的继承关系如下</p>\n<ul>\n<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>继承自 netty 自己的 OrderedEventExecutor<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件循环组</strong> EventLoopGroup</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-EventLoop处理普通与定时任务\"><a href=\"#1-EventLoop处理普通与定时任务\" class=\"headerlink\" title=\"1. EventLoop处理普通与定时任务\"></a>1. EventLoop处理普通与定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">io.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2</code></pre>\n\n<p><strong>关闭 EventLoopGroup</strong></p>\n<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"2-EventLoop处理IO任务\"><a href=\"#2-EventLoop处理IO任务\" class=\"headerlink\" title=\"2. EventLoop处理IO任务\"></a>2. EventLoop处理IO任务</h4><p><strong>服务器端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        Channel channel &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                .sync()\n                .channel();\n        System.out.println(channel);\n        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>多个EventLoopGroup分工</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n            \t&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n\t\t\t\t...\n    &#125;\n&#125;</code></pre>\n\n<p>多个客户端分别发送 <code>hello</code> 结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nioEventLoopGroup-3-1 hello1\nnioEventLoopGroup-3-2 hello2\nnioEventLoopGroup-3-1 hello3\nnioEventLoopGroup-3-2 hello4\nnioEventLoopGroup-3-2 hello4Copy</code></pre>\n\n<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png\"><img src=\"/Netty/20210421103251.png\" alt=\"img\"></a></p>\n<h4 id=\"3-增加自定义EventLoopGroup\"><a href=\"#3-增加自定义EventLoopGroup\" class=\"headerlink\" title=\"3. 增加自定义EventLoopGroup\"></a>3. 增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        \n        new ServerBootstrap()\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理\n                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                                &#x2F;&#x2F; 调用下一个handler\n                                ctx.fireChannelRead(msg);\n                            &#125;\n                        &#125;)\n                        &#x2F;&#x2F; 该handler绑定自定义的Group\n                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p>启动四个客户端发送数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-4-1 hello1\ndefaultEventLoopGroup-2-1 hello1\nnioEventLoopGroup-4-2 hello2\ndefaultEventLoopGroup-2-2 hello2\nnioEventLoopGroup-4-1 hello3\ndefaultEventLoopGroup-2-3 hello3\nnioEventLoopGroup-4-2 hello4\ndefaultEventLoopGroup-2-4 hello4</code></pre>\n\n<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>\n<img src=\"/post/Netty/20210421103607.png\" class=\"\" title=\"img\">\n\n<h4 id=\"4-切换的实现\"><a href=\"#4-切换的实现\" class=\"headerlink\" title=\"4. 切换的实现\"></a>4. 切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>\n<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中\n    if (executor.inEventLoop()) &#123;\n        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务\n        next.invokeChannelRead(m);\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行\n        executor.execute(new Runnable() &#123;\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>\n</ul>\n<h3 id=\"b-Channel\"><a href=\"#b-Channel\" class=\"headerlink\" title=\"b. Channel\"></a>b. Channel</h3><p>Channel 的常用方法</p>\n<ul>\n<li>close() 可以用来关闭Channel</li>\n<li>closeFuture() 用来处理 Channel 的关闭<ul>\n<li>sync 方法作用是同步等待 Channel 关闭</li>\n<li>而 addListener 方法是异步等待 Channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法用于添加处理器</li>\n<li>write() 方法将数据写入<ul>\n<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>\n<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>\n</ul>\n</li>\n<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>\n</ul>\n<h4 id=\"1-ChannelFuture连接问题\"><a href=\"#1-ChannelFuture连接问题\" class=\"headerlink\" title=\"1. ChannelFuture连接问题\"></a>1. ChannelFuture连接问题</h4><p><strong>拆分客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n            \t&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n        &#x2F;&#x2F; 该方法用于等待连接真正建立\n        channelFuture.sync();\n        \n        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象\n        Channel channel &#x3D; channelFuture.channel();\n        channel.writeAndFlush(&quot;hello world&quot;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>\n<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>\n<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>\n<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>\n<p><strong>addListener方法</strong></p>\n<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n\t\t&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后\n        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法\n        channelFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n                Channel channel &#x3D; channelFuture.channel();\n                channel.writeAndFlush(&quot;hello world&quot;);\n            &#125;\n        &#125;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-处理关闭\"><a href=\"#2-处理关闭\" class=\"headerlink\" title=\"2.处理关闭\"></a>2.处理关闭</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReadClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        \n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        channelFuture.sync();\n\n        Channel channel &#x3D; channelFuture.channel();\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送\n        new Thread(()-&gt;&#123;\n            while (true) &#123;\n                String msg &#x3D; scanner.next();\n                if (&quot;q&quot;.equals(msg)) &#123;\n                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行\n                    channel.close();\n                    break;\n                &#125;\n                channel.writeAndFlush(msg);\n            &#125;\n        &#125;, &quot;inputThread&quot;).start();\n\n        &#x2F;&#x2F; 获得closeFuture对象\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        System.out.println(&quot;waiting close...&quot;);\n        \n        &#x2F;&#x2F; 同步等待NIO线程执行完close操作\n        closeFuture.sync();\n        \n        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        \n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>关闭channel</strong></p>\n<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>\n<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>\n<ul>\n<li><p>通过<code>channel.closeFuture()</code>方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得closeFuture对象\nChannelFuture closeFuture &#x3D; channel.closeFuture();\n\n&#x2F;&#x2F; 同步等待NIO线程执行完close操作\ncloseFuture.sync();</code></pre>\n</li>\n<li><p>调用<code>closeFuture.addListener</code>方法，添加close的后续操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">closeFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n        &#x2F;&#x2F; 等待channel关闭后才执行的操作\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;);</code></pre></li>\n</ul>\n<h3 id=\"c-Future-amp-Promise\"><a href=\"#c-Future-amp-Promise\" class=\"headerlink\" title=\"c. Future &amp; Promise\"></a>c. Future &amp; Promise</h3><h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>\n<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-JDK-Future\"><a href=\"#2-JDK-Future\" class=\"headerlink\" title=\"2. JDK Future\"></a>2. JDK Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ThreadFactory factory &#x3D; new ThreadFactory() &#123;\n            @Override\n            public Thread newThread(Runnable r) &#123;\n                return new Thread(r, &quot;JdkFuture&quot;);\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 创建线程池\n        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);\n\n        &#x2F;&#x2F; 获得Future对象\n        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;\n\n            @Override\n            public Integer call() throws Exception &#123;\n                TimeUnit.SECONDS.sleep(1);\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果\n        System.out.println(future.get());\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Netty-Future\"><a href=\"#3-Netty-Future\" class=\"headerlink\" title=\"3.Netty Future\"></a>3.Netty Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n\n        &#x2F;&#x2F; 获得 EventLoop 对象\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 主线程中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n        System.out.println(&quot;getNow &quot; + future.getNow());\n        System.out.println(&quot;get &quot; + future.get());\n\n        &#x2F;&#x2F; NIO线程中异步获取结果\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n                System.out.println(&quot;getNow &quot; + future.getNow());\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">main 获取结果\ngetNow null\nget 50\nnioEventLoopGroup-2-1 获取结果\ngetNow 50</code></pre>\n\n<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>\n<ul>\n<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>\n<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>\n<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>\n</ul>\n<h4 id=\"4-Netty-Promise\"><a href=\"#4-Netty-Promise\" class=\"headerlink\" title=\"4.Netty Promise\"></a>4.Netty Promise</h4><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoop\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n\n        &#x2F;&#x2F; 创建Promise对象，用于存放结果\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n\n        new Thread(()-&gt;&#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 自定义线程向Promise中存放结果\n            promise.setSuccess(50);\n        &#125;).start();\n\n        &#x2F;&#x2F; 主线程从Promise中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"d-Handler-amp-Pipline\"><a href=\"#d-Handler-amp-Pipline\" class=\"headerlink\" title=\"d. Handler &amp; Pipline\"></a>d. Handler &amp; Pipline</h3><h3 id=\"e-ByteBuf\"><a href=\"#e-ByteBuf\" class=\"headerlink\" title=\"e. ByteBuf\"></a>e. ByteBuf</h3>","feature":true,"text":"1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protoc...","link":"","photos":[],"count_time":{"symbolsCount":"22k","symbolsTime":"20 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Netty 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Netty-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. Netty 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-EventLoop\"><span class=\"toc-text\">a. EventLoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-EventLoop%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1. EventLoop处理普通与定时任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-EventLoop%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">2. EventLoop处理IO任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup\"><span class=\"toc-text\">3. 增加自定义EventLoopGroup</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 切换的实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Channel\"><span class=\"toc-text\">b. Channel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ChannelFuture%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. ChannelFuture连接问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%84%E7%90%86%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">2.处理关闭</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Future-amp-Promise\"><span class=\"toc-text\">c. Future &amp; Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JDK-Future\"><span class=\"toc-text\">2. JDK Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Netty-Future\"><span class=\"toc-text\">3.Netty Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Netty-Promise\"><span class=\"toc-text\">4.Netty Promise</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-Handler-amp-Pipline\"><span class=\"toc-text\">d. Handler &amp; Pipline</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ByteBuf\"><span class=\"toc-text\">e. ByteBuf</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-11T13:26:52.459Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":null,"text":"1. 环境搭建","link":"","photos":[],"count_time":{"symbolsCount":7,"symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}