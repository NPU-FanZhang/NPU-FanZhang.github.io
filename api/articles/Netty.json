{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-12T13:46:19.288Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<h2 id=\"1-NIO基础\"><a href=\"#1-NIO基础\" class=\"headerlink\" title=\"1. NIO基础\"></a>1. NIO基础</h2><p><strong>NIO - Non-blocking IO</strong> 或 <strong>New IO</strong></p>\n<h3 id=\"a-NIO的三大核心-Channel、Buffer、Selector\"><a href=\"#a-NIO的三大核心-Channel、Buffer、Selector\" class=\"headerlink\" title=\"a. NIO的三大核心-Channel、Buffer、Selector\"></a>a. NIO的三大核心-Channel、Buffer、Selector</h3><h4 id=\"1-Channel-与-Buffer\"><a href=\"#1-Channel-与-Buffer\" class=\"headerlink\" title=\"1. Channel 与 Buffer\"></a>1. Channel 与 Buffer</h4><p>Java NIO系统的<strong>核心</strong>在于：<strong>通道(Channel)和缓冲区(Buffer)。</strong></p>\n<p>通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于<strong>连接 IO 设备的通道</strong>以及用于<strong>容纳数据的缓冲区</strong>。然后操作缓冲区，对数据进行处理。简而言之，<strong>通道负责传输，缓冲区负责存储</strong></p>\n<p><strong>常见的Channel有以下四种</strong></p>\n<ul>\n<li><code>FileChannel</code>    主要用于文件传输</li>\n<li><code>DatagramChannel</code>   </li>\n<li><code>SocketChannel</code></li>\n<li><code>ServerSocketChannel</code></li>\n</ul>\n<p>其中FileChannel主要用于文件传输，其余三种用于网络通信</p>\n<p><strong>Buffer有以下几种</strong>，其中使用较多的是<strong>ByteBuffer</strong></p>\n<ul>\n<li><code>ByteBuffer</code>  常用<ul>\n<li>MappedByteBuffer</li>\n<li>DirectByteBuffer</li>\n<li>HeapByteBuffer</li>\n</ul>\n</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n<li>CharBuffer</li>\n</ul>\n<h4 id=\"2-Selector\"><a href=\"#2-Selector\" class=\"headerlink\" title=\"2. Selector\"></a>2. Selector</h4><p>在使用Selector之前，服务器处理socket连接还有以下两种方法</p>\n<p><strong>a. 服务器使用多线程技术</strong></p>\n<p>为每个连接分别开辟一个线程，分别去处理对应的socke连接</p>\n<img src=\"/post/Netty/20210418181918.png\" class=\"\" title=\"img\">\n\n<p>这种方法存在以下几个问题</p>\n<ul>\n<li>内存占用高<ul>\n<li>每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存</li>\n</ul>\n</li>\n<li>线程上下文切换成本高</li>\n<li>只适合连接数少的场景<ul>\n<li>连接数过多，会导致创建很多线程，从而出现问题</li>\n</ul>\n</li>\n</ul>\n<p><strong>b. 服务器使用线程池技术</strong></p>\n<p>使用线程池，让线程池中的线程去处理连接</p>\n<img src=\"/post/Netty/20210418181933.png\" class=\"\" title=\"img\">\n\n<p>这种方法存在以下几个问题</p>\n<ul>\n<li><strong>阻塞模式下，线程仅能处理一个连接</strong><ul>\n<li>线程池中的线程获取任务（task）后，<strong>只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务</strong></li>\n<li>若socke连接一直未断开，则其对应的线程无法处理其他socke连接</li>\n</ul>\n</li>\n<li>仅适合<strong>短连接</strong>场景<ul>\n<li>短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接</li>\n</ul>\n</li>\n</ul>\n<p><strong>c.服务器使用selector技术</strong></p>\n<p><strong>selector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector）</strong>，获取这些 channel 上发生的<strong>事件</strong>，这些 channel 工作在<strong>非阻塞模式</strong>下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。<strong>适合连接数多，但流量较少的场景</strong></p>\n<p>若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理。</p>\n<img src=\"/post/Netty/20210418181947.png\" class=\"\" title=\"img\">\n\n<h3 id=\"b-ByteBuffer\"><a href=\"#b-ByteBuffer\" class=\"headerlink\" title=\"b. ByteBuffer\"></a>b. ByteBuffer</h3><h4 id=\"1-使用方式\"><a href=\"#1-使用方式\" class=\"headerlink\" title=\"1. 使用方式\"></a>1. 使用方式</h4><ul>\n<li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p>\n</li>\n<li><p>调用 flip() 切换至读模式</p>\n<ul>\n<li><strong>flip会使得buffer中的limit变为position，position变为0</strong></li>\n</ul>\n</li>\n<li><p>从 buffer 读取数据，例如调用 buffer.get()</p>\n</li>\n<li><p>调用 clear() 或者compact()切换至</p>\n<p>写模式</p>\n<ul>\n<li>调用clear()方法时<strong>position&#x3D;0，limit变为capacity</strong></li>\n<li>调用compact()方法时，<strong>会将缓冲区中的未读数据压缩到缓冲区前面</strong></li>\n</ul>\n</li>\n<li><p>重复以上步骤</p>\n</li>\n</ul>\n<p><strong>使用ByteBuffer读取文件中的内容</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; FileChannel\n    &#x2F;&#x2F; 1. 使用输入输出流来获取 2. RandomAccessFile\n    try &#123;\n        &#x2F;&#x2F; 获取通道\n        FileChannel channel &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel();\n        &#x2F;&#x2F; 准备缓冲区\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);\n        &#x2F;&#x2F; 从channel 读取数据,向buffer写入\n        &#x2F;&#x2F; return : The number of bytes read, possibly zero, or -1 if the channel has reached\n        &#x2F;&#x2F; end-of-stream\n        int len &#x3D; channel.read(buffer);\n        &#x2F;&#x2F; 每次读缓冲区大小的数据,循环读,知道文件读完\n        while (len !&#x3D; -1)&#123;\n            &#x2F;&#x2F; 打印验证\n            buffer.flip(); &#x2F;&#x2F; 切换至读模式\n            while (buffer.hasRemaining()) &#123;\n                byte b &#x3D; buffer.get();&#x2F;&#x2F; 无参代表一次读一个字节\n                System.out.print((char) b);\n            &#125;\n            buffer.clear();&#x2F;&#x2F; 切换为写模式 不加会死循环,一直循环读前是个字节\n            len &#x3D; channel.read(buffer);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-ByteBuffer-结构\"><a href=\"#2-ByteBuffer-结构\" class=\"headerlink\" title=\"2. ByteBuffer 结构\"></a>2. ByteBuffer 结构</h4><h5 id=\"a-核心属性\"><a href=\"#a-核心属性\" class=\"headerlink\" title=\"a. 核心属性\"></a>a. 核心属性</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity\nprivate int mark &#x3D; -1;\nprivate int position &#x3D; 0;\nprivate int limit;\nprivate int capacity;</code></pre>\n\n<ul>\n<li><strong>capacity</strong>：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改</li>\n<li><strong>limit</strong>：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且<strong>不能大于其容量</strong></li>\n<li><strong>position</strong>：<strong>下一个</strong>读写位置的索引（类似PC）。缓冲区的位置不能为负，并且<strong>不能大于limit</strong></li>\n<li><strong>mark</strong>：记录当前position的值。<strong>position被改变后，可以通过调用reset() 方法恢复到mark的位置。</strong></li>\n</ul>\n<p>以上四个属性必须满足以下要求</p>\n<ul>\n<li><strong>mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity</strong></li>\n</ul>\n<h5 id=\"b-核心方法\"><a href=\"#b-核心方法\" class=\"headerlink\" title=\"b. 核心方法\"></a>b. 核心方法</h5><p><strong>put()方法</strong></p>\n<ul>\n<li>put()方法可以将一个数据放入到缓冲区中。</li>\n<li>进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。</li>\n</ul>\n<img src=\"Netty/20201109145709.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n<p><strong>flip()方法</strong></p>\n<ul>\n<li>flip()方法会<strong>切换对缓冲区的操作模式</strong>，由写-&gt;读 &#x2F; 读-&gt;写</li>\n<li>进行该操作后<ul>\n<li>如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变</li>\n<li>如果是读-&gt;写，则恢复为put()方法中的值</li>\n</ul>\n</li>\n</ul>\n<img src=\"Netty/20201109145753.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>get()方法</strong></p>\n<ul>\n<li>get()方法会读取缓冲区中的一个值</li>\n<li>进行该操作后，position会+1，如果超过了limit则会抛出异常</li>\n<li><strong>注意：get(i)方法不会改变position的值</strong></li>\n</ul>\n<img src=\"Netty/20201109145822.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>rewind()方法</strong></p>\n<ul>\n<li>该方法<strong>只能在读模式下使用</strong></li>\n<li>rewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值</li>\n</ul>\n<img src=\"Netty/20201109145852.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<p><strong>clean()方法</strong></p>\n<ul>\n<li>clean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit</li>\n<li><strong>此时缓冲区的数据依然存在</strong>，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据</li>\n</ul>\n<img src=\"Netty/20201109145905.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>mark()和reset()方法</strong></p>\n<ul>\n<li>mark()方法会将postion的值保存到mark属性中</li>\n<li>reset()方法会将position的值改为mark中保存的值</li>\n</ul>\n<p><strong>compact()方法</strong></p>\n<p><strong>此方法为ByteBuffer的方法，而不是Buffer的方法</strong></p>\n<ul>\n<li>compact会把未读完的数据向前压缩，然后切换到写模式</li>\n<li>数据前移后，原位置的值并未清零，写时会<strong>覆盖</strong>之前的值</li>\n</ul>\n<img src=\"Netty/20210412155726.png\" alt=\"img\" style=\"zoom: 67%;\" />\n\n\n\n<p><strong>clear() VS compact()</strong></p>\n<p>clear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。<strong>所以compact比clear更耗性能。</strong>但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了</p>\n<p><strong>所以需要根据情况来判断使用哪种方法进行模式切换</strong></p>\n<h4 id=\"3-字符串和-ByteBuffer-之间的转换\"><a href=\"#3-字符串和-ByteBuffer-之间的转换\" class=\"headerlink\" title=\"3. 字符串和 ByteBuffer 之间的转换\"></a>3. 字符串和 ByteBuffer 之间的转换</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 字符串和 ByteBuffer 之间的转换\npublic static void testByteBufferString() &#123;\n    &#x2F;&#x2F; 字符串转为 byteBuffer\n    &#x2F;&#x2F; 1. String 的 getBytes方法\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    buffer.put(&quot;hello&quot;.getBytes());\n    &#x2F;&#x2F; 2. StandardCharsets.UTF_8.encode 方法\n    ByteBuffer buffer2 &#x3D; StandardCharsets.UTF_8.encode(&quot;输出Hell&quot;);\n    &#x2F;&#x2F; 3. ByteBuffer.wrap\n    ByteBuffer buffer3 &#x3D; ByteBuffer.wrap(&quot;hello&quot;.getBytes());\n\n    &#x2F;&#x2F; byteBuffer转为字符串\n    String string &#x3D; StandardCharsets.UTF_8.decode(buffer2).toString();\n    &#x2F;&#x2F; buffer2的pos指针已经在第一个位置,可以直接转换\n    System.out.println(string);\n    buffer.flip();\n    String string2 &#x3D; StandardCharsets.UTF_8.decode(buffer).toString();\n    &#x2F;&#x2F; buffer1的pos指针不在第一个位置,要先转换模式\n    System.out.println(string2);\n&#125;</code></pre>\n\n\n\n<h4 id=\"4-粘包半包处理\"><a href=\"#4-粘包半包处理\" class=\"headerlink\" title=\"4. 粘包半包处理\"></a>4. 粘包半包处理</h4><p><strong>现象</strong></p>\n<p>网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>\n<ul>\n<li>Hello,world\\n</li>\n<li>I’m Nyima\\n</li>\n<li>How are you?\\n</li>\n</ul>\n<p>变成了下面的两个 byteBuffer (粘包，半包)</p>\n<ul>\n<li>Hello,world\\nI’m Nyima\\nHo</li>\n<li>w are you?\\n</li>\n</ul>\n<p><strong>出现原因</strong></p>\n<ul>\n<li><p><strong>粘包</strong>:发送方在发送数据时，并不是一条一条地发送数据，而是<strong>将数据整合在一起</strong>，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去</p>\n</li>\n<li><p><strong>半包</strong>:接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要<strong>将信息截断</strong>，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象</p>\n</li>\n</ul>\n<p><strong>解决办法</strong></p>\n<ul>\n<li><p>通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。</p>\n<p>注意</p>\n<p>：get(index)不会改变position的值</p>\n<ul>\n<li>记录该段数据长度，以便于申请对应大小的缓冲区</li>\n<li>将缓冲区的数据通过get()方法写入到target中</li>\n</ul>\n</li>\n<li><p>调用<strong>compact方法</strong>切换模式，因为缓冲区中可能还有未读的数据</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void testByteBufferExam() &#123;\n    &#x2F;*\n\t\t网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n\t\t但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\t\tHello,world\\n\n\t\tI’m Nyima\\n\n\t\tHow are you?\\n\n\t\t变成了下面的两个 byteBuffer (粘包，半包)\n\t\tHello,world\\nI’m Nyima\\nHo\n\t\tw are you?\\n\n    *&#x2F;\n    &#x2F;&#x2F; 接收到被分割的信息\n    ByteBuffer source &#x3D; ByteBuffer.allocate(32);\n    source.put(&quot;Hello,world\\nI’m Nyima\\nHo&quot;.getBytes());\n    &#x2F;&#x2F; 进行分割\n    split(source);\n    source.put(&quot;w are you?\\n&quot;.getBytes());\n    split(source);\n&#125;\n\npublic static void split(ByteBuffer source) &#123;\n    &#x2F;&#x2F; 切换读模式\n    source.flip();\n    for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n        &#x2F;&#x2F; 找到一个换行符则有一条消息\n        if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n            &#x2F;&#x2F; 把消息存入新的ByteBuffer\n            int len &#x3D; i + 1 - source.position(); &#x2F;&#x2F; 计算两个 \\n 之间内容的长度\n            ByteBuffer tar &#x3D; ByteBuffer.allocate(len);\n            for (int j &#x3D; 0; j &lt; len; j++) &#123;\n                tar.put(source.get());\n            &#125;\n            tar.flip(); &#x2F;&#x2F; 切换模式,让指针指向起始\n             System.out.print(StandardCharsets.UTF_8.decode(tar).toString());\n            tar.flip();\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 没读完,前推\n    source.compact();\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">+--------+-------------------- all ------------------------+----------------+\nposition: [12], limit: [12]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [10], limit: [10]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#39;m Nyima.      |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [13], limit: [13]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n<h3 id=\"c-文件编程\"><a href=\"#c-文件编程\" class=\"headerlink\" title=\"c. 文件编程\"></a>c. 文件编程</h3><h4 id=\"1-FileChannel\"><a href=\"#1-FileChannel\" class=\"headerlink\" title=\"1. FileChannel\"></a>1. FileChannel</h4><blockquote><p><strong>FileChannel只能工作在阻塞模式</strong>下，所以无法搭配Selector</p></blockquote>\n<h5 id=\"a-获取\"><a href=\"#a-获取\" class=\"headerlink\" title=\"a. 获取\"></a>a. 获取</h5><p>不能直接打开 FileChannel，<strong>必须</strong>通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>\n<ul>\n<li>通过 FileInputStream 获取的 channel <strong>只能读</strong></li>\n<li>通过 FileOutputStream 获取的 channel <strong>只能写</strong></li>\n<li>通过 RandomAccessFile 是否能读写<strong>根据构造 RandomAccessFile 时的读写模式决定</strong></li>\n</ul>\n<h5 id=\"b-读取\"><a href=\"#b-读取\" class=\"headerlink\" title=\"b. 读取\"></a>b. 读取</h5><p>通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中</p>\n<p>read方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int readBytes &#x3D; channel.read(buffer);</code></pre>\n\n<p><strong>可根据返回值判断是否读取完毕</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while(channel.read(buffer) &gt; 0) &#123;\n    &#x2F;&#x2F; 进行对应操作\n    ...\n&#125;</code></pre>\n\n\n\n<h5 id=\"c-写入\"><a href=\"#c-写入\" class=\"headerlink\" title=\"c. 写入\"></a>c. 写入</h5><p>因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须<strong>需要按照以下规则进行写入</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F; 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中\nwhile(buffer.hasRemaining()) &#123;\n\tchannel.write(buffer);\n&#125;</code></pre>\n\n\n\n<h5 id=\"d-关闭\"><a href=\"#d-关闭\" class=\"headerlink\" title=\"d. 关闭\"></a>d. 关闭</h5><p>通道需要close，一般情况通过try-with-resource进行关闭，<strong>最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 执行对应操作\n            ...\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h5 id=\"e-位置-position\"><a href=\"#e-位置-position\" class=\"headerlink\" title=\"e.位置 position\"></a>e.位置 position</h5><p>channel也拥有一个保存读取数据位置的属性，即position</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long pos &#x3D; channel.position();</code></pre>\n\n<p>可以通过position(int pos)设置channel中position的值</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">long newPos &#x3D; ...;\nchannel.position(newPos);</code></pre>\n\n<p>设置当前位置时，如果设置为文件的末尾</p>\n<ul>\n<li>这时读取会返回 -1</li>\n<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>\n</ul>\n<h5 id=\"f-强制写入\"><a href=\"#f-强制写入\" class=\"headerlink\" title=\"f. 强制写入\"></a>f. 强制写入</h5><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 <strong>force(true)</strong> 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>\n<h4 id=\"2-两个Channel传输数据\"><a href=\"#2-两个Channel传输数据\" class=\"headerlink\" title=\"2. 两个Channel传输数据\"></a>2. 两个Channel传输数据</h4><p><strong>transferTo方法</strong></p>\n<p>使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但<strong>一次只能传输2G的内容</strong></p>\n<p><strong>transferTo底层使用了零拷贝技术</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 参数：inputChannel的起始位置，传输数据的大小，目的channel\n            &#x2F;&#x2F; 返回值为传输的数据的字节数\n            &#x2F;&#x2F; transferTo一次只能传输2G的数据\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>当传输的文件<strong>大于2G</strong>时，需要使用以下方法进行多次传输</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            long size &#x3D; inputChannel.size();\n            long capacity &#x3D; inputChannel.size();\n            &#x2F;&#x2F; 分多次传输\n            while (capacity &gt; 0) &#123;\n                &#x2F;&#x2F; transferTo返回值为传输了的字节数\n                capacity -&#x3D; inputChannel.transferTo(size-capacity, capacity, outputChannel);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Path\"><a href=\"#3-Path\" class=\"headerlink\" title=\"3. Path\"></a>3. Path</h4><ul>\n<li>Path 用来表示文件路径</li>\n<li>Paths 是工具类，用来获取 Path 实例</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt\n\nPath source &#x3D; Paths.get(&quot;d:\\\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\\1.txt 反斜杠需要转义\n\nPath source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\\1.txt\n\nPath projects &#x3D; Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\\data\\projects</code></pre>\n\n<ul>\n<li><code>.</code> 代表了当前路径</li>\n<li><code>..</code> 代表了上一级路径</li>\n</ul>\n<p>例如目录结构如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">d:\n|- data\n\t|- projects\n\t\t|- a\n\t\t|- bCopy</code></pre>\n\n<p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);\nSystem.out.println(path);\nSystem.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径 会去除 . 以及 ..</code></pre>\n\n<p>输出结果为</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">d:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b</code></pre>\n\n<h4 id=\"4-Files\"><a href=\"#4-Files\" class=\"headerlink\" title=\"4. Files\"></a>4. Files</h4><h5 id=\"a-查找\"><a href=\"#a-查找\" class=\"headerlink\" title=\"a. 查找\"></a>a. 查找</h5><p>检查文件是否存在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nSystem.out.println(Files.exists(path));</code></pre>\n\n<h5 id=\"b-创建\"><a href=\"#b-创建\" class=\"headerlink\" title=\"b. 创建\"></a>b. 创建</h5><p>创建<strong>一级目录</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.createDirectory(path);</code></pre>\n\n<ul>\n<li>如果目录已存在，会抛异常 <code>FileAlreadyExistsException</code></li>\n<li>不能一次创建多级目录，否则会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n<p>创建<strong>多级目录用</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);\nFiles.createDirectories(path);</code></pre>\n\n<h5 id=\"c-拷贝及移动\"><a href=\"#c-拷贝及移动\" class=\"headerlink\" title=\"c. 拷贝及移动\"></a>c. 拷贝及移动</h5><p><strong>拷贝文件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.copy(source, target);</code></pre>\n\n<ul>\n<li>如果文件已存在，会抛异常 <code>FileAlreadyExistsException</code></li>\n</ul>\n<p>如果希望用 source <strong>覆盖</strong>掉 target，需要用 <code>StandardCopyOption</code> 来控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</code></pre>\n\n<p>移动文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);</code></pre>\n\n<ul>\n<li><strong>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</strong></li>\n</ul>\n<h5 id=\"d-删除\"><a href=\"#d-删除\" class=\"headerlink\" title=\"d. 删除\"></a>d. 删除</h5><p>删除文件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果文件不存在，会抛异常 <code>NoSuchFileException</code></li>\n</ul>\n<p>删除目录</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Path target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.delete(target);</code></pre>\n\n<ul>\n<li>如果<strong>目录还有内容</strong>，会抛异常 <code>DirectoryNotEmptyException</code></li>\n<li>只能删除空目录</li>\n</ul>\n<h5 id=\"e-遍历目录\"><a href=\"#e-遍历目录\" class=\"headerlink\" title=\"e. 遍历目录\"></a>e. 遍历目录</h5><p>可以<strong>使用Files工具类中的walkFileTree(Path, FileVisitor)方法</strong>，其中需要传入两个参数</p>\n<ul>\n<li><p>Path：文件起始路径</p>\n</li>\n<li><p><code>FileVisitor</code>：文件访问器，</p>\n<p>使用访问者模式</p>\n<ul>\n<li>接口的实现类<code>SimpleFileVisitor</code>有四个方法<ul>\n<li><code>preVisitDirectory</code>：访问目录前的操作</li>\n<li><code>visitFile</code>：访问文件的操作</li>\n<li><code>visitFileFailed</code>：访问文件失败时的操作</li>\n<li><code>postVisitDirectory</code>：访问目录后的操作</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void testFilesWalkFileTree() throws IOException &#123;\n    final AtomicInteger dirCnt &#x3D; new AtomicInteger();\n    final AtomicInteger fileCnt &#x3D; new AtomicInteger();\n    Files.walkFileTree(Paths.get(&quot;C:\\\\Users\\\\Lenovo\\\\.jdks\\\\corretto-1.8.0_302&quot;), new SimpleFileVisitor&lt;Path&gt;() &#123;\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&gt;&quot; + dir);\n            dirCnt.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        &#125;\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(file);\n            fileCnt.incrementAndGet();\n            return super.visitFile(file, attrs);\n        &#125;\n    &#125;);\n    System.out.println(&quot;dir count &quot; + dirCnt);\n    System.out.println(&quot;file count &quot; + fileCnt);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">...\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\index.html\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\CustomAutoCloseableSample.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\Unzip.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\ZipCat.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\src.zip\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\THIRD_PARTY_README\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\version.txt\ndir count 166\nfile count 701</code></pre>\n\n\n\n<h3 id=\"d-网络编程\"><a href=\"#d-网络编程\" class=\"headerlink\" title=\"d. 网络编程\"></a>d. 网络编程</h3>","feature":true,"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":8,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-NIO%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">1. NIO基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-NIO%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83-Channel%E3%80%81Buffer%E3%80%81Selector\"><span class=\"toc-text\">a. NIO的三大核心-Channel、Buffer、Selector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Channel-%E4%B8%8E-Buffer\"><span class=\"toc-text\">1. Channel 与 Buffer</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-Selector\"><span class=\"toc-text\">2. Selector</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-ByteBuffer\"><span class=\"toc-text\">b. ByteBuffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">1. 使用方式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-ByteBuffer-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. ByteBuffer 结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">a. 核心属性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">b. 核心方法</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C-ByteBuffer-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">3. 字符串和 ByteBuffer 之间的转换</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%B2%98%E5%8C%85%E5%8D%8A%E5%8C%85%E5%A4%84%E7%90%86\"><span class=\"toc-text\">4. 粘包半包处理</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%96%87%E4%BB%B6%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">c. 文件编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-FileChannel\"><span class=\"toc-text\">1. FileChannel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E8%8E%B7%E5%8F%96\"><span class=\"toc-text\">a. 获取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">b. 读取</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-%E5%86%99%E5%85%A5\"><span class=\"toc-text\">c. 写入</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#d-%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">d. 关闭</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#e-%E4%BD%8D%E7%BD%AE-position\"><span class=\"toc-text\">e.位置 position</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#f-%E5%BC%BA%E5%88%B6%E5%86%99%E5%85%A5\"><span class=\"toc-text\">f. 强制写入</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%A4%E4%B8%AAChannel%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">2. 两个Channel传输数据</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Path\"><span class=\"toc-text\">3. Path</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Files\"><span class=\"toc-text\">4. Files</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">a. 查找</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">b. 创建</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-%E6%8B%B7%E8%B4%9D%E5%8F%8A%E7%A7%BB%E5%8A%A8\"><span class=\"toc-text\">c. 拷贝及移动</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#d-%E5%88%A0%E9%99%A4\"><span class=\"toc-text\">d. 删除</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#e-%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95\"><span class=\"toc-text\">e. 遍历目录</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">d. 网络编程</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-11T13:26:52.459Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":null,"text":"1. 环境搭建","link":"","photos":[],"count_time":{"symbolsCount":7,"symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}