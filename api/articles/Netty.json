{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-18T05:45:34.731Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<h2 id=\"1-Netty-概述\"><a href=\"#1-Netty-概述\" class=\"headerlink\" title=\"1. Netty 概述\"></a>1. Netty 概述</h2><blockquote><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p></blockquote>\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>\n<p><strong>优势:</strong></p>\n<p>如果使用传统NIO，其工作量大，bug 多</p>\n<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>\n</ul>\n<p>Netty 对 API 进行增强，使之更易用，如</p>\n<ul>\n<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>\n<li>ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n<h2 id=\"2-入门案例\"><a href=\"#2-入门案例\" class=\"headerlink\" title=\"2. 入门案例\"></a>2. 入门案例</h2><p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行流程:</strong></p>\n<p><strong>左：客户端 右：服务器端</strong></p>\n<img src=\"/post/Netty/20210420132155.png\" class=\"\" title=\"img\">\n\n<p><strong>组件解释</strong></p>\n<ul>\n<li>channel 可以理解为数据的通道</li>\n<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>handler 可以理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>\n<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>\n</ul>\n</li>\n<li>handler 分 Inbound 和 Outbound 两类<ul>\n<li>Inbound 入站</li>\n<li>Outbound 出站</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>eventLoop 可以理解为处理数据的工人<ul>\n<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>\n<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-Netty-组件\"><a href=\"#3-Netty-组件\" class=\"headerlink\" title=\"3. Netty 组件\"></a>3. Netty 组件</h2><h3 id=\"a-EventLoop\"><a href=\"#a-EventLoop\" class=\"headerlink\" title=\"a. EventLoop\"></a>a. EventLoop</h3><p><strong>事件循环对象</strong> EventLoop</p>\n<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>\n<p>它的继承关系如下</p>\n<ul>\n<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>继承自 netty 自己的 OrderedEventExecutor<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件循环组</strong> EventLoopGroup</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-EventLoop处理普通与定时任务\"><a href=\"#1-EventLoop处理普通与定时任务\" class=\"headerlink\" title=\"1. EventLoop处理普通与定时任务\"></a>1. EventLoop处理普通与定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">io.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2</code></pre>\n\n\n\n<h4 id=\"2-EventLoop处理IO任务\"><a href=\"#2-EventLoop处理IO任务\" class=\"headerlink\" title=\"2. EventLoop处理IO任务\"></a>2. EventLoop处理IO任务</h4><h3 id=\"b-Channel\"><a href=\"#b-Channel\" class=\"headerlink\" title=\"b. Channel\"></a>b. Channel</h3><h3 id=\"c-Future-amp-Promise\"><a href=\"#c-Future-amp-Promise\" class=\"headerlink\" title=\"c. Future &amp; Promise\"></a>c. Future &amp; Promise</h3><h3 id=\"d-Handler-amp-Pipline\"><a href=\"#d-Handler-amp-Pipline\" class=\"headerlink\" title=\"d. Handler &amp; Pipline\"></a>d. Handler &amp; Pipline</h3><h3 id=\"e-ByteBuf\"><a href=\"#e-ByteBuf\" class=\"headerlink\" title=\"e. ByteBuf\"></a>e. ByteBuf</h3>","feature":true,"text":"1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protoc...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Netty 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Netty-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. Netty 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-EventLoop\"><span class=\"toc-text\">a. EventLoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-EventLoop%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1. EventLoop处理普通与定时任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-EventLoop%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">2. EventLoop处理IO任务</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Channel\"><span class=\"toc-text\">b. Channel</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Future-amp-Promise\"><span class=\"toc-text\">c. Future &amp; Promise</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-Handler-amp-Pipline\"><span class=\"toc-text\">d. Handler &amp; Pipline</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ByteBuf\"><span class=\"toc-text\">e. ByteBuf</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-11T13:26:52.459Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":null,"text":"1. 环境搭建","link":"","photos":[],"count_time":{"symbolsCount":7,"symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}