{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-20T05:03:03.642Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<h2 id=\"1-Netty-概述\"><a href=\"#1-Netty-概述\" class=\"headerlink\" title=\"1. Netty 概述\"></a>1. Netty 概述</h2><blockquote><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p></blockquote>\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>\n<p><strong>优势:</strong></p>\n<p>如果使用传统NIO，其工作量大，bug 多</p>\n<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>\n</ul>\n<p>Netty 对 API 进行增强，使之更易用，如</p>\n<ul>\n<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>\n<li>ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n<h2 id=\"2-入门案例\"><a href=\"#2-入门案例\" class=\"headerlink\" title=\"2. 入门案例\"></a>2. 入门案例</h2><p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行流程:</strong></p>\n<p><strong>左：客户端 右：服务器端</strong></p>\n<img src=\"/post/Netty/20210420132155.png\" class=\"\" title=\"img\">\n\n<p><strong>组件解释</strong></p>\n<ul>\n<li>channel 可以理解为数据的通道</li>\n<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>handler 可以理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>\n<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>\n</ul>\n</li>\n<li>handler 分 Inbound 和 Outbound 两类<ul>\n<li>Inbound 入站</li>\n<li>Outbound 出站</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>eventLoop 可以理解为处理数据的工人<ul>\n<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>\n<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-Netty-组件\"><a href=\"#3-Netty-组件\" class=\"headerlink\" title=\"3. Netty 组件\"></a>3. Netty 组件</h2><h3 id=\"a-EventLoop\"><a href=\"#a-EventLoop\" class=\"headerlink\" title=\"a. EventLoop\"></a>a. EventLoop</h3><p><strong>事件循环对象</strong> EventLoop</p>\n<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>\n<p>它的继承关系如下</p>\n<ul>\n<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>继承自 netty 自己的 OrderedEventExecutor<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件循环组</strong> EventLoopGroup</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-EventLoop处理普通与定时任务\"><a href=\"#1-EventLoop处理普通与定时任务\" class=\"headerlink\" title=\"1. EventLoop处理普通与定时任务\"></a>1. EventLoop处理普通与定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">io.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2</code></pre>\n\n<p><strong>关闭 EventLoopGroup</strong></p>\n<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"2-EventLoop处理IO任务\"><a href=\"#2-EventLoop处理IO任务\" class=\"headerlink\" title=\"2. EventLoop处理IO任务\"></a>2. EventLoop处理IO任务</h4><p><strong>服务器端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        Channel channel &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                .sync()\n                .channel();\n        System.out.println(channel);\n        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>多个EventLoopGroup分工</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n            \t&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n\t\t\t\t...\n    &#125;\n&#125;</code></pre>\n\n<p>多个客户端分别发送 <code>hello</code> 结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nioEventLoopGroup-3-1 hello1\nnioEventLoopGroup-3-2 hello2\nnioEventLoopGroup-3-1 hello3\nnioEventLoopGroup-3-2 hello4\nnioEventLoopGroup-3-2 hello4Copy</code></pre>\n\n<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png\"><img src=\"/Netty/20210421103251.png\" alt=\"img\"></a></p>\n<h4 id=\"3-增加自定义EventLoopGroup\"><a href=\"#3-增加自定义EventLoopGroup\" class=\"headerlink\" title=\"3. 增加自定义EventLoopGroup\"></a>3. 增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        \n        new ServerBootstrap()\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理\n                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                                &#x2F;&#x2F; 调用下一个handler\n                                ctx.fireChannelRead(msg);\n                            &#125;\n                        &#125;)\n                        &#x2F;&#x2F; 该handler绑定自定义的Group\n                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p>启动四个客户端发送数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-4-1 hello1\ndefaultEventLoopGroup-2-1 hello1\nnioEventLoopGroup-4-2 hello2\ndefaultEventLoopGroup-2-2 hello2\nnioEventLoopGroup-4-1 hello3\ndefaultEventLoopGroup-2-3 hello3\nnioEventLoopGroup-4-2 hello4\ndefaultEventLoopGroup-2-4 hello4</code></pre>\n\n<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>\n<img src=\"/post/Netty/20210421103607.png\" class=\"\" title=\"img\">\n\n<h4 id=\"4-切换的实现\"><a href=\"#4-切换的实现\" class=\"headerlink\" title=\"4. 切换的实现\"></a>4. 切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>\n<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中\n    if (executor.inEventLoop()) &#123;\n        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务\n        next.invokeChannelRead(m);\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行\n        executor.execute(new Runnable() &#123;\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>\n</ul>\n<h3 id=\"b-Channel\"><a href=\"#b-Channel\" class=\"headerlink\" title=\"b. Channel\"></a>b. Channel</h3><p>Channel 的常用方法</p>\n<ul>\n<li>close() 可以用来关闭Channel</li>\n<li>closeFuture() 用来处理 Channel 的关闭<ul>\n<li>sync 方法作用是同步等待 Channel 关闭</li>\n<li>而 addListener 方法是异步等待 Channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法用于添加处理器</li>\n<li>write() 方法将数据写入<ul>\n<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>\n<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>\n</ul>\n</li>\n<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>\n</ul>\n<h4 id=\"1-ChannelFuture连接问题\"><a href=\"#1-ChannelFuture连接问题\" class=\"headerlink\" title=\"1. ChannelFuture连接问题\"></a>1. ChannelFuture连接问题</h4><p><strong>拆分客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n            \t&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n        &#x2F;&#x2F; 该方法用于等待连接真正建立\n        channelFuture.sync();\n        \n        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象\n        Channel channel &#x3D; channelFuture.channel();\n        channel.writeAndFlush(&quot;hello world&quot;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>\n<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>\n<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>\n<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>\n<p><strong>addListener方法</strong></p>\n<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n\t\t&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后\n        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法\n        channelFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n                Channel channel &#x3D; channelFuture.channel();\n                channel.writeAndFlush(&quot;hello world&quot;);\n            &#125;\n        &#125;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-处理关闭\"><a href=\"#2-处理关闭\" class=\"headerlink\" title=\"2.处理关闭\"></a>2.处理关闭</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReadClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        \n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        channelFuture.sync();\n\n        Channel channel &#x3D; channelFuture.channel();\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送\n        new Thread(()-&gt;&#123;\n            while (true) &#123;\n                String msg &#x3D; scanner.next();\n                if (&quot;q&quot;.equals(msg)) &#123;\n                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行\n                    channel.close();\n                    break;\n                &#125;\n                channel.writeAndFlush(msg);\n            &#125;\n        &#125;, &quot;inputThread&quot;).start();\n\n        &#x2F;&#x2F; 获得closeFuture对象\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        System.out.println(&quot;waiting close...&quot;);\n        \n        &#x2F;&#x2F; 同步等待NIO线程执行完close操作\n        closeFuture.sync();\n        \n        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        \n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>关闭channel</strong></p>\n<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>\n<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>\n<ul>\n<li><p>通过<code>channel.closeFuture()</code>方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得closeFuture对象\nChannelFuture closeFuture &#x3D; channel.closeFuture();\n\n&#x2F;&#x2F; 同步等待NIO线程执行完close操作\ncloseFuture.sync();</code></pre>\n</li>\n<li><p>调用<code>closeFuture.addListener</code>方法，添加close的后续操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">closeFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n        &#x2F;&#x2F; 等待channel关闭后才执行的操作\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;);</code></pre></li>\n</ul>\n<h3 id=\"c-Future-amp-Promise\"><a href=\"#c-Future-amp-Promise\" class=\"headerlink\" title=\"c. Future &amp; Promise\"></a>c. Future &amp; Promise</h3><h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>\n<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-JDK-Future\"><a href=\"#2-JDK-Future\" class=\"headerlink\" title=\"2. JDK Future\"></a>2. JDK Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ThreadFactory factory &#x3D; new ThreadFactory() &#123;\n            @Override\n            public Thread newThread(Runnable r) &#123;\n                return new Thread(r, &quot;JdkFuture&quot;);\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 创建线程池\n        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);\n\n        &#x2F;&#x2F; 获得Future对象\n        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;\n\n            @Override\n            public Integer call() throws Exception &#123;\n                TimeUnit.SECONDS.sleep(1);\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果\n        System.out.println(future.get());\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Netty-Future\"><a href=\"#3-Netty-Future\" class=\"headerlink\" title=\"3.Netty Future\"></a>3.Netty Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n\n        &#x2F;&#x2F; 获得 EventLoop 对象\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 主线程中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n        System.out.println(&quot;getNow &quot; + future.getNow());\n        System.out.println(&quot;get &quot; + future.get());\n\n        &#x2F;&#x2F; NIO线程中异步获取结果\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n                System.out.println(&quot;getNow &quot; + future.getNow());\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">main 获取结果\ngetNow null\nget 50\nnioEventLoopGroup-2-1 获取结果\ngetNow 50</code></pre>\n\n<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>\n<ul>\n<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>\n<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>\n<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>\n</ul>\n<h4 id=\"4-Netty-Promise\"><a href=\"#4-Netty-Promise\" class=\"headerlink\" title=\"4.Netty Promise\"></a>4.Netty Promise</h4><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoop\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n\n        &#x2F;&#x2F; 创建Promise对象，用于存放结果\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n\n        new Thread(()-&gt;&#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 自定义线程向Promise中存放结果\n            promise.setSuccess(50);\n        &#125;).start();\n\n        &#x2F;&#x2F; 主线程从Promise中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"d-Handler-amp-Pipline\"><a href=\"#d-Handler-amp-Pipline\" class=\"headerlink\" title=\"d. Handler &amp; Pipline\"></a>d. Handler &amp; Pipline</h3><h4 id=\"1-Pipeline\"><a href=\"#1-Pipeline\" class=\"headerlink\" title=\"1. Pipeline\"></a>1. Pipeline</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PipeLineServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler\n                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为\n    \t\t\t\t \t&#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail\n                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法\n                        &#x2F;&#x2F; 入站时，handler是从head向后调用的\n                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);\n                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead\n                                &#x2F;&#x2F; 将数据传递给下一个handler\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);\n                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用\n          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法\n                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的\n                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-2-2 Inbound handler 1\nnioEventLoopGroup-2-2 Inbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 1</code></pre>\n\n<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>\n<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>\n<ul>\n<li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul>\n<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>\n</ul>\n</li>\n<li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li>\n<li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li>\n</ul>\n<p><strong>具体结构如下</strong></p>\n<img src=\"/post/Netty/20210423102354.png\" class=\"\" title=\"img\">\n\n<p><strong>调用顺序如下</strong></p>\n<img src=\"/post/Netty/20210423105200.png\" class=\"\" title=\"img\">\n\n<h4 id=\"2-OutboundHandler\"><a href=\"#2-OutboundHandler\" class=\"headerlink\" title=\"2. OutboundHandler\"></a>2. OutboundHandler</h4><h5 id=\"a-socketChannel-writeAndFlush\"><a href=\"#a-socketChannel-writeAndFlush\" class=\"headerlink\" title=\"a. socketChannel.writeAndFlush()\"></a>a. socketChannel.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122010.png\" class=\"\" title=\"img\">\n\n<h5 id=\"b-ctx-writeAndFlush\"><a href=\"#b-ctx-writeAndFlush\" class=\"headerlink\" title=\"b. ctx.writeAndFlush()\"></a>b. ctx.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122050.png\" class=\"\" title=\"img\">\n\n<h4 id=\"3-EmbeddedChannel\"><a href=\"#3-EmbeddedChannel\" class=\"headerlink\" title=\"3. EmbeddedChannel\"></a>3. EmbeddedChannel</h4><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEmbeddedChannel &#123;\n    public static void main(String[] args) &#123;\n        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;1&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;2&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;3&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;4&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F; 用于测试Handler的Channel\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);\n        \n        &#x2F;&#x2F; 执行Inbound操作 \n        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n        &#x2F;&#x2F; 执行Outbound操作\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"e-ByteBuf\"><a href=\"#e-ByteBuf\" class=\"headerlink\" title=\"e. ByteBuf\"></a>e. ByteBuf</h3><h4 id=\"1-创建\"><a href=\"#1-创建\" class=\"headerlink\" title=\"1.创建\"></a>1.创建</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        StringBuilder sb &#x3D; new StringBuilder();\n        for(int i &#x3D; 0; i &lt; 20; i++) &#123;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        &#x2F;&#x2F; 查看写入结果\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:20 capacity:64\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|\n|00000010| 61 61 61 61                                     |aaaa            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>\n<p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p>\n<p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>\n<h4 id=\"2-直接内存与堆内存\"><a href=\"#2-直接内存与堆内存\" class=\"headerlink\" title=\"2.直接内存与堆内存\"></a>2.直接内存与堆内存</h4><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);Copy</code></pre>\n\n<p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);Copy</code></pre>\n\n<p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);Copy</code></pre>\n\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>\n<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<p><strong>验证</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);\n        System.out.println(buffer.getClass());\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用池化的直接内存\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n    \n&#x2F;&#x2F; 使用池化的堆内存    \nclass io.netty.buffer.PooledUnsafeHeapByteBuf\n    \n&#x2F;&#x2F; 使用池化的直接内存    \nclass io.netty.buffer.PooledUnsafeDirectByteBufCopy</code></pre>\n\n<h4 id=\"3-池化与非池化\"><a href=\"#3-池化与非池化\" class=\"headerlink\" title=\"3.池化与非池化\"></a>3.池化与非池化</h4><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p>\n<ul>\n<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>\n<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>\n<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125;Copy</code></pre>\n\n<ul>\n<li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<h4 id=\"4-组成\"><a href=\"#4-组成\" class=\"headerlink\" title=\"4.组成\"></a>4.组成</h4><p>ByteBuf主要有以下几个组成部分</p>\n<ul>\n<li><p>最大容量与当前容量</p>\n<ul>\n<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>\n<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>\n</ul>\n</li>\n<li><p>读写操作不同于ByteBuffer只用position进行控制，</p>\n<p>ByteBuf分别由读指针和写指针两个指针控制</p>\n<p>。进行读写操作时，无需进行模式的切换</p>\n<ul>\n<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>\n<li>读指针与写指针之间的空间称为可读部分</li>\n<li>写指针与当前容量之间的空间称为可写部分</li>\n</ul>\n</li>\n</ul>\n<img src=\"/post/Netty/20210423143030.png\" class=\"\" title=\"img\">\n\n<h4 id=\"5-写入\"><a href=\"#5-写入\" class=\"headerlink\" title=\"5.写入\"></a>5.写入</h4><p>常用方法如下</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td><strong>用一字节 01|00 代表 true|false</strong></td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 <strong>ByteBuffer</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td>\n</tr>\n</tbody></table>\n<blockquote><p>注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li>\n<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>\n</ul></blockquote>\n<p><strong>使用方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeInt(5);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeIntLE(6);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeLong(7);\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:4 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p>\n<h4 id=\"6-扩容\"><a href=\"#6-扩容\" class=\"headerlink\" title=\"6.扩容\"></a>6.扩容</h4><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeLong(7);\nByteBufUtil.log(buffer);Copy\n&#x2F;&#x2F; 扩容前\nread index:0 write index:12 capacity:16\n...\n\n&#x2F;&#x2F; 扩容后\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"7-扩容规则\"><a href=\"#7-扩容规则\" class=\"headerlink\" title=\"7.扩容规则\"></a>7.扩容规则</h4><ul>\n<li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p>\n<ul>\n<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>\n</ul>\n</li>\n<li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p>\n<p>n</p>\n<ul>\n<li>例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）</li>\n</ul>\n</li>\n<li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)\n...</code></pre>\n\n<h4 id=\"8-读取\"><a href=\"#8-读取\" class=\"headerlink\" title=\"8.读取\"></a>8.读取</h4><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>\n<p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        buffer.writeInt(5);\n\n        &#x2F;&#x2F; 读取4个字节\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 通过mark与reset实现重复读取\n        buffer.markReaderIndex();\n        System.out.println(buffer.readInt());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 恢复到mark标记处\n        buffer.resetReaderIndex();\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;Copy\n1\n2\n3\n4\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+\n5\nread index:8 write index:8 capacity:16\n\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p>\n<h4 id=\"9-释放\"><a href=\"#9-释放\" class=\"headerlink\" title=\"9.释放\"></a>9.释放</h4><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>\n</ul>\n<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>\n<ul>\n<li>每个 ByteBuf 对象的初始计数为 1</li>\n<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>\n</ul>\n<h4 id=\"10-释放规则\"><a href=\"#10-释放规则\" class=\"headerlink\" title=\"10.释放规则\"></a>10.释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p>\n<ul>\n<li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p>\n</li>\n<li><p>入站 ByteBuf 处理原则</p>\n<ul>\n<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>\n<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>\n<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>\n<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>\n<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>\n</ul>\n</li>\n<li><p>出站 ByteBuf 处理原则</p>\n<ul>\n<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>\n</ul>\n</li>\n<li><p>异常处理原则</p>\n<ul>\n<li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">while (!buffer.release()) &#123;&#125;Copy</code></pre></li>\n</ul>\n</li>\n</ul>\n<p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p>\n<p><strong>TailConext中释放ByteBuf的源码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        &#x2F;&#x2F; 具体的释放方法\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;</code></pre>\n\n<p>判断传过来的是否为ByteBuf，是的话才需要释放</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static boolean release(Object msg) &#123;\n\treturn msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;\n&#125;</code></pre>\n\n<h4 id=\"11-切片\"><a href=\"#11-切片\" class=\"headerlink\" title=\"11.切片\"></a>11.切片</h4><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>\n<p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p>\n<p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p>\n<img src=\"/post/Netty/20210423154059.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestSlice &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);\n\n        &#x2F;&#x2F; 将buffer分成两部分\n        ByteBuf slice1 &#x3D; buffer.slice(0, 5);\n        ByteBuf slice2 &#x3D; buffer.slice(5, 5);\n\n        &#x2F;&#x2F; 需要让分片的buffer引用计数加一\n        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用\n        slice1.retain();\n        slice2.retain();\n        \n        ByteBufUtil.log(slice1);\n        ByteBufUtil.log(slice2);\n\n        &#x2F;&#x2F; 更改原始buffer中的值\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        buffer.setByte(0,5);\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        ByteBufUtil.log(slice1);\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 05 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"12-优势\"><a href=\"#12-优势\" class=\"headerlink\" title=\"12.优势\"></a>12.优势</h4><ul>\n<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以<strong>自动扩容</strong></li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如<ul>\n<li>slice、duplicate、CompositeByteBuf</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-黏包半包\"><a href=\"#4-黏包半包\" class=\"headerlink\" title=\"4. 黏包半包\"></a>4. 黏包半包</h2><h3 id=\"a-黏包与半包现象\"><a href=\"#a-黏包与半包现象\" class=\"headerlink\" title=\"a.黏包与半包现象\"></a>a.黏包与半包现象</h3><p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StudyServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    void start() &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) &#123;\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接建立时会执行该方法\n                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                            super.channelActive(ctx);\n                        &#125;\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接断开时会执行该方法\n                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                            super.channelInactive(ctx);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n            channelFuture.sync();\n            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n            &#x2F;&#x2F; 关闭channel\n            channelFuture.channel().closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(&quot;stopped&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new StudyServer().start();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"1-粘包现象\"><a href=\"#1-粘包现象\" class=\"headerlink\" title=\"1. 粘包现象\"></a>1. 粘包现象</h4><p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StudyClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connected...&quot;);\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                                ctx.writeAndFlush(buffer);\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>服务器接收结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p>\n<h4 id=\"2-半包现象\"><a href=\"#2-半包现象\" class=\"headerlink\" title=\"2. 半包现象\"></a>2. 半包现象</h4><p>将客户端-服务器之间的channel容量进行调整</p>\n<p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 调整channel的容量\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</code></pre>\n\n<p><strong>注意</strong></p>\n<blockquote><p><code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code> 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote>\n<p><strong>服务器接收结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p>\n<h3 id=\"b-现象分析\"><a href=\"#b-现象分析\" class=\"headerlink\" title=\"b. 现象分析\"></a>b. 现象分析</h3><h4 id=\"1-粘包\"><a href=\"#1-粘包\" class=\"headerlink\" title=\"1. 粘包\"></a>1. 粘包</h4><ul>\n<li>现象<ul>\n<li>发送 abc def，接收 abcdef</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>应用层<ul>\n<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>\n</ul>\n</li>\n<li>传输层-网络层<ul>\n<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li>\n<li>Nagle 算法：会造成粘包</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-半包\"><a href=\"#2-半包\" class=\"headerlink\" title=\"2. 半包\"></a>2. 半包</h4><ul>\n<li>现象<ul>\n<li>发送 abcdef，接收 abc def</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>应用层<ul>\n<li>接收方 ByteBuf 小于实际发送数据量</li>\n</ul>\n</li>\n<li>传输层-网络层<ul>\n<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-本质\"><a href=\"#3-本质\" class=\"headerlink\" title=\"3. 本质\"></a>3. 本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p>\n<h3 id=\"c-解决方案\"><a href=\"#c-解决方案\" class=\"headerlink\" title=\"c. 解决方案\"></a>c. 解决方案</h3><h4 id=\"1-短链接\"><a href=\"#1-短链接\" class=\"headerlink\" title=\"1. 短链接\"></a>1. 短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>\n<p><strong>客户端代码改进</strong></p>\n<p>修改channelActive方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n    log.debug(&quot;sending...&quot;);\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);\n    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n    ctx.writeAndFlush(buffer);\n    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接\n    ctx.channel().close();\n&#125;Copy</code></pre>\n\n<p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 发送10次\n    for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n        send();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE\n\n...</code></pre>\n\n<p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p>\n<h4 id=\"2-定长解码器\"><a href=\"#2-定长解码器\" class=\"headerlink\" title=\"2. 定长解码器\"></a>2. 定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p>\n<p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ch.pipeline().addLast(new FixedLengthFrameDecoder(16));Copy</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<p>客户端发送数据的代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 约定最大长度为16\nfinal int maxLength &#x3D; 16;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\n&#x2F;&#x2F; 向服务器发送10个报文\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充\n    byte[] bytes &#x3D; new byte[maxLength];\n    &#x2F;&#x2F; 生成长度为0~15的数据\n    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;\n        bytes[j] &#x3D; (byte) c;\n    &#125;\n    buffer.writeBytes(bytes);\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;</code></pre>\n\n<p><strong>服务器代码</strong></p>\n<p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分\nch.pipeline().addLast(new FixedLengthFrameDecoder(16));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|\n+--------+-------------------------------------------------+----------------+\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|\n+--------+-------------------------------------------------+----------------+\n\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<h4 id=\"3-行解码器\"><a href=\"#3-行解码器\" class=\"headerlink\" title=\"3. 行解码器\"></a>3. 行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p>\n<p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p>\n<p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>\n<p><strong>以换行符 \\n 为分隔符</strong></p>\n<p>客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 约定最大长度为 64\nfinal int maxLength &#x3D; 64;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 生成长度为0~62的数据\n    Random random &#x3D; new Random();\n    StringBuilder sb &#x3D; new StringBuilder();\n    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;\n        sb.append(c);\n    &#125;\n    &#x2F;&#x2F; 数据以 \\n 结尾\n    sb.append(&quot;\\n&quot;);\n    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;</code></pre>\n\n<p>服务器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\n 为分隔符\n&#x2F;&#x2F; 需要指定最大长度\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63                                           |cc              |\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<p><strong>以自定义分隔符 \\c 为分隔符</strong></p>\n<p>客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">...\n    \n&#x2F;&#x2F; 数据以 \\c 结尾\nsb.append(&quot;\\\\c&quot;);\nbuffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n...</code></pre>\n\n<p>服务器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 将分隔符放入ByteBuf中\nByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\\\c&quot;.getBytes(StandardCharsets.UTF_8));\n&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\c 为分隔符\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |\n+--------+-------------------------------------------------+----------------+\n\n\n8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<h4 id=\"4-长度字段解码器\"><a href=\"#4-长度字段解码器\" class=\"headerlink\" title=\"4. 长度字段解码器\"></a>4. 长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>\n<p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public LengthFieldBasedFrameDecoder(\n    int maxFrameLength,\n    int lengthFieldOffset, int lengthFieldLength,\n    int lengthAdjustment, int initialBytesToStrip)</code></pre>\n\n<p><strong>参数解析</strong></p>\n<ul>\n<li>maxFrameLength 数据最大长度<ul>\n<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>\n</ul>\n</li>\n<li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul>\n<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>\n</ul>\n</li>\n<li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul>\n<li>数据中用于表示有用数据长度的标识所占的字节数</li>\n</ul>\n</li>\n<li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul>\n<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>\n</ul>\n</li>\n<li>initialBytesToStrip <strong>数据读取起点</strong><ul>\n<li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>参数图解</strong></p>\n<img src=\"/post/Netty/20210425200007.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)\n+--------+----------------+      +--------+----------------+\n| Length | Actual Content |-----&gt;| Length | Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +--------+----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为2个字节</p>\n<p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)\n+--------+----------------+      +----------------+\n| Length | Actual Content |-----&gt;| Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p>\n<p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |\n|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+</code></pre>\n\n<p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p>\n<p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |\n| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p>\n<p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p>\n<hr>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)\ninitialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)\n  \nBEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)\n+------+--------+------+----------------+      +------+----------------+\n| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |\n| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |\n+------+--------+------+----------------+      +------+----------------+Copy</code></pre>\n\n<p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p>\n<hr>\n<p><strong>使用</strong></p>\n<p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EncoderStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 模拟服务器\n        &#x2F;&#x2F; 使用EmbeddedChannel测试handler\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）\n                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),\n                new LoggingHandler(LogLevel.DEBUG)\n        );\n\n        &#x2F;&#x2F; 模拟客户端，写入数据\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();\n        send(buffer, &quot;Hello&quot;);\n        channel.writeInbound(buffer);\n        send(buffer, &quot;World&quot;);\n        channel.writeInbound(buffer);\n    &#125;\n\n    private static void send(ByteBuf buf, String msg) &#123;\n        &#x2F;&#x2F; 得到数据的长度\n        int length &#x3D; msg.length();\n        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);\n        &#x2F;&#x2F; 将数据信息写入buf\n        &#x2F;&#x2F; 写入长度标识前的其他信息\n        buf.writeByte(0xCA);\n        &#x2F;&#x2F; 写入数据长度标识\n        buf.writeInt(length);\n        &#x2F;&#x2F; 写入长度标识后的其他信息\n        buf.writeByte(0xFE);\n        &#x2F;&#x2F; 写入具体的数据\n        buf.writeBytes(bytes);\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |\n+--------+-------------------------------------------------+----------------+\n\n146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","feature":true,"text":"1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protoc...","link":"","photos":[],"count_time":{"symbolsCount":"67k","symbolsTime":"1:01"},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Netty 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Netty-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. Netty 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-EventLoop\"><span class=\"toc-text\">a. EventLoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-EventLoop%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1. EventLoop处理普通与定时任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-EventLoop%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">2. EventLoop处理IO任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup\"><span class=\"toc-text\">3. 增加自定义EventLoopGroup</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 切换的实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Channel\"><span class=\"toc-text\">b. Channel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ChannelFuture%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. ChannelFuture连接问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%84%E7%90%86%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">2.处理关闭</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Future-amp-Promise\"><span class=\"toc-text\">c. Future &amp; Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JDK-Future\"><span class=\"toc-text\">2. JDK Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Netty-Future\"><span class=\"toc-text\">3.Netty Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Netty-Promise\"><span class=\"toc-text\">4.Netty Promise</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-Handler-amp-Pipline\"><span class=\"toc-text\">d. Handler &amp; Pipline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Pipeline\"><span class=\"toc-text\">1. Pipeline</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-OutboundHandler\"><span class=\"toc-text\">2. OutboundHandler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-socketChannel-writeAndFlush\"><span class=\"toc-text\">a. socketChannel.writeAndFlush()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-ctx-writeAndFlush\"><span class=\"toc-text\">b. ctx.writeAndFlush()</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-EmbeddedChannel\"><span class=\"toc-text\">3. EmbeddedChannel</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ByteBuf\"><span class=\"toc-text\">e. ByteBuf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">1.创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\">2.直接内存与堆内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B1%A0%E5%8C%96%E4%B8%8E%E9%9D%9E%E6%B1%A0%E5%8C%96\"><span class=\"toc-text\">3.池化与非池化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">4.组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%86%99%E5%85%A5\"><span class=\"toc-text\">5.写入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">6.扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99\"><span class=\"toc-text\">7.扩容规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">8.读取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">9.释放</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E9%87%8A%E6%94%BE%E8%A7%84%E5%88%99\"><span class=\"toc-text\">10.释放规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E5%88%87%E7%89%87\"><span class=\"toc-text\">11.切片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">12.优势</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">4. 黏包半包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E9%BB%8F%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">a.黏包与半包现象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">1. 粘包现象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">2. 半包现象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90\"><span class=\"toc-text\">b. 现象分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">1. 粘包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">2. 半包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">3. 本质</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">c. 解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%9F%AD%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">1. 短链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%9A%E9%95%BF%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">2. 定长解码器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%A1%8C%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">3. 行解码器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">4. 长度字段解码器</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-11T13:26:52.459Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":null,"text":"1. 环境搭建","link":"","photos":[],"count_time":{"symbolsCount":7,"symbolsTime":"1 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Mybatis","slug":"Mybatis","count":1,"path":"api/tags/Mybatis.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}