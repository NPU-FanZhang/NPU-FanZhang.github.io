{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-28T13:31:20.367Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"content":"<blockquote><p>视频教程参考 <a href=\"https://www.bilibili.com/video/BV1py4y1E7oA\">黑马程序员Netty全套教程</a></p>\n<p>博客参考了 <a href=\"https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/\">Nyima</a></p></blockquote>\n<h2 id=\"1-Netty-概述\"><a href=\"#1-Netty-概述\" class=\"headerlink\" title=\"1. Netty 概述\"></a>1. Netty 概述</h2><blockquote><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p></blockquote>\n<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>\n<p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p>\n<p><strong>优势:</strong></p>\n<p>如果使用传统NIO，其工作量大，bug 多</p>\n<ul>\n<li>需要自己构建协议</li>\n<li>解决 TCP 传输问题，如粘包、半包</li>\n<li>因为bug的存在，epoll 空轮询导致 CPU 100%</li>\n</ul>\n<p>Netty 对 API 进行增强，使之更易用，如</p>\n<ul>\n<li>FastThreadLocal &#x3D;&gt; ThreadLocal</li>\n<li>ByteBuf &#x3D;&gt; ByteBuffer</li>\n</ul>\n<h2 id=\"2-入门案例\"><a href=\"#2-入门案例\" class=\"headerlink\" title=\"2. 入门案例\"></a>2. 入门案例</h2><p><strong>服务器端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>执行流程:</strong></p>\n<p><strong>左：客户端 右：服务器端</strong></p>\n<img src=\"/post/Netty/20210420132155.png\" class=\"\" title=\"img\">\n\n<p><strong>组件解释</strong></p>\n<ul>\n<li>channel 可以理解为数据的通道</li>\n<li>msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>\n<li>handler 可以理解为数据的处理工序<ul>\n<li>工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）<ul>\n<li>pipeline 中有多个 handler，处理时会依次调用其中的 handler</li>\n</ul>\n</li>\n<li>handler 分 Inbound 和 Outbound 两类<ul>\n<li>Inbound 入站</li>\n<li>Outbound 出站</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>eventLoop 可以理解为处理数据的工人<ul>\n<li>eventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就<strong>会将其与channel进行绑定</strong>，以后该 channel 中的 io 操作都由该 eventLoop 负责</li>\n<li>eventLoop 既可以执行 io 操作，<strong>也可以进行任务处理</strong>，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>\n<li>eventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"3-Netty-组件\"><a href=\"#3-Netty-组件\" class=\"headerlink\" title=\"3. Netty 组件\"></a>3. Netty 组件</h2><h3 id=\"a-EventLoop\"><a href=\"#a-EventLoop\" class=\"headerlink\" title=\"a. EventLoop\"></a>a. EventLoop</h3><p><strong>事件循环对象</strong> EventLoop</p>\n<p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p>\n<p>它的继承关系如下</p>\n<ul>\n<li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>\n<li>继承自 netty 自己的 OrderedEventExecutor<ul>\n<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>\n<li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li>\n</ul>\n</li>\n</ul>\n<p><strong>事件循环组</strong> EventLoopGroup</p>\n<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>\n<ul>\n<li>继承自 netty 自己的 EventExecutorGroup<ul>\n<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>\n<li>另有 next 方法获取集合中下一个 EventLoop</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-EventLoop处理普通与定时任务\"><a href=\"#1-EventLoop处理普通与定时任务\" class=\"headerlink\" title=\"1. EventLoop处理普通与定时任务\"></a>1. EventLoop处理普通与定时任务</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p>输出结果如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">io.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2</code></pre>\n\n<p><strong>关闭 EventLoopGroup</strong></p>\n<p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>\n<h4 id=\"2-EventLoop处理IO任务\"><a href=\"#2-EventLoop处理IO任务\" class=\"headerlink\" title=\"2. EventLoop处理IO任务\"></a>2. EventLoop处理IO任务</h4><p><strong>服务器端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>客户端</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        Channel channel &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                .sync()\n                .channel();\n        System.out.println(channel);\n        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>多个EventLoopGroup分工</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n            \t&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n\t\t\t\t...\n    &#125;\n&#125;</code></pre>\n\n<p>多个客户端分别发送 <code>hello</code> 结果</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">nioEventLoopGroup-3-1 hello1\nnioEventLoopGroup-3-2 hello2\nnioEventLoopGroup-3-1 hello3\nnioEventLoopGroup-3-2 hello4\nnioEventLoopGroup-3-2 hello4 </code></pre>\n\n<p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210421103251.png\"><img src=\"/Netty/20210421103251.png\" alt=\"img\"></a></p>\n<h4 id=\"3-增加自定义EventLoopGroup\"><a href=\"#3-增加自定义EventLoopGroup\" class=\"headerlink\" title=\"3. 增加自定义EventLoopGroup\"></a>3. 增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        \n        new ServerBootstrap()\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理\n                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                                &#x2F;&#x2F; 调用下一个handler\n                                ctx.fireChannelRead(msg);\n                            &#125;\n                        &#125;)\n                        &#x2F;&#x2F; 该handler绑定自定义的Group\n                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p>启动四个客户端发送数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-4-1 hello1\ndefaultEventLoopGroup-2-1 hello1\nnioEventLoopGroup-4-2 hello2\ndefaultEventLoopGroup-2-2 hello2\nnioEventLoopGroup-4-1 hello3\ndefaultEventLoopGroup-2-3 hello3\nnioEventLoopGroup-4-2 hello4\ndefaultEventLoopGroup-2-4 hello4</code></pre>\n\n<p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p>\n<img src=\"/post/Netty/20210421103607.png\" class=\"\" title=\"img\">\n\n<h4 id=\"4-切换的实现\"><a href=\"#4-切换的实现\" class=\"headerlink\" title=\"4. 切换的实现\"></a>4. 切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p>\n<p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中\n    if (executor.inEventLoop()) &#123;\n        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务\n        next.invokeChannelRead(m);\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行\n        executor.execute(new Runnable() &#123;\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li>\n<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li>\n</ul>\n<h3 id=\"b-Channel\"><a href=\"#b-Channel\" class=\"headerlink\" title=\"b. Channel\"></a>b. Channel</h3><p>Channel 的常用方法</p>\n<ul>\n<li>close() 可以用来关闭Channel</li>\n<li>closeFuture() 用来处理 Channel 的关闭<ul>\n<li>sync 方法作用是同步等待 Channel 关闭</li>\n<li>而 addListener 方法是异步等待 Channel 关闭</li>\n</ul>\n</li>\n<li>pipeline() 方法用于添加处理器</li>\n<li>write() 方法将数据写入<ul>\n<li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li>\n<li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li>\n</ul>\n</li>\n<li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li>\n</ul>\n<h4 id=\"1-ChannelFuture连接问题\"><a href=\"#1-ChannelFuture连接问题\" class=\"headerlink\" title=\"1. ChannelFuture连接问题\"></a>1. ChannelFuture连接问题</h4><p><strong>拆分客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n            \t&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n        &#x2F;&#x2F; 该方法用于等待连接真正建立\n        channelFuture.sync();\n        \n        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象\n        Channel channel &#x3D; channelFuture.channel();\n        channel.writeAndFlush(&quot;hello world&quot;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p>\n<p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p>\n<p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p>\n<p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p>\n<p><strong>addListener方法</strong></p>\n<p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n\t\t&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后\n        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法\n        channelFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n                Channel channel &#x3D; channelFuture.channel();\n                channel.writeAndFlush(&quot;hello world&quot;);\n            &#125;\n        &#125;);\n        System.in.read();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-处理关闭\"><a href=\"#2-处理关闭\" class=\"headerlink\" title=\"2.处理关闭\"></a>2.处理关闭</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ReadClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        \n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        channelFuture.sync();\n\n        Channel channel &#x3D; channelFuture.channel();\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送\n        new Thread(()-&gt;&#123;\n            while (true) &#123;\n                String msg &#x3D; scanner.next();\n                if (&quot;q&quot;.equals(msg)) &#123;\n                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行\n                    channel.close();\n                    break;\n                &#125;\n                channel.writeAndFlush(msg);\n            &#125;\n        &#125;, &quot;inputThread&quot;).start();\n\n        &#x2F;&#x2F; 获得closeFuture对象\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        System.out.println(&quot;waiting close...&quot;);\n        \n        &#x2F;&#x2F; 同步等待NIO线程执行完close操作\n        closeFuture.sync();\n        \n        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        \n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>关闭channel</strong></p>\n<p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p>\n<p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p>\n<ul>\n<li><p>通过<code>channel.closeFuture()</code>方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得closeFuture对象\nChannelFuture closeFuture &#x3D; channel.closeFuture();\n\n&#x2F;&#x2F; 同步等待NIO线程执行完close操作\ncloseFuture.sync();</code></pre>\n</li>\n<li><p>调用<code>closeFuture.addListener</code>方法，添加close的后续操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">closeFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n        &#x2F;&#x2F; 等待channel关闭后才执行的操作\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;);</code></pre></li>\n</ul>\n<h3 id=\"c-Future-amp-Promise\"><a href=\"#c-Future-amp-Promise\" class=\"headerlink\" title=\"c. Future &amp; Promise\"></a>c. Future &amp; Promise</h3><h4 id=\"1-概念\"><a href=\"#1-概念\" class=\"headerlink\" title=\"1.概念\"></a>1.概念</h4><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p>\n<p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>\n<ul>\n<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>\n<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li>\n<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;名称</th>\n<th>jdk Future</th>\n<th>netty Future</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>cancel</td>\n<td>取消任务</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isCanceled</td>\n<td>任务是否取消</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isDone</td>\n<td>任务是否完成，不能区分成功失败</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>get</td>\n<td>获取任务结果，阻塞等待</td>\n<td>-</td>\n<td>-</td>\n</tr>\n<tr>\n<td>getNow</td>\n<td>-</td>\n<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>await</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td>\n<td>-</td>\n</tr>\n<tr>\n<td>sync</td>\n<td>-</td>\n<td>等待任务结束，如果任务失败，抛出异常</td>\n<td>-</td>\n</tr>\n<tr>\n<td>isSuccess</td>\n<td>-</td>\n<td>判断任务是否成功</td>\n<td>-</td>\n</tr>\n<tr>\n<td>cause</td>\n<td>-</td>\n<td>获取失败信息，非阻塞，如果没有失败，返回null</td>\n<td>-</td>\n</tr>\n<tr>\n<td>addLinstener</td>\n<td>-</td>\n<td>添加回调，异步接收结果</td>\n<td>-</td>\n</tr>\n<tr>\n<td>setSuccess</td>\n<td>-</td>\n<td>-</td>\n<td>设置成功结果</td>\n</tr>\n<tr>\n<td>setFailure</td>\n<td>-</td>\n<td>-</td>\n<td>设置失败结果</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-JDK-Future\"><a href=\"#2-JDK-Future\" class=\"headerlink\" title=\"2. JDK Future\"></a>2. JDK Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ThreadFactory factory &#x3D; new ThreadFactory() &#123;\n            @Override\n            public Thread newThread(Runnable r) &#123;\n                return new Thread(r, &quot;JdkFuture&quot;);\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 创建线程池\n        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);\n\n        &#x2F;&#x2F; 获得Future对象\n        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;\n\n            @Override\n            public Integer call() throws Exception &#123;\n                TimeUnit.SECONDS.sleep(1);\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果\n        System.out.println(future.get());\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Netty-Future\"><a href=\"#3-Netty-Future\" class=\"headerlink\" title=\"3.Netty Future\"></a>3.Netty Future</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n\n        &#x2F;&#x2F; 获得 EventLoop 对象\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 主线程中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n        System.out.println(&quot;getNow &quot; + future.getNow());\n        System.out.println(&quot;get &quot; + future.get());\n\n        &#x2F;&#x2F; NIO线程中异步获取结果\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n                System.out.println(&quot;getNow &quot; + future.getNow());\n            &#125;\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">main 获取结果\ngetNow null\nget 50\nnioEventLoopGroup-2-1 获取结果\ngetNow 50</code></pre>\n\n<p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p>\n<ul>\n<li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li>\n<li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li>\n<li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li>\n</ul>\n<h4 id=\"4-Netty-Promise\"><a href=\"#4-Netty-Promise\" class=\"headerlink\" title=\"4.Netty Promise\"></a>4.Netty Promise</h4><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class NettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoop\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n\n        &#x2F;&#x2F; 创建Promise对象，用于存放结果\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n\n        new Thread(()-&gt;&#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 自定义线程向Promise中存放结果\n            promise.setSuccess(50);\n        &#125;).start();\n\n        &#x2F;&#x2F; 主线程从Promise中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"d-Handler-amp-Pipline\"><a href=\"#d-Handler-amp-Pipline\" class=\"headerlink\" title=\"d. Handler &amp; Pipline\"></a>d. Handler &amp; Pipline</h3><h4 id=\"1-Pipeline\"><a href=\"#1-Pipeline\" class=\"headerlink\" title=\"1. Pipeline\"></a>1. Pipeline</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class PipeLineServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler\n                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为\n    \t\t\t\t \t&#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail\n                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法\n                        &#x2F;&#x2F; 入站时，handler是从head向后调用的\n                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);\n                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead\n                                &#x2F;&#x2F; 将数据传递给下一个handler\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);\n                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用\n          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法\n                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的\n                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">nioEventLoopGroup-2-2 Inbound handler 1\nnioEventLoopGroup-2-2 Inbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 1</code></pre>\n\n<p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p>\n<p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p>\n<ul>\n<li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul>\n<li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li>\n</ul>\n</li>\n<li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li>\n<li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li>\n</ul>\n<p><strong>具体结构如下</strong></p>\n<img src=\"/post/Netty/20210423102354.png\" class=\"\" title=\"img\">\n\n<p><strong>调用顺序如下</strong></p>\n<img src=\"/post/Netty/20210423105200.png\" class=\"\" title=\"img\">\n\n<h4 id=\"2-OutboundHandler\"><a href=\"#2-OutboundHandler\" class=\"headerlink\" title=\"2. OutboundHandler\"></a>2. OutboundHandler</h4><h5 id=\"a-socketChannel-writeAndFlush\"><a href=\"#a-socketChannel-writeAndFlush\" class=\"headerlink\" title=\"a. socketChannel.writeAndFlush()\"></a>a. socketChannel.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122010.png\" class=\"\" title=\"img\">\n\n<h5 id=\"b-ctx-writeAndFlush\"><a href=\"#b-ctx-writeAndFlush\" class=\"headerlink\" title=\"b. ctx.writeAndFlush()\"></a>b. ctx.writeAndFlush()</h5><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p>\n<img src=\"/post/Netty/20210423122050.png\" class=\"\" title=\"img\">\n\n<h4 id=\"3-EmbeddedChannel\"><a href=\"#3-EmbeddedChannel\" class=\"headerlink\" title=\"3. EmbeddedChannel\"></a>3. EmbeddedChannel</h4><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestEmbeddedChannel &#123;\n    public static void main(String[] args) &#123;\n        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;1&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;2&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;3&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;4&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F; 用于测试Handler的Channel\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);\n        \n        &#x2F;&#x2F; 执行Inbound操作 \n        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n        &#x2F;&#x2F; 执行Outbound操作\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"e-ByteBuf\"><a href=\"#e-ByteBuf\" class=\"headerlink\" title=\"e. ByteBuf\"></a>e. ByteBuf</h3><h4 id=\"1-创建\"><a href=\"#1-创建\" class=\"headerlink\" title=\"1.创建\"></a>1.创建</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        StringBuilder sb &#x3D; new StringBuilder();\n        for(int i &#x3D; 0; i &lt; 20; i++) &#123;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        &#x2F;&#x2F; 查看写入结果\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:20 capacity:64\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|\n|00000010| 61 61 61 61                                     |aaaa            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p>\n<p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p>\n<p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p>\n<h4 id=\"2-直接内存与堆内存\"><a href=\"#2-直接内存与堆内存\" class=\"headerlink\" title=\"2.直接内存与堆内存\"></a>2.直接内存与堆内存</h4><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16); </code></pre>\n\n<p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16); </code></pre>\n\n<p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16); </code></pre>\n\n<ul>\n<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>\n<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>\n</ul>\n<p><strong>验证</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);\n        System.out.println(buffer.getClass());\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用池化的直接内存\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n    \n&#x2F;&#x2F; 使用池化的堆内存    \nclass io.netty.buffer.PooledUnsafeHeapByteBuf\n    \n&#x2F;&#x2F; 使用池化的直接内存    \nclass io.netty.buffer.PooledUnsafeDirectByteBuf </code></pre>\n\n<h4 id=\"3-池化与非池化\"><a href=\"#3-池化与非池化\" class=\"headerlink\" title=\"3.池化与非池化\"></a>3.池化与非池化</h4><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p>\n<ul>\n<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>\n<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>\n<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>\n</ul>\n<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125; </code></pre>\n\n<ul>\n<li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li>\n<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>\n</ul>\n<h4 id=\"4-组成\"><a href=\"#4-组成\" class=\"headerlink\" title=\"4.组成\"></a>4.组成</h4><p>ByteBuf主要有以下几个组成部分</p>\n<ul>\n<li><p>最大容量与当前容量</p>\n<ul>\n<li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li>\n<li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li>\n</ul>\n</li>\n<li><p>读写操作不同于ByteBuffer只用position进行控制，</p>\n<p>ByteBuf分别由读指针和写指针两个指针控制</p>\n<p>。进行读写操作时，无需进行模式的切换</p>\n<ul>\n<li>读指针前的部分被称为废弃部分，是已经读过的内容</li>\n<li>读指针与写指针之间的空间称为可读部分</li>\n<li>写指针与当前容量之间的空间称为可写部分</li>\n</ul>\n</li>\n</ul>\n<img src=\"/post/Netty/20210423143030.png\" class=\"\" title=\"img\">\n\n<h4 id=\"5-写入\"><a href=\"#5-写入\" class=\"headerlink\" title=\"5.写入\"></a>5.写入</h4><p>常用方法如下</p>\n<table>\n<thead>\n<tr>\n<th>方法签名</th>\n<th>含义</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>writeBoolean(boolean value)</td>\n<td>写入 boolean 值</td>\n<td><strong>用一字节 01|00 代表 true|false</strong></td>\n</tr>\n<tr>\n<td>writeByte(int value)</td>\n<td>写入 byte 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeShort(int value)</td>\n<td>写入 short 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeInt(int value)</td>\n<td>写入 int 值</td>\n<td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td>\n</tr>\n<tr>\n<td>writeIntLE(int value)</td>\n<td>写入 int 值</td>\n<td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td>\n</tr>\n<tr>\n<td>writeLong(long value)</td>\n<td>写入 long 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeChar(int value)</td>\n<td>写入 char 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeFloat(float value)</td>\n<td>写入 float 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeDouble(double value)</td>\n<td>写入 double 值</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuf src)</td>\n<td>写入 netty 的 ByteBuf</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(byte[] src)</td>\n<td>写入 byte[]</td>\n<td></td>\n</tr>\n<tr>\n<td>writeBytes(ByteBuffer src)</td>\n<td>写入 nio 的 <strong>ByteBuffer</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>\n<td>写入字符串</td>\n<td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td>\n</tr>\n</tbody></table>\n<blockquote><p>注意</p>\n<ul>\n<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li>\n<li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li>\n</ul></blockquote>\n<p><strong>使用方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeInt(5);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeIntLE(6);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeLong(7);\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:0 capacity:16\n\nread index:0 write index:4 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p>\n<h4 id=\"6-扩容\"><a href=\"#6-扩容\" class=\"headerlink\" title=\"6.扩容\"></a>6.扩容</h4><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">buffer.writeLong(7);\nByteBufUtil.log(buffer); \n&#x2F;&#x2F; 扩容前\nread index:0 write index:12 capacity:16\n...\n\n&#x2F;&#x2F; 扩容后\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"7-扩容规则\"><a href=\"#7-扩容规则\" class=\"headerlink\" title=\"7.扩容规则\"></a>7.扩容规则</h4><ul>\n<li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p>\n<ul>\n<li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li>\n</ul>\n</li>\n<li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p>\n<p>n</p>\n<ul>\n<li>例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）</li>\n</ul>\n</li>\n<li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Exception in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)\n...</code></pre>\n\n<h4 id=\"8-读取\"><a href=\"#8-读取\" class=\"headerlink\" title=\"8.读取\"></a>8.读取</h4><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p>\n<p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        buffer.writeInt(5);\n\n        &#x2F;&#x2F; 读取4个字节\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 通过mark与reset实现重复读取\n        buffer.markReaderIndex();\n        System.out.println(buffer.readInt());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 恢复到mark标记处\n        buffer.resetReaderIndex();\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125; \n1\n2\n3\n4\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+\n5\nread index:8 write index:8 capacity:16\n\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p>\n<h4 id=\"9-释放\"><a href=\"#9-释放\" class=\"headerlink\" title=\"9.释放\"></a>9.释放</h4><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p>\n<ul>\n<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>\n<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>\n<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>\n</ul>\n<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>\n<ul>\n<li>每个 ByteBuf 对象的初始计数为 1</li>\n<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>\n<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>\n<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>\n</ul>\n<h4 id=\"10-释放规则\"><a href=\"#10-释放规则\" class=\"headerlink\" title=\"10.释放规则\"></a>10.释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>\n<p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p>\n<ul>\n<li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p>\n</li>\n<li><p>入站 ByteBuf 处理原则</p>\n<ul>\n<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>\n<li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li>\n<li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li>\n<li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li>\n<li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>\n</ul>\n</li>\n<li><p>出站 ByteBuf 处理原则</p>\n<ul>\n<li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li>\n</ul>\n</li>\n<li><p>异常处理原则</p>\n<ul>\n<li><p>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while (!buffer.release()) &#123;&#125; </code></pre></li>\n</ul>\n</li>\n</ul>\n<p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p>\n<p><strong>TailConext中释放ByteBuf的源码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        &#x2F;&#x2F; 具体的释放方法\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;</code></pre>\n\n<p>判断传过来的是否为ByteBuf，是的话才需要释放</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static boolean release(Object msg) &#123;\n\treturn msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;\n&#125;</code></pre>\n\n<h4 id=\"11-切片\"><a href=\"#11-切片\" class=\"headerlink\" title=\"11.切片\"></a>11.切片</h4><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p>\n<p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p>\n<p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p>\n<img src=\"/post/Netty/20210423154059.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestSlice &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);\n\n        &#x2F;&#x2F; 将buffer分成两部分\n        ByteBuf slice1 &#x3D; buffer.slice(0, 5);\n        ByteBuf slice2 &#x3D; buffer.slice(5, 5);\n\n        &#x2F;&#x2F; 需要让分片的buffer引用计数加一\n        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用\n        slice1.retain();\n        slice2.retain();\n        \n        ByteBufUtil.log(slice1);\n        ByteBufUtil.log(slice2);\n\n        &#x2F;&#x2F; 更改原始buffer中的值\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        buffer.setByte(0,5);\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        ByteBufUtil.log(slice1);\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">read index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 05 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h4 id=\"12-优势\"><a href=\"#12-优势\" class=\"headerlink\" title=\"12.优势\"></a>12.优势</h4><ul>\n<li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>\n<li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li>\n<li>可以<strong>自动扩容</strong></li>\n<li>支持链式调用，使用更流畅</li>\n<li>很多地方体现零拷贝，例如<ul>\n<li>slice、duplicate、CompositeByteBuf</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-黏包半包\"><a href=\"#4-黏包半包\" class=\"headerlink\" title=\"4. 黏包半包\"></a>4. 黏包半包</h2><h3 id=\"a-黏包与半包现象\"><a href=\"#a-黏包与半包现象\" class=\"headerlink\" title=\"a.黏包与半包现象\"></a>a.黏包与半包现象</h3><p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StudyServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    void start() &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) &#123;\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接建立时会执行该方法\n                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                            super.channelActive(ctx);\n                        &#125;\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接断开时会执行该方法\n                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                            super.channelInactive(ctx);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n            channelFuture.sync();\n            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n            &#x2F;&#x2F; 关闭channel\n            channelFuture.channel().closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(&quot;stopped&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new StudyServer().start();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"1-粘包现象\"><a href=\"#1-粘包现象\" class=\"headerlink\" title=\"1. 粘包现象\"></a>1. 粘包现象</h4><p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StudyClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connected...&quot;);\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                                ctx.writeAndFlush(buffer);\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>服务器接收结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p>\n<h4 id=\"2-半包现象\"><a href=\"#2-半包现象\" class=\"headerlink\" title=\"2. 半包现象\"></a>2. 半包现象</h4><p>将客户端-服务器之间的channel容量进行调整</p>\n<p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 调整channel的容量\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);</code></pre>\n\n<p><strong>注意</strong></p>\n<blockquote><p><code>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10)</code> 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote>\n<p><strong>服务器接收结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f                                     |....            |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p>\n<h3 id=\"b-现象分析\"><a href=\"#b-现象分析\" class=\"headerlink\" title=\"b. 现象分析\"></a>b. 现象分析</h3><h4 id=\"1-粘包\"><a href=\"#1-粘包\" class=\"headerlink\" title=\"1. 粘包\"></a>1. 粘包</h4><ul>\n<li>现象<ul>\n<li>发送 abc def，接收 abcdef</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>应用层<ul>\n<li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li>\n</ul>\n</li>\n<li>传输层-网络层<ul>\n<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li>\n<li>Nagle 算法：会造成粘包</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"2-半包\"><a href=\"#2-半包\" class=\"headerlink\" title=\"2. 半包\"></a>2. 半包</h4><ul>\n<li>现象<ul>\n<li>发送 abcdef，接收 abc def</li>\n</ul>\n</li>\n<li>原因<ul>\n<li>应用层<ul>\n<li>接收方 ByteBuf 小于实际发送数据量</li>\n</ul>\n</li>\n<li>传输层-网络层<ul>\n<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li>\n</ul>\n</li>\n<li>数据链路层<ul>\n<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"3-本质\"><a href=\"#3-本质\" class=\"headerlink\" title=\"3. 本质\"></a>3. 本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p>\n<h3 id=\"c-解决方案\"><a href=\"#c-解决方案\" class=\"headerlink\" title=\"c. 解决方案\"></a>c. 解决方案</h3><h4 id=\"1-短链接\"><a href=\"#1-短链接\" class=\"headerlink\" title=\"1. 短链接\"></a>1. 短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p>\n<p><strong>客户端代码改进</strong></p>\n<p>修改channelActive方法</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n    log.debug(&quot;sending...&quot;);\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);\n    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n    ctx.writeAndFlush(buffer);\n    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接\n    ctx.channel().close();\n&#125; </code></pre>\n\n<p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 发送10次\n    for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n        send();\n    &#125;\n&#125;</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE\n\n...</code></pre>\n\n<p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p>\n<h4 id=\"2-定长解码器\"><a href=\"#2-定长解码器\" class=\"headerlink\" title=\"2. 定长解码器\"></a>2. 定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p>\n<p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ch.pipeline().addLast(new FixedLengthFrameDecoder(16)); </code></pre>\n\n<p><strong>客户端代码</strong></p>\n<p>客户端发送数据的代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 约定最大长度为16\nfinal int maxLength &#x3D; 16;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\n&#x2F;&#x2F; 向服务器发送10个报文\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充\n    byte[] bytes &#x3D; new byte[maxLength];\n    &#x2F;&#x2F; 生成长度为0~15的数据\n    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;\n        bytes[j] &#x3D; (byte) c;\n    &#125;\n    buffer.writeBytes(bytes);\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;</code></pre>\n\n<p><strong>服务器代码</strong></p>\n<p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分\nch.pipeline().addLast(new FixedLengthFrameDecoder(16));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p><strong>运行结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|\n+--------+-------------------------------------------------+----------------+\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|\n+--------+-------------------------------------------------+----------------+\n\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<h4 id=\"3-行解码器\"><a href=\"#3-行解码器\" class=\"headerlink\" title=\"3. 行解码器\"></a>3. 行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p>\n<p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p>\n<p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p>\n<p><strong>以换行符 \\n 为分隔符</strong></p>\n<p>客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 约定最大长度为 64\nfinal int maxLength &#x3D; 64;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 生成长度为0~62的数据\n    Random random &#x3D; new Random();\n    StringBuilder sb &#x3D; new StringBuilder();\n    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;\n        sb.append(c);\n    &#125;\n    &#x2F;&#x2F; 数据以 \\n 结尾\n    sb.append(&quot;\\n&quot;);\n    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;</code></pre>\n\n<p>服务器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\n 为分隔符\n&#x2F;&#x2F; 需要指定最大长度\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63                                           |cc              |\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<p><strong>以自定义分隔符 \\c 为分隔符</strong></p>\n<p>客户端代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">...\n    \n&#x2F;&#x2F; 数据以 \\c 结尾\nsb.append(&quot;\\\\c&quot;);\nbuffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n...</code></pre>\n\n<p>服务器代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 将分隔符放入ByteBuf中\nByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\\\c&quot;.getBytes(StandardCharsets.UTF_8));\n&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\c 为分隔符\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |\n+--------+-------------------------------------------------+----------------+\n\n\n8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n\n...</code></pre>\n\n<h4 id=\"4-长度字段解码器\"><a href=\"#4-长度字段解码器\" class=\"headerlink\" title=\"4. 长度字段解码器\"></a>4. 长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p>\n<p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public LengthFieldBasedFrameDecoder(\n    int maxFrameLength,\n    int lengthFieldOffset, int lengthFieldLength,\n    int lengthAdjustment, int initialBytesToStrip)</code></pre>\n\n<p><strong>参数解析</strong></p>\n<ul>\n<li>maxFrameLength 数据最大长度<ul>\n<li>表示数据的最大长度（包括附加信息、长度标识等内容）</li>\n</ul>\n</li>\n<li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul>\n<li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li>\n</ul>\n</li>\n<li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul>\n<li>数据中用于表示有用数据长度的标识所占的字节数</li>\n</ul>\n</li>\n<li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul>\n<li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li>\n</ul>\n</li>\n<li>initialBytesToStrip <strong>数据读取起点</strong><ul>\n<li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li>\n</ul>\n</li>\n</ul>\n<p><strong>参数图解</strong></p>\n<img src=\"/post/Netty/20210425200007.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)\n+--------+----------------+      +--------+----------------+\n| Length | Actual Content |-----&gt;| Length | Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +--------+----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为2个字节</p>\n<p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)\n+--------+----------------+      +----------------+\n| Length | Actual Content |-----&gt;| Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p>\n<p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |\n|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+</code></pre>\n\n<p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p>\n<p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p>\n<hr>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">lengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |\n| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+</code></pre>\n\n<p>从0开始即为长度标识，长度标识长度为3个字节，<strong>长度标识之后还有2个字节的其他内容</strong>（0xCAFE）</p>\n<p>长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即<code>HELLO, WORLD</code>**，不包括0xCAFE</p>\n<hr>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">lengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)\ninitialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)\n  \nBEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)\n+------+--------+------+----------------+      +------+----------------+\n| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |\n| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |\n+------+--------+------+----------------+      +------+----------------+ </code></pre>\n\n<p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p>\n<hr>\n<p><strong>使用</strong></p>\n<p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class EncoderStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 模拟服务器\n        &#x2F;&#x2F; 使用EmbeddedChannel测试handler\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）\n                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),\n                new LoggingHandler(LogLevel.DEBUG)\n        );\n\n        &#x2F;&#x2F; 模拟客户端，写入数据\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();\n        send(buffer, &quot;Hello&quot;);\n        channel.writeInbound(buffer);\n        send(buffer, &quot;World&quot;);\n        channel.writeInbound(buffer);\n    &#125;\n\n    private static void send(ByteBuf buf, String msg) &#123;\n        &#x2F;&#x2F; 得到数据的长度\n        int length &#x3D; msg.length();\n        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);\n        &#x2F;&#x2F; 将数据信息写入buf\n        &#x2F;&#x2F; 写入长度标识前的其他信息\n        buf.writeByte(0xCA);\n        &#x2F;&#x2F; 写入数据长度标识\n        buf.writeInt(length);\n        &#x2F;&#x2F; 写入长度标识后的其他信息\n        buf.writeByte(0xFE);\n        &#x2F;&#x2F; 写入具体的数据\n        buf.writeBytes(bytes);\n    &#125;\n&#125;</code></pre>\n\n<p>运行结果</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |\n+--------+-------------------------------------------------+----------------+\n\n146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n\n\n\n\n<h2 id=\"5-协议设计与解析\"><a href=\"#5-协议设计与解析\" class=\"headerlink\" title=\"5. 协议设计与解析\"></a>5. 协议设计与解析</h2><h3 id=\"a-协议的作用\"><a href=\"#a-协议的作用\" class=\"headerlink\" title=\"a. 协议的作用\"></a>a. 协议的作用</h3><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界</p>\n<p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p>\n<h3 id=\"b-Redis协议\"><a href=\"#b-Redis协议\" class=\"headerlink\" title=\"b. Redis协议\"></a>b. Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Nyima</code>的指令，需要遵守如下协议</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 该指令一共有3部分，每条指令之后都要添加回车与换行符\n*3\\r\\n\n&#x2F;&#x2F; 第一个指令的长度是3\n$3\\r\\n\n&#x2F;&#x2F; 第一个指令是set指令\nset\\r\\n\n&#x2F;&#x2F; 下面的指令以此类推\n$4\\r\\n\nname\\r\\n\n$5\\r\\n\nNyima\\r\\n</code></pre>\n\n<p><strong>客户端代码如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class RedisClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D;  new NioEventLoopGroup();\n        try &#123;\n            ChannelFuture channelFuture &#x3D; new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                        @Override\n                        protected void initChannel(SocketChannel ch) &#123;\n                            &#x2F;&#x2F; 打印日志\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                                    &#x2F;&#x2F; 回车与换行符\n                                    final byte[] LINE &#x3D; &#123;&#39;\\r&#39;,&#39;\\n&#39;&#125;;\n                                    &#x2F;&#x2F; 获得ByteBuf\n                                    ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                    &#x2F;&#x2F; 连接建立后，向Redis中发送一条指令，注意添加回车与换行\n                                    &#x2F;&#x2F; set name Nyima\n                                    buffer.writeBytes(&quot;*3&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$3&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;set&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$4&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;name&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$5&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;Nyima&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    ctx.writeAndFlush(buffer);\n                                &#125;\n\n                            &#125;);\n                        &#125;\n                    &#125;)\n                    .connect(new InetSocketAddress(&quot;localhost&quot;, 6379));\n            channelFuture.sync();\n            &#x2F;&#x2F; 关闭channel\n            channelFuture.channel().close().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 关闭group\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p><strong>控制台打印结果</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:&#x2F;127.0.0.1:60792 - R:localhost&#x2F;127.0.0.1:6379] WRITE: 34B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|\n|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..$5..Nyima|\n|00000020| 0d 0a                                           |..              |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<p><strong>Redis中查询执行结果</strong></p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426101530.png\"><img src=\"/Netty/20210426101530.png\" alt=\"img\"></a></p>\n<h3 id=\"c-HTTP协议\"><a href=\"#c-HTTP协议\" class=\"headerlink\" title=\"c. HTTP协议\"></a>c. HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder\n&#x2F;&#x2F; Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器\npublic final class HttpServerCodec extends CombinedChannelDuplexHandler&lt;HttpRequestDecoder, HttpResponseEncoder&gt;\n        implements HttpServerUpgradeHandler.SourceCodec</code></pre>\n\n<p><strong>服务器代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HttpServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        new ServerBootstrap()\n                .group(group)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel ch) &#123;\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        &#x2F;&#x2F; 作为服务器，使用 HttpServerCodec 作为编码器与解码器\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        &#x2F;&#x2F; 服务器只处理HTTPRequest\n                        ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) &#123;\n                                &#x2F;&#x2F; 获得请求uri\n                                log.debug(msg.uri());\n\n                                &#x2F;&#x2F; 获得完整响应，设置版本号与状态码\n                                DefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n                                &#x2F;&#x2F; 设置响应内容\n                                byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);\n                                &#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容\n                                response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                                &#x2F;&#x2F; 设置响应体\n                                response.content().writeBytes(bytes);\n\n                                &#x2F;&#x2F; 写回响应\n                                ctx.writeAndFlush(response);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;</code></pre>\n\n<p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 服务器只处理HTTPRequest\nch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;()</code></pre>\n\n<p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得完整响应，设置版本号与状态码\nDefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n&#x2F;&#x2F; 设置响应内容\nbyte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);\n&#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容\nresponse.headers().setInt(CONTENT_LENGTH, bytes.length);\n&#x2F;&#x2F; 设置响应体\nresponse.content().writeBytes(bytes);</code></pre>\n\n<p><strong>运行结果</strong></p>\n<p>浏览器</p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210426111017.png\"><img src=\"/Netty/20210426111017.png\" alt=\"img\"></a></p>\n<p>控制台</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 请求内容\n1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] READ: 688B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET &#x2F;favicon.ico|\n|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP&#x2F;1.1..Host:|\n|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|\n|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|\n|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|\n....\n\n&#x2F;&#x2F; 响应内容\n1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] WRITE: 61B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP&#x2F;1.1 200 OK.|\n|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|\n|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello|\n|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;&#x2F;h1&gt;   |\n+--------+-------------------------------------------------+----------------+</code></pre>\n\n<h3 id=\"d-自定义协议\"><a href=\"#d-自定义协议\" class=\"headerlink\" title=\"d. 自定义协议\"></a>d. 自定义协议</h3><h4 id=\"1-组成要素\"><a href=\"#1-组成要素\" class=\"headerlink\" title=\"1.组成要素\"></a>1.组成要素</h4><ul>\n<li><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</li>\n<li><strong>版本号</strong>：可以支持协议的升级</li>\n<li>序列化算法：消息正文到底采用哪种序列化反序列化方式<ul>\n<li>如：json、protobuf、hessian、jdk</li>\n</ul>\n</li>\n<li><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</li>\n<li><strong>请求序号</strong>：为了双工通信，提供异步能力</li>\n<li><strong>正文长度</strong></li>\n<li><strong>消息正文</strong></li>\n</ul>\n<h4 id=\"2-编码器与解码器\"><a href=\"#2-编码器与解码器\" class=\"headerlink\" title=\"2. 编码器与解码器\"></a>2. 编码器与解码器</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;\n        &#x2F;&#x2F; 设置魔数 4个字节\n        out.writeBytes(new byte[]&#123;&#39;N&#39;,&#39;Y&#39;,&#39;I&#39;,&#39;M&#39;&#125;);\n        &#x2F;&#x2F; 设置版本号 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置序列化方式 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置指令类型 1个字节\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 设置请求序号 4个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据\n        out.writeByte(0xff);\n\n        &#x2F;&#x2F; 获得序列化后的msg\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; 获取魔数\n        int magic &#x3D; in.readInt();\n        &#x2F;&#x2F; 获取版本号\n        byte version &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得序列化方式\n        byte seqType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得指令类型\n        byte messageType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得请求序号\n        int sequenceId &#x3D; in.readInt();\n        &#x2F;&#x2F; 移除补齐字节\n        in.readByte();\n        &#x2F;&#x2F; 获得正文长度\n        int length &#x3D; in.readInt();\n        &#x2F;&#x2F; 获得正文\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n\t\t&#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n        \n        &#x2F;&#x2F; 打印获得的信息正文\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(magic);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(version);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(seqType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(messageType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(sequenceId);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(length);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(message);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; </code></pre>\n</li>\n<li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p>\n</li>\n<li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p>\n</li>\n</ul>\n<p><strong>编写测试类</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestCodec &#123;\n    static final org.slf4j.Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    public static void main(String[] args) throws Exception &#123;\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel();\n        &#x2F;&#x2F; 添加解码器，避免粘包半包问题\n        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));\n        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n        channel.pipeline().addLast(new MessageCodec());\n        LoginRequestMessage user &#x3D; new LoginRequestMessage(&quot;Nyima&quot;, &quot;123&quot;);\n\n        &#x2F;&#x2F; 测试编码与解码\n        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();\n        new MessageCodec().encode(null, user, byteBuf);\n        channel.writeInbound(byteBuf);\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li>\n<li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li>\n</ul>\n<p>运行结果</p>\n<img src=\"/post/Netty/20210427111344.png\" class=\"\" title=\"img\">\n\n<img src=\"/post/Netty/20210427134513.png\" class=\"\" title=\"img\">\n\n\n\n<h4 id=\"3-Sharable注解\"><a href=\"#3-Sharable注解\" class=\"headerlink\" title=\"3. @Sharable注解\"></a>3. @Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n&#x2F;&#x2F; 不同的channel中使用同一个handler对象，提高复用率\nchannel1.pipeline().addLast(loggingHandler);\nchannel2.pipeline().addLast(loggingHandler); </code></pre>\n\n<p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p>\n<ul>\n<li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li>\n<li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li>\n</ul>\n<p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<code>@Sharable</code>注解来标明，该handler能否在多个channel中共享。</strong></p>\n<p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p>\n<h4 id=\"4-自定义编解码器能否使用-Sharable注解\"><a href=\"#4-自定义编解码器能否使用-Sharable注解\" class=\"headerlink\" title=\"4. 自定义编解码器能否使用@Sharable注解\"></a>4. <strong>自定义编解码器能否使用@Sharable注解</strong></h4><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p>\n<p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p>\n<p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<code>ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared</code></p>\n<ul>\n<li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p>\n<img src=\"/post/Netty/20210427144049.png\" class=\"\" title=\"img\">\n\n<p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p>\n<ul>\n<li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li>\n</ul>\n</li>\n</ul>\n<p><strong>如果想要共享，需要怎么办呢？</strong></p>\n<p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\npublic class MessageSharableCodec extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out) throws Exception &#123;\n        ...\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123;\n\t\t...\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"6-源码分析\"><a href=\"#6-源码分析\" class=\"headerlink\" title=\"6. 源码分析\"></a>6. 源码分析</h2><h3 id=\"a、启动流程\"><a href=\"#a、启动流程\" class=\"headerlink\" title=\"a、启动流程\"></a>a、启动流程</h3><p>Netty启动流程可以简化成如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector &#x3D; Selector.open(); \n\n&#x2F;&#x2F; 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();\n\n&#x2F;&#x2F; 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n&#x2F;&#x2F; 启动 nio boss 线程执行接下来的操作\n\n&#x2F;&#x2F;注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);\n\n&#x2F;&#x2F; head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor\n\n&#x2F;&#x2F; 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F; 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);</code></pre>\n\n<ul>\n<li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li>\n<li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li>\n<li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li>\n<li>绑定端口</li>\n<li>通过<code>interestOps</code>设置感兴趣的事件</li>\n</ul>\n<h4 id=\"1-bind\"><a href=\"#1-bind\" class=\"headerlink\" title=\"1. bind\"></a>1. bind</h4><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p>\n<p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ChannelFuture bind(SocketAddress localAddress) &#123;\n\tvalidate();\n\treturn doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));\n&#125; </code></pre>\n\n<h4 id=\"2-doBind\"><a href=\"#2-doBind\" class=\"headerlink\" title=\"2. doBind\"></a>2. doBind</h4><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p>\n<p><strong>dobind方法在主线程中执行</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private ChannelFuture doBind(final SocketAddress localAddress) &#123;\n    &#x2F;&#x2F; 负责NioServerSocketChannel和ServerSocketChannel的创建\n    &#x2F;&#x2F; ServerSocketChannel的注册工作\n    &#x2F;&#x2F; init由main线程完成，regisetr由NIO线程完成\n    final ChannelFuture regFuture &#x3D; initAndRegister();\n    final Channel channel &#x3D; regFuture.channel();\n    if (regFuture.cause() !&#x3D; null) &#123;\n        return regFuture;\n    &#125;\n\n    &#x2F;&#x2F; 因为register操作是异步的\n    &#x2F;&#x2F; 所以要判断主线程执行到这里时，register操作是否已经执行完毕\n    if (regFuture.isDone()) &#123;\n        &#x2F;&#x2F; At this point we know that the registration was complete and successful.\n        ChannelPromise promise &#x3D; channel.newPromise();\n        \n        &#x2F;&#x2F; 执行doBind0绑定操作\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    &#125; else &#123;\n        &#x2F;&#x2F; Registration future is almost always fulfilled already, but just in case it&#39;s not.\n        &#x2F;&#x2F; 如果register操作还没执行完，就会到这个分支中来\n        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);\n        \n        &#x2F;&#x2F; 添加监听器，NIO线程异步进行doBind0操作\n        regFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                Throwable cause &#x3D; future.cause();\n                if (cause !&#x3D; null) &#123;\n                    &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                    &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.\n                    promise.setFailure(cause);\n                &#125; else &#123;\n                    &#x2F;&#x2F; Registration was successful, so set the correct executor to use.\n                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586\n                    promise.registered();\n\n                    doBind0(regFuture, channel, localAddress, promise);\n                &#125;\n            &#125;\n        &#125;);\n        return promise;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li>\n<li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li>\n<li><strong>doBind0</strong>则负责连接的创建工作</li>\n</ul>\n<h4 id=\"3-initAndRegisterd\"><a href=\"#3-initAndRegisterd\" class=\"headerlink\" title=\"3. initAndRegisterd\"></a>3. initAndRegisterd</h4><p>代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final ChannelFuture initAndRegister() &#123;\n    Channel channel &#x3D; null;\n    try &#123;\n        channel &#x3D; channelFactory.newChannel();\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        if (channel !&#x3D; null) &#123;\n            &#x2F;&#x2F; channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))\n            channel.unsafe().closeForcibly();\n            &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);\n        &#125;\n        &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    &#125;\n\n    ChannelFuture regFuture &#x3D; config().group().register(channel);\n    if (regFuture.cause() !&#x3D; null) &#123;\n        if (channel.isRegistered()) &#123;\n            channel.close();\n        &#125; else &#123;\n            channel.unsafe().closeForcibly();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; If we are here and the promise is not failed, it&#39;s one of the following cases:\n    &#x2F;&#x2F; 1) If we attempted registration from the event loop, the registration has been completed at this point.\n    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now because the channel has been registered.\n    &#x2F;&#x2F; 2) If we attempted registration from the other thread, the registration request has been successfully\n    &#x2F;&#x2F;    added to the event loop&#39;s task queue for later execution.\n    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now:\n    &#x2F;&#x2F;         because bind() or connect() will be executed *after* the scheduled registration task is executed\n    &#x2F;&#x2F;         because register(), bind(), and connect() are all bound to the same thread.\n\n    return regFuture;\n&#125;</code></pre>\n\n<h4 id=\"4-init\"><a href=\"#4-init\" class=\"headerlink\" title=\"4. init\"></a>4. init</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Channel channel &#x3D; null;\ntry &#123;\n    &#x2F;&#x2F; 通过反射初始化NioServerSocketChannel\n    channel &#x3D; channelFactory.newChannel();\n    init(channel);\n&#125;</code></pre>\n\n<p>newChannel方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic T newChannel() &#123;\n    try &#123;\n        &#x2F;&#x2F; 通过反射调用NioServerSocketChannel的构造方法\n        &#x2F;&#x2F; 创建NioServerSocketChannel对象\n        return constructor.newInstance();\n    &#125; catch (Throwable t) &#123;\n        throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);\n    &#125;\n&#125;</code></pre>\n\n<p>NioServerSocketChannel构造方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public NioServerSocketChannel() &#123;\n    &#x2F;&#x2F; 创建了ServerSocketChannel实例\n    this(newSocket(DEFAULT_SELECTOR_PROVIDER));\n&#125;</code></pre>\n\n<p>newSocket方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static ServerSocketChannel newSocket(SelectorProvider provider) &#123;\n    try &#123;\n        &#x2F;&#x2F; ServerSocketChannel.open方法：\n        &#x2F;&#x2F; SelectorProvider.provider().openServerSocketChannel()\n\t    &#x2F;&#x2F; 所以此处相当于ServerSocketChannel.open()\n        &#x2F;&#x2F; 创建了ServerSocketChannel实例\n    \treturn provider.openServerSocketChannel();\n\t&#125; catch (IOException e) &#123;\n  \t  throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>init方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nvoid init(Channel channel) &#123;\n   \t...\n\t\t\n    &#x2F;&#x2F; NioSocketChannl的Pipeline    \n    ChannelPipeline p &#x3D; channel.pipeline();\n\t\t\n    ...\n\n    &#x2F;&#x2F; 向Pipeline中添加了一个handler，该handler等待被调用\n    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        &#x2F;&#x2F; register之后才调用该方法\n        public void initChannel(final Channel ch) &#123;\n            final ChannelPipeline pipeline &#x3D; ch.pipeline();\n            \n            &#x2F;&#x2F; 创建handler并加入到pipeline中\n            ChannelHandler handler &#x3D; config.handler();\n            if (handler !&#x3D; null) &#123;\n                pipeline.addLast(handler);\n            &#125;\n\n            ch.eventLoop().execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 添加新的handler，在发生Accept事件后建立连接\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n&#125; </code></pre>\n\n<p><strong>init主要完成了以下三个操作</strong></p>\n<ul>\n<li><p>创建NioServerSocketChannel</p>\n</li>\n<li><p>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</p>\n</li>\n<li><p>由initChannel方法向NioServerSocketChannel中添加了两个handler，</p>\n<p>添加操作在register之后被执行</p>\n<ul>\n<li>一个handler负责设置配置</li>\n<li>一个handler负责发生Accepet事件后建立连接</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"5-Register\"><a href=\"#5-Register\" class=\"headerlink\" title=\"5. Register\"></a>5. Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p>\n<p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p>\n<p><strong>promise.channel().unsafe().register(this, promise)</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    ...\n\n    &#x2F;&#x2F; 获取EventLoop\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n   \t&#x2F;&#x2F; 此处完成了由 主线程 到 NIO线程 的切换\n    &#x2F;&#x2F; eventLoop.inEventLoop()用于判断当前线程是否为NIO线程\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 向NIO线程中添加任务\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 该方法中会执行doRegister\n                    &#x2F;&#x2F; 执行真正的注册操作\n                    register0(promise);\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n           ...\n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p>register0方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void register0(ChannelPromise promise) &#123;\n    try &#123;\n       \t...\n            \n        &#x2F;&#x2F; 执行真正的注册操作\n        doRegister();\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\n        &#x2F;&#x2F; Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n        &#x2F;&#x2F; user may already fire events through the pipeline in the ChannelFutureListener.\n        \n        &#x2F;&#x2F; 调用init中的initChannel方法\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        ...\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n&#125; </code></pre>\n\n<p><strong>doRegister方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void doRegister() throws Exception &#123;\n    boolean selected &#x3D; false;\n    for (;;) &#123;\n        try &#123;\n            &#x2F;&#x2F; javaChannel()即为ServerSocketChannel\n            &#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector\n            &#x2F;&#x2F; this为NIOServerSocketChannel，作为附件\n            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        &#125; catch (CancelledKeyException e) &#123;\n            ...\n           \n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p>回调initChannel</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void initChannel(final Channel ch) &#123;\n    final ChannelPipeline pipeline &#x3D; ch.pipeline();\n    ChannelHandler handler &#x3D; config.handler();\n    if (handler !&#x3D; null) &#123;\n        pipeline.addLast(handler);\n    &#125;\n\n    &#x2F;&#x2F; 添加新任务，任务负责添加handler\n    &#x2F;&#x2F; 该handler负责发生Accepet事件后建立连接\n    ch.eventLoop().execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            pipeline.addLast(new ServerBootstrapAcceptor(\n                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n        &#125;\n    &#125;);\n&#125; </code></pre>\n\n<p>Register主要完成了以下三个操作</p>\n<ul>\n<li><p>完成了主线程到NIO的<strong>线程切换</strong></p>\n<ul>\n<li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li>\n<li>切换的方式为让eventLoop执行register的操作</li>\n<li><strong>register的操作在NIO线程中完成</strong></li>\n</ul>\n</li>\n<li><p><strong>调用doRegister方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; javaChannel()即为ServerSocketChannel\n&#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector\n&#x2F;&#x2F; this为NIOServerSocketChannel，作为附件\nselectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this); </code></pre>\n\n<ul>\n<li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li>\n<li>此时还未关注事件</li>\n<li>添加NioServerSocketChannel附件</li>\n</ul>\n</li>\n<li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p>\n<ul>\n<li><p>initChannel方法主要创建了</p>\n<p>两个handler</p>\n<ul>\n<li>一个handler负责设置配置</li>\n<li>一个handler负责发生Accept事件后建立连接</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"6-doBind0\"><a href=\"#6-doBind0\" class=\"headerlink\" title=\"6. doBind0\"></a>6. doBind0</h4><p><strong>绑定端口</strong></p>\n<p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; initAndRegister为异步方法，会返回ChannelFuture对象\nfinal ChannelFuture regFuture &#x3D; initAndRegister();\nregFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture future) throws Exception &#123;\n        Throwable cause &#x3D; future.cause();\n        if (cause !&#x3D; null) &#123;\n            &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n            &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.\n            promise.setFailure(cause);\n        &#125; else &#123;\n            &#x2F;&#x2F; Registration was successful, so set the correct executor to use.\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586\n            promise.registered();\n            &#x2F;&#x2F; 如果没有异常，则执行绑定操作\n            doBind0(regFuture, channel, localAddress, promise);\n        &#125;\n    &#125;\n&#125;); </code></pre>\n\n<p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p>\n<p>NioServerSocketChannel.doBind方法</p>\n<p>通过该方法，绑定了对应的端口</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@SuppressJava6Requirement(reason &#x3D; &quot;Usage guarded by java version check&quot;)\n@Override\nprotected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        &#x2F;&#x2F; 调用ServerSocketChannel的bind方法，绑定端口\n        javaChannel().bind(localAddress, config.getBacklog());\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125; </code></pre>\n\n\n\n<p><strong>关注事件</strong></p>\n<p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (!wasActive &amp;&amp; isActive()) &#123;\n    invokeLater(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            pipeline.fireChannelActive();\n        &#125;\n    &#125;);\n&#125; </code></pre>\n\n<p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n    readPending &#x3D; true;\n    final int interestOps &#x3D; selectionKey.interestOps();\n    &#x2F;&#x2F; 如果ServerSocketChannel没有关注Accept事件\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 则让其关注Accepet事件\n        &#x2F;&#x2F; readInterestOp 取值是 16\n        &#x2F;&#x2F; 在 NioServerSocketChannel 创建时初始化\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125; </code></pre>\n\n<p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p>\n<ul>\n<li><p>首先获取Channel所有感兴趣的事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final int interestOps &#x3D; selectionKey.interestOps(); </code></pre>\n</li>\n<li><p>然后再设置其感兴趣的事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">selectionKey.interestOps(interestOps | readInterestOp); </code></pre></li>\n</ul>\n<p><strong>各个事件对应的值</strong></p>\n<p><a href=\"https://nyimapicture.oss-cn-beijing.aliyuncs.com/img/20210506090047.png\"><img src=\"/Netty/20210506090047.png\" alt=\"img\"></a></p>\n<h4 id=\"7-总结\"><a href=\"#7-总结\" class=\"headerlink\" title=\"7.总结\"></a>7.总结</h4><p>通过上述步骤，完成了</p>\n<ul>\n<li>NioServerSocketChannel与ServerSocketChannel的创建</li>\n<li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li>\n<li>绑定了对应的端口</li>\n<li>关注了Accept事件</li>\n</ul>\n<h3 id=\"b、NioEventLoop剖析\"><a href=\"#b、NioEventLoop剖析\" class=\"headerlink\" title=\"b、NioEventLoop剖析\"></a>b、NioEventLoop剖析</h3><h4 id=\"1-组成\"><a href=\"#1-组成\" class=\"headerlink\" title=\"1. 组成\"></a>1. 组成</h4><p>NioEventLoop的重要组成部分有三个</p>\n<ul>\n<li><p><strong>Selector</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class NioEventLoop extends SingleThreadEventLoop &#123;\n    \n    ...\n        \n    &#x2F;&#x2F; selector中的selectedKeys是基于数组的\n    &#x2F;&#x2F; unwrappedSelector中的selectedKeys是基于HashSet的    \n    private Selector selector;\n    private Selector unwrappedSelector;\n    private SelectedSelectionKeySet selectedKeys;\n    \n    ...\n&#125; </code></pre>\n</li>\n<li><p><strong>Thread与TaskQueue</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor &#123;\n    &#x2F;&#x2F; 任务队列\n    private final Queue&lt;Runnable&gt; taskQueue;\n\n    &#x2F;&#x2F; 线程\n    private volatile Thread thread;\n&#125; </code></pre></li>\n</ul>\n<p><strong>Selector的创建</strong></p>\n<p>Selector是在NioEventLoop的构造方法中被创建的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;\n    \n        ...\n           \n        &#x2F;&#x2F; 初始化selector，初始化过程在openSelector中\n        final SelectorTuple selectorTuple &#x3D; openSelector();\n        this.selector &#x3D; selectorTuple.selector;\n        this.unwrappedSelector &#x3D; selectorTuple.unwrappedSelector;\n&#125;\n\n\nprivate SelectorTuple openSelector() &#123;\n    final Selector unwrappedSelector;\n    try &#123;\n        &#x2F;&#x2F; 此处等同于 Selector.open()方法\n        &#x2F;&#x2F; 创建了unwrappedSelector对象\n        unwrappedSelector &#x3D; provider.openSelector();\n    &#125; catch (IOException e) &#123;\n        throw new ChannelException(&quot;failed to open a new selector&quot;, e);\n    &#125;\n&#125; </code></pre>\n\n<p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p>\n<p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">unwrappedSelector &#x3D; provider.openSelector(); </code></pre>\n\n<p>获得了Selector对象<code>unwrappedSelector</code></p>\n<p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final class SelectorTuple &#123;\n    final Selector unwrappedSelector;\n    final Selector selector;\n\n    SelectorTuple(Selector unwrappedSelector) &#123;\n        this.unwrappedSelector &#x3D; unwrappedSelector;\n        this.selector &#x3D; unwrappedSelector;\n    &#125;\n\n    &#x2F;**\n    * 一般调用的是这个构造方法\n    *&#x2F;\n    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;\n        this.unwrappedSelector &#x3D; unwrappedSelector;\n        this.selector &#x3D; selector;\n    &#125;\n&#125; </code></pre>\n\n<p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p>\n<p><strong>两个Selector</strong></p>\n<p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p>\n<ul>\n<li>selector中的SelectedKeys是<strong>基于数组</strong>的</li>\n<li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li>\n</ul>\n<p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private SelectorTuple openSelector() &#123;\n    final Selector unwrappedSelector;\n    try &#123;\n        unwrappedSelector &#x3D; provider.openSelector();\n    &#125; catch (IOException e) &#123;\n        throw new ChannelException(&quot;failed to open a new selector&quot;, e);\n    &#125;\n\n    ...\n    \n    &#x2F;&#x2F; 获得基于数组的selectedKeySet实现\n    final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();\n\n\n    Object maybeException &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;\n        @Override\n        public Object run() &#123;\n            try &#123;\n                &#x2F;&#x2F; 通过反射拿到unwrappedSelector中的selectedKeys属性\n                Field selectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);\n                Field publicSelectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);\n\n                ...\n\t\n                &#x2F;&#x2F; 暴力反射，修改私有属性\n                Throwable cause &#x3D; ReflectionUtil.trySetAccessible(selectedKeysField, true);\n                if (cause !&#x3D; null) &#123;\n                    return cause;\n                &#125;\n                cause &#x3D; ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);\n                if (cause !&#x3D; null) &#123;\n                    return cause;\n                &#125;\n\n                &#x2F;&#x2F; 替换为基于数组的selectedKeys实现\n                selectedKeysField.set(unwrappedSelector, selectedKeySet);\n                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n                return null;\n            &#125; catch (NoSuchFieldException e) &#123;\n                return e;\n            &#125; catch (IllegalAccessException e) &#123;\n                return e;\n            &#125;\n        &#125;\n    &#125;);\n\n    selectedKeys &#x3D; selectedKeySet;\n    \n    &#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector\n    return new SelectorTuple(unwrappedSelector,\n                             new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));\n&#125; </code></pre>\n\n<p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p>\n<ul>\n<li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获得基于数组的selectedKeySet实现\nfinal SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();\n\nSelectedSelectionKeySet() &#123;\n\tkeys &#x3D; new SelectionKey[1024];\n&#125; </code></pre>\n</li>\n<li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p>\n</li>\n<li><p><strong>通过Selector的构造方法</strong>获得selector</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet) </code></pre>\n</li>\n<li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector\nreturn new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)); </code></pre></li>\n</ul>\n<h4 id=\"2-NIO线程启动时机\"><a href=\"#2-NIO线程启动时机\" class=\"headerlink\" title=\"2. NIO线程启动时机\"></a>2. NIO线程启动时机</h4><p><strong>启动</strong></p>\n<p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p>\n<p><strong>测试代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestNioEventLoop &#123;\n    public static void main(String[] args) &#123;\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        &#x2F;&#x2F; 使用NioEventLoop执行任务\n        eventLoop.execute(()-&gt;&#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;);\n    &#125;\n&#125;</code></pre>\n\n<p>进入<code>execute</code>执行任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic void execute(Runnable task) &#123;\n    &#x2F;&#x2F; 检测传入的任务是否为空，为空会抛出NullPointerException\n    ObjectUtil.checkNotNull(task, &quot;task&quot;);\n    &#x2F;&#x2F; 执行任务\n    &#x2F;&#x2F; 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true\n    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));\n&#125; </code></pre>\n\n<p>进入上述代码的<code>execute</code>方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void execute(Runnable task, boolean immediate) &#123;\n    &#x2F;&#x2F; 判断当前线程是否为NIO线程\n    &#x2F;&#x2F; 判断方法为 return thread &#x3D;&#x3D; this.thread;\n    &#x2F;&#x2F; this.thread即为NIO线程，首次执行任务时，其为null\n    boolean inEventLoop &#x3D; inEventLoop();\n    \n    &#x2F;&#x2F; 向任务队列taskQueue中添加任务\n    addTask(task);\n    \n    &#x2F;&#x2F; 当前线程不是NIO线程，则进入if语句\n    if (!inEventLoop) &#123;\n        &#x2F;&#x2F; 启动NIO线程的核心方法\n        startThread();\n        \n        ...\n        \n    &#125;\n\t\n    &#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程\n    if (!addTaskWakesUp &amp;&amp; immediate) &#123;\n        wakeup(inEventLoop);\n    &#125;\n&#125; </code></pre>\n\n<p>进入<code>startThread</code>方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void startThread() &#123;\n    &#x2F;&#x2F; 查看NIO线程状态是否为未启动\n    &#x2F;&#x2F; 该if代码块只会执行一次\n    &#x2F;&#x2F; state一开始的值就是ST_NOT_STARTED\n    &#x2F;&#x2F; private volatile int state &#x3D; ST_NOT_STARTED;\n    if (state &#x3D;&#x3D; ST_NOT_STARTED) &#123;\n        &#x2F;&#x2F; 通过原子属性更新器将状态更新为启动（ST_STARTED）\n        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;\n            boolean success &#x3D; false;\n            try &#123;\n                &#x2F;&#x2F; 执行启动线程\n                doStartThread();\n                success &#x3D; true;\n            &#125; finally &#123;\n                if (!success) &#123;\n                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void doStartThread() &#123;\n    assert thread &#x3D;&#x3D; null;\n    &#x2F;&#x2F; 创建NIO线程并执行任务\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            &#x2F;&#x2F; thread即为NIO线程\n            thread &#x3D; Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success &#x3D; false;\n            updateLastExecutionTime();\n            try &#123;\n                &#x2F;&#x2F; 执行内部run方法\n                SingleThreadEventExecutor.this.run();\n                success &#x3D; true;\n            &#125; \n            \n            ...\n    &#125;);\n&#125; </code></pre>\n\n<p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p>\n<p>该run方法是<strong>NioEvnetLoop的run方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void run() &#123;\n    int selectCnt &#x3D; 0;\n    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行\n    for (;;) &#123;\t\n      \t&#x2F;&#x2F; 执行各种任务\n   \t\ttry &#123;\n            int strategy;\n            try &#123;\n                strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());\n                switch (strategy) &#123;\n                case SelectStrategy.CONTINUE:\n                    continue;\n\n                case SelectStrategy.BUSY_WAIT:\n                    &#x2F;&#x2F; fall-through to SELECT since the busy-wait is not supported with NIO\n\n                case SelectStrategy.SELECT:\n                    long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();\n                    if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;\n                        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar\n                    &#125;\n                    nextWakeupNanos.set(curDeadlineNanos);\n                    try &#123;\n                        if (!hasTasks()) &#123;\n                            strategy &#x3D; select(curDeadlineNanos);\n                        &#125;\n                    &#125; finally &#123;\n                        &#x2F;&#x2F; This update is just to help block unnecessary selector wakeups\n                        &#x2F;&#x2F; so use of lazySet is ok (no race condition)\n                        nextWakeupNanos.lazySet(AWAKE);\n                    &#125;\n                    &#x2F;&#x2F; fall through\n                default:\n                &#125;\n       \t\t&#125;\n    \t&#125;\n\t&#125; </code></pre>\n\n\n\n<p><strong>唤醒</strong></p>\n<p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void run() &#123;\n    int selectCnt &#x3D; 0;\n    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行\n    for (;;) &#123;\n      \t&#x2F;&#x2F; 执行各种任务\n   \t\t...\n    &#125;\n&#125; </code></pre>\n\n<p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p>\n<p>run方法中有SELECT分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">case SelectStrategy.SELECT:\n\tlong curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();\n\tif (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;\n        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar\n    &#125;\n\tnextWakeupNanos.set(curDeadlineNanos);\n\ttry &#123;\n    \tif (!hasTasks()) &#123;\n            &#x2F;&#x2F; 执行select方法\n            strategy &#x3D; select(curDeadlineNanos);\n        &#125;\n    &#125;\n\t... </code></pre>\n\n<p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private int select(long deadlineNanos) throws IOException &#123;\n    &#x2F;&#x2F; 如果没有指定阻塞事件，就调用select()\n    if (deadlineNanos &#x3D;&#x3D; NONE) &#123;\n        return selector.select();\n    &#125;\n    &#x2F;&#x2F; 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞\n    &#x2F;&#x2F; Timeout will only be 0 if deadline is within 5 microsecs\n    long timeoutMillis &#x3D; deadlineToDelayNanos(deadlineNanos + 995000L) &#x2F; 1000000L;\n    return timeoutMillis &lt;&#x3D; 0 ? selector.selectNow() : selector.select(timeoutMillis);\n&#125; </code></pre>\n\n<p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p>\n<p>唤醒是通过execute最后的if代码块来完成的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程\nif (!addTaskWakesUp &amp;&amp; immediate) &#123;\n    wakeup(inEventLoop);\n&#125; </code></pre>\n\n<p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void wakeup(boolean inEventLoop) &#123;\n    &#x2F;&#x2F; 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒\n    &#x2F;&#x2F; 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功\n    if (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) !&#x3D; AWAKE) &#123;\n        &#x2F;&#x2F; 唤醒被selector.select方法阻塞的NIO线程\n        selector.wakeup();\n    &#125;\n&#125; </code></pre>\n\n<p>唤醒时需要进行两个判断</p>\n<ul>\n<li><p>判断提交任务的</p>\n<p>是否为NIO线程</p>\n<ul>\n<li>若是其他线程，才能唤醒NIO线程</li>\n<li>若是NIO线程自己，则不能唤醒</li>\n</ul>\n</li>\n<li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p>\n</li>\n</ul>\n<p><strong>SELECT分支</strong></p>\n<p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());\nswitch (strategy) &#123;\n\t...\n&#125; </code></pre>\n\n<p>strategy的值由<code>calculateStrategy</code>方法确定</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;\n    &#x2F;&#x2F; selectSupplier.get() 底层是 selector.selectNow();\n    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;\n&#125; </code></pre>\n\n<p>该方法会<strong>根据hasTaks变量判断任务队列中是否有任务</strong></p>\n<ul>\n<li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p>\n<ul>\n<li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final IntSupplier selectNowSupplier &#x3D; new IntSupplier() &#123;\n    public int get() throws Exception &#123;\n        return NioEventLoop.this.selectNow();\n    &#125;\n&#125;;\n\nint selectNow() throws IOException &#123;\n    return this.selector.selectNow();\n&#125; </code></pre></li>\n</ul>\n</li>\n<li><p>若没有任务，就会进入SELECT分支</p>\n</li>\n</ul>\n<p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p>\n<h4 id=\"3-Java-NIO空轮询BUG\"><a href=\"#3-Java-NIO空轮询BUG\" class=\"headerlink\" title=\"3. Java NIO空轮询BUG\"></a>3. Java NIO空轮询BUG</h4><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p>\n<p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void run() &#123;\n    ...\n    for(;;)&#123;\n        ...\n        &#x2F;&#x2F; 可能发生空轮询，无法阻塞NIO线程\n        strategy &#x3D; select(curDeadlineNanos);  \n        ...     \n    \n     \tif(...) &#123;\n\t\t\t...\n     \t&#125; else if (unexpectedSelectorWakeup(selectCnt) )&#123;\n            &#x2F;&#x2F; 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector\n            &#x2F;&#x2F; 并将selectCnt重置为0\n            selectCnt &#x3D; 0;\n        &#125;\n\t&#125;\n&#125; </code></pre>\n\n<p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p>\n<p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;\n    &#x2F;&#x2F; The selector returned prematurely many times in a row.\n    &#x2F;&#x2F; Rebuild the selector to work around the problem.\n    logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);\n    &#x2F;&#x2F; 重建selector，将原selector的配置信息传给新selector\n    &#x2F;&#x2F; 再用新selector覆盖旧selector\n    rebuildSelector();\n    return true;\n&#125; </code></pre>\n\n<p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p>\n<h4 id=\"5-ioRatio\"><a href=\"#5-ioRatio\" class=\"headerlink\" title=\"5. ioRatio\"></a>5. ioRatio</h4><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p>\n<p><strong>NioEventLoop.run方法</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 处理IO事件时间比例，默认为50%\nfinal int ioRatio &#x3D; this.ioRatio;\n\n&#x2F;&#x2F; 如果IO事件时间比例设置为100%\nif (ioRatio &#x3D;&#x3D; 100) &#123;\n    try &#123;\n        &#x2F;&#x2F; 如果需要去处理IO事件\n        if (strategy &gt; 0) &#123;\n            &#x2F;&#x2F; 先处理IO事件\n            processSelectedKeys();\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; Ensure we always run tasks.\n        &#x2F;&#x2F; 剩下的时间都去处理普通任务和定时任务\n        ranTasks &#x3D; runAllTasks();\n    &#125;\n&#125; else if (strategy &gt; 0) &#123; &#x2F;&#x2F; 如果需要去处理IO事件\n    &#x2F;&#x2F; 记录处理IO事件前的时间\n    final long ioStartTime &#x3D; System.nanoTime();\n    try &#123;\n        &#x2F;&#x2F; 去处理IO事件\n        processSelectedKeys();\n    &#125; finally &#123;\n        &#x2F;&#x2F; Ensure we always run tasks.\n        &#x2F;&#x2F; ioTime为处理IO事件耗费的事件\n        final long ioTime &#x3D; System.nanoTime() - ioStartTime;\n        &#x2F;&#x2F; 计算出处理其他任务的事件\n        &#x2F;&#x2F; 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行\n        ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);\n    &#125;\n&#125; else &#123; &#x2F;&#x2F; 没有IO事件需要处理\n    &#x2F;&#x2F; This will run the minimum number of tasks\n    &#x2F;&#x2F; 直接处理普通和定时任务\n    ranTasks &#x3D; runAllTasks(0); \n&#125; </code></pre>\n\n<p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p>\n<ul>\n<li><p>判断ioRatio是否为100</p>\n<ul>\n<li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p>\n<ul>\n<li>若需要处理IO事件，则先处理IO事件</li>\n</ul>\n</li>\n<li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 没有指定执行任务的时间\nranTasks &#x3D; runAllTasks(); </code></pre></li>\n</ul>\n</li>\n<li><p>若ioRatio不为100</p>\n<ul>\n<li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p>\n</li>\n<li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 比如ioTime为10s，ioRatio为50\n&#x2F;&#x2F; 那么通过 10*(100-50)&#x2F;50&#x3D;10 计算出其他任务可用的时间为 10s\n&#x2F;&#x2F; 处理IO事件占用的事件总比例为50%\nranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio); </code></pre>\n</li>\n<li><p>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</p>\n</li>\n</ul>\n</li>\n<li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 运行最少数量的任务\nranTasks &#x3D; runAllTasks(0); </code></pre></li>\n</ul>\n<h4 id=\"6-处理事件\"><a href=\"#6-处理事件\" class=\"headerlink\" title=\"6. 处理事件\"></a>6. 处理事件</h4><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKeys() &#123;\n    &#x2F;&#x2F; 如果selectedKeys是基于数组的\n    &#x2F;&#x2F; 一般情况下都走这个分支\n    if (selectedKeys !&#x3D; null) &#123;\n        &#x2F;&#x2F; 处理各种IO事件\n        processSelectedKeysOptimized();\n    &#125; else &#123;\n        processSelectedKeysPlain(selector.selectedKeys());\n    &#125;\n&#125; </code></pre>\n\n<p>processSelectedKeysOptimized方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKeysOptimized() &#123;\n    for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;\n        &#x2F;&#x2F; 拿到SelectionKeyec\n        final SelectionKey k &#x3D; selectedKeys.keys[i];\n        &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n        selectedKeys.keys[i] &#x3D; null;\n\n        &#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel\n        final Object a &#x3D; k.attachment();\n\n        if (a instanceof AbstractNioChannel) &#123;\n            &#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel\n            processSelectedKey(k, (AbstractNioChannel) a);\n        &#125; else &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;\n            processSelectedKey(k, task);\n        &#125;\n\n        if (needsToSelectAgain) &#123;\n            &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n            selectedKeys.reset(i + 1);\n\n            selectAgain();\n            i &#x3D; -1;\n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">final SelectionKey k &#x3D; selectedKeys.keys[i]; </code></pre>\n\n<p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel\nfinal Object a &#x3D; k.attachment(); </code></pre>\n\n<p>如果附件继承自AbstractNioChannel，则会调用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel\nprocessSelectedKey(k, (AbstractNioChannel) a); </code></pre>\n\n<p>去处理各个事件</p>\n<p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p>\n<p>获取SelectionKey的事件，然后进行相应处理</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;\n    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();\n    if (!k.isValid()) &#123;\n        final EventLoop eventLoop;\n        try &#123;\n            eventLoop &#x3D; ch.eventLoop();\n        &#125; catch (Throwable ignored) &#123;\n            &#x2F;&#x2F; If the channel implementation throws an exception because there is no event loop, we ignore this\n            &#x2F;&#x2F; because we are only trying to determine if ch is registered to this event loop and thus has authority\n            &#x2F;&#x2F; to close ch.\n            return;\n        &#125;\n        &#x2F;&#x2F; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop\n        &#x2F;&#x2F; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is\n        &#x2F;&#x2F; still healthy and should not be closed.\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;5125\n        if (eventLoop &#x3D;&#x3D; this) &#123;\n            &#x2F;&#x2F; close the channel if the key is not valid anymore\n            unsafe.close(unsafe.voidPromise());\n        &#125;\n        return;\n    &#125;\n\n    try &#123;\n        int readyOps &#x3D; k.readyOps();\n        &#x2F;&#x2F; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise\n        &#x2F;&#x2F; the NIO JDK channel implementation may throw a NotYetConnectedException.\n        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;\n            &#x2F;&#x2F; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;924\n            int ops &#x3D; k.interestOps();\n            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        &#125;\n\n        &#x2F;&#x2F; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.\n        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;\n            &#x2F;&#x2F; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write\n            ch.unsafe().forceFlush();\n        &#125;\n\n        &#x2F;&#x2F; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead\n        &#x2F;&#x2F; to a spin loop\n        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n            unsafe.read();\n        &#125;\n    &#125; catch (CancelledKeyException ignored) &#123;\n        unsafe.close(unsafe.voidPromise());\n    &#125;\n&#125; </code></pre>\n\n<h3 id=\"c、Accept剖析\"><a href=\"#c、Accept剖析\" class=\"headerlink\" title=\"c、Accept剖析\"></a>c、Accept剖析</h3><h4 id=\"1-NIO中处理Accept事件流程\"><a href=\"#1-NIO中处理Accept事件流程\" class=\"headerlink\" title=\"1. NIO中处理Accept事件流程\"></a>1. NIO中处理Accept事件流程</h4><p>NIO中处理Accept事件主要有以下六步</p>\n<ul>\n<li>selector.select()阻塞线程，直到事件发生</li>\n<li>遍历selectionKeys</li>\n<li>获取一个key，判断事件类型是否为Accept</li>\n</ul>\n<hr>\n<ul>\n<li>创建SocketChannel，设置为非阻塞</li>\n<li>将SocketChannel注册到selector中</li>\n<li>关注selectionKeys的read事件</li>\n</ul>\n<p>代码如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 阻塞直到事件发生\nselector.select();\n\nIterator&lt;SelectionKey&gt; iter &#x3D; selector.selectionKeys().iterator();\nwhile (iter.hasNext()) &#123;    \n    &#x2F;&#x2F; 拿到一个事件\n    SelectionKey key &#x3D; iter.next();\n    \n    &#x2F;&#x2F; 如果是 accept 事件\n    if (key.isAcceptable()) &#123;\n        \n        &#x2F;&#x2F; 执行accept，获得SocketChannel\n        SocketChannel channel &#x3D; serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        &#x2F;&#x2F; 将SocketChannel注册到selector中，并关注read事件\n        channel.register(selector, SelectionKey.OP_READ);\n    &#125;\n    &#x2F;&#x2F; ...\n&#125; </code></pre>\n\n<p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p>\n<h4 id=\"2-SocketChannel的创建与注册\"><a href=\"#2-SocketChannel的创建与注册\" class=\"headerlink\" title=\"2. SocketChannel的创建与注册\"></a>2. SocketChannel的创建与注册</h4><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n\tunsafe.read();\n&#125; </code></pre>\n\n<p><code>NioMessageUnsafe.read</code>方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void read() &#123;\n\n    ...\n    \n    try &#123;\n        try &#123;\n            do &#123;\n\t\t\t\t&#x2F;&#x2F; doReadMessages中执行了accept获得了SocketChannel\n                &#x2F;&#x2F; 并创建NioSocketChannel作为消息放入readBuf\n                &#x2F;&#x2F; readBuf是一个ArrayList用来缓存消息\n                &#x2F;&#x2F; private final List&lt;Object&gt; readBuf &#x3D; new ArrayList&lt;Object&gt;();\n                int localRead &#x3D; doReadMessages(readBuf);\n                \n                ...\n                \n\t\t\t\t&#x2F;&#x2F; localRead值为1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            &#125; while (allocHandle.continueReading());\n        &#125; catch (Throwable t) &#123;\n            exception &#x3D; t;\n        &#125;\n\n        int size &#x3D; readBuf.size();\n        for (int i &#x3D; 0; i &lt; size; i ++) &#123;\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发read事件，让pipeline上的handler处理\n            &#x2F;&#x2F; ServerBootstrapAcceptor.channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        &#125;\n        \n        ...\n        \n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125; </code></pre>\n\n<p><code>NioSocketChannel.doReadMessages</code>方法</p>\n<p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;\n    &#x2F;&#x2F; 处理accpet事件，获得SocketChannel\n    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());\n\n    try &#123;\n        if (ch !&#x3D; null) &#123;\n            &#x2F;&#x2F; 创建了NioSocketChannel，作为消息放在了readBuf中\n            buf.add(new NioSocketChannel(this, ch));\n            return 1;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n       ...\n    &#125;\n\n    return 0;\n&#125; \nServerBootstrapAcceptor.channelRead\npublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n    &#x2F;&#x2F; 这时的msg是NioSocketChannel\n    final Channel child &#x3D; (Channel) msg;\n\n    &#x2F;&#x2F; NioSocketChannel添加childHandler，即初始化器\n    child.pipeline().addLast(childHandler);\n\n    &#x2F;&#x2F; 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;\n        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());\n    &#125;\n\n    try &#123;\n        &#x2F;&#x2F; 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程\n        childGroup.register(child).addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                if (!future.isSuccess()) &#123;\n                    forceClose(child, future.cause());\n                &#125;\n            &#125;\n        &#125;);\n    &#125; catch (Throwable t) &#123;\n        forceClose(child, t);\n    &#125;\n&#125; </code></pre>\n\n<p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    \n    ...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 这行代码完成的是nio boss -&gt; nio worker线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 真正的注册操作\n                    register0(promise);\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            ...\n        &#125;\n    &#125;\n&#125; \nAbstractChannel.AbstractUnsafe.register0\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n        \n        ...\n            \n        &#x2F;&#x2F; 该方法将SocketChannel注册到Selector中\n        doRegister();\n        \n        &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                &#x2F;&#x2F; 触发pipeline上active事件\n                pipeline.fireChannelActive();\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125; </code></pre>\n\n<p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void doRegister() throws Exception &#123;\n    boolean selected &#x3D; false;\n    for (;;) &#123;\n        try &#123;\n            &#x2F;&#x2F; 将Selector注册到Selector中\n            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        &#125; catch (CancelledKeyException e) &#123;\n            ...\n        &#125;\n    &#125;\n&#125; \nHeadContext.channelActive\npublic void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n&#125; </code></pre>\n\n<p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\t&#x2F;&#x2F; 这时候 interestOps是0\n    final int interestOps &#x3D; selectionKey.interestOps();\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 关注read事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125; </code></pre>\n\n<h3 id=\"d、Read剖析\"><a href=\"#d、Read剖析\" class=\"headerlink\" title=\"d、Read剖析\"></a>d、Read剖析</h3><p>read事件的处理也是在</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n\tunsafe.read();\n&#125;</code></pre>\n\n<p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\npublic final void read() &#123;\n    &#x2F;&#x2F; 获得Channel的配置\n    final ChannelConfig config &#x3D; config();\n    if (shouldBreakReadReady(config)) &#123;\n        clearReadPending();\n        return;\n    &#125;\n    final ChannelPipeline pipeline &#x3D; pipeline();\n\t&#x2F;&#x2F; 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）\n\tfinal ByteBufAllocator allocator &#x3D; config.getAllocator();\n    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf &#x3D; null;\n    boolean close &#x3D; false;\n    try &#123;\n        do &#123;\n            &#x2F;&#x2F; 创建ByteBuf\n            byteBuf &#x3D; allocHandle.allocate(allocator);\n            &#x2F;&#x2F; 读取内容，放入ByteBUf中\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;\n                byteBuf.release();\n                byteBuf &#x3D; null;\n                close &#x3D; allocHandle.lastBytesRead() &lt; 0;\n                if (close) &#123;\n                    readPending &#x3D; false;\n                &#125;\n                break;\n            &#125;\n\n            allocHandle.incMessagesRead(1);\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发read 事件，让pipeline上的handler处理\n            &#x2F;&#x2F; 这时是处理NioSocketChannel上的handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf &#x3D; null;\n        &#125; \n        &#x2F;&#x2F; 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        &#x2F;&#x2F; 触发 read complete事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) &#123;\n            closeOnRead(pipeline);\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    &#125; finally &#123;\n         &#x2F;&#x2F; Check if there is a readPending which was not processed yet.\n         &#x2F;&#x2F; This could be for two reasons:\n         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n         &#x2F;&#x2F;\n         &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2254\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125; \nDefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;\n    return \n           &#x2F;&#x2F; 一般为true\n           config.isAutoRead() &amp;&amp;\n           &#x2F;&#x2F; respectMaybeMoreData默认为true\n           &#x2F;&#x2F; maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;\n           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead默认16\n           totalMessages &lt; maxMessagePerRead &amp;&amp;\n           &#x2F;&#x2F; 实际读到了数据\n           totalBytesRead &gt; 0;\n&#125;</code></pre>\n","feature":true,"text":"视频教程参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of ma...","link":"","photos":[],"count_time":{"symbolsCount":"129k","symbolsTime":"1:58"},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Netty-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. Netty 概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">2. 入门案例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Netty-%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">3. Netty 组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-EventLoop\"><span class=\"toc-text\">a. EventLoop</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-EventLoop%E5%A4%84%E7%90%86%E6%99%AE%E9%80%9A%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">1. EventLoop处理普通与定时任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-EventLoop%E5%A4%84%E7%90%86IO%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">2. EventLoop处理IO任务</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%A2%9E%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89EventLoopGroup\"><span class=\"toc-text\">3. 增加自定义EventLoopGroup</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%88%87%E6%8D%A2%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">4. 切换的实现</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Channel\"><span class=\"toc-text\">b. Channel</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ChannelFuture%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">1. ChannelFuture连接问题</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%A4%84%E7%90%86%E5%85%B3%E9%97%AD\"><span class=\"toc-text\">2.处理关闭</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Future-amp-Promise\"><span class=\"toc-text\">c. Future &amp; Promise</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">1.概念</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JDK-Future\"><span class=\"toc-text\">2. JDK Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Netty-Future\"><span class=\"toc-text\">3.Netty Future</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Netty-Promise\"><span class=\"toc-text\">4.Netty Promise</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-Handler-amp-Pipline\"><span class=\"toc-text\">d. Handler &amp; Pipline</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-Pipeline\"><span class=\"toc-text\">1. Pipeline</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-OutboundHandler\"><span class=\"toc-text\">2. OutboundHandler</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-socketChannel-writeAndFlush\"><span class=\"toc-text\">a. socketChannel.writeAndFlush()</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-ctx-writeAndFlush\"><span class=\"toc-text\">b. ctx.writeAndFlush()</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-EmbeddedChannel\"><span class=\"toc-text\">3. EmbeddedChannel</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ByteBuf\"><span class=\"toc-text\">e. ByteBuf</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%88%9B%E5%BB%BA\"><span class=\"toc-text\">1.创建</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98\"><span class=\"toc-text\">2.直接内存与堆内存</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B1%A0%E5%8C%96%E4%B8%8E%E9%9D%9E%E6%B1%A0%E5%8C%96\"><span class=\"toc-text\">3.池化与非池化</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">4.组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E5%86%99%E5%85%A5\"><span class=\"toc-text\">5.写入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E6%89%A9%E5%AE%B9\"><span class=\"toc-text\">6.扩容</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99\"><span class=\"toc-text\">7.扩容规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E8%AF%BB%E5%8F%96\"><span class=\"toc-text\">8.读取</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">9.释放</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-%E9%87%8A%E6%94%BE%E8%A7%84%E5%88%99\"><span class=\"toc-text\">10.释放规则</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-%E5%88%87%E7%89%87\"><span class=\"toc-text\">11.切片</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#12-%E4%BC%98%E5%8A%BF\"><span class=\"toc-text\">12.优势</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%BB%8F%E5%8C%85%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">4. 黏包半包</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E9%BB%8F%E5%8C%85%E4%B8%8E%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">a.黏包与半包现象</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">1. 粘包现象</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8D%8A%E5%8C%85%E7%8E%B0%E8%B1%A1\"><span class=\"toc-text\">2. 半包现象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E7%8E%B0%E8%B1%A1%E5%88%86%E6%9E%90\"><span class=\"toc-text\">b. 现象分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B2%98%E5%8C%85\"><span class=\"toc-text\">1. 粘包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%8D%8A%E5%8C%85\"><span class=\"toc-text\">2. 半包</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%9C%AC%E8%B4%A8\"><span class=\"toc-text\">3. 本质</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">c. 解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%9F%AD%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">1. 短链接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%AE%9A%E9%95%BF%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">2. 定长解码器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%A1%8C%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">3. 行解码器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">4. 长度字段解码器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1%E4%B8%8E%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">5. 协议设计与解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">a. 协议的作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-Redis%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">b. Redis协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-HTTP%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">c. HTTP协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">d. 自定义协议</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0\"><span class=\"toc-text\">1.组成要素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E7%BC%96%E7%A0%81%E5%99%A8%E4%B8%8E%E8%A7%A3%E7%A0%81%E5%99%A8\"><span class=\"toc-text\">2. 编码器与解码器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Sharable%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">3. @Sharable注解</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8-Sharable%E6%B3%A8%E8%A7%A3\"><span class=\"toc-text\">4. 自定义编解码器能否使用@Sharable注解</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">6. 源码分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">a、启动流程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-bind\"><span class=\"toc-text\">1. bind</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-doBind\"><span class=\"toc-text\">2. doBind</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-initAndRegisterd\"><span class=\"toc-text\">3. initAndRegisterd</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-init\"><span class=\"toc-text\">4. init</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Register\"><span class=\"toc-text\">5. Register</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-doBind0\"><span class=\"toc-text\">6. doBind0</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">7.总结</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b%E3%80%81NioEventLoop%E5%89%96%E6%9E%90\"><span class=\"toc-text\">b、NioEventLoop剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">1. 组成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-NIO%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">2. NIO线程启动时机</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Java-NIO%E7%A9%BA%E8%BD%AE%E8%AF%A2BUG\"><span class=\"toc-text\">3. Java NIO空轮询BUG</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-ioRatio\"><span class=\"toc-text\">5. ioRatio</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6\"><span class=\"toc-text\">6. 处理事件</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c%E3%80%81Accept%E5%89%96%E6%9E%90\"><span class=\"toc-text\">c、Accept剖析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-NIO%E4%B8%AD%E5%A4%84%E7%90%86Accept%E4%BA%8B%E4%BB%B6%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1. NIO中处理Accept事件流程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-SocketChannel%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%B3%A8%E5%86%8C\"><span class=\"toc-text\">2. SocketChannel的创建与注册</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d%E3%80%81Read%E5%89%96%E6%9E%90\"><span class=\"toc-text\">d、Read剖析</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"NIO","uid":"c9f2b21b690f4db6367244e90c766293","slug":"NIO","date":"2022-04-18T05:11:37.000Z","updated":"2022-04-18T05:43:59.525Z","comments":true,"path":"api/articles/NIO.json","keywords":null,"cover":[],"text":"1. NIO基础NIO - Non-blocking IO 或 New IO a. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。 通道表示打开...","link":"","photos":[],"count_time":{"symbolsCount":"39k","symbolsTime":"36 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"NIO","slug":"NIO","count":1,"path":"api/tags/NIO.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-28T08:45:37.915Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":[],"text":"博文主要介绍后端的核心内容 视频教训参考 黑马程序员Netty全套教程 博客参考了 Nyima 0. 总体思路前后端信息交互的推送技术有三类: 短轮询 一般是客户端定时发送普通Http请求给服务端 会占用大量服务器资源 数据响应不及时 长轮询(Comet) 基于Ajax长轮询技术...","link":"","photos":[],"count_time":{"symbolsCount":"57k","symbolsTime":"52 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Maven","slug":"Maven","count":1,"path":"api/tags/Maven.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}