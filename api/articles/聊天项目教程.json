{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-25T12:09:36.107Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":[],"content":"<blockquote><p>博文主要介绍后端的核心内容</p>\n<p>视频教训参考 <a href=\"https://www.bilibili.com/video/BV1py4y1E7oA\">黑马程序员Netty全套教程</a></p>\n<p>博客参考了 <a href=\"https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/\">Nyima</a></p></blockquote>\n<h2 id=\"1-环境搭建\"><a href=\"#1-环境搭建\" class=\"headerlink\" title=\"1. 环境搭建\"></a>1. 环境搭建</h2><p>本项目的后端使用<code>Maven</code>构建，主要的依赖如下:</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;com.netty.netty&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;8&lt;&#x2F;source&gt;\n                    &lt;target&gt;8&lt;&#x2F;target&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.1.51.Final&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.18.20&lt;&#x2F;version&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n&lt;!--        &lt;dependency&gt;--&gt;\n&lt;!--            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;--&gt;\n&lt;!--            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;--&gt;\n&lt;!--            &lt;version&gt;1.7.30&lt;&#x2F;version&gt;--&gt;\n&lt;!--            &lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;\n&lt;!--        &lt;&#x2F;dependency&gt;--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.8.5&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n\n\n<h2 id=\"2-创建聊天传送的消息类\"><a href=\"#2-创建聊天传送的消息类\" class=\"headerlink\" title=\"2. 创建聊天传送的消息类\"></a>2. 创建聊天传送的消息类</h2><p>这些都是聊天过程中发送的消息类，主要是为了规范消息的格式。</p>\n<img src=\"%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425112210971.png\" alt=\"image-20220425112210971\"  />\n\n<p>所有的类都实现了<code>Message</code>类,它的主要内容如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     *&#x2F;\n    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;\n        return messageClasses.get(messageType);\n    &#125;\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage &#x3D; 0;\n    public static final int LoginResponseMessage &#x3D; 1;\n    public static final int ChatRequestMessage &#x3D; 2;\n    public static final int ChatResponseMessage &#x3D; 3;\n    public static final int GroupCreateRequestMessage &#x3D; 4;\n    public static final int GroupCreateResponseMessage &#x3D; 5;\n    public static final int GroupJoinRequestMessage &#x3D; 6;\n    public static final int GroupJoinResponseMessage &#x3D; 7;\n    public static final int GroupQuitRequestMessage &#x3D; 8;\n    public static final int GroupQuitResponseMessage &#x3D; 9;\n    public static final int GroupChatRequestMessage &#x3D; 10;\n    public static final int GroupChatResponseMessage &#x3D; 11;\n    public static final int GroupMembersRequestMessage &#x3D; 12;\n    public static final int GroupMembersResponseMessage &#x3D; 13;\n    public static final int PingMessage &#x3D; 14;\n    public static final int PongMessage &#x3D; 15;\n    &#x2F;**\n     * 请求类型 byte 值\n     *&#x2F;\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    &#x2F;**\n     * 响应类型 byte 值\n     *&#x2F;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        messageClasses.put(LoginRequestMessage, cn.message.LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, cn.message.LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, cn.message.ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, cn.message.ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, cn.message.GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, cn.message.GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, cn.message.GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, cn.message.GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, cn.message.GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, cn.message.GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, cn.message.GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, cn.message.GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, cn.message.GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, cn.message.GroupMembersResponseMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;</code></pre>\n\n\n\n<h2 id=\"3-创建会话管理类\"><a href=\"#3-创建会话管理类\" class=\"headerlink\" title=\"3. 创建会话管理类\"></a>3. 创建会话管理类</h2><p>会话Session相关类的作用是:</p>\n<ul>\n<li><code>Session</code> 维护 channel 和 用户之间的关系。</li>\n<li><code>GroupSession</code>维护聊天室和成员的关系信息</li>\n</ul>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425170611799.png\" class=\"\" title=\"image-20220425170611799\">\n\n<p>他们都通过工厂模式实现,可以他们的接口定义如下:</p>\n<p><code>Session</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 会话管理接口\n *&#x2F;\npublic interface Session &#123;\n\n    &#x2F;**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     *&#x2F;\n    void bind(Channel channel, String username);\n\n    &#x2F;**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     *&#x2F;\n    void unbind(Channel channel);\n\n    &#x2F;**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     *&#x2F;\n    Object getAttribute(Channel channel, String name);\n\n    &#x2F;**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     *&#x2F;\n    void setAttribute(Channel channel, String name, Object value);\n\n    &#x2F;**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     *&#x2F;\n    Channel getChannel(String username);\n&#125;\n</code></pre>\n\n<p><code>GroupSession</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface GroupSession &#123;\n    &#x2F;**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     *&#x2F;\n    Group createGroup(String name, Set&lt;String&gt; members);\n    &#x2F;**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group joinMember(String name, String member);\n    &#x2F;**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeMember(String name, String member);\n    &#x2F;**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeGroup(String name);\n    &#x2F;**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 如果群不存在或没有成员会返回 empty set\n     *&#x2F;\n    Set&lt;String&gt; getMembers(String name);\n    &#x2F;**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     *&#x2F;\n    List&lt;Channel&gt; getMembersChannel(String name);\n&#125;\n</code></pre>\n\n\n\n<p>个人聊天建立的时候，会执行如下代码保存会话信息：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SessionFactory.getSession().bind(ctx.channel(), username);</code></pre>\n\n<p>聊天室建立的时候,会执行如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();\nGroup group &#x3D; groupSession.createGroup(groupName, members);\nif (group &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 发送拉群消息\n    List&lt;Channel&gt; channels &#x3D; groupSession.getMembersChannel(groupName);\n    &#x2F;&#x2F;---\n&#125;</code></pre>\n\n\n\n<p>本地存储用户的信息,也可以通过数据库实现</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425195209747.png\" class=\"\" title=\"image-20220425195209747\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 用户管理接口\n *&#x2F;\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     *&#x2F;\n    boolean login(String username, String password);\n&#125;</code></pre>\n\n<p><code>UserServiceMemoryImpl</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserServiceMemoryImpl implements UserService &#123;\n    private Map&lt;String, String&gt; allUserMap &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    &#123;\n        allUserMap.put(&quot;zhangsan&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;lisi&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;wangwu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;zhaoliu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;qianqi&quot;, &quot;123&quot;);\n    &#125;\n\n    @Override\n    public boolean login(String username, String password) &#123;\n        String pass &#x3D; allUserMap.get(username);\n        if (pass &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n        return pass.equals(password);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n\n\n\n\n\n\n<h2 id=\"4-创建应用层传输的协议\"><a href=\"#4-创建应用层传输的协议\" class=\"headerlink\" title=\"4. 创建应用层传输的协议\"></a>4. 创建应用层传输的协议</h2><p>规定应用层报文的格式,他们是对消息进行编解码的。</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425112509531.png\" class=\"\" title=\"image-20220425112509531\">\n\n<p><code>MessageCodecSharable</code>来解决编解码问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 设置魔数 4个字节\n        out.writeBytes(new byte[]&#123;&#39;N&#39;, &#39;Y&#39;, &#39;I&#39;, &#39;M&#39;&#125;);\n        &#x2F;&#x2F; 设置版本号 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置序列化方式 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置指令类型 1个字节\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 设置请求序号 4个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 获得序列化后的msg\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; 获取魔数\n        int magic &#x3D; in.readInt();\n        &#x2F;&#x2F; 获取版本号\n        byte version &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得序列化方式\n        byte seqType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得指令类型\n        byte messageType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得请求序号\n        int sequenceId &#x3D; in.readInt();\n        &#x2F;&#x2F; 移除补齐字节\n        in.readByte();\n        &#x2F;&#x2F; 获得正文长度\n        int length &#x3D; in.readInt();\n        &#x2F;&#x2F; 获得正文\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        &#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n        &#x2F;&#x2F; 打印获得的信息正文\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(magic);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(version);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(seqType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(messageType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(sequenceId);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(length);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(message);\n    &#125;\n&#125;</code></pre>\n\n<p><code>ProcotolFrameDecoder</code>解决黏包半包问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProcotolFrameDecoder extends LengthFieldBasedFrameDecoder &#123;\n    public ProcotolFrameDecoder() &#123;\n        this(1024, 12, 4, 0, 0);\n    &#125;\n    public ProcotolFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) &#123;\n        super(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"5-创建客户端代码\"><a href=\"#5-创建客户端代码\" class=\"headerlink\" title=\"5. 创建客户端代码\"></a>5. 创建客户端代码</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatClient &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN &#x3D; new CountDownLatch(1);\n        AtomicBoolean LOGIN &#x3D; new AtomicBoolean(false);\n        AtomicBoolean EXIT &#x3D; new AtomicBoolean(false);\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.group(group);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                        &#x2F;&#x2F; 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n&#x2F;&#x2F;                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);\n                            if ((msg instanceof LoginResponseMessage)) &#123;\n                                LoginResponseMessage response &#x3D; (LoginResponseMessage) msg;\n                                if (response.isSuccess()) &#123;\n                                    &#x2F;&#x2F; 如果登录成功\n                                    LOGIN.set(true);\n                                &#125;\n                                &#x2F;&#x2F; 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            &#125;\n                            System.out.println(msg);\n                        &#125;\n\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            new Thread(() -&gt; &#123;\n                                System.out.println(&quot;请输入用户名:&quot;);\n                                Scanner scanner &#x3D; new Scanner(System.in);\n                                String username &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                System.out.println(&quot;请输入密码:&quot;);\n                                String password &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                &#x2F;&#x2F; 构造消息对象\n                                LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);\n                                System.out.println(message);\n                                &#x2F;&#x2F; 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(&quot;等待后续操作...&quot;);\n                                try &#123;\n                                    WAIT_FOR_LOGIN.await();\n                                &#125; catch (InterruptedException e) &#123;\n                                    e.printStackTrace();\n                                &#125;\n                                &#x2F;&#x2F; 如果登录失败\n                                if (!LOGIN.get()) &#123;\n                                    ctx.channel().close();\n                                    return;\n                                &#125;\n                                while (true) &#123;\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    System.out.println(&quot;send [username] [content]&quot;);\n                                    System.out.println(&quot;gsend [group name] [content]&quot;);\n                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);\n                                    System.out.println(&quot;gmembers [group name]&quot;);\n                                    System.out.println(&quot;gjoin [group name]&quot;);\n                                    System.out.println(&quot;gquit [group name]&quot;);\n                                    System.out.println(&quot;quit&quot;);\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    String command &#x3D; null;\n                                    try &#123;\n                                        command &#x3D; scanner.nextLine();\n                                    &#125; catch (Exception e) &#123;\n                                        break;\n                                    &#125;\n                                    if (EXIT.get()) &#123;\n                                        return;\n                                    &#125;\n                                    String[] s &#x3D; command.split(&quot; &quot;);\n                                    switch (s[0]) &#123;\n                                        case &quot;send&quot;:\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gsend&quot;:\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gcreate&quot;:\n                                            Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));\n                                            set.add(username); &#x2F;&#x2F; 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case &quot;gmembers&quot;:\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case &quot;gjoin&quot;:\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;gquit&quot;:\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;quit&quot;:\n                                            ctx.channel().close();\n                                            return;\n                                    &#125;\n                                &#125;\n                            &#125;, &quot;System in&quot;).start();\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"6-创建服务器代码\"><a href=\"#6-创建服务器代码\" class=\"headerlink\" title=\"6. 创建服务器代码\"></a>6. 创建服务器代码</h2><p>服务器端代码,逻辑很简单,但是重点对于各个<code>Handler</code>的封装,然后依次加入<code>SocketChannel</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ch.pipeline().addLast(new ProcotolFrameDecoder());\nch.pipeline().addLast(loggingHandler);\nch.pipeline().addLast(messageSharableCodec);\nch.pipeline().addLast(loginRequestMessageHandler);\nch.pipeline().addLast(chatRequestMessageHandler);\nch.pipeline().addLast(groupCreateRequestMessageHandler);\nch.pipeline().addLast(groupJoinRequestMessageHandler);\nch.pipeline().addLast(groupMembersRequestMessageHandler);\nch.pipeline().addLast(groupQuitRequestMessageHandler);\nch.pipeline().addLast(groupChatRequestMessageHandler);\nch.pipeline().addLast(quitHandler);</code></pre>\n\n<p>每个<code>Handler</code>是对客户端发过来不同类型的消息进行处理,按照消息类型的不同,封装成不同的<code>Handler</code>,下面以一个<code>loginRequestMessageHandler</code>为例来介绍具体代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable &#x2F;&#x2F; 设置成Sharable 可以公用一个处理器\n&#x2F;&#x2F; 继承SimpleChannelInboundHandler,注意针对的数据类型LoginRequestMessage\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n        String username &#x3D; msg.getUsername();\n        String password &#x3D; msg.getPassword();\n        boolean login &#x3D; UserServiceFactory.getUserService().login(username,\n                password);\n        LoginResponseMessage message;\n        if (login) &#123;\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);\n        &#125; else &#123;\n            message &#x3D; new LoginResponseMessage(false, &quot;登录失败&quot;);\n        &#125;\n        &#x2F;&#x2F; 消息传回客户端\n        ctx.writeAndFlush(message);\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>完整代码如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatServer &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();\n        ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();\n        GroupCreateRequestMessageHandler groupCreateRequestMessageHandler &#x3D; new GroupCreateRequestMessageHandler();\n        GroupJoinRequestMessageHandler groupJoinRequestMessageHandler &#x3D; new GroupJoinRequestMessageHandler();\n        GroupMembersRequestMessageHandler groupMembersRequestMessageHandler &#x3D; new GroupMembersRequestMessageHandler();\n        GroupQuitRequestMessageHandler groupQuitRequestMessageHandler &#x3D; new GroupQuitRequestMessageHandler();\n        GroupChatRequestMessageHandler groupChatRequestMessageHandler &#x3D; new GroupChatRequestMessageHandler();\n        QuitHandler quitHandler &#x3D; new QuitHandler();\n        try &#123;\n            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();\n            bootstrap.group(boss, worker);\n            bootstrap.channel(NioServerSocketChannel.class);\n            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(loginRequestMessageHandler);\n                    ch.pipeline().addLast(chatRequestMessageHandler);\n                    ch.pipeline().addLast(groupCreateRequestMessageHandler);\n                    ch.pipeline().addLast(groupJoinRequestMessageHandler);\n                    ch.pipeline().addLast(groupMembersRequestMessageHandler);\n                    ch.pipeline().addLast(groupQuitRequestMessageHandler);\n                    ch.pipeline().addLast(groupChatRequestMessageHandler);\n                    ch.pipeline().addLast(quitHandler);\n\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"7-添加心跳机制\"><a href=\"#7-添加心跳机制\" class=\"headerlink\" title=\"7. 添加心跳机制\"></a>7. 添加心跳机制</h2>","feature":true,"text":"博文主要介绍后端的核心内容 视频教训参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. 环境搭建本项目的后端使用Maven构建，主要的依赖如下: &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UT...","link":"","photos":[],"count_time":{"symbolsCount":"26k","symbolsTime":"24 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Maven","slug":"Maven","count":1,"path":"api/tags/Maven.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">1. 环境搭建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E4%BC%A0%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB\"><span class=\"toc-text\">2. 创建聊天传送的消息类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%B1%BB\"><span class=\"toc-text\">3. 创建会话管理类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4. 创建应用层传输的协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">5. 创建客户端代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">6. 创建服务器代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%B7%BB%E5%8A%A0%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">7. 添加心跳机制</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-22T06:52:47.865Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"text":"视频教程参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of ma...","link":"","photos":[],"count_time":{"symbolsCount":"82k","symbolsTime":"1:15"},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"常用命令","uid":"a5f30086118eef4097b37f892ce916b2","slug":"常用命令","date":"2022-04-11T13:18:09.000Z","updated":"2022-04-11T13:21:13.824Z","comments":true,"path":"api/articles/常用命令.json","keywords":null,"cover":null,"text":"Dockerdocker search [镜像名称] # 搜索镜像 docker pull [镜像名称[:版本号]] # 拉取镜像 docker images # 查看本地镜像 docker exec -it [redis] bash # 以命令行形式进入容器内部 docker ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"常用命令","slug":"常用命令","count":1,"path":"api/categories/常用命令.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"},{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}