{"title":"聊天项目教程","uid":"9bc6b9b8ef2259594a736fcc57388eb4","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","updated":"2022-04-27T06:56:29.259Z","comments":true,"path":"api/articles/聊天项目教程.json","keywords":null,"cover":[],"content":"<blockquote><p>博文主要介绍后端的核心内容</p>\n<p>视频教训参考 <a href=\"https://www.bilibili.com/video/BV1py4y1E7oA\">黑马程序员Netty全套教程</a></p>\n<p>博客参考了 <a href=\"https://nyimac.gitee.io/2021/04/25/Netty%E5%9F%BA%E7%A1%80/\">Nyima</a></p></blockquote>\n<h2 id=\"1-环境搭建\"><a href=\"#1-环境搭建\" class=\"headerlink\" title=\"1. 环境搭建\"></a>1. 环境搭建</h2><p>本项目的后端使用<code>Maven</code>构建，主要的依赖如下:</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;com.netty.netty&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;8&lt;&#x2F;source&gt;\n                    &lt;target&gt;8&lt;&#x2F;target&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.1.51.Final&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.18.20&lt;&#x2F;version&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n&lt;!--        &lt;dependency&gt;--&gt;\n&lt;!--            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;--&gt;\n&lt;!--            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;--&gt;\n&lt;!--            &lt;version&gt;1.7.30&lt;&#x2F;version&gt;--&gt;\n&lt;!--            &lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;\n&lt;!--        &lt;&#x2F;dependency&gt;--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.8.5&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;</code></pre>\n\n\n\n<h2 id=\"2-创建聊天传送的消息类\"><a href=\"#2-创建聊天传送的消息类\" class=\"headerlink\" title=\"2. 创建聊天传送的消息类\"></a>2. 创建聊天传送的消息类</h2><p>这些都是聊天过程中发送的消息类，主要是为了规范消息的格式。</p>\n<img src=\"%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425112210971.png\" alt=\"image-20220425112210971\"  />\n\n<p>所有的类都实现了<code>Message</code>类,它的主要内容如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     *&#x2F;\n    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;\n        return messageClasses.get(messageType);\n    &#125;\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage &#x3D; 0;\n    public static final int LoginResponseMessage &#x3D; 1;\n    public static final int ChatRequestMessage &#x3D; 2;\n    public static final int ChatResponseMessage &#x3D; 3;\n    public static final int GroupCreateRequestMessage &#x3D; 4;\n    public static final int GroupCreateResponseMessage &#x3D; 5;\n    public static final int GroupJoinRequestMessage &#x3D; 6;\n    public static final int GroupJoinResponseMessage &#x3D; 7;\n    public static final int GroupQuitRequestMessage &#x3D; 8;\n    public static final int GroupQuitResponseMessage &#x3D; 9;\n    public static final int GroupChatRequestMessage &#x3D; 10;\n    public static final int GroupChatResponseMessage &#x3D; 11;\n    public static final int GroupMembersRequestMessage &#x3D; 12;\n    public static final int GroupMembersResponseMessage &#x3D; 13;\n    public static final int PingMessage &#x3D; 14;\n    public static final int PongMessage &#x3D; 15;\n    &#x2F;**\n     * 请求类型 byte 值\n     *&#x2F;\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    &#x2F;**\n     * 响应类型 byte 值\n     *&#x2F;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        messageClasses.put(LoginRequestMessage, cn.message.LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, cn.message.LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, cn.message.ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, cn.message.ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, cn.message.GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, cn.message.GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, cn.message.GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, cn.message.GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, cn.message.GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, cn.message.GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, cn.message.GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, cn.message.GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, cn.message.GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, cn.message.GroupMembersResponseMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;</code></pre>\n\n\n\n<h2 id=\"3-创建会话管理类\"><a href=\"#3-创建会话管理类\" class=\"headerlink\" title=\"3. 创建会话管理类\"></a>3. 创建会话管理类</h2><p>会话Session相关类的作用是:</p>\n<ul>\n<li><code>Session</code> 维护 channel 和 用户之间的关系。</li>\n<li><code>GroupSession</code>维护聊天室和成员的关系信息</li>\n</ul>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425170611799.png\" class=\"\" title=\"image-20220425170611799\">\n\n<p>他们都通过工厂模式实现,可以他们的接口定义如下:</p>\n<p><code>Session</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 会话管理接口\n *&#x2F;\npublic interface Session &#123;\n\n    &#x2F;**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     *&#x2F;\n    void bind(Channel channel, String username);\n\n    &#x2F;**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     *&#x2F;\n    void unbind(Channel channel);\n\n    &#x2F;**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     *&#x2F;\n    Object getAttribute(Channel channel, String name);\n\n    &#x2F;**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     *&#x2F;\n    void setAttribute(Channel channel, String name, Object value);\n\n    &#x2F;**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     *&#x2F;\n    Channel getChannel(String username);\n&#125;\n</code></pre>\n\n<p><code>GroupSession</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface GroupSession &#123;\n    &#x2F;**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     *&#x2F;\n    Group createGroup(String name, Set&lt;String&gt; members);\n    &#x2F;**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group joinMember(String name, String member);\n    &#x2F;**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeMember(String name, String member);\n    &#x2F;**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeGroup(String name);\n    &#x2F;**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 如果群不存在或没有成员会返回 empty set\n     *&#x2F;\n    Set&lt;String&gt; getMembers(String name);\n    &#x2F;**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     *&#x2F;\n    List&lt;Channel&gt; getMembersChannel(String name);\n&#125;\n</code></pre>\n\n\n\n<p>个人聊天建立的时候，会执行如下代码保存会话信息：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SessionFactory.getSession().bind(ctx.channel(), username);</code></pre>\n\n<p>聊天室建立的时候,会执行如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">GroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();\nGroup group &#x3D; groupSession.createGroup(groupName, members);\nif (group &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 发送拉群消息\n    List&lt;Channel&gt; channels &#x3D; groupSession.getMembersChannel(groupName);\n    &#x2F;&#x2F;---\n&#125;</code></pre>\n\n\n\n<p>本地存储用户的信息,也可以通过数据库实现</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425195209747.png\" class=\"\" title=\"image-20220425195209747\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 用户管理接口\n *&#x2F;\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     *&#x2F;\n    boolean login(String username, String password);\n&#125;</code></pre>\n\n<p><code>UserServiceMemoryImpl</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class UserServiceMemoryImpl implements UserService &#123;\n    private Map&lt;String, String&gt; allUserMap &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    &#123;\n        allUserMap.put(&quot;zhangsan&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;lisi&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;wangwu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;zhaoliu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;qianqi&quot;, &quot;123&quot;);\n    &#125;\n\n    @Override\n    public boolean login(String username, String password) &#123;\n        String pass &#x3D; allUserMap.get(username);\n        if (pass &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n        return pass.equals(password);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n\n\n\n\n\n\n<h2 id=\"4-创建应用层传输的协议\"><a href=\"#4-创建应用层传输的协议\" class=\"headerlink\" title=\"4. 创建应用层传输的协议\"></a>4. 创建应用层传输的协议</h2><p>规定应用层报文的格式,他们是对消息进行编解码的。</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/image-20220425112509531.png\" class=\"\" title=\"image-20220425112509531\">\n\n<p><code>MessageCodecSharable</code>来解决编解码问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 设置魔数 4个字节\n        out.writeBytes(new byte[]&#123;&#39;N&#39;, &#39;Y&#39;, &#39;I&#39;, &#39;M&#39;&#125;);\n        &#x2F;&#x2F; 设置版本号 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置序列化方式 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置指令类型 1个字节\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 设置请求序号 4个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 获得序列化后的msg\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; 获取魔数\n        int magic &#x3D; in.readInt();\n        &#x2F;&#x2F; 获取版本号\n        byte version &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得序列化方式\n        byte seqType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得指令类型\n        byte messageType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得请求序号\n        int sequenceId &#x3D; in.readInt();\n        &#x2F;&#x2F; 移除补齐字节\n        in.readByte();\n        &#x2F;&#x2F; 获得正文长度\n        int length &#x3D; in.readInt();\n        &#x2F;&#x2F; 获得正文\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        &#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n        &#x2F;&#x2F; 打印获得的信息正文\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(magic);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(version);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(seqType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(messageType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(sequenceId);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(length);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(message);\n    &#125;\n&#125;</code></pre>\n\n<p><code>ProcotolFrameDecoder</code>解决黏包半包问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ProcotolFrameDecoder extends LengthFieldBasedFrameDecoder &#123;\n    public ProcotolFrameDecoder() &#123;\n        this(1024, 12, 4, 0, 0);\n    &#125;\n    public ProcotolFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) &#123;\n        super(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"5-创建客户端代码\"><a href=\"#5-创建客户端代码\" class=\"headerlink\" title=\"5. 创建客户端代码\"></a>5. 创建客户端代码</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\npublic class ChatClient &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN &#x3D; new CountDownLatch(1);\n        AtomicBoolean LOGIN &#x3D; new AtomicBoolean(false);\n        AtomicBoolean EXIT &#x3D; new AtomicBoolean(false);\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.group(group);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    &#x2F;&#x2F; 心跳机制\n                    ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n                    ch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n                        @Override\n                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n                            IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n                            if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n                                &#x2F;&#x2F; 发送心跳包\n                                ctx.writeAndFlush(new PingMessage());\n                            &#125;\n                        &#125;\n                    &#125;);\n                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                        &#x2F;&#x2F; 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n&#x2F;&#x2F;                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);\n                            if ((msg instanceof LoginResponseMessage)) &#123;\n                                LoginResponseMessage response &#x3D; (LoginResponseMessage) msg;\n                                if (response.isSuccess()) &#123;\n                                    &#x2F;&#x2F; 如果登录成功\n                                    LOGIN.set(true);\n                                &#125;\n                                &#x2F;&#x2F; 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            &#125;\n                            System.out.println(msg);\n                        &#125;\n\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            new Thread(() -&gt; &#123;\n                                System.out.println(&quot;请输入用户名:&quot;);\n                                Scanner scanner &#x3D; new Scanner(System.in);\n                                String username &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                System.out.println(&quot;请输入密码:&quot;);\n                                String password &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                &#x2F;&#x2F; 构造消息对象\n                                LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);\n                                System.out.println(message);\n                                &#x2F;&#x2F; 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(&quot;等待后续操作...&quot;);\n                                try &#123;\n                                    WAIT_FOR_LOGIN.await();\n                                &#125; catch (InterruptedException e) &#123;\n                                    e.printStackTrace();\n                                &#125;\n                                &#x2F;&#x2F; 如果登录失败\n                                if (!LOGIN.get()) &#123;\n                                    ctx.channel().close();\n                                    return;\n                                &#125;\n                                while (true) &#123;\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    System.out.println(&quot;send [username] [content]&quot;);\n                                    System.out.println(&quot;gsend [group name] [content]&quot;);\n                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);\n                                    System.out.println(&quot;gmembers [group name]&quot;);\n                                    System.out.println(&quot;gjoin [group name]&quot;);\n                                    System.out.println(&quot;gquit [group name]&quot;);\n                                    System.out.println(&quot;quit&quot;);\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    String command &#x3D; null;\n                                    try &#123;\n                                        command &#x3D; scanner.nextLine();\n                                    &#125; catch (Exception e) &#123;\n                                        break;\n                                    &#125;\n                                    if (EXIT.get()) &#123;\n                                        return;\n                                    &#125;\n                                    String[] s &#x3D; command.split(&quot; &quot;);\n                                    switch (s[0]) &#123;\n                                        case &quot;send&quot;:\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gsend&quot;:\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gcreate&quot;:\n                                            Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));\n                                            set.add(username); &#x2F;&#x2F; 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case &quot;gmembers&quot;:\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case &quot;gjoin&quot;:\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;gquit&quot;:\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;quit&quot;:\n                                            ctx.channel().close();\n                                            return;\n                                    &#125;\n                                &#125;\n                            &#125;, &quot;System in&quot;).start();\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"6-创建服务器代码\"><a href=\"#6-创建服务器代码\" class=\"headerlink\" title=\"6. 创建服务器代码\"></a>6. 创建服务器代码</h2><p>服务器端代码,逻辑很简单,但是重点对于各个<code>Handler</code>的封装,然后依次加入<code>SocketChannel</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ch.pipeline().addLast(new ProcotolFrameDecoder());\nch.pipeline().addLast(loggingHandler);\nch.pipeline().addLast(messageSharableCodec);\nch.pipeline().addLast(loginRequestMessageHandler);\nch.pipeline().addLast(chatRequestMessageHandler);\nch.pipeline().addLast(groupCreateRequestMessageHandler);\nch.pipeline().addLast(groupJoinRequestMessageHandler);\nch.pipeline().addLast(groupMembersRequestMessageHandler);\nch.pipeline().addLast(groupQuitRequestMessageHandler);\nch.pipeline().addLast(groupChatRequestMessageHandler);\nch.pipeline().addLast(quitHandler);</code></pre>\n\n<p>每个<code>Handler</code>是对客户端发过来不同类型的消息进行处理,按照消息类型的不同,封装成不同的<code>Handler</code>,下面以一个<code>loginRequestMessageHandler</code>为例来介绍具体代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@ChannelHandler.Sharable &#x2F;&#x2F; 设置成Sharable 可以公用一个处理器\n&#x2F;&#x2F; 继承SimpleChannelInboundHandler,注意针对的数据类型LoginRequestMessage\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n        String username &#x3D; msg.getUsername();\n        String password &#x3D; msg.getPassword();\n        boolean login &#x3D; UserServiceFactory.getUserService().login(username,\n                password);\n        LoginResponseMessage message;\n        if (login) &#123;\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);\n        &#125; else &#123;\n            message &#x3D; new LoginResponseMessage(false, &quot;登录失败&quot;);\n        &#125;\n        &#x2F;&#x2F; 消息传回客户端\n        ctx.writeAndFlush(message);\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>完整代码如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ChatServer &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();\n        ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();\n        GroupCreateRequestMessageHandler groupCreateRequestMessageHandler &#x3D; new GroupCreateRequestMessageHandler();\n        GroupJoinRequestMessageHandler groupJoinRequestMessageHandler &#x3D; new GroupJoinRequestMessageHandler();\n        GroupMembersRequestMessageHandler groupMembersRequestMessageHandler &#x3D; new GroupMembersRequestMessageHandler();\n        GroupQuitRequestMessageHandler groupQuitRequestMessageHandler &#x3D; new GroupQuitRequestMessageHandler();\n        GroupChatRequestMessageHandler groupChatRequestMessageHandler &#x3D; new GroupChatRequestMessageHandler();\n        QuitHandler quitHandler &#x3D; new QuitHandler();\n        try &#123;\n            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();\n            bootstrap.group(boss, worker);\n            bootstrap.channel(NioServerSocketChannel.class);\n            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    &#x2F;&#x2F; 判断是不是读写时间过长\n                    &#x2F;&#x2F; 5s内如果没有收到Channel的数据,会触发事件IdleStateEvent\n                    ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n                    ch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n                        &#x2F;&#x2F; 用来处理特殊事件\n                        @Override\n                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n                            IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n                            &#x2F;&#x2F; 如果触发了读空闲事件\n                            if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE)&#123;\n                                System.out.println(&quot;已经5s没有读到数据了&quot;);\n                            &#125;\n&#x2F;&#x2F;                            super.userEventTriggered(ctx, evt);\n                        &#125;\n                    &#125;);\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(loginRequestMessageHandler);\n                    ch.pipeline().addLast(chatRequestMessageHandler);\n                    ch.pipeline().addLast(groupCreateRequestMessageHandler);\n                    ch.pipeline().addLast(groupJoinRequestMessageHandler);\n                    ch.pipeline().addLast(groupMembersRequestMessageHandler);\n                    ch.pipeline().addLast(groupQuitRequestMessageHandler);\n                    ch.pipeline().addLast(groupChatRequestMessageHandler);\n                    ch.pipeline().addLast(quitHandler);\n\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"7-添加心跳机制\"><a href=\"#7-添加心跳机制\" class=\"headerlink\" title=\"7. 添加心跳机制\"></a>7. 添加心跳机制</h2><h3 id=\"a-连接假死原因\"><a href=\"#a-连接假死原因\" class=\"headerlink\" title=\"a. 连接假死原因\"></a>a. <strong>连接假死原因</strong></h3><ul>\n<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，<strong>但应用程序没有感知到</strong>，仍然占用着资源</li>\n<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源</li>\n<li>应用程序线程阻塞，无法进行数据读写</li>\n</ul>\n<p><strong>问题</strong></p>\n<ul>\n<li>假死的连接占用的资源不能自动释放</li>\n<li>向假死的连接发送数据，得到的反馈是发送超时</li>\n</ul>\n<h3 id=\"b-解决方法\"><a href=\"#b-解决方法\" class=\"headerlink\" title=\"b. 解决方法\"></a>b. 解决方法</h3><p>可以添加<code>IdleStateHandler</code>对空闲时间进行检测，通过构造函数可以传入三个参数</p>\n<ul>\n<li><code>readerIdleTimeSeconds</code> 读空闲经过的秒数</li>\n<li><code>writerIdleTimeSeconds</code> 写空闲经过的秒数</li>\n<li><code>allIdleTimeSeconds</code> 读和写空闲经过的秒数</li>\n</ul>\n<p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/20210428132848.png\" class=\"\" title=\"img\">\n\n<ul>\n<li>读空闲会触发<code>READER_IDLE</code></li>\n<li>写空闲会触发<code>WRITE_IDLE</code></li>\n<li>读和写空闲会触发<code>ALL_IDEL</code></li>\n</ul>\n<p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 判断是不是读写时间过长\n&#x2F;&#x2F; 5s内如果没有收到Channel的数据,会触发事件IdleStateEvent\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来处理特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 如果触发了读空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE)&#123;\n            System.out.println(&quot;已经5s没有读到数据了&quot;);\n        &#125;\n  \t\t&#x2F;&#x2F;super.userEventTriggered(ctx, evt);\n    &#125;\n&#125;);</code></pre>\n\n<h3 id=\"c-心跳机制\"><a href=\"#c-心跳机制\" class=\"headerlink\" title=\"c. 心跳机制\"></a>c. 心跳机制</h3><p>为<strong>避免因非网络等原因引发的READ_IDLE事件</strong>，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，<strong>直接让服务器断开连接是不可取的</strong></p>\n<p>为避免此类情况，需要在<strong>客户端向服务器发送心跳包</strong>，发送频率要<strong>小于</strong>服务器设置的<code>IdleTimeSeconds</code>，一般设置为其值的一半</p>\n<p><strong>客户端代码</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 发送心跳包，让服务器知道客户端在线\n&#x2F;&#x2F; 3s未发生WRITER_IDLE，就像服务器发送心跳包\n&#x2F;&#x2F; 该值为服务器端设置的READER_IDLE触发时间的一半左右\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n            &#x2F;&#x2F; 发送心跳包\n            ctx.writeAndFlush(new PingMessage());\n        &#125;\n    &#125;\n&#125;);</code></pre>\n\n<h2 id=\"8-序列化\"><a href=\"#8-序列化\" class=\"headerlink\" title=\"8. 序列化\"></a>8. 序列化</h2><h3 id=\"a-定义序列化接口\"><a href=\"#a-定义序列化接口\" class=\"headerlink\" title=\"a. 定义序列化接口\"></a>a. 定义序列化接口</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Serializer &#123;\n    &#x2F;**\n     * 序列化\n     * @param object 被序列化的对象\n     * @param &lt;T&gt; 被序列化对象类型\n     * @return 序列化后的字节数组\n     *&#x2F;\n    &lt;T&gt; byte[] serialize(T object);\n\n    &#x2F;**\n     * 反序列化\n     * @param clazz 反序列化的目标类的Class对象\n     * @param bytes 被反序列化的字节数组\n     * @param &lt;T&gt; 反序列化目标类\n     * @return 反序列化后的对象\n     *&#x2F;\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n&#125;</code></pre>\n\n<h3 id=\"b-枚举实现类\"><a href=\"#b-枚举实现类\" class=\"headerlink\" title=\"b. 枚举实现类\"></a>b. 枚举实现类</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public enum SerializerAlgorithm implements Serializer &#123;\n    &#x2F;&#x2F; Java的序列化和反序列化\n    Java &#123;\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            &#x2F;&#x2F; 序列化后的字节数组\n            byte[] bytes &#x3D; null;\n            try (ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                 ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos)) &#123;\n                oos.writeObject(object);\n                bytes &#x3D; bos.toByteArray();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            return bytes;\n        &#125;\n\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            T target &#x3D; null;\n            System.out.println(Arrays.toString(bytes));\n            try (ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);\n                 ObjectInputStream ois &#x3D; new ObjectInputStream(bis)) &#123;\n                target &#x3D; (T) ois.readObject();\n            &#125; catch (IOException | ClassNotFoundException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 返回反序列化后的对象\n            return target;\n        &#125;\n    &#125;\n    \n     &#x2F;&#x2F; Json的序列化和反序列化\n    Json &#123;\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            String s &#x3D; new Gson().toJson(object);\n            System.out.println(s);\n            &#x2F;&#x2F; 指定字符集，获得字节数组\n            return s.getBytes(StandardCharsets.UTF_8);\n        &#125;\n\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            String s &#x3D; new String(bytes, StandardCharsets.UTF_8);\n            System.out.println(s);\n            &#x2F;&#x2F; 此处的clazz为具体类型的Class对象，而不是父类Message的\n            return new Gson().fromJson(s, clazz);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"c-调用自定义的序列化算法\"><a href=\"#c-调用自定义的序列化算法\" class=\"headerlink\" title=\"c. 调用自定义的序列化算法\"></a>c. 调用自定义的序列化算法</h3><p><code>MessageCodecSharable</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; 获得序列化后的msg\n        byte[] bytes &#x3D; Serializer.Algorithm.Java.serializer(msg);\n\n&#x2F;&#x2F;        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n&#x2F;&#x2F;        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n&#x2F;&#x2F;        oos.writeObject(msg);\n&#x2F;&#x2F;        byte[] bytes &#x3D; bos.toByteArray();\n\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; ...\n        Message message &#x3D; Serializer.Algorithm.Java.deserialize(Message.class, bytes);\n&#x2F;&#x2F;        byte[] bytes &#x3D; new byte[length];\n&#x2F;&#x2F;        in.readBytes(bytes, 0, length);\n&#x2F;&#x2F;        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n&#x2F;&#x2F;        Message message &#x3D; (Message) ois.readObject();\n        &#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n\n\n    &#125;</code></pre>\n\n\n\n<h2 id=\"9-参数优化\"><a href=\"#9-参数优化\" class=\"headerlink\" title=\"9. 参数优化\"></a>9. 参数优化</h2><h3 id=\"a-连接超时优化\"><a href=\"#a-连接超时优化\" class=\"headerlink\" title=\"a. 连接超时优化\"></a>a. 连接超时优化</h3><p><code>CONNECT_TIMEOUT_MILLIS</code></p>\n<ul>\n<li>属于 <strong>SocketChannal</strong> 的参数</li>\n<li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li>\n<li><strong>注意</strong>：Netty 中不要用成了<code>SO_TIMEOUT</code> 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class TestParam &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常\n        new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n        \n        &#x2F;&#x2F; ServerSocketChannel 5s内未建立连接就抛出异常\n        new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);\n        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常\n        new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n    &#125;\n&#125;\\</code></pre>\n\n<ul>\n<li>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></li>\n<li>服务器通过<code>ServerBootstrap</code>来配置参数，但是对于不同的 Channel 需要选择不同的方法<ul>\n<li>通过 <code>option</code> 来配置 <code>ServerSocketChannel</code> 上的参数</li>\n<li>通过 <code>childOption</code> 来配置 <code>SocketChannel</code> 上的参数</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p>\n<p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void connect(\n                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    \n    ...\n        \n    &#x2F;&#x2F; Schedule connect timeout.\n    &#x2F;&#x2F; 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置\n    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();\n    &#x2F;&#x2F; 如果超时时间大于0\n    if (connectTimeoutMillis &gt; 0) &#123;\n        &#x2F;&#x2F; 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行\n        &#x2F;&#x2F; schedule(Runnable command, long delay, TimeUnit unit)\n        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                &#x2F;&#x2F; 判断是否建立连接，Promise进行NIO线程与主线程之间的通信\n                &#x2F;&#x2F; 如果超时，则通过tryFailure方法将异常放入Promise中\n                &#x2F;&#x2F; 在主线程中抛出\n                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause &#x3D; new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);\n                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;\n                    close(voidPromise());\n                &#125;\n            &#125;\n        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    &#125;\n    \n   \t...\n        \n&#125;</code></pre>\n\n<p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p>\n<ul>\n<li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li>\n<li>如果指定时间内没有建立连接，则会执行其中的任务<ul>\n<li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"b-SO-BACKLOG\"><a href=\"#b-SO-BACKLOG\" class=\"headerlink\" title=\"b.SO_BACKLOG\"></a>b.SO_BACKLOG</h3><p>该参数是 <code>ServerSocketChannel</code> 的参数</p>\n<h4 id=\"三次握手与连接队列\"><a href=\"#三次握手与连接队列\" class=\"headerlink\" title=\"三次握手与连接队列\"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/20210429211913.png\" class=\"\" title=\"img\">\n\n<p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/20210429211952.png\" class=\"\" title=\"img\">\n\n<p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p>\n<img src=\"/post/%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%95%99%E7%A8%8B/20210430094836.png\" class=\"\" title=\"img\">\n\n<p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p>\n<ul>\n<li>半连接队列 - <code>sync queue</code><ul>\n<li>大小通过 <code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code> 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>\n</ul>\n</li>\n<li>全连接队列 - <code>accept queue</code><ul>\n<li>其大小通过 <code>/proc/sys/net/core/somaxconn</code> 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li>\n<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p>\n<p><strong>设置方式如下</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 设置全连接队列，大小为2\nnew ServerBootstrap().option(ChannelOption.SO_BACKLOG, 2);</code></pre>\n\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Override\nprotected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        javaChannel().bind(localAddress, config.getBacklog());\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125;</code></pre>\n\n<p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private volatile int backlog &#x3D; NetUtil.SOMAXCONN;</code></pre>\n\n<p>具体的赋值操作如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;\n    @Override\n    public Integer run() &#123;\n        &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.\n        &#x2F;&#x2F; The known defaults:\n        &#x2F;&#x2F; - Windows NT Server 4.0+: 200\n        &#x2F;&#x2F; - Linux and Mac OS X: 128\n        int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;\n        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);\n        BufferedReader in &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n            &#x2F;&#x2F; try &#x2F; catch block.\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936\n            if (file.exists()) &#123;\n                in &#x3D; new BufferedReader(new FileReader(file));\n                &#x2F;&#x2F; 将somaxconn设置为Linux配置文件中设置的值\n                somaxconn &#x3D; Integer.parseInt(in.readLine());\n                if (logger.isDebugEnabled()) &#123;\n                    logger.debug(&quot;&#123;&#125;: &#123;&#125;&quot;, file, somaxconn);\n                &#125;\n            &#125; else &#123;\n                ...\n            &#125;\n            ...\n        &#125;  \n        &#x2F;&#x2F; 返回backlog的值\n        return somaxconn;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li><p>backlog的值会根据操作系统的不同，来</p>\n<p>选择不同的默认值</p>\n<ul>\n<li>Windows 200</li>\n<li>Linux&#x2F;Mac OS 128</li>\n</ul>\n</li>\n<li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p>\n</li>\n</ul>\n<h3 id=\"c-TCP-NODELAY\"><a href=\"#c-TCP-NODELAY\" class=\"headerlink\" title=\"c. TCP_NODELAY\"></a>c. TCP_NODELAY</h3><ul>\n<li>属于 <strong>SocketChannal</strong> 参数</li>\n<li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li>\n<li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li>\n</ul>\n<h3 id=\"d-SO-SNDBUF-amp-SO-RCVBUF\"><a href=\"#d-SO-SNDBUF-amp-SO-RCVBUF\" class=\"headerlink\" title=\"d. SO_SNDBUF &amp; SO_RCVBUF\"></a>d. SO_SNDBUF &amp; SO_RCVBUF</h3><ul>\n<li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li>\n<li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li>\n<li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li>\n</ul>\n<h3 id=\"e-ALLOCATOR\"><a href=\"#e-ALLOCATOR\" class=\"headerlink\" title=\"e. ALLOCATOR\"></a>e. ALLOCATOR</h3><ul>\n<li>属于 <strong>SocketChannal</strong> 参数</li>\n<li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li>\n</ul>\n<h4 id=\"1-使用\"><a href=\"#1-使用\" class=\"headerlink\" title=\"1. 使用\"></a>1. 使用</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型\n&#x2F;&#x2F; 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型\nnew ServerBootstrap().childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator());</code></pre>\n\n<p><strong>ByteBufAllocator类型</strong></p>\n<ul>\n<li><p>池化并使用直接内存</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; true表示使用直接内存\nnew PooledByteBufAllocator(true);</code></pre>\n</li>\n<li><p>池化并使用堆内存</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; false表示使用堆内存\nnew PooledByteBufAllocator(false);</code></pre>\n</li>\n<li><p>非池化并使用直接内存</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; ture表示使用直接内存\nnew UnpooledByteBufAllocator(true);</code></pre>\n</li>\n<li><p>非池化并使用堆内存</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; false表示使用堆内存\nnew UnpooledByteBufAllocator(false);</code></pre></li>\n</ul>\n<h3 id=\"f-RCVBUF-ALLOCATOR\"><a href=\"#f-RCVBUF-ALLOCATOR\" class=\"headerlink\" title=\"f. RCVBUF_ALLOCATOR\"></a>f. RCVBUF_ALLOCATOR</h3><ul>\n<li>属于 <strong>SocketChannal</strong> 参数</li>\n<li><strong>控制 Netty 接收缓冲区大小</strong></li>\n<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li>\n</ul>\n","feature":true,"text":"博文主要介绍后端的核心内容 视频教训参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. 环境搭建本项目的后端使用Maven构建，主要的依赖如下: &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UT...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"36 mins."},"categories":[{"name":"项目","slug":"项目","count":1,"path":"api/categories/项目.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"},{"name":"Spring Boot","slug":"Spring-Boot","count":1,"path":"api/tags/Spring-Boot.json"},{"name":"Maven","slug":"Maven","count":1,"path":"api/tags/Maven.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">1. 环境搭建</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%88%9B%E5%BB%BA%E8%81%8A%E5%A4%A9%E4%BC%A0%E9%80%81%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB\"><span class=\"toc-text\">2. 创建聊天传送的消息类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E7%B1%BB\"><span class=\"toc-text\">3. 创建会话管理类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%88%9B%E5%BB%BA%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">4. 创建应用层传输的协议</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%88%9B%E5%BB%BA%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">5. 创建客户端代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">6. 创建服务器代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E6%B7%BB%E5%8A%A0%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">7. 添加心跳机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E8%BF%9E%E6%8E%A5%E5%81%87%E6%AD%BB%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">a. 连接假死原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">b. 解决方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">c. 心跳机制</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%BA%8F%E5%88%97%E5%8C%96\"><span class=\"toc-text\">8. 序列化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">a. 定义序列化接口</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E7%B1%BB\"><span class=\"toc-text\">b. 枚举实现类</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E8%B0%83%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">c. 调用自定义的序列化算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#9-%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">9. 参数优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E8%BF%9E%E6%8E%A5%E8%B6%85%E6%97%B6%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">a. 连接超时优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90\"><span class=\"toc-text\">源码分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-SO-BACKLOG\"><span class=\"toc-text\">b.SO_BACKLOG</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97\"><span class=\"toc-text\">三次握手与连接队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">作用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E5%80%BC\"><span class=\"toc-text\">默认值</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-TCP-NODELAY\"><span class=\"toc-text\">c. TCP_NODELAY</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-SO-SNDBUF-amp-SO-RCVBUF\"><span class=\"toc-text\">d. SO_SNDBUF &amp; SO_RCVBUF</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-ALLOCATOR\"><span class=\"toc-text\">e. ALLOCATOR</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1. 使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#f-RCVBUF-ALLOCATOR\"><span class=\"toc-text\">f. RCVBUF_ALLOCATOR</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Netty","uid":"46d3e14db35995d713fed042cf2dff6b","slug":"Netty","date":"2022-04-12T02:52:09.000Z","updated":"2022-04-22T06:52:47.865Z","comments":true,"path":"api/articles/Netty.json","keywords":null,"cover":[],"text":"视频教程参考 黑马程序员Netty全套教程 博客参考了 Nyima 1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of ma...","link":"","photos":[],"count_time":{"symbolsCount":"82k","symbolsTime":"1:15"},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Netty","slug":"Netty","count":2,"path":"api/tags/Netty.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"常用命令","uid":"a5f30086118eef4097b37f892ce916b2","slug":"常用命令","date":"2022-04-11T13:18:09.000Z","updated":"2022-04-11T13:21:13.824Z","comments":true,"path":"api/articles/常用命令.json","keywords":null,"cover":null,"text":"Dockerdocker search [镜像名称] # 搜索镜像 docker pull [镜像名称[:版本号]] # 拉取镜像 docker images # 查看本地镜像 docker exec -it [redis] bash # 以命令行形式进入容器内部 docker ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"常用命令","slug":"常用命令","count":1,"path":"api/categories/常用命令.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"},{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}