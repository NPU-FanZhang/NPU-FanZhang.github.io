{"title":"LeetCode-剑指Offer篇","uid":"aad8a83fde81c29db907afa89d192a10","slug":"LeetCode-剑指Offer篇","date":"2022-04-08T08:41:11.000Z","updated":"2022-04-08T08:45:52.702Z","comments":true,"path":"api/articles/LeetCode-剑指Offer篇.json","keywords":null,"cover":[],"content":"<h1 id=\"剑指-Offer\"><a href=\"#剑指-Offer\" class=\"headerlink\" title=\"剑指 Offer\"></a>剑指 Offer</h1><h2 id=\"剑指-Offer-II-4-只出现一次的数字\"><a href=\"#剑指-Offer-II-4-只出现一次的数字\" class=\"headerlink\" title=\"剑指 Offer II 4. 只出现一次的数字 \"></a><a href=\"https://leetcode-cn.com/problems/WGki4K/\">剑指 Offer II 4. 只出现一次的数字 </a></h2><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 <strong>三次 。</strong>请你找出并返回那个只出现了一次的元素。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [0,1,0,1,0,1,100]\n输出：100</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li><p>状态机 不会。</p>\n</li>\n<li><p>位运算</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/1629341475-GhErJW-image.png\" alt=\"image.png\" style=\"zoom:50%;\" /></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int singleNumber(int[] nums) &#123;\n       int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n            int cnt &#x3D; 0;\n            for (int j &#x3D; 0; j &lt; nums.length; j++) &#123;\n                &#x2F;&#x2F;计算每一位和\n                cnt +&#x3D; (nums[j] &gt;&gt; i) &amp; 1;\n            &#125;\n            if (cnt % 3 !&#x3D; 0) &#123;\n                &#x2F;&#x2F;取余后只有 0 1 两种情况\n                &#x2F;&#x2F;边保存边左移。\n                ans &#x3D; ans | 1 &lt;&lt; i;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-14-剪绳子-II\"><a href=\"#剑指-Offer-II-14-剪绳子-II\" class=\"headerlink\" title=\"剑指 Offer II 14. 剪绳子 II\"></a><a href=\"https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/\">剑指 Offer II 14. 剪绳子 II</a></h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36\n2 &lt;&#x3D; n &lt;&#x3D; 1000</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>基本不等式+快速幂</p>\n<p>大数求余解法：<br>大数越界： 当 a 增大时，最后返回的 $3^a$大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。<br>大数求余问题： 在仅使用 int32 类型存储的前提下，正确计算 $x^a$ 对 p 求余（即 $x^a \\odot p$）的值。解决方案： 循环求余 、 快速幂求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：$(xy) \\odot p &#x3D; [(x \\odot p)(y \\odot p)] \\odot p<br>(xy)⊙p&#x3D;[(x⊙p)(y⊙p)]⊙p$</p>\n<ul>\n<li><p>循环求余 可通过循环操作依次求 $x^1, x^2, …, x^{a-1}, x^a$  对 p 的余数，保证每轮中间值 rem 都在 int32 取值范围中。</p>\n</li>\n<li><p>快速幂求余</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 求 (x^a) % p —— 快速幂求余\n   public long remainder(long num, int quotient, int MOD) &#123;\n       long rem &#x3D; 1;\n       while (quotient &gt; 0) &#123;\n           if ((quotient &amp; 1) &#x3D;&#x3D; 1) &#123;\n               rem *&#x3D;  num;\n               rem %&#x3D; MOD;\n           &#125;\n           num *&#x3D; num;\n           num %&#x3D; MOD;\n           quotient &gt;&gt;&#x3D; 1;\n       &#125;\n       return rem;\n   &#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int cuttingRope(int n) &#123;\n        final int MOD &#x3D; 1000000007;\n        int ans &#x3D; 0;\n        if (n &lt;&#x3D; 3) &#123;\n            return n-1;\n        &#125;\n        int residue &#x3D; n % 3;\n        int quotient &#x3D; n &#x2F; 3;\n        if (residue &#x3D;&#x3D; 0) &#123;\n            ans &#x3D; (int)remainder(3, quotient, MOD) % MOD;\n        &#125; else if (residue &#x3D;&#x3D; 1) &#123;\n            ans &#x3D; (int)((remainder(3, quotient - 1, MOD) * 4) % MOD);\n        &#125; else &#123;\n            ans &#x3D; (int)(remainder(3, quotient, MOD) * 2) % MOD;\n        &#125;\n        return ans;\n    &#125;\n    &#x2F;&#x2F; 求 (x^a) % p —— 快速幂求余\n    public long remainder(long num, int quotient, int MOD) &#123;\n        long rem &#x3D; 1;\n        while (quotient &gt; 0) &#123;\n            if ((quotient &amp; 1) &#x3D;&#x3D; 1) &#123;\n                rem *&#x3D;  num;\n                rem %&#x3D; MOD;\n            &#125;\n            num *&#x3D; num;\n            num %&#x3D; MOD;\n            quotient &gt;&gt;&#x3D; 1;\n        &#125;\n        return rem;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-15-字符串中的所有变位词\"><a href=\"#剑指-Offer-II-15-字符串中的所有变位词\" class=\"headerlink\" title=\"剑指 Offer II 15. 字符串中的所有变位词\"></a><a href=\"https://leetcode-cn.com/problems/VabMRr/\">剑指 Offer II 15. 字符串中的所有变位词</a></h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<p>变位词 指字母相同，但排列不同的字符串。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;\n输出: [0,1,2]\n解释:\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>滑动窗口来统计两个字符串中字符出现的次数，进行对比，当<code>都为 0 且长度相等</code>时就是变位词。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;\n        int N &#x3D; s.length();\n        int M &#x3D; p.length();\n        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        if (M &gt; N) &#123;\n            return list;\n        &#125;\n        int[] pCnt &#x3D; new int[26];\n        int[] sCnt &#x3D; new int[26];\n        for (char ch : p.toCharArray()) &#123;\n            pCnt[ch - &#39;a&#39;]++;\n        &#125;\n        int left &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            int x &#x3D; s.charAt(i) - &#39;a&#39;;\n            sCnt[x]++;\n            while (sCnt[x] &gt; pCnt[x]) &#123;\n                int l &#x3D; s.charAt(left) - &#39;a&#39;;\n                sCnt[l]--;\n                left++;\n            &#125;\n            if(i - left + 1 &#x3D;&#x3D; M)&#123;\n                list.add(left);\n            &#125;\n        &#125;\n        return list;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"剑指-Offer-II-30-插入、删除和随机访问都是-O-1-的容器\"><a href=\"#剑指-Offer-II-30-插入、删除和随机访问都是-O-1-的容器\" class=\"headerlink\" title=\"剑指 Offer II 30. 插入、删除和随机访问都是 O(1) 的容器\"></a><a href=\"https://leetcode-cn.com/problems/FortPu/\">剑指 Offer II 30. 插入、删除和随机访问都是 O(1) 的容器</a></h2><p>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：</p>\n<p>insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。<br>remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。<br>getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 :\n输入: inputs &#x3D; [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n输出: [null, true, false, true, 2, true, false, 2]\n解释:\nRandomizedSet randomSet &#x3D; new RandomizedSet();  &#x2F;&#x2F; 初始化一个空的集合\nrandomSet.insert(1); &#x2F;&#x2F; 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\nrandomSet.remove(2); &#x2F;&#x2F; 返回 false，表示集合中不存在 2 \nrandomSet.insert(2); &#x2F;&#x2F; 向集合中插入 2 返回 true ，集合现在包含 [1,2] \nrandomSet.getRandom(); &#x2F;&#x2F; getRandom 应随机返回 1 或 2 \nrandomSet.remove(1); &#x2F;&#x2F; 从集合中移除 1 返回 true 。集合现在包含 [2] \nrandomSet.insert(2); &#x2F;&#x2F; 2 已在集合中，所以返回 false \nrandomSet.getRandom(); &#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>本来数组是最合适的，随机按值访问采用hashMap保存&lt;值,小标&gt;下标，但是有删除操作，所以使用变长数组<code>ArrayList</code>。删除时用最后一个值替换，然后尾删。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class RandomizedSet &#123;\n    ArrayList&lt;Integer&gt; list;\n    HashMap&lt;Integer, Integer&gt; hashMap;\n    public RandomizedSet() &#123;\n        this.hashMap &#x3D; new HashMap&lt;&gt;();\n        this.list &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n    public boolean insert(int val) &#123;\n        if (hashMap.containsKey(val)) &#123;\n            return false;\n        &#125;\n        int idx &#x3D; list.size();\n        list.add(idx, val);\n        hashMap.put(val, idx);\n        return true;\n    &#125;\n    public boolean remove(int val) &#123;\n        if (hashMap.containsKey(val)) &#123;\n            int idx &#x3D; hashMap.get(val);\n            list.set(idx, list.get(list.size() - 1));\n            hashMap.replace(list.get(list.size()-1),idx);\n            list.remove(list.size() - 1);\n            hashMap.remove(val);\n            return true;\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n    public int getRandom() &#123;\n        Random rand &#x3D; new Random();\n        int random &#x3D; rand.nextInt(hashMap.size());\n        return list.get(random);\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-37-小行星碰撞\"><a href=\"#剑指-Offer-II-37-小行星碰撞\" class=\"headerlink\" title=\"剑指 Offer II 37. 小行星碰撞\"></a><a href=\"https://leetcode-cn.com/problems/XagZNi/\">剑指 Offer II 37. 小行星碰撞</a></h2><p>给定一个整数数组 asteroids，表示在同一行的小行星。</p>\n<p>对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。</p>\n<p>找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：asteroids &#x3D; [-2,-1,1,2]\n输出：[-2,-1,1,2]\n解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。</code></pre>\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：asteroids &#x3D; [5,10,-5]\n输出：[5,10]\n解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>栈。由于碰撞是单向的，所以使用栈可以很好的模拟。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[] asteroidCollision(int[] asteroids) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; asteroids.length; i++) &#123;\n            if (stack.empty()) &#123;\n                stack.push(asteroids[i]);\n                continue;\n            &#125;\n            int top &#x3D; stack.peek();\n            if ((top ^ asteroids[i]) &gt;&#x3D; 0 || (top &lt; 0 &amp;&amp; asteroids[i] &gt; 0)) &#123;\n                stack.push(asteroids[i]);\n                continue;\n            &#125;\n            boolean collision &#x3D; false;\n            while (!stack.empty() &amp;&amp; (top &gt; 0 &amp;&amp; asteroids[i] &lt; 0)) &#123;\n                if (Math.abs(top) &gt; Math.abs(asteroids[i])) &#123;\n                    collision &#x3D; true;\n                    break;\n                &#125; else if (Math.abs(top) &lt; Math.abs(asteroids[i])) &#123;\n                    stack.pop();\n                    collision &#x3D; false;\n                    if (stack.empty()) &#123;\n                        break;\n                    &#125;\n                    top &#x3D; stack.peek();\n                    continue;\n                &#125; else &#123;\n                    collision &#x3D; true;\n                    stack.pop();\n                    break;\n                &#125;\n            &#125;\n            if (!collision) &#123;\n                stack.push(asteroids[i]);\n            &#125;\n        &#125;\n        Iterator&lt;Integer&gt; it &#x3D; stack.iterator();\n        int[] ans &#x3D; new int[stack.size()];\n        int i &#x3D; 0;\n        while (it.hasNext()) &#123;\n            ans[i++] &#x3D; it.next();\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-39-直方图最大矩形面积\"><a href=\"#剑指-Offer-II-39-直方图最大矩形面积\" class=\"headerlink\" title=\"剑指 Offer II 39. 直方图最大矩形面积\"></a><a href=\"https://leetcode-cn.com/problems/0ynMMM/\">剑指 Offer II 39. 直方图最大矩形面积</a></h2><p>给定非负整数数组 heights ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/histogram.jpg\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：heights &#x3D; [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>单调栈。</p>\n<p>首先，要想找到第 i 位置最大面积是什么？</p>\n<p>是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示：</p>\n<p>所以，我们的问题就变成如何找 right_i 和 left_i ? </p>\n<p>最简单的思路就是，就是暴力法，直接分别在 i 左右移动。</p>\n</li>\n</ul>\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/441ac778821dc26689b31466bced9f61ec241f092bf7e4f0f8699ef4fa3be1b2-1559826097853.png\" class=\"\" title=\"1559826097853.png\">\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int largestRectangleArea(int[] heights) &#123;\n        int ans &#x3D; 0;\n        Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;&gt;();\n        int[] new_heights &#x3D; new int[heights.length + 2];\n        for (int i &#x3D; 1; i &lt; heights.length + 1; i++) new_heights[i] &#x3D; heights[i - 1];\n        for (int i &#x3D; 0; i &lt; new_heights.length; i++) &#123;\n            while (!stack.isEmpty() &amp;&amp; new_heights[stack.peek()] &gt; new_heights[i]) &#123;\n                int cur &#x3D; stack.pop();\n                ans &#x3D; Math.max(ans, (i - stack.peek()-1) * new_heights[cur]);\n            &#125;\n            stack.push(i);\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-40-矩阵中最大的矩形\"><a href=\"#剑指-Offer-II-40-矩阵中最大的矩形\" class=\"headerlink\" title=\"剑指 Offer II 40. 矩阵中最大的矩形\"></a><a href=\"https://leetcode-cn.com/problems/PLYXKQ/\">剑指 Offer II 40. 矩阵中最大的矩形</a></h2><p>给定一个由 <code>0</code> 和 <code>1</code> 组成的矩阵 <code>matrix</code> ，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>\n<p><strong>注意：</strong>此题 <code>matrix</code> 输入格式为一维 <code>01</code> 字符串数组。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：matrix &#x3D; [&quot;10100&quot;,&quot;10111&quot;,&quot;11111&quot;,&quot;10010&quot;]\n输出：6\n解释：最大矩形如上图所示。</code></pre>\n\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/maximal.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>单调栈。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int maximalRectangle(String[] matrix) &#123;\n        int N &#x3D; matrix.length;\n        if (N &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int M &#x3D; matrix[0].length();\n        int[][] preSum &#x3D; new int[N][M + 2];\n        for (int j &#x3D; 1; j &lt;&#x3D; M; j++) &#123;\n            for (int i &#x3D; 0; i &lt; N; i++) &#123;\n                if (i &#x3D;&#x3D; 0) &#123;\n                    preSum[i][j] &#x3D; matrix[i].charAt(j - 1) - &#39;0&#39;;\n                &#125; else if (matrix[i].charAt(j - 1) !&#x3D; &#39;0&#39;) &#123;\n                    preSum[i][j] &#x3D; preSum[i - 1][j] + matrix[i].charAt(j - 1) - &#39;0&#39;;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;单调栈\n        Deque&lt;Integer&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        int ans &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; N; j++) &#123;\n            int[] temp &#x3D; preSum[j];\n            for (int i &#x3D; 0; i &lt; M + 2; i++) &#123;\n                while (!deque.isEmpty() &amp;&amp; temp[deque.peek()] &gt; temp[i]) &#123;\n                    int cur &#x3D; deque.pop();\n                    int area &#x3D; (i - deque.peek() - 1) * (temp[cur]);\n                    ans &#x3D; area &gt; ans ? area : ans;\n                &#125;\n                deque.push(i);\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-47-二叉树剪枝\"><a href=\"#剑指-Offer-II-47-二叉树剪枝\" class=\"headerlink\" title=\"剑指 Offer II 47. 二叉树剪枝\"></a><a href=\"https://leetcode-cn.com/problems/pOCWxh/\">剑指 Offer II 47. 二叉树剪枝</a></h2><p>给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。</p>\n<p>节点 node 的子树为 node 本身，以及所有 node 的后代。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: [1,null,0,0,1]\n输出: [1,null,0,null,1] \n解释: \n只有红色节点满足条件“所有不包含 1 的子树”。\n图为返回的答案。</code></pre>\n\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/1028_2.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>递归删除。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public TreeNode pruneTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null &amp;&amp; root.val &#x3D;&#x3D; 0) &#123;\n            return null;\n        &#125;\n        root.left &#x3D; pruneTree(root.left);\n        root.right &#x3D; pruneTree(root.right);\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null &amp;&amp; root.val &#x3D;&#x3D; 0) &#123;\n            return null;\n        &#125;\n        return root;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-48-序列化与反序列化二叉树\"><a href=\"#剑指-Offer-II-48-序列化与反序列化二叉树\" class=\"headerlink\" title=\"剑指 Offer II 48. 序列化与反序列化二叉树\"></a><a href=\"https://leetcode-cn.com/problems/h54YBf/\">剑指 Offer II 48. 序列化与反序列化二叉树</a></h2><p>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p>\n<p>请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/serdeser.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>层次遍历来保存和反序列化。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Codec &#123;\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    public String serialize(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return &quot;&quot;;\n        &#125;\n        Deque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;TreeNode&gt;();\n        StringBuilder ans &#x3D; new StringBuilder();\n        deque.offer(root);\n        ans.append(root.val);\n        ans.append(&#39;,&#39;);\n        while (!deque.isEmpty()) &#123;\n            TreeNode temp &#x3D; deque.poll();\n            if (temp.left &#x3D;&#x3D; null) &#123;\n                ans.append(&quot;null&quot;);\n            &#125; else &#123;\n                ans.append(temp.left.val);\n                deque.offer(temp.left);\n            &#125;\n            ans.append(&#39;,&#39;);\n            if (temp.right &#x3D;&#x3D; null) &#123;\n                ans.append(&quot;null&quot;);\n            &#125; else &#123;\n                ans.append(temp.right.val);\n                deque.offer(temp.right);\n            &#125;\n            ans.append(&#39;,&#39;);\n        &#125;\n        return ans.toString();\n    &#125;\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) &#123;\n        if (data &#x3D;&#x3D; &quot;&quot;) &#123;\n            return null;\n        &#125;\n        String[] leaf &#x3D; data.split(&quot;,&quot;);\n        Deque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        TreeNode root &#x3D; new TreeNode(Integer.parseInt(leaf[0]));\n        deque.offer(root);\n        int index &#x3D; 1;\n        while (!deque.isEmpty()) &#123;\n            TreeNode temp &#x3D; deque.poll();\n            if (leaf[index].equals(&quot;null&quot;) ) &#123;\n                temp.left &#x3D; null;\n            &#125; else &#123;\n                temp.left &#x3D; new TreeNode(Integer.parseInt(leaf[index]));\n                deque.offer(temp.left);\n            &#125;\n            index++;\n            if (leaf[index].equals(&quot;null&quot;)) &#123;\n                temp.right &#x3D; null;\n            &#125; else &#123;\n                temp.right &#x3D; new TreeNode(Integer.parseInt(leaf[index]));\n                deque.offer(temp.right);\n            &#125;\n            index++;\n        &#125;\n        return root;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-49-从根节点到叶节点的路径数字之和\"><a href=\"#剑指-Offer-II-49-从根节点到叶节点的路径数字之和\" class=\"headerlink\" title=\"剑指 Offer II 49. 从根节点到叶节点的路径数字之和\"></a><a href=\"https://leetcode-cn.com/problems/3Etpl5/\">剑指 Offer II 49. 从根节点到叶节点的路径数字之和</a></h2><p>给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</p>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n<p>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。<br>计算从根节点到叶节点生成的 所有数字之和 。</p>\n<p>叶节点 是指没有子节点的节点。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495\n从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491\n从根到叶子节点路径 4-&gt;0 代表数字 40\n因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026</code></pre>\n\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/num2tree.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>DFS，到叶节点相加即可。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    private static int ans;\n    public int sumNumbers(TreeNode root) &#123;\n        ans &#x3D; 0;\n        DFS(root, 0);\n        return ans;\n    &#125;\n    public  void DFS(TreeNode root, int num) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;\n            ans +&#x3D; num * 10 + root.val;\n            return;\n        &#125;\n        DFS(root.left, num*10+root.val);\n        DFS(root.right, num*10+root.val);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-50-向下的路径节点之和\"><a href=\"#剑指-Offer-II-50-向下的路径节点之和\" class=\"headerlink\" title=\"剑指 Offer II 50. 向下的路径节点之和\"></a><a href=\"https://leetcode-cn.com/problems/6eUYwP/\">剑指 Offer II 50. 向下的路径节点之和</a></h2><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。</p>\n<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8\n输出：3\n解释：和等于 8 的路径有 3 条，如图所示。</code></pre>\n\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/pathsum3-1-tree.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>前缀和。</p>\n<p>​    统计以每个节点为「路径结尾」的合法数量的话，配合原本就是「从上往下」进行的数的遍历（最完整的路径必然是从原始根节点到当前节点的唯一路径），相当于只需要在完整路径中找到有多少个节点到当前节点的路径总和为 targetSum。</p>\n<p>​    于是这个树上问题彻底转换一维问题：求解从原始起点（根节点）到当前节点 b 的路径中，有多少节点 a 满足 sum[a…b]&#x3D;targetSum，由于从原始起点（根节点）到当前节点的路径唯一，因此这其实是一个「一维前缀和」问题。</p>\n<p>​    我们可以在进行树的遍历时，记录下从原始根节点 rootroot 到当前节点 curcur 路径中，从 rootroot 到任意中间节点 xx 的路径总和，配合哈希表，快速找到满足以 curcur 为「路径结尾」的、使得路径总和为 targetSumtargetSum 的目标「路径起点」有多少个。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static Map&lt;Integer, Integer&gt; hashMap;\n    static int ans, tar;\n    public int pathSum(TreeNode root, int targetSum) &#123;\n        hashMap &#x3D; new HashMap&lt;&gt;();\n        ans &#x3D; 0;\n        if (root &#x3D;&#x3D; null) &#123;\n            return 0;\n        &#125;\n        tar &#x3D; targetSum;\n        hashMap.put(0, 1);\n        DFS(root, root.val);\n        return ans;\n    &#125;\n    &#x2F;&#x2F;DFS 从 root 节点出发的和为Sum的路径个数\n    public  void DFS(TreeNode root, int sum) &#123;\n        if (hashMap.containsKey(sum - tar)) &#123;\n            ans +&#x3D; hashMap.get(sum - tar);\n        &#125;\n        hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);\n\n        if (root.left !&#x3D; null) DFS(root.left, sum + root.left.val);\n        if (root.right !&#x3D; null) DFS(root.right, sum + root.right.val);\n\n        hashMap.put(sum, hashMap.getOrDefault(sum, 0) - 1);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-53-二叉搜索树中的中序后继\"><a href=\"#剑指-Offer-II-53-二叉搜索树中的中序后继\" class=\"headerlink\" title=\"剑指 Offer II 53. 二叉搜索树中的中序后继\"></a><a href=\"https://leetcode-cn.com/problems/P5rCT8/\">剑指 Offer II 53. 二叉搜索树中的中序后继</a></h2><p>给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。</p>\n<p>节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：root &#x3D; [5,3,6,2,4,null,null,1], p &#x3D; 6\n输出：null\n解释：因为给出的节点没有中序后继，所以答案就返回 null 了。</code></pre>\n\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/285_example_2.PNG\" class=\"\" title=\"img\">\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>标记法。 二叉搜索树的中序后继的特点是：中序遍历时，当找到节点P后，下一个<strong>第一次</strong>访问的节点就是中序后继节点。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static TreeNode ans;\n    static boolean isP;\n\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;\n        isP &#x3D; false;\n        ans &#x3D; null;\n        &#x2F;&#x2F;TreeNode pre &#x3D; null;\n        inOrder(root, p);\n        return ans;   \n    &#125;\n    public void inOrder(TreeNode root, TreeNode p) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inOrder(root.left, p);\n        if (isP) &#123;\n            ans &#x3D; root;\n            isP &#x3D; false;\n        &#125;\n        if (p &#x3D;&#x3D; root) &#123;\n            isP &#x3D; true;\n        &#125;\n        inOrder(root.right, p);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-54-所有大于等于节点的值之和\"><a href=\"#剑指-Offer-II-54-所有大于等于节点的值之和\" class=\"headerlink\" title=\"剑指 Offer II 54. 所有大于等于节点的值之和\"></a><a href=\"https://leetcode-cn.com/problems/w6cpku/\">剑指 Offer II 54. 所有大于等于节点的值之和</a></h2><p>给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<p>节点的左子树仅包含键 小于 节点键的节点。<br>节点的右子树仅包含键 大于 节点键的节点。<br>左右子树也必须是二叉搜索树。</p>\n<p>输入：root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/tree.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>右-中-左遍历。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static int ans;\n    public TreeNode convertBST(TreeNode root) &#123;\n        ans &#x3D; 0;\n        reverseOrder(root);\n        return root;\n    &#125;\n    public static void reverseOrder(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        reverseOrder(root.right);\n        ans +&#x3D; root.val;\n        root.val &#x3D; ans;\n\n        reverseOrder(root.left);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-55-平衡二叉树\"><a href=\"#剑指-Offer-II-55-平衡二叉树\" class=\"headerlink\" title=\"剑指 Offer II 55. 平衡二叉树\"></a><a href=\"https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/\">剑指 Offer II 55. 平衡二叉树</a></h2><p>输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>\n<p>示例 1:</p>\n<p>给定二叉树 [3,9,20,null,null,15,7]</p>\n<pre><code>    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回 true 。\n</code></pre>\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>自底而上递归。</p>\n<p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static boolean ans &#x3D; true;\n    public boolean isBalanced(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        ans &#x3D; true;\n        DFS(root);\n        return ans;\n    &#125;\n    public int DFS(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return 0;\n        &#125;\n        int left &#x3D; DFS(root.left);\n        int right &#x3D; DFS(root.right);\n        if (ans &amp;&amp; Math.abs(left - right) &lt;&#x3D; 1) &#123;\n            return Math.max(left, right) + 1;\n        &#125; else &#123;\n            ans &#x3D; false;\n            return -1;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-059-数据流的第-K-大数值\"><a href=\"#剑指-Offer-II-059-数据流的第-K-大数值\" class=\"headerlink\" title=\"剑指 Offer II 059. 数据流的第 K 大数值\"></a><a href=\"https://leetcode-cn.com/problems/jBjn9C/\">剑指 Offer II 059. 数据流的第 K 大数值</a></h2><p>设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p>\n<p>请实现 KthLargest 类：</p>\n<p>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。<br>int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n输出：\n[null, 4, 5, 5, 8, 8]\n\n解释：\nKthLargest kthLargest &#x3D; new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   &#x2F;&#x2F; return 4\nkthLargest.add(5);   &#x2F;&#x2F; return 5\nkthLargest.add(10);  &#x2F;&#x2F; return 5\nkthLargest.add(9);   &#x2F;&#x2F; return 8\nkthLargest.add(4);   &#x2F;&#x2F; return 8</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>大根堆。</li>\n<li>快排。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class KthLargest &#123;\n    PriorityQueue&lt;Integer&gt; queue;\n    int k;\n\n    public KthLargest(int k, int[] nums) &#123;\n        this.k &#x3D; k;\n        queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1 - o2);\n        int min &#x3D; k &lt; nums.length ? k : nums.length;\n        for (int i &#x3D; 0; i &lt; min; i++) &#123;\n            queue.offer(nums[i]);\n        &#125;\n\n        for (int i &#x3D; min; i &lt; nums.length; i++) &#123;\n            if (nums[i] &gt; queue.peek()) &#123;\n                queue.poll();\n                queue.offer(nums[i]);\n            &#125;\n        &#125;\n    &#125;\n\n    public int add(int val) &#123;\n        if (queue.size() &lt; k) &#123;\n            queue.offer(val);\n        &#125; else if (val &gt; queue.peek()) &#123;\n            queue.poll();\n            queue.offer(val);\n        &#125;\n        return queue.peek();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-055-二叉搜索树迭代器\"><a href=\"#剑指-Offer-II-055-二叉搜索树迭代器\" class=\"headerlink\" title=\"剑指 Offer II 055. 二叉搜索树迭代器\"></a><a href=\"https://leetcode-cn.com/problems/kTOapQ/\">剑指 Offer II 055. 二叉搜索树迭代器</a></h2><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>\n<p>BSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。<br>boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。<br>int next()将指针向右移动，然后返回指针处的数字。<br>注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。</p>\n<p>可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入\ninputs &#x3D; [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\ninputs &#x3D; [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n输出\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\t3\n   &#x2F;  \\\n  7\t   15\n       &#x2F; \\\n      9   20\n解释\nBSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    &#x2F;&#x2F; 返回 3\nbSTIterator.next();    &#x2F;&#x2F; 返回 7\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 9\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 15\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 20\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 False</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>将二叉搜索树的值转换为顺序数组，然后进行操作即可。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class BSTIterator &#123;\n    static int next;\n    TreeNode root;\n    &#x2F;&#x2F; 中序遍历后有序的节点数组\n    List&lt;Integer&gt; array;\n    public BSTIterator(TreeNode root) &#123;\n        next &#x3D; 0;\n        this.root &#x3D; root;\n        array &#x3D; new ArrayList&lt;&gt;();\n        midOrder(root);\n    &#125;\n    public int next() &#123;\n        return array.get(next++);\n    &#125;\n    public boolean hasNext() &#123;\n        return next &lt; array.size();\n    &#125;\n    public void midOrder(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        midOrder(root.left);\n        array.add(root.val);\n        midOrder(root.right);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-060-出现频率最高的-k-个数字\"><a href=\"#剑指-Offer-II-060-出现频率最高的-k-个数字\" class=\"headerlink\" title=\"剑指 Offer II 060. 出现频率最高的 k 个数字\"></a><a href=\"https://leetcode-cn.com/problems/g5c51o/\">剑指 Offer II 060. 出现频率最高的 k 个数字</a></h2><p>给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1:\n输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><strong>HashMap</strong>统计,然后<strong>PriorityQueue</strong>排序。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        HashMap&lt;Integer, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        for (int num : nums) &#123;\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n        &#125;\n        PriorityQueue&lt;Integer[]&gt; queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[1] - o2[1]);\n        int idx &#x3D; 0;\n        for (Map.Entry&lt;Integer, Integer&gt; en : hashMap.entrySet()) &#123;\n            if (idx &lt; k) &#123;\n                queue.offer(new Integer[]&#123;en.getKey(), en.getValue()&#125;);\n            &#125; else &#123;\n                if (en.getValue() &gt;&#x3D; queue.peek()[1]) &#123;\n                    queue.poll();\n                    queue.offer(new Integer[]&#123;en.getKey(), en.getValue()&#125;);\n                &#125;\n            &#125;\n            idx++;\n        &#125;\n        int[] ans &#x3D; new int[k];\n        idx &#x3D; 0;\n        Iterator&lt;Integer[]&gt; it &#x3D; queue.iterator();\n        while (it.hasNext()) &#123;\n            ans[idx++] &#x3D; it.next()[0];\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-063-替换单词\"><a href=\"#剑指-Offer-II-063-替换单词\" class=\"headerlink\" title=\"剑指 Offer II 063. 替换单词\"></a><a href=\"https://leetcode-cn.com/problems/UhWRSj/\">剑指 Offer II 063. 替换单词</a></h2><p>在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>\n<p>现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>\n<p>需要输出替换之后的句子。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：dictionary &#x3D; [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence &#x3D; &quot;the cattle was rattled by the battery&quot;\n输出：&quot;the cat was rat by the bat&quot;</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>前缀树。题目本质是找前缀。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123;\n        trie root &#x3D; new trie();\n        Iterator&lt;String&gt; it &#x3D; dictionary.iterator();\n        while (it.hasNext()) &#123;\n            root.insert(it.next());\n        &#125;\n        String[] arr &#x3D; sentence.trim().split(&quot;\\\\s+&quot;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            ans.append(root.preSearch(arr[i])+&quot; &quot;);\n        &#125;\n        return ans.toString().trim();\n    &#125;\n    static class trie &#123;\n        trie[] child;\n        String isWord;\n        public trie() &#123;\n            child &#x3D; new trie[26];\n            isWord &#x3D; &quot;&quot;;\n        &#125;\n        public void insert(String word) &#123;\n            char[] chars &#x3D; word.toCharArray();\n            trie temp &#x3D; this;\n            for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n                char ch &#x3D; chars[i];\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    temp.child[ch - &#39;a&#39;] &#x3D; new trie();\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n            &#125;\n            temp.isWord &#x3D; word;\n        &#125;\n        public String preSearch(String word) &#123;\n            char[] chars &#x3D; word.toCharArray();\n            trie temp &#x3D; this;\n            for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n                char ch &#x3D; chars[i];\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    return word;\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n                if (!temp.isWord.equals(&quot;&quot;)) &#123;\n                    return temp.isWord;\n                &#125;\n            &#125;\n            return word;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-064-神奇的字典\"><a href=\"#剑指-Offer-II-064-神奇的字典\" class=\"headerlink\" title=\"剑指 Offer II 064. 神奇的字典\"></a><a href=\"https://leetcode-cn.com/problems/US1pGT/\">剑指 Offer II 064. 神奇的字典</a></h2><p>设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p>\n<p>实现 MagicDictionary 类：</p>\n<p>MagicDictionary() 初始化对象<br>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同<br>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例：\n输入\ninputs &#x3D; [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\ninputs &#x3D; [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n输出\n[null, null, false, true, false, false]\n\n解释\nMagicDictionary magicDictionary &#x3D; new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); &#x2F;&#x2F; 返回 False\nmagicDictionary.search(&quot;hhllo&quot;); &#x2F;&#x2F; 将第二个 &#39;h&#39; 替换为 &#39;e&#39; 可以匹配 &quot;hello&quot; ，所以返回 True\nmagicDictionary.search(&quot;hell&quot;); &#x2F;&#x2F; 返回 False\nmagicDictionary.search(&quot;leetcoded&quot;); &#x2F;&#x2F; 返回 False</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>前缀树 + DFS。</li>\n<li>或者直接统计两个字符串不相同字符数，等于 1 就返回真。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MagicDictionary &#123;\n    MagicDictionary[] child;\n    String word;\n    public MagicDictionary() &#123;\n        child &#x3D; new MagicDictionary[26];\n        word &#x3D; null;\n    &#125;\n    public void buildDict(String[] dictionary) &#123;\n        for (String word : dictionary) &#123;\n            MagicDictionary temp &#x3D; this;\n            for (char ch : word.toCharArray()) &#123;\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    temp.child[ch - &#39;a&#39;] &#x3D; new MagicDictionary();\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n            &#125;\n            temp.word &#x3D; word;\n        &#125;\n    &#125;\n    static boolean ans;\n    public boolean search(String searchWord) &#123;\n        ans &#x3D; false;\n        char[] arr &#x3D; searchWord.toCharArray();\n        DFS(this, arr, 0, false);\n        return ans;\n    &#125;\n    public void DFS(MagicDictionary root, char[] arr, int idx, boolean change) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (arr.length &#x3D;&#x3D; idx) &#123;\n            if (root.word !&#x3D; null &amp;&amp; change) &#123;\n                ans &#x3D; ans || true;\n            &#125;else &#123;\n                ans &#x3D; ans || false;\n            &#125;\n            return;\n        &#125;\n        int index &#x3D; arr[idx] - &#39;a&#39;;\n        if (change &amp;&amp; root.child[index] &#x3D;&#x3D; null) &#123;\n            ans &#x3D; ans || false;\n            return;\n        &#125;\n        if (change &amp;&amp; root.child[index] !&#x3D; null) &#123;\n            DFS(root.child[index], arr, idx + 1, true);\n        &#125;\n\n        if (!change) &#123;\n            for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n                if (root.child[i] !&#x3D; null &amp;&amp; i !&#x3D; index) &#123;\n                    DFS(root.child[i], arr, idx + 1, true);\n                &#125;\n            &#125;\n            DFS(root.child[index], arr, idx + 1, false);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-065-最短的单词编码\"><a href=\"#剑指-Offer-II-065-最短的单词编码\" class=\"headerlink\" title=\"剑指 Offer II 065. 最短的单词编码\"></a><a href=\"https://leetcode-cn.com/problems/iSwD2y/\">剑指 Offer II 065. 最短的单词编码</a></h2><p>单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：</p>\n<p>words.length &#x3D;&#x3D; indices.length<br>助记字符串 s 以 ‘#’ 字符结尾<br>对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等<br>给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]\n输出：10\n解释：一组有效编码为 s &#x3D; &quot;time#bell#&quot; 和 indices &#x3D; [0, 2, 5] 。\nwords[0] &#x3D; &quot;time&quot; ，s 开始于 indices[0] &#x3D; 0 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;\nwords[1] &#x3D; &quot;me&quot; ，s 开始于 indices[1] &#x3D; 2 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;\nwords[2] &#x3D; &quot;bell&quot; ，s 开始于 indices[2] &#x3D; 5 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>前缀树。 此题的本质是找后缀重合的单词。所以从后往前建立”后缀树”，然后搜索，可以优化为在建树的过程中计算。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int minimumLengthEncoding(String[] words) &#123;\n        Trie root &#x3D; new Trie();\n        for (String word : words) &#123;\n            root.insert(word);\n        &#125;\n        len  &#x3D; 0;\n        dfs(root, 0);\n        return len;\n    &#125;\n    public static int len;\n    public static void dfs(Trie root, int deep) &#123;\n        boolean flag &#x3D; false;\n        for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n            if (root.child[i] !&#x3D; null) &#123;\n                flag &#x3D; true;\n                dfs(root.child[i], deep + 1);\n            &#125;\n        &#125;\n        if (!flag) &#123;\n            len +&#x3D; deep;\n            if (root.word !&#x3D; null)&#123;\n                len +&#x3D; 1;\n            &#125;\n        &#125;\n    &#125;\n    static class Trie &#123;\n        Trie[] child;\n        String word;\n        &#x2F;&#x2F;后缀\n        public Trie() &#123;\n            child &#x3D; new Trie[26];\n            word &#x3D; null;\n        &#125;\n        public void insert(String word) &#123;\n            Trie temp &#x3D; this;\n            char[] chars &#x3D; word.toCharArray();\n            for (int i &#x3D; chars.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                int idx &#x3D; chars[i] - &#39;a&#39;;\n                if (temp.child[idx] &#x3D;&#x3D; null) &#123;\n                    temp.child[idx] &#x3D; new Trie();\n                &#125;\n                temp &#x3D; temp.child[idx];\n            &#125;\n            temp.word &#x3D; word;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-066-单词之和\"><a href=\"#剑指-Offer-II-066-单词之和\" class=\"headerlink\" title=\"剑指 Offer II 066. 单词之和\"></a><a href=\"https://leetcode-cn.com/problems/z1R5dt/\">剑指 Offer II 066. 单词之和</a></h2><p>实现一个 MapSum 类，支持两个方法，insert 和 sum：</p>\n<p>MapSum() 初始化 MapSum 对象<br>void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。<br>int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例：\n输入：\ninputs &#x3D; [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\ninputs &#x3D; [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n输出：\n[null, null, 3, null, 5]\n解释：\nMapSum mapSum &#x3D; new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           &#x2F;&#x2F; return 3 (apple &#x3D; 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           &#x2F;&#x2F; return 5 (apple + app &#x3D; 3 + 2 &#x3D; 5)</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>前缀树。把节点存储的单词换为值即可，然后遍历。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MapSum &#123;\n    MapSum[] child;\n    int val;\n    static int ans &#x3D; 0;\n    public MapSum() &#123;\n        val &#x3D; -1;\n        child &#x3D; new MapSum[26];\n    &#125;\n    public void insert(String key, int val) &#123;\n        MapSum temp &#x3D; this;\n        for (char ch : key.toCharArray()) &#123;\n            if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                temp.child[ch - &#39;a&#39;] &#x3D; new MapSum();\n            &#125;\n            temp &#x3D; temp.child[ch - &#39;a&#39;];\n        &#125;\n        temp.val &#x3D; val;\n    &#125;\n    public int sum(String prefix) &#123;\n        MapSum temp &#x3D; this;\n        for (char ch : prefix.toCharArray()) &#123;\n            int idx &#x3D; ch - &#39;a&#39;;\n            if (temp.child[idx] &#x3D;&#x3D; null) &#123;\n                return 0;\n            &#125;\n            temp &#x3D; temp.child[idx];\n        &#125;\n        ans &#x3D; 0;\n        DFS(temp);\n        return ans;\n    &#125;\n    public static void DFS(MapSum root) &#123;\n        if (root &#x3D;&#x3D; null) return;\n        if (root.val !&#x3D; -1) ans +&#x3D; root.val;\n        for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n            if (root.child[i] !&#x3D; null) &#123;\n                DFS(root.child[i]);\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-067-最大的异或\"><a href=\"#剑指-Offer-II-067-最大的异或\" class=\"headerlink\" title=\"剑指 Offer II 067. 最大的异或\"></a><a href=\"https://leetcode-cn.com/problems/ms70jA/\">剑指 Offer II 067. 最大的异或</a></h2><p>给定一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1：\n输入：nums &#x3D; [3,10,5,25,2,8]\n输出：28\n解释：最大运算结果是 5 XOR 25 &#x3D; 28.</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>异或。</p>\n</li>\n<li><p>前缀树:</p>\n<p>搜索的方法<br>异或值最大，我们就要尽量让每个异或位都和 num 对应的二进制位不同。</p>\n<p>如果 num 当前位为 0，就到 next[1] 去搜索；<br>如果 num 当前位为 1，就到 next[0] 去搜索;<br>如果与 num 当前位相反的那一位为空，那就只能到相同的那一位去搜索了。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int findMaximumXOR(int[] nums) &#123;\n        Trie trie &#x3D; new Trie();\n        int max &#x3D; -1;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            trie.build(nums[i]);\n            int val &#x3D; trie.search(nums[i]);\n            max &#x3D; max &gt; val ? max : val;\n        &#125;\n        return max;\n    &#125;\n    static class Trie &#123;\n        Trie[] child;\n\n        public Trie() &#123;\n            child &#x3D; new Trie[2];\n        &#125;\n\n        public void build(Integer num) &#123;\n            Trie temp &#x3D; this;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--) &#123;\n                int flag &#x3D; (num &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0 ? 0 : 1;\n                if (temp.child[flag] &#x3D;&#x3D; null) &#123;\n                    temp.child[flag] &#x3D; new Trie();\n                &#125;\n                temp &#x3D; temp.child[flag];\n            &#125;\n        &#125;\n\n        public int search(Integer val) &#123;\n            Trie temp &#x3D; this;\n            int ans &#x3D; 0;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--) &#123;\n                int flag &#x3D; (val &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0 ? 0 : 1;\n                if (flag &#x3D;&#x3D; 1) &#123;\n                    if (temp.child[0] !&#x3D; null) &#123;\n                        temp &#x3D; temp.child[0];\n                        ans &#x3D; ans | (1 &lt;&lt; i);\n                    &#125; else &#123;\n                        temp &#x3D; temp.child[1];\n                    &#125;\n                &#125; else &#123;\n                    if (temp.child[1] !&#x3D; null) &#123;\n                        temp &#x3D; temp.child[1];\n                        ans &#x3D; ans | (1 &lt;&lt; i);\n                    &#125; else &#123;\n                        temp &#x3D; temp.child[0];\n                    &#125;\n                &#125;\n            &#125;\n            return ans;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n\n\n\n\n<h2 id=\"剑指-Offer-II-070-排序数组中只出现一次的数字\"><a href=\"#剑指-Offer-II-070-排序数组中只出现一次的数字\" class=\"headerlink\" title=\"剑指 Offer II 070. 排序数组中只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/skFtm2/\">剑指 Offer II 070. 排序数组中只出现一次的数字</a></h2><p>给定一个只包含整数的有序数组 <code>nums</code> ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: nums &#x3D; [1,1,2,3,3,4,4,8,8]\n输出: 2</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>二分查找，区分 区间长度的奇偶 来进行二分。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int singleNonDuplicate(int[] nums) &#123;\n        int l &#x3D; 0;\n        int r &#x3D; nums.length - 1;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt; 1;\n            if ((mid &#x3D;&#x3D; 0 &amp;&amp; nums[mid] !&#x3D; nums[mid + 1]) || (mid &#x3D;&#x3D; nums.length - 1 &amp;&amp; nums[mid] !&#x3D; nums[mid - 1])) &#123;\n                return nums[mid];\n            &#125;\n            if (nums[mid] !&#x3D; nums[mid - 1] &amp;&amp; nums[mid] !&#x3D; nums[mid + 1]) &#123;\n                return nums[mid];\n            &#125;\n            if (mid - 1 &gt;&#x3D; 0 &amp;&amp; nums[mid] &#x3D;&#x3D; nums[mid - 1]) &#123;\n                if ((mid - l) % 2 &#x3D;&#x3D; 0) &#123;\n                    r &#x3D; mid - 2;\n                &#125; else &#123;\n                    l &#x3D; mid + 1;\n                &#125;\n            &#125;\n            if (mid + 1 &lt; nums.length &amp;&amp; nums[mid] &#x3D;&#x3D; nums[mid + 1]) &#123;\n                if ((r - mid) % 2 &#x3D;&#x3D; 0) &#123;\n                    l &#x3D; mid + 2;\n                &#125; else &#123;\n                    r &#x3D; mid - 1;\n                &#125;\n            &#125;\n        &#125;\n        return nums[l];\n    &#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-071-按权重生成随机数\"><a href=\"#剑指-Offer-II-071-按权重生成随机数\" class=\"headerlink\" title=\"剑指 Offer II 071. 按权重生成随机数\"></a><a href=\"https://leetcode-cn.com/problems/cuyjEf/\">剑指 Offer II 071. 按权重生成随机数</a></h2><p>给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。</p>\n<p>例如，对于 w &#x3D; [1, 3]，挑选下标 0 的概率为 1 &#x2F; (1 + 3) &#x3D; 0.25 （即，25%），而选取下标 1 的概率为 3 &#x2F; (1 + 3) &#x3D; 0.75（即，75%）。</p>\n<p>也就是说，选取下标 i 的概率为 w[i] &#x2F; sum(w) 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：\ninputs &#x3D; [&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\ninputs &#x3D; [[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution &#x3D; new Solution([1, 3]);\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1，返回下标 1，返回该下标概率为 3&#x2F;4 。\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 0，返回下标 0，返回该下标概率为 1&#x2F;4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>前缀和 + 二分查找。</p>\n<p>把<strong>权重和total</strong>求出来，在1~total上求随机数，然后和每个权重的区间(通过前缀和求)进行映射，求得下标随机数。</p>\n<pre><code> w   3   1   4   2  total = 10 (0-3] 代表下标0  (3-4]代表1 (4-8] 代表2 ...\npre  3   4   8   10 代表具体随机的值。\n i   [1   2   3]   [4]   [5   6   7   8]   [9   10]\n</code></pre>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n        int[] preSum;\n        int total;\n        &#x2F;&#x2F;  w   3   1   4   2\n        &#x2F;&#x2F; pre  3   4   (8   10] 代表具体随机的值。\n        &#x2F;&#x2F;  i   [1   2   3]   [4]   [5   6   7   8]   [9   10]\n        public Solution(int[] w) &#123;\n            preSum &#x3D; new int[w.length];\n            total &#x3D; Arrays.stream(w).sum();\n            for (int i &#x3D; 0; i &lt; w.length; i++) &#123;\n                preSum[i] &#x3D; i &#x3D;&#x3D; 0 ? w[0] : w[i] + preSum[i - 1];\n            &#125;\n\n        &#125;\n        public int pickIndex() &#123;\n            int seed &#x3D; (int) (Math.random() * total) + 1;\n            int idx &#x3D; Arrays.binarySearch(preSum, seed);\n            if (idx &lt; 0) &#123;\n                idx &#x3D; -idx -1;\n            &#125;\n            return idx;\n        &#125;\n    &#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-073-狒狒吃香蕉\"><a href=\"#剑指-Offer-II-073-狒狒吃香蕉\" class=\"headerlink\" title=\"剑指 Offer II 073. 狒狒吃香蕉\"></a><a href=\"https://leetcode-cn.com/problems/nZZqjQ/\">剑指 Offer II 073. 狒狒吃香蕉</a></h2><p>狒狒喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。</p>\n<p>狒狒可以决定她吃香蕉的速度 K （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  </p>\n<p>狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p>\n<p>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: piles &#x3D; [3,6,7,11], H &#x3D; 8\n输出: 4</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>二分查找最小速度。</p>\n<ul>\n<li>&#96;&#96;&#96;java<br>以此可以缩短判断时间。<br>time +&#x3D; (pile-1)&#x2F;K + 1;<br>&#x2F;&#x2F;time +&#x3D; pile % K &#x3D;&#x3D; 0 ? pile &#x2F; K : pile &#x2F; K + 1;<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n  - 最大值范围确定可以直接赋值，省去了搜索最大值过程。\n\n&#96;&#96;&#96;java\nclass Solution &#123;\n    public int minEatingSpeed(int[] piles, int h) &#123;\n        int left &#x3D;1,right &#x3D; 1000000000;\n        while(left&lt;right)&#123;\n            int mid &#x3D; left + (right - left)&#x2F;2;\n            if(isFinished(piles,h,mid))&#123;\n                right &#x3D; mid;\n            &#125;else&#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n    private boolean isFinished(int[] piles,int h,int speed)&#123;\n        int time &#x3D; 0;\n        for(int pile:piles)&#123;\n            time +&#x3D; (pile-1)&#x2F;speed + 1;\n        &#125;\n        return time&lt;&#x3D;h;\n    &#125;\n&#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"剑指-Offer-II-074-合并区间\"><a href=\"#剑指-Offer-II-074-合并区间\" class=\"headerlink\" title=\"剑指 Offer II 074. 合并区间\"></a><a href=\"https://leetcode-cn.com/problems/SsGoHC/\">剑指 Offer II 074. 合并区间</a></h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1：\n输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>按开始时间排序。</p>\n<p>可以合并的肯定是连续的。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[][] merge(int[][] intervals) &#123;\n        if (intervals.length &#x3D;&#x3D; 0) &#123;\n            return new int[0][2];\n        &#125;\n        Arrays.sort(intervals,(o1, o2) -&gt; o1[0]-o2[0]);\n        List&lt;int[]&gt; merged &#x3D; new ArrayList&lt;int[]&gt;();\n        for (int i &#x3D; 0; i &lt; intervals.length; ++i) &#123;\n            int L &#x3D; intervals[i][0], R &#x3D; intervals[i][1];\n            if (merged.size() &#x3D;&#x3D; 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123;\n                merged.add(new int[]&#123;L, R&#125;);\n            &#125; else &#123;\n                merged.get(merged.size() - 1)[1] &#x3D; Math.max(merged.get(merged.size() - 1)[1], R);\n            &#125;\n        &#125;\n        return merged.toArray(new int[merged.size()][]);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-079-所有子集\"><a href=\"#剑指-Offer-II-079-所有子集\" class=\"headerlink\" title=\"剑指 Offer II 079. 所有子集\"></a><a href=\"https://leetcode-cn.com/problems/TVdhkn/\">剑指 Offer II 079. 所有子集</a></h2><p>给定一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>两种回溯方法。<ul>\n<li><strong>第一种，递归实现。</strong> 每个元素的两种情况往下遍历。</li>\n<li><strong>第二种，for循环实现。</strong>每个元素及其后面的元素一起遍历。</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), nums, 0);\n        return ans;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums,\n                                 int idx) &#123;\n        if (idx &gt;&#x3D; nums.length) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(nums[idx]);\n        traceback(ans, list, nums, idx + 1);\n        list.remove(list.size() - 1);\n        traceback(ans, list, nums, idx + 1);\n    &#125;\n    public  void traceback2(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums,\n                                 int idx) &#123;\n        ans.add(new ArrayList&lt;&gt;(list));\n        for (int i &#x3D; idx; i &lt; nums.length; i++) &#123;\n            list.add(nums[i]);\n            traceback(ans, list, nums, i + 1);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-080-含有-k-个元素的组合\"><a href=\"#剑指-Offer-II-080-含有-k-个元素的组合\" class=\"headerlink\" title=\"剑指 Offer II 080. 含有 k 个元素的组合\"></a><a href=\"https://leetcode-cn.com/problems/uUsW3B/\">剑指 Offer II 080. 含有 k 个元素的组合</a></h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: n &#x3D; 4, k &#x3D; 2\n输出:\n[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>回溯方法。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), 1, n, k);\n        return ans;\n    &#125;\n    public void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int idx, int n,\n                                 int k) &#123;\n        if (n - idx + 1 &lt; k)return;\n        if (k &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt;&#x3D; n; i++) &#123;\n            list.add(i);\n            traceback(ans, list, i + 1, n, k - 1);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n    public void traceback2(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int idx, int n,\n                                  int k) &#123;\n        if (n - idx + 1 &lt; k)return;\n        if (k &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(idx);\n        traceback(ans, list, idx + 1, n, k - 1);\n        list.remove(list.size() - 1);\n        traceback(ans, list, idx + 1, n, k );\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-081-允许重复选择元素的组合\"><a href=\"#剑指-Offer-II-081-允许重复选择元素的组合\" class=\"headerlink\" title=\"剑指 Offer II 081. 允许重复选择元素的组合\"></a><a href=\"https://leetcode-cn.com/problems/Ygoe9J/\">剑指 Offer II 081. 允许重复选择元素的组合</a></h2><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p>\n<p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p>\n<p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7\n输出: [[7],[2,2,3]]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>回溯法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), candidates, 0, target);\n        return ans;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] candidates,\n                                 int idx, int target) &#123;\n        if (target &lt; 0 || idx &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        if (target &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt; candidates.length; i++) &#123;\n            list.add(candidates[i]);\n            traceback(ans, list, candidates, i, target - candidates[i]);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] candidates,\n                                 int idx, int target) &#123;\n        if (target &lt; 0 || idx &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        if (target &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(candidates[idx]);\n        &#x2F;&#x2F; 加上当前这个数\n        traceback(ans, list, candidates, idx, target - candidates[idx]);\n        list.remove(list.size() - 1);\n        if (idx + 1 &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; 不加当前这个数\n        traceback(ans, list, candidates, idx + 1, target);\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"剑指-Offer-II-082-含有重复元素集合的组合\"><a href=\"#剑指-Offer-II-082-含有重复元素集合的组合\" class=\"headerlink\" title=\"剑指 Offer II 082. 含有重复元素集合的组合\"></a><a href=\"https://leetcode-cn.com/problems/4sjJUc/\">剑指 Offer II 082. 含有重复元素集合的组合</a></h2><p>给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。 </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,\n输出: [[1,1,6],[1,2,5],[1,7],[2,6]]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>回溯法。去重用排序的方法。遇到相同的数就不再进行访问，但是要拿当前的这个数。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static HashSet&lt;List&lt;Integer&gt;&gt; ans;\n    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F; 为了避免重复答案\n        Arrays.sort(candidates);\n        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        traceback(candidates, ans, list, 0, 0, target);\n        return ans;\n    &#125;\n    public  void traceback(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ans,\n                                 List&lt;Integer&gt; list, int idx, int sum,\n                                 int target) &#123;\n        if (sum &#x3D;&#x3D; target) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt; candidates.length; i++) &#123;\n            if (sum + candidates[i] &gt; target) &#123;\n                break;\n            &#125;\n            if (i &gt; idx &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i-1])&#123;\n                &#x2F;&#x2F; 因为前面那个同样的数已经经历过dfs，再拿同样的数dfs就会得到重复的答案\n                continue;\n            &#125;\n            list.add(candidates[i]);\n            traceback(candidates, ans, list, i+1, sum + candidates[i], target);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-II-083-没有重复元素集合的全排列\"><a href=\"#剑指-Offer-II-083-没有重复元素集合的全排列\" class=\"headerlink\" title=\"剑指 Offer II 083. 没有重复元素集合的全排列\"></a><a href=\"https://leetcode-cn.com/problems/VvJkup/\">剑指 Offer II 083. 没有重复元素集合的全排列</a></h2><p>给定一个不含重复数字的整数数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。可以 <strong>按任意顺序</strong> 返回答案。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>回溯。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), nums);\n        return ans;\n    &#125;\n    public void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums) &#123;\n        if (list.size() &#x3D;&#x3D; nums.length) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            if (nums[i]&#x3D;&#x3D; -100)continue;\n            int temp &#x3D; nums[i];\n            nums[i] &#x3D; -100;\n            list.add(temp);\n            traceback(ans, list, nums);\n            list.remove(list.size() - 1);\n            nums[i] &#x3D; temp;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n\n\n<h2 id=\"剑指-Offer-II-116-省份数量\"><a href=\"#剑指-Offer-II-116-省份数量\" class=\"headerlink\" title=\"剑指 Offer II 116. 省份数量\"></a><a href=\"https://leetcode-cn.com/problems/bLyHh0/\">剑指 Offer II 116. 省份数量</a></h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p>\n<p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>\n<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p>\n<p>返回矩阵中 省份 的数量。</p>\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/graph1.jpg\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]\n输出：2</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>DFS</p>\n</li>\n<li><p>BFS</p>\n</li>\n<li><p>并查集。</p>\n<p>每找到两个联通的节点，将其祖先统一。 即就是 isConnected[i][j] &#x3D; 1 时，Union(i,j)</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int findCircleNum(int[][] isConnected) &#123;\n        int N &#x3D; isConnected.length;\n        int[] original &#x3D; new int[N];\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            original[i] &#x3D; i;\n        &#125;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                if (isConnected[i][j] &#x3D;&#x3D; 1) &#123;\n                    &#x2F;&#x2F; 连接节点 i j\n                    int left &#x3D; i;\n                    int right &#x3D; j;\n                    &#x2F;&#x2F; 找左节点的 祖先\n                    while (original[left] !&#x3D; left) left &#x3D; original[left];\n                    &#x2F;&#x2F; 找右节点的 祖先\n                    while (original[right] !&#x3D; right) right &#x3D; original[right];\n                    &#x2F;&#x2F; 找到后将其中一个的祖先赋给另外一个, 这样就可以统一祖先了\n                    original[left] &#x3D; right;\n                &#125;\n            &#125;\n        &#125;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            if (original[i] &#x3D;&#x3D; i) &#123;\n                ans++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-090-环形房屋偷盗\"><a href=\"#剑指-Offer-II-090-环形房屋偷盗\" class=\"headerlink\" title=\"剑指 Offer II 090. 环形房屋偷盗\"></a><a href=\"https://leetcode-cn.com/problems/PzWKhm/\">剑指 Offer II 090. 环形房屋偷盗</a></h2><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。\n     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>动态规划 + 分类讨论。</p>\n<p>前后相接，只需要讨论第一个位置是否被抢，进行两次动态规划即可。</p>\n<p>抢 1 , 则不抢最后一个。不抢 1 , 则考虑抢最后一个。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        int n &#x3D; nums.length;\n        if (n &#x3D;&#x3D; 1) return nums[0];\n        if (n &#x3D;&#x3D; 2) return Math.max(nums[0], nums[1]);\n        int[] dp &#x3D; new int[n];\n        &#x2F;&#x2F; rob 0\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; Math.max(nums[0], nums[1]);\n        for (int j &#x3D; 2; j &lt; n - 1; j++) &#123;\n            dp[j] &#x3D; Math.max(nums[j] + dp[j - 2], dp[j - 1]);\n        &#125;\n        int ans &#x3D; dp[n - 2];\n        &#x2F;&#x2F; rob 1\n        dp[0] &#x3D; 0;\n        dp[1] &#x3D; nums[1];\n        for (int j &#x3D; 2; j &lt; n; j++) &#123;\n            dp[j] &#x3D; Math.max(nums[j] + dp[j - 2], dp[j - 1]);\n        &#125;\n        return Math.max(ans, dp[n - 1]);\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-092-翻转字符\"><a href=\"#剑指-Offer-II-092-翻转字符\" class=\"headerlink\" title=\"剑指 Offer II 092. 翻转字符\"></a><a href=\"https://leetcode-cn.com/problems/cyJERH/\">剑指 Offer II 092. 翻转字符</a></h2><p>如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是 单调递增 的。</p>\n<p>我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 s，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。</p>\n<p>返回使 s 单调递增 的最小翻转次数。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：s &#x3D; &quot;010110&quot;\n输出：2\n解释：我们翻转得到 011111，或者是 000111。</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>动态规划。答案字符串左侧肯定都是 0 ，右侧都是 1 。所以枚举每一个分割点，统计一次左侧 1 出现的次数，右侧 0 出现的次数，加在一起便是需要反转的字符个数。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int minFlipsMonoIncr(String s) &#123;\n        int n &#x3D; s.length();\n        int[] pre &#x3D; new int[n];\n        int[] dp &#x3D; new int[n];\n        int num &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            num +&#x3D; s.charAt(i) - &#39;0&#39;;\n            pre[i] &#x3D; num;\n        &#125;\n        dp[0] &#x3D; n - pre[n - 1];\n        dp[n - 1] &#x3D; pre[n - 1];\n        int min &#x3D; Math.min(dp[0], dp[n - 1]);\n        for (int i &#x3D; 1; i &lt; n - 1; i++) &#123;\n            dp[i] &#x3D; pre[i - 1] + (n - 1 - i - pre[n - 1] + pre[i]);\n            min &#x3D; Math.min(min, dp[i]);\n        &#125;\n        return min;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-093-最长斐波那契数列\"><a href=\"#剑指-Offer-II-093-最长斐波那契数列\" class=\"headerlink\" title=\"剑指 Offer II 093. 最长斐波那契数列\"></a><a href=\"https://leetcode-cn.com/problems/Q91FMA/\">剑指 Offer II 093. 最长斐波那契数列</a></h2><p>如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：</p>\n<ul>\n<li>n &gt;&#x3D; 3</li>\n<li>对于所有 i + 2 &lt;&#x3D; n，都有 $X_i + X_{i+1} &#x3D; X_{i+2}$<br>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。</li>\n</ul>\n<p>（回想一下，子序列是从原序列  arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: arr &#x3D; [1,3,7,11,12,14,18]\n输出: 3\n解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>动态规划。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n    *      1   2   3   4   5   6   7   8\n    *   1  1   2   2   2   2   2   2   2\n    *   2      1   3   2   2   2   2   2\n    *   3          1   3   4   2   2   2\n    *   4              1   3   3   4   2\n    *   5                  1   3   3   5\n    *   6                      1   3   3\n    *   7                          1   3\n    *   8                              1\n*&#x2F;\ndp[i][j]：表示以A[i],A[j]结尾的斐波那契数列的最大长度\n             dp[i][j]&#x3D;Len(......,A[i],A[j])\n             A[k]+A[i]&#x3D;&#x3D;A[j]\n dp[i][j] &#x3D; max (dp[k][i]+1) 其中 A[k]+A[i]&#x3D;&#x3D;A[j]</code></pre></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int lenLongestFibSubseq(int[] arr) &#123;\n        int n &#x3D; arr.length;\n        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;\n            return 0;\n        &#125;\n        int[][] dp &#x3D; new int[n][n];\n        HashMap&lt;Integer, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            hashMap.put(arr[i], i);\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n                dp[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n                &#x2F;&#x2F; i 开始 j 结束 A[j] - A[i] &#x3D; A[k]\n                if (hashMap.containsKey(arr[j] - arr[i])) &#123;\n                    int idx &#x3D; hashMap.get(arr[j] - arr[i]);\n                    dp[i][j] &#x3D; Math.max(dp[i][j], dp[idx][i]+1);\n                    ans &#x3D; Math.max(dp[i][j], ans);\n                &#125;\n            &#125;\n        &#125;\n        return ans &gt;&#x3D; 3 ? ans : 0;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-095-最长公共子序列\"><a href=\"#剑指-Offer-II-095-最长公共子序列\" class=\"headerlink\" title=\"剑指 Offer II 095. 最长公共子序列\"></a><a href=\"https://leetcode-cn.com/problems/qJnOS7/\">剑指 Offer II 095. 最长公共子序列</a></h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。</p>\n<p>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<p>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。<br>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; \n输出：3  \n解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>动态规划。</p>\n</li>\n<li><p>其中 dp[i][j] 表示 text1 [0:i]和 text2 [0:j] 的最长公共子序列的长度。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">       a   b   c   d   e\n   ij  0   0   0   0   0\na   0  1   1   1   1   1\nc   0  1   1   2   2   2\ne   0  1   1   2   2   3</code></pre></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int longestCommonSubsequence(String text1, String text2) &#123;\n        int m &#x3D; text1.length(), n &#x3D; text2.length();\n        int[][] dp &#x3D; new int[m + 1][n + 1];\n        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n            char c1 &#x3D; text1.charAt(i - 1);\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n                char c2 &#x3D; text2.charAt(j - 1);\n                if (c1 &#x3D;&#x3D; c2) &#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125; else &#123;\n                    dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-100-三角形中最小路径之和\"><a href=\"#剑指-Offer-II-100-三角形中最小路径之和\" class=\"headerlink\" title=\"剑指 Offer II 100. 三角形中最小路径之和\"></a><a href=\"https://leetcode-cn.com/problems/IlPe0q/\">剑指 Offer II 100. 三角形中最小路径之和</a></h2><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p>\n<p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>动态规划。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;\n        int n &#x3D; triangle.size();\n        if (n &#x3D;&#x3D; 1) &#123;\n            return triangle.get(0).get(0);\n        &#125;\n        int[] preDp &#x3D; new int[n];\n        int[] dp &#x3D; new int[n];\n        preDp[0] &#x3D; triangle.get(0).get(0);\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            dp[0] &#x3D; preDp[0] + triangle.get(i).get(0);\n            dp[i] &#x3D; preDp[i - 1] + triangle.get(i).get(i);\n            for (int j &#x3D; 1; j &lt; i; j++) &#123;\n                dp[j] &#x3D; Math.min(preDp[j], preDp[j - 1]) + triangle.get(i).get(j);\n            &#125;\n            preDp &#x3D; Arrays.copyOf(dp, i+1);\n        &#125;\n        int min &#x3D; Integer.MAX_VALUE;\n        for (int i : dp) &#123;\n            if (i &lt; min) &#123;\n                min &#x3D; i;\n            &#125;\n        &#125;\n        return min;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-101-分割等和子集\"><a href=\"#剑指-Offer-II-101-分割等和子集\" class=\"headerlink\" title=\"剑指 Offer II 101. 分割等和子集\"></a><a href=\"https://leetcode-cn.com/problems/NUPfPr/\">剑指 Offer II 101. 分割等和子集</a></h2><p>给定一个非空的正整数数组 <code>nums</code> ，请判断能否将这些数字分成元素和相等的两部分。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [1,5,11,5]\n输出：true\n解释：nums 可以分割成 [1, 5, 5] 和 [11] 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>NP完全问题。动态规划转为<strong>0-1背包</strong>问题。</p>\n<p>能否从数组中选出若个数字，使它们的和等于 target &#x3D; sum &#x2F; 2，那么所有数字之和 sum 必须为偶数，若 sum 不为偶数则等和子集肯定不存在。有 n 个数字，每一步都判断该数字是否加入等和子集，最终需要判断组合的解的个数是否大于 0</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        int sum &#x3D; Arrays.stream(nums).sum();\n        if (sum % 2 &#x3D;&#x3D; 1) &#123;\n            return false;\n        &#125;\n        sum &#x2F;&#x3D; 2;\n        boolean[][] dp &#x3D; new boolean[nums.length][sum + 1];\n        for (int i &#x3D; 0; i &lt;&#x3D; sum; i++) &#123;\n            dp[0][i] &#x3D; i &#x3D;&#x3D; nums[0] ? true : false;\n        &#125;\n        if (dp[0][sum]) &#123;\n            return true;\n        &#125;\n        for (int i &#x3D; 1; i &lt; nums.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt;&#x3D; sum; j++) &#123;\n                dp[i][j] &#x3D;\n                        dp[i - 1][j] || (j - nums[i] &gt; 0 &amp;&amp; dp[i - 1][j - nums[i]]) || j &#x3D;&#x3D; nums[i];\n            &#125;\n            if (dp[i][sum]) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-102-加减的目标值\"><a href=\"#剑指-Offer-II-102-加减的目标值\" class=\"headerlink\" title=\"剑指 Offer II 102. 加减的目标值\"></a><a href=\"https://leetcode-cn.com/problems/YaVDxD/\">剑指 Offer II 102. 加减的目标值</a></h2><p>给定一个正整数数组 nums 和一个整数 target 。</p>\n<p>向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：</p>\n<p>例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。<br>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 &#x3D; 3\n+1 - 1 + 1 + 1 + 1 &#x3D; 3\n+1 + 1 - 1 + 1 + 1 &#x3D; 3\n+1 + 1 + 1 - 1 + 1 &#x3D; 3\n+1 + 1 + 1 + 1 - 1 &#x3D; 3</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>动态规划。</p>\n<p>目标和target可以表达为:  </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">负数(-neg) + 正数(pos) &#x3D; target\n-neg + (sum-neg) &#x3D; target\nsum - target &#x3D; 2*neg</code></pre>\n\n<p>所以只需要找到用 num[i] 组合成neg即可，转换为背包问题。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int findTargetSumWays(int[] nums, int target) &#123;\n        int sum &#x3D; Arrays.stream(nums).sum();\n        target &#x3D; sum - target;\n        if (target &lt; 0 || target % 2 !&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        target &#x2F;&#x3D; 2;\n        int[] dp &#x3D; new int[target + 1];\n        dp[0] &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            for (int j &#x3D; target; j &gt;&#x3D; 0; j--) &#123;\n                if (j - nums[i] &gt;&#x3D; 0)\n                    dp[j] &#x3D; dp[j - nums[i]] + dp[j];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"剑指-Offer-II-103-最少的硬币数目\"><a href=\"#剑指-Offer-II-103-最少的硬币数目\" class=\"headerlink\" title=\"剑指 Offer II 103. 最少的硬币数目\"></a><a href=\"https://leetcode-cn.com/problems/gaM7Ch/\">剑指 Offer II 103. 最少的硬币数目</a></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11\n输出：3 \n解释：11 &#x3D; 5 + 5 + 1</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>动态规划。</p>\n<p>dp[j]表示价格为 j 时的最小硬币数，枚举价格。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);\namount  0   1   2   3   4   5   6   7   8   9   10  11\n    1   0   1   2   3   4   5   6   7   8   9   10  11\n    2   0   1   1   2   2   3   3   4   4   5   5   6\n    3   0   1   1   1   2   2   2   3   3   3   4   4</code></pre></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int coinChange(int[] coins, int amount) &#123;\n        if (amount &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int[] dp &#x3D; new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt;&#x3D; amount; j++) &#123;\n                if (j - coins[i] &gt;&#x3D; 0) &#123;\n                    dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[amount] &gt; amount ? -1 : dp[amount];\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-105-岛屿的最大面积\"><a href=\"#剑指-Offer-II-105-岛屿的最大面积\" class=\"headerlink\" title=\"剑指 Offer II 105. 岛屿的最大面积\"></a><a href=\"https://leetcode-cn.com/problems/ZL6zAn/\">剑指 Offer II 105. 岛屿的最大面积</a></h2><p>给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。</p>\n<p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p>\n<p>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出: 6\n解释: 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>DFS。求得是最大岛屿面积，每次DFS要算出岛屿面积。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int maxAreaOfIsland(int[][] grid) &#123;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; grid.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    ans &#x3D; Math.max(ans, DFS(grid, i, j));\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    public int DFS(int[][] grid, int i, int j) &#123;\n        if (i &gt;&#x3D; grid.length || j &gt;&#x3D; grid[0].length || i &lt; 0 || j &lt; 0) &#123;\n            return 0;\n        &#125;\n        grid[i][j] &#x3D; 0;\n        int num &#x3D; 1;\n        if (i + 1 &lt; grid.length &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i + 1, j);\n        if (i - 1 &gt;&#x3D; 0 &amp;&amp; grid[i - 1][j] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i - 1, j);\n        if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i, j + 1);\n        if (j - 1 &gt;&#x3D; 0 &amp;&amp; grid[i][j - 1] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i, j - 1);\n        return num;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-II-106-二分图\"><a href=\"#剑指-Offer-II-106-二分图\" class=\"headerlink\" title=\"剑指 Offer II 106. 二分图\"></a><a href=\"https://leetcode-cn.com/problems/vEAB3K/\">剑指 Offer II 106. 二分图</a></h2><p>存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。</p>\n<p>给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：</p>\n<p>不存在自环（graph[u] 不包含 u）。<br>不存在平行边（graph[u] 不包含重复值）。<br>如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）<br>这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。<br>二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。</p>\n<p>如果图是二分图，返回 true ；否则，返回 false 。</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/bi1.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：graph &#x3D; [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>染色法+DFS。相邻的染上不同颜色，如果要染得颜色不一致，返回false。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public  boolean ans;\n    public boolean isBipartite(int[][] graph) &#123;\n        ans &#x3D; true;\n        int[] color &#x3D; new int[graph.length];\n        for (int i &#x3D; 0; i &lt; graph.length &amp;&amp; ans; i++) &#123;\n            if (color[i] &#x3D;&#x3D; 0) DFS(graph, color, i, 1);\n        &#125;\n        return ans;\n    &#125;\n    &#x2F;&#x2F; 第i个节点为初始节点.\n    public  void DFS(int[][] graph, int[] color, int i, int rORg) &#123;\n        if (color[i] !&#x3D; 0) &#123;&#x2F;&#x2F; 节点已经染过色\n            &#x2F;&#x2F; 和需要染得颜色不一样\n            if (color[i] !&#x3D; rORg) ans &#x3D; false;\n            return;\n        &#125;\n        color[i] &#x3D; rORg;\n        for (int i1 : graph[i]) &#123;\n            &#x2F;&#x2F; 给与 i 相邻的节点都染上相反的颜色\n            DFS(graph, color, i1, -rORg);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-06-从尾到头打印链表\"><a href=\"#剑指-Offer-06-从尾到头打印链表\" class=\"headerlink\" title=\"剑指 Offer 06. 从尾到头打印链表\"></a><a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">剑指 Offer 06. 从尾到头打印链表</a></h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：head &#x3D; [1,3,2]\n输出：[2,3,1]</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<p>用栈进行逆序。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int[] reversePrint(ListNode head) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        while (head !&#x3D; null) &#123;\n            stack.push(head.val);\n            head &#x3D; head.next;\n        &#125;\n        int size &#x3D; stack.size();\n        int[] array &#x3D; new int[size];\n        for(int i &#x3D; 0; i &lt; size; i++) &#123;\n            array[i] &#x3D; stack.pop();\n        &#125;\n        return array;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-09-用两个栈实现队列\"><a href=\"#剑指-Offer-09-用两个栈实现队列\" class=\"headerlink\" title=\"剑指 Offer 09. 用两个栈实现队列\"></a><a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">剑指 Offer 09. 用两个栈实现队列</a></h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>\n<p>输入：<br>[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”]<br>[[],[],[5],[2],[],[]]<br>输出：[null,-1,null,null,5,2]</p>\n<hr>\n<p>解题思路:</p>\n<p>双栈实现队列，当一个序列经过一个栈会变成倒序，经过两个栈会重新变为顺序。维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。</p>\n<ul>\n<li>加入队尾 appendTail()函数： 将数字 val 加入栈 A 即可。</li>\n<li>删除队首 deleteHead()函数： 有以下三种情况。<ul>\n<li>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。</li>\n<li>否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1−1 。</li>\n<li>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class CQueue &#123;\n    private Stack&lt;Integer&gt; stackA;\n    private Stack&lt;Integer&gt; stackB;\n    public CQueue() &#123;\n        stackA &#x3D; new Stack&lt;Integer&gt;();\n        stackB &#x3D; new Stack&lt;Integer&gt;();\n    &#125;\n\n    public void appendTail(int value) &#123;\n        stackA.push(value);\n    &#125;\n\n    public int deleteHead() &#123;\n        if (stackB.isEmpty()) &#123;\n            if (stackA.isEmpty()) &#123;\n                return -1;\n            &#125; else &#123;\n                while (!stackA.empty()) &#123;\n                    stackB.push(stackA.pop());\n                &#125;\n            &#125;\n        &#125;\n        return stackB.pop();\n    &#125;\n&#125;\n\n&#x2F;**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj &#x3D; new CQueue();\n * obj.appendTail(value);\n * int param_2 &#x3D; obj.deleteHead();\n *&#x2F;</code></pre>\n\n<h2 id=\"剑指-Offer-14-I-剪绳子\"><a href=\"#剑指-Offer-14-I-剪绳子\" class=\"headerlink\" title=\"剑指 Offer 14- I. 剪绳子\"></a><a href=\"https://leetcode-cn.com/problems/jian-sheng-zi-lcof/\">剑指 Offer 14- I. 剪绳子</a></h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1：\n输入: 2\n输出: 1\n解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1\n    \n示例 2:\n输入: 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>数学推理。</p>\n<p>设将长度为 n 的绳子切为 a 段：<br>$n &#x3D; n_1 + n_2 + … + n_a$ 本题等价于求解：$\\max(n_1 \\times n_2 \\times … \\times n_a)$</p>\n<p>以下公式为“算术几何均值不等式” ，等号当且仅当 $n_1 &#x3D; n_2 &#x3D; … &#x3D; n_a $时成立。$\\frac{n_1 + n_2 + … + n_a}{a} \\geq \\sqrt[a]{n_1 n_2 … n_a}$</p>\n<blockquote><p><strong>推论一：</strong> 将绳子 <strong>以相等的长度等分为多段</strong> ，得到的乘积最大。</p></blockquote>\n<p>即就是求下式的最值，求导后得最值点为 x &#x3D; e，取最近的整数点3。<br>$$<br>x^a&#x3D;x^{\\frac {x}{n}}&#x3D;(x^{\\frac {1}{x}})^n<br>$$</p>\n<blockquote><p><strong>推论二：</strong> 尽可能将绳子以长度 33 等分为多段时，乘积最大。</p></blockquote>\n<p>当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m&gt;1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1 。<br>当 n&gt;3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n &#x3D; 3a + b），并分为以下三种情况：<br>当 b &#x3D; 0 时，直接返回 $3^a $</p>\n<p>当 b &#x3D; 1 时，要将一个 1 + 3 转换为 2+2，因此返回 $3^{a-1} \\times 4$</p>\n<p>当 b &#x3D; 2 时，返回 $3^a \\times 2$</p>\n</li>\n<li><p>动态规划。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int cuttingRope(int n) &#123;\n        if (n &lt;&#x3D; 3) &#123;\n            return n - 1;\n        &#125;\n        int residue &#x3D; n % 3;\n        int quotient &#x3D; n &#x2F; 3;\n        if (residue &#x3D;&#x3D; 0) &#123;\n            return (int) (Math.pow(3,quotient));\n        &#125; else if (residue &#x3D;&#x3D; 1) &#123;\n            return (int) (Math.pow(3,quotient-1))*4;\n        &#125; else &#123;\n            return (int) (Math.pow(3,quotient)) *2 ;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n\n\n<h2 id=\"剑指-Offer-24-反转链表\"><a href=\"#剑指-Offer-24-反转链表\" class=\"headerlink\" title=\"剑指 Offer 24. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\">剑指 Offer 24. 反转链表</a></h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<p>头插法反转链表。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode ans &#x3D; new ListNode();\n\n        ListNode temp &#x3D; head;\n        while (head !&#x3D; null) &#123;\n            temp &#x3D; head;\n            head &#x3D; head.next;\n\n            temp.next &#x3D; ans.next;\n            ans.next &#x3D; temp;\n\n        &#125;\n        return ans.next;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-26-树的子结构\"><a href=\"#剑指-Offer-26-树的子结构\" class=\"headerlink\" title=\"剑指 Offer 26. 树的子结构\"></a><a href=\"https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\">剑指 Offer 26. 树的子结构</a></h2><p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)</p>\n<p>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>\n<pre><code>例如:\n给定的树 A:  \n  3\n / \\\n4   5\n   / \\\n  1   2\n给定的树 B：\n   4 \n  /\n 1\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n</code></pre>\n<hr>\n<p>解题思路：</p>\n<p>​    若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：</p>\n<ul>\n<li>先序遍历树 A 中的每个节点 $n_A$ 对应函数 isSubStructure(A, B)</li>\n<li>判断树 A 中 以 $n_A$为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;\n        if (A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n\n        return recur(A, B) || (isSubStructure(A.left, B) || isSubStructure(A.right, B));\n    &#125;\n    public  boolean recur(TreeNode A, TreeNode B) &#123;\n        if (B &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125; else if (A &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n\n        if (A.val !&#x3D; B.val) &#123;\n            return false;\n        &#125; else &#123;\n            return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-28-对称的二叉树\"><a href=\"#剑指-Offer-28-对称的二叉树\" class=\"headerlink\" title=\"剑指 Offer 28. 对称的二叉树\"></a><a href=\"https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/\">剑指 Offer 28. 对称的二叉树</a></h2><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>\n<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>\n<pre><code>    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n</code></pre>\n<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>\n<pre><code>    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n</code></pre>\n<hr>\n<p>解题思路：</p>\n<p>递归判断。</p>\n<ul>\n<li>判断两节点 <code>L.left</code> 和 <code>R.right</code> 是否对称；</li>\n<li>判断两节点 <code>L.right</code> 和 <code>R.left</code> 是否对称；</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean isSymmetric(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        return judge(root.left, root.right);\n    &#125;\n    public boolean judge(TreeNode left, TreeNode right) &#123;\n        if (left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        if (left !&#x3D; null &amp;&amp; right !&#x3D; null &amp;&amp; left.val &#x3D;&#x3D; right.val) &#123;\n            return judge(left.left, right.right) &amp;&amp; judge(left.right, right.left);\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-30-包含min函数的栈\"><a href=\"#剑指-Offer-30-包含min函数的栈\" class=\"headerlink\" title=\"剑指 Offer 30. 包含min函数的栈\"></a><a href=\"https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\">剑指 Offer 30. 包含min函数的栈</a></h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">MinStack minStack &#x3D; new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.min();   --&gt; 返回 -2.</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<p>双栈实现最小栈。</p>\n<p>​    两个栈<code>stack</code>，<code>minStack</code>维持相同的大小，minStack的栈顶元素是当前对应的stack栈中的最小值。</p>\n<p>​    在栈插入时，stack正常插入，minStack插入时，将插入元素与栈顶元素相比，如果栈顶元素更小，则插入栈顶元素，如果插入元素小，就插入需要插入的元素。这样维持着最小栈，当弹出最小值时只需要将minStack中的栈顶元素弹出。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MinStack &#123;\n    &#x2F;&#x2F;双栈实现最小栈\n    Stack&lt;Integer&gt; stack;\n    Stack&lt;Integer&gt; minStack;\n    public MinStack() &#123;\n        stack &#x3D; new Stack&lt;&gt;();\n        minStack &#x3D; new Stack&lt;&gt;();\n    &#125;\n    public void push(int x) &#123;\n        stack.push(x);\n        if (minStack.empty()) &#123;\n            minStack.push(x);\n            return;\n        &#125;\n        minStack.push(x &gt; minStack.peek() ? minStack.peek() : x);\n    &#125;\n    public void pop() &#123;\n        stack.pop();\n        minStack.pop();\n    &#125;\n    public int top() &#123;\n        return stack.peek();\n    &#125;\n    public int min() &#123;\n        return minStack.peek();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-31-栈的压入、弹出序列\"><a href=\"#剑指-Offer-31-栈的压入、弹出序列\" class=\"headerlink\" title=\"剑指 Offer 31. 栈的压入、弹出序列\"></a><a href=\"https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\">剑指 Offer 31. 栈的压入、弹出序列</a></h2><p>入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n\n输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>模拟。创建一个栈，用出栈顺序和进栈顺序可以模拟是否可以为一个弹出序列。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        if (pushed.length &#x3D;&#x3D; 0) &#123;\n            return true;\n        &#125;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        int pushIndex &#x3D; 0;\n        int popIndex &#x3D; 0;\n        while (pushIndex &lt; pushed.length &amp;&amp; popIndex &lt; popped.length) &#123;\n            if (stack.empty()) &#123;\n                stack.push(pushed[pushIndex++]);\n            &#125;\n            while (pushIndex &lt; pushed.length &amp;&amp; stack.peek() !&#x3D; popped[popIndex]) &#123;\n                stack.push(pushed[pushIndex++]);\n            &#125;\n            while (popIndex &lt; popped.length &amp;&amp; !stack.empty() &amp;&amp; stack.peek() &#x3D;&#x3D; popped[popIndex]) &#123;\n                popIndex++;\n                stack.pop();\n            &#125;\n            if (stack.empty() &amp;&amp; popIndex &#x3D;&#x3D; popped.length) &#123;\n                return true;\n            &#125;\n            if (pushIndex &#x3D;&#x3D; pushed.length &amp;&amp; !stack.empty()) &#123;\n                return false;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\nclass Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        int i &#x3D; 0;\n        for(int num : pushed) &#123;\n            stack.push(num); &#x2F;&#x2F; num 入栈\n            while(!stack.isEmpty() &amp;&amp; stack.peek() &#x3D;&#x3D; popped[i]) &#123; &#x2F;&#x2F; 循环判断与出栈\n                stack.pop();\n                i++;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n\n\n</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-34-二叉树中和为某一值的路径\"><a href=\"#剑指-Offer-34-二叉树中和为某一值的路径\" class=\"headerlink\" title=\"剑指 Offer 34. 二叉树中和为某一值的路径\"></a><a href=\"https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/\">剑指 Offer 34. 二叉树中和为某一值的路径</a></h2><p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例:\n给定如下二叉树，以及目标和 target &#x3D; 22，\n              5\n             &#x2F; \\\n            4   8\n           &#x2F;   &#x2F; \\\n          11  13  4\n         &#x2F;  \\    &#x2F; \\\n        7    2  5   1\n返回:\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>DFS</li>\n<li>BFS</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;\n        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        DFS(root, list, target, 0, ans);\n        return ans;\n    &#125;\n    public  void DFS(TreeNode root, List&lt;Integer&gt; list, int tar, int sum, List&lt;List&lt;Integer&gt;&gt; ans) &#123;\n        if (root &#x3D;&#x3D; null ) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; if (root.val + sum &#x3D;&#x3D; tar &amp;&amp; (root.left !&#x3D; null || root.right !&#x3D; null)) &#123;\n        &#x2F;&#x2F;     return;\n        &#x2F;&#x2F; &#125;\n        if (root.val + sum &#x3D;&#x3D; tar &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;\n            list.add(root.val);\n            List&lt;Integer&gt; temp &#x3D; new ArrayList&lt;Integer&gt;();\n            Iterator&lt;Integer&gt; it &#x3D; list.iterator();\n            while (it.hasNext()) &#123;\n                temp.add(it.next());\n            &#125;\n            ans.add(temp);\n            list.remove(list.size() - 1);\n            return;\n        &#125;\n        list.add(root.val);\n        DFS(root.left, list, tar, sum + root.val, ans);\n        DFS(root.right, list, tar, sum + root.val, ans);\n        list.remove(list.size() - 1);\n\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"剑指-Offer-35-复杂链表的复制\"><a href=\"#剑指-Offer-35-复杂链表的复制\" class=\"headerlink\" title=\"剑指 Offer 35. 复杂链表的复制\"></a><a href=\"https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/\">剑指 Offer 35. 复杂链表的复制</a></h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/e1.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<p>​    使用Hash表保存新旧节点的映射关系，然后待新链表创建完成后再进行随机节点的复制。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public Node copyRandomList(Node head) &#123;\n        Node ans &#x3D; new Node(0);\n        Node tail &#x3D; ans;\n        Node tempHead &#x3D; head;\n        HashMap&lt;Node, Node&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        while (tempHead !&#x3D; null) &#123;\n            Node temp &#x3D; new Node(tempHead.val);\n            temp.next &#x3D; tail.next;\n            tail.next &#x3D; temp;\n            hashMap.put(tempHead, temp);\n            tail &#x3D; tail.next;\n            tempHead &#x3D; tempHead.next;\n        &#125;\n\n        tempHead &#x3D; head;\n        tail &#x3D; ans.next;\n        while (tempHead !&#x3D; null) &#123;\n            if (tempHead.random !&#x3D; null) &#123;\n                tail.random &#x3D; hashMap.get(tempHead.random);\n            &#125;\n            &#x2F;&#x2F;System.out.println(tempHead+&quot;--&quot;+tempHead.random);\n            tempHead &#x3D; tempHead.next;\n            tail &#x3D; tail.next;\n        &#125;\n        return ans.next;\n\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-36-二叉搜索树与双向链表\"><a href=\"#剑指-Offer-36-二叉搜索树与双向链表\" class=\"headerlink\" title=\"剑指 Offer 36. 二叉搜索树与双向链表\"></a><a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/\">剑指 Offer 36. 二叉搜索树与双向链表</a></h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p>\n<p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p>\n<img src=\"LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/1599401091-PKIjds-Picture1.png\" alt=\"Picture1.png\" style=\"zoom:67%;\" />\n\n<p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p>\n<p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p>\n<p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p>\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>中序遍历，中序遍历排序二叉树，所得的结果序列递增。所以选择中序遍历，在遍历过程中修改指针。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    static Node pre, head;\n    public Node treeToDoublyList(Node root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        pre&#x3D; null;\n        head &#x3D; null;\n        midOrder(root);\n        head.left &#x3D; pre;\n        pre.right &#x3D; head;\n        return head;\n    &#125;\n    public void midOrder(Node root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        midOrder(root.left);\n&#x2F;&#x2F;      1. 修改前一个节点的后 为当前节点\n&#x2F;&#x2F;      2. 修改当前节点的前 为前一个节点\n&#x2F;&#x2F;      3. 更新当前节点为前一个节点\n        if (pre !&#x3D; null) &#123;\n            pre.right &#x3D; root;\n        &#125; else &#123;\n            head &#x3D; root;\n        &#125;\n        root.left &#x3D; pre;\n\n        pre &#x3D; root;\n        midOrder(root.right);\n\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-45-把数组排成最小的数\"><a href=\"#剑指-Offer-45-把数组排成最小的数\" class=\"headerlink\" title=\"剑指 Offer 45. 把数组排成最小的数\"></a><a href=\"https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/\">剑指 Offer 45. 把数组排成最小的数</a></h2><p>输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p>\n<pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">输入: [3,30,34,5,9]\n输出: &quot;3033459&quot;</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>重写排序。</p>\n<p>设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 排序判断规则 为：</p>\n<p>若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；<br>反之，若 x + y &lt; y + x，则 x “小于” y ；<br>x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。</p>\n<p>根据以上规则，套用任何排序方法对 numsnums 执行排序即可。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public String minNumber(int[] nums) &#123;\n        String[] number &#x3D; new String[nums.length];\n        for (int i &#x3D; 0; i &lt; number.length; i++) &#123;\n            number[i] &#x3D; String.valueOf(nums[i]);\n        &#125;\n        Arrays.sort(number, new Comparator&lt;String&gt;() &#123;\n            @Override\n            public int compare(String o1, String o2) &#123;\n                String s1 &#x3D; o1 + o2;\n                String s2 &#x3D; o2 + o1;\n                return s1.compareTo(s2);\n            &#125;\n        &#125;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (String s : number) &#123;\n            ans.append(s);\n        &#125;\n        return ans.toString();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-46-把数字翻译成字符串\"><a href=\"#剑指-Offer-46-把数字翻译成字符串\" class=\"headerlink\" title=\"剑指 Offer 46. 把数字翻译成字符串\"></a><a href=\"https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/\">剑指 Offer 46. 把数字翻译成字符串</a></h2><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1:\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li>动态规划。<br>$$<br>dp[i] &#x3D; \\begin{cases}<br>dp[i-1]+dp[i-2],&amp; 10\\le x_i x_{i-1} \\le25 \\<br>dp[i-1],&amp;else \\<br>\\end{cases}<br>$$</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int translateNum(int num) &#123;\n        String str &#x3D; String.valueOf(num);\n        int n &#x3D; str.length();\n        if (n &#x3D;&#x3D; 1) &#123;\n            return 1;\n        &#125;\n        if (n &#x3D;&#x3D; 2) &#123;\n            if (num &lt;&#x3D; 25) &#123;\n                return 2;\n            &#125;\n            return 1;\n        &#125;\n        int[] dp &#x3D; new int[str.length()];\n        dp[0] &#x3D; 1;\n        int temp &#x3D; Integer.parseInt(str.substring(0, 2));\n        dp[1] &#x3D; temp &lt;&#x3D; 25  &amp;&amp; temp &gt;&#x3D; 10? 2 : 1;\n        for (int i &#x3D; 2; i &lt; n; i++) &#123;\n            temp &#x3D; Integer.parseInt(str.substring(i - 1, i + 1));\n            if (temp &gt;&#x3D; 10 &amp;&amp; temp &lt;&#x3D; 25) &#123;\n                dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n            &#125; else &#123;\n                dp[i] &#x3D; dp[i - 1];\n            &#125;\n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-41-数据流中的中位数\"><a href=\"#剑指-Offer-41-数据流中的中位数\" class=\"headerlink\" title=\"剑指 Offer 41. 数据流中的中位数\"></a><a href=\"https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\">剑指 Offer 41. 数据流中的中位数</a></h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>\n<p>例如，</p>\n<p>[2,3,4] 的中位数是 3</p>\n<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>\n<p>设计一个支持以下两种操作的数据结构：</p>\n<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1：\n输入：\n[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>大顶堆 + 小顶堆。</p>\n<p>建立一个 小顶堆 AA 和 大顶堆 BB ，各保存列表的一半元素，且规定：</p>\n<ul>\n<li><p>A 保存 较大 的一半，长度为 $\\frac{N}{2}$ （N 为偶数）或 $\\frac{N+1}{2}$ （N为奇数）;</p>\n</li>\n<li><p>BB 保存 较小 的一半，长度为 $\\frac{N}{2}$ （N 为偶数）或 $\\frac{N-1}{2} $（NN 为奇数）；</p>\n<p>随后，中位数可仅根据 A,B 的堆顶元素计算得到。</p>\n</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MedianFinder &#123;\n    &#x2F;** initialize your data structure here. *&#x2F;\n    private PriorityQueue&lt;Integer&gt; smallHeap;\n        private PriorityQueue&lt;Integer&gt; bigHeap;\n    public MedianFinder() &#123;\n        smallHeap &#x3D; new PriorityQueue&lt;&gt;();\n            bigHeap &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;\n                @Override\n                public int compare(Integer o1, Integer o2) &#123;\n                    return o2 - o1;\n                &#125;\n            &#125;);\n    &#125;\n    public void addNum(int num) &#123;\n        if (bigHeap.isEmpty() || num &lt;&#x3D; bigHeap.peek()) &#123;\n                bigHeap.offer(num);\n            &#125; else &#123;\n                smallHeap.offer(num);\n            &#125;\n            int N1 &#x3D; bigHeap.size();\n            int N2 &#x3D; smallHeap.size();\n            if (N1 - N2 &gt; 1) &#123;\n                smallHeap.offer(bigHeap.poll());\n            &#125;\n            if (N1 - N2 &lt;&#x3D; -1) &#123;\n                bigHeap.offer(smallHeap.poll());\n            &#125;\n    &#125;\n    public double findMedian() &#123;\n        int N1 &#x3D; bigHeap.size();\n            int N2 &#x3D; smallHeap.size();\n            if (N1 &#x3D;&#x3D; N2) &#123;\n                return ((double) smallHeap.peek() + bigHeap.peek()) &#x2F; 2;\n            &#125;\n            return bigHeap.peek();\n    &#125;\n&#125;\n&#x2F;**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj &#x3D; new MedianFinder();\n * obj.addNum(num);\n * double param_2 &#x3D; obj.findMedian();\n *&#x2F;</code></pre>\n\n\n\n<h2 id=\"剑指-Offer-48-最长不含重复字符的子字符串\"><a href=\"#剑指-Offer-48-最长不含重复字符的子字符串\" class=\"headerlink\" title=\"剑指 Offer 48. 最长不含重复字符的子字符串\"></a><a href=\"https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/\">剑指 Offer 48. 最长不含重复字符的子字符串</a></h2><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1:\n输入: &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre>\n\n<hr>\n<p>解题思路：</p>\n<ul>\n<li><p>双指针+哈希表。</p>\n<p>哈希表存储字符最后一次出现的索引，遍历字符串，双指针统计<code>最长不含重复字符</code>的子串。</p>\n<p>右指针依次遍历每个字符。</p>\n<p>当右指针指向的元素在前面出现过时，更新左指针。$$left &#x3D; Math.max(hashMap.get(ch) + 1, left);$$</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int lengthOfLongestSubstring(String s) &#123;\n         HashMap&lt;Character, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        if (s.length() &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int max &#x3D; 1;\n        int left &#x3D; 0;\n        int right &#x3D; 0;\n        while (right &lt; s.length()) &#123;\n            char ch &#x3D; s.charAt(right);\n            if (hashMap.containsKey(ch)) &#123;\n                left &#x3D; Math.max(hashMap.get(ch) + 1, left);\n                hashMap.replace(ch, right);\n            &#125; else &#123;\n                hashMap.put(ch, right);\n            &#125;\n            max &#x3D; max &gt; right - left + 1 ? max : right - left + 1;\n            right++;\n        &#125;\n        return max;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"剑指-Offer-49-丑数\"><a href=\"#剑指-Offer-49-丑数\" class=\"headerlink\" title=\"剑指 Offer 49. 丑数\"></a><a href=\"https://leetcode-cn.com/problems/chou-shu-lcof/\">剑指 Offer 49. 丑数</a></h2><p>我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例:\n输入: n &#x3D; 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li>动态规划。 和选择素数一样，只需要从1开始，选择所有丑数的2 、 3 、5 倍数，自然就是丑数，当需要顺序找到第几个时，需要用三个指针来判断顺序。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int nthUglyNumber(int n) &#123;\n        if (n &#x3D;&#x3D; 1) &#123;\n            return 1;\n        &#125;\n\n        int[] flag &#x3D; new int[n + 1];\n        flag[1] &#x3D; 1;\n        int p2 &#x3D; 1;\n        int p3 &#x3D; 1;\n        int p5 &#x3D; 1;\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            int num2 &#x3D; flag[p2] * 2;\n            int num3 &#x3D; flag[p3] * 3;\n            int num5 &#x3D; flag[p5] * 5;\n            int min &#x3D; Math.min(num2, Math.min(num3, num5));\n            flag[i] &#x3D; min;\n            if (min &#x3D;&#x3D; num2) &#123;\n                p2++;\n            &#125;\n            if (min &#x3D;&#x3D; num3) &#123;\n                p3++;\n            &#125;\n            if (min &#x3D;&#x3D; num5) &#123;\n                p5++;\n            &#125;\n        &#125;\n        return flag[n];\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"剑指-Offer-60-n个骰子的点数\"><a href=\"#剑指-Offer-60-n个骰子的点数\" class=\"headerlink\" title=\"剑指 Offer 60. n个骰子的点数\"></a><a href=\"https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/\">剑指 Offer 60. n个骰子的点数</a></h2><p>把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>\n<p> 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>暴力。超时</p>\n</li>\n<li><p>动态规划。</p>\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/image-20210929162210939.png\" class=\"\" title=\"image-20210929162210939\">\n\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/image-20210929162222971.png\" class=\"\" title=\"image-20210929162222971\">\n\n<img src=\"/post/LeetCode-%E5%89%91%E6%8C%87Offer%E7%AF%87/image-20210929162247423.png\" class=\"\" title=\"image-20210929162247423\">\n\n<p>以此类推，前一次掷的骰子概率×1&#x2F;6，然后求和就好。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public double[] dicesProbability(int n) &#123;\n        double[] dp &#x3D; new double[6];\n        Arrays.fill(dp, 1.0 &#x2F; 6);\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            double[] ans &#x3D; new double[i * 5 + 1];\n            for (int j &#x3D; 0; j &lt; dp.length; j++) &#123;\n                for (int k &#x3D; 0; k &lt; 6; k++) &#123;\n                    ans[j + k] +&#x3D; dp[j] &#x2F; 6.0;\n                &#125;\n            &#125;\n            dp &#x3D; ans;\n        &#125;\n        return dp;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n\n\n<h2 id=\"剑指-Offer-64-求1-2-…-n\"><a href=\"#剑指-Offer-64-求1-2-…-n\" class=\"headerlink\" title=\"剑指 Offer 64. 求1+2+…+n\"></a><a href=\"https://leetcode-cn.com/problems/qiu-12n-lcof/\">剑指 Offer 64. 求1+2+…+n</a></h2><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">示例 1：\n输入: n &#x3D; 3\n输出: 6</code></pre>\n\n<hr>\n<p>解题思路:</p>\n<ul>\n<li><p>递归。</p>\n<p>不使用循环时，递归是一个很好的办法，但是要求不使用if语句，所以难点是处理递归出口，解决办法是利用<code>&amp;&amp;</code>的短路运算性质。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Solution &#123;\n    public int sumNums(int n) &#123;\n        boolean flag &#x3D; n &gt; 0 &amp;&amp; (n +&#x3D; sumNums(n - 1)) &gt; 0;\n        return n;\n    &#125;\n&#125;</code></pre>\n\n\n\n\n\n","text":"剑指 Offer剑指 Offer II 4. 只出现一次的数字 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 输入：nums &#x3D; [0,1,0,1,0,1,100] 输出：100 解题思路...","link":"","photos":[],"count_time":{"symbolsCount":"88k","symbolsTime":"1:20"},"categories":[{"name":"算法","slug":"算法","count":1,"path":"api/categories/算法.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"刷题","slug":"刷题","count":1,"path":"api/tags/刷题.json"},{"name":"数据结构","slug":"数据结构","count":1,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":1,"path":"api/tags/算法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer\"><span class=\"toc-text\">剑指 Offer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-4-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">剑指 Offer II 4. 只出现一次的数字 </span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-14-%E5%89%AA%E7%BB%B3%E5%AD%90-II\"><span class=\"toc-text\">剑指 Offer II 14. 剪绳子 II</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-15-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%98%E4%BD%8D%E8%AF%8D\"><span class=\"toc-text\">剑指 Offer II 15. 字符串中的所有变位词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-30-%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%E5%92%8C%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%83%BD%E6%98%AF-O-1-%E7%9A%84%E5%AE%B9%E5%99%A8\"><span class=\"toc-text\">剑指 Offer II 30. 插入、删除和随机访问都是 O(1) 的容器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-37-%E5%B0%8F%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E\"><span class=\"toc-text\">剑指 Offer II 37. 小行星碰撞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-39-%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">剑指 Offer II 39. 直方图最大矩形面积</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-40-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2\"><span class=\"toc-text\">剑指 Offer II 40. 矩阵中最大的矩形</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-47-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D\"><span class=\"toc-text\">剑指 Offer II 47. 二叉树剪枝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-48-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">剑指 Offer II 48. 序列化与反序列化二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-49-%E4%BB%8E%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">剑指 Offer II 49. 从根节点到叶节点的路径数字之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-50-%E5%90%91%E4%B8%8B%E7%9A%84%E8%B7%AF%E5%BE%84%E8%8A%82%E7%82%B9%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">剑指 Offer II 50. 向下的路径节点之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-53-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%B8%AD%E5%BA%8F%E5%90%8E%E7%BB%A7\"><span class=\"toc-text\">剑指 Offer II 53. 二叉搜索树中的中序后继</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-54-%E6%89%80%E6%9C%89%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E%E8%8A%82%E7%82%B9%E7%9A%84%E5%80%BC%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">剑指 Offer II 54. 所有大于等于节点的值之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-55-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">剑指 Offer II 55. 平衡二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-059-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E7%AC%AC-K-%E5%A4%A7%E6%95%B0%E5%80%BC\"><span class=\"toc-text\">剑指 Offer II 059. 数据流的第 K 大数值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-055-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BF%AD%E4%BB%A3%E5%99%A8\"><span class=\"toc-text\">剑指 Offer II 055. 二叉搜索树迭代器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-060-%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84-k-%E4%B8%AA%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">剑指 Offer II 060. 出现频率最高的 k 个数字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-063-%E6%9B%BF%E6%8D%A2%E5%8D%95%E8%AF%8D\"><span class=\"toc-text\">剑指 Offer II 063. 替换单词</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-064-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">剑指 Offer II 064. 神奇的字典</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-065-%E6%9C%80%E7%9F%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E7%BC%96%E7%A0%81\"><span class=\"toc-text\">剑指 Offer II 065. 最短的单词编码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-066-%E5%8D%95%E8%AF%8D%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">剑指 Offer II 066. 单词之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-067-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96\"><span class=\"toc-text\">剑指 Offer II 067. 最大的异或</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-070-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\"><span class=\"toc-text\">剑指 Offer II 070. 排序数组中只出现一次的数字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-071-%E6%8C%89%E6%9D%83%E9%87%8D%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0\"><span class=\"toc-text\">剑指 Offer II 071. 按权重生成随机数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-073-%E7%8B%92%E7%8B%92%E5%90%83%E9%A6%99%E8%95%89\"><span class=\"toc-text\">剑指 Offer II 073. 狒狒吃香蕉</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-074-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">剑指 Offer II 074. 合并区间</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-079-%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86\"><span class=\"toc-text\">剑指 Offer II 079. 所有子集</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-080-%E5%90%AB%E6%9C%89-k-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88\"><span class=\"toc-text\">剑指 Offer II 080. 含有 k 个元素的组合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-081-%E5%85%81%E8%AE%B8%E9%87%8D%E5%A4%8D%E9%80%89%E6%8B%A9%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%84%E5%90%88\"><span class=\"toc-text\">剑指 Offer II 081. 允许重复选择元素的组合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-082-%E5%90%AB%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%84%E5%90%88\"><span class=\"toc-text\">剑指 Offer II 082. 含有重复元素集合的组合</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-083-%E6%B2%A1%E6%9C%89%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E9%9B%86%E5%90%88%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97\"><span class=\"toc-text\">剑指 Offer II 083. 没有重复元素集合的全排列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-116-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F\"><span class=\"toc-text\">剑指 Offer II 116. 省份数量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-090-%E7%8E%AF%E5%BD%A2%E6%88%BF%E5%B1%8B%E5%81%B7%E7%9B%97\"><span class=\"toc-text\">剑指 Offer II 090. 环形房屋偷盗</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-092-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6\"><span class=\"toc-text\">剑指 Offer II 092. 翻转字符</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-093-%E6%9C%80%E9%95%BF%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\"><span class=\"toc-text\">剑指 Offer II 093. 最长斐波那契数列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-095-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">剑指 Offer II 095. 最长公共子序列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-100-%E4%B8%89%E8%A7%92%E5%BD%A2%E4%B8%AD%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">剑指 Offer II 100. 三角形中最小路径之和</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-101-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86\"><span class=\"toc-text\">剑指 Offer II 101. 分割等和子集</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-102-%E5%8A%A0%E5%87%8F%E7%9A%84%E7%9B%AE%E6%A0%87%E5%80%BC\"><span class=\"toc-text\">剑指 Offer II 102. 加减的目标值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-103-%E6%9C%80%E5%B0%91%E7%9A%84%E7%A1%AC%E5%B8%81%E6%95%B0%E7%9B%AE\"><span class=\"toc-text\">剑指 Offer II 103. 最少的硬币数目</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-105-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF\"><span class=\"toc-text\">剑指 Offer II 105. 岛屿的最大面积</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-II-106-%E4%BA%8C%E5%88%86%E5%9B%BE\"><span class=\"toc-text\">剑指 Offer II 106. 二分图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">剑指 Offer 06. 从尾到头打印链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97\"><span class=\"toc-text\">剑指 Offer 09. 用两个栈实现队列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-14-I-%E5%89%AA%E7%BB%B3%E5%AD%90\"><span class=\"toc-text\">剑指 Offer 14- I. 剪绳子</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">剑指 Offer 24. 反转链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">剑指 Offer 26. 树的子结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91\"><span class=\"toc-text\">剑指 Offer 28. 对称的二叉树</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88\"><span class=\"toc-text\">剑指 Offer 30. 包含min函数的栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">剑指 Offer 31. 栈的压入、弹出序列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">剑指 Offer 34. 二叉树中和为某一值的路径</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">剑指 Offer 35. 复杂链表的复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">剑指 Offer 36. 二叉搜索树与双向链表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0\"><span class=\"toc-text\">剑指 Offer 45. 把数组排成最小的数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">剑指 Offer 46. 把数字翻译成字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0\"><span class=\"toc-text\">剑指 Offer 41. 数据流中的中位数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">剑指 Offer 48. 最长不含重复字符的子字符串</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-49-%E4%B8%91%E6%95%B0\"><span class=\"toc-text\">剑指 Offer 49. 丑数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0\"><span class=\"toc-text\">剑指 Offer 60. n个骰子的点数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-64-%E6%B1%821-2-%E2%80%A6-n\"><span class=\"toc-text\">剑指 Offer 64. 求1+2+…+n</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"常用命令","uid":"a5f30086118eef4097b37f892ce916b2","slug":"常用命令","date":"2022-04-11T13:18:09.000Z","updated":"2022-04-11T13:21:13.824Z","comments":true,"path":"api/articles/常用命令.json","keywords":null,"cover":null,"text":"Dockerdocker search [镜像名称] # 搜索镜像 docker pull [镜像名称[:版本号]] # 拉取镜像 docker images # 查看本地镜像 docker exec -it [redis] bash # 以命令行形式进入容器内部 docker ...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"常用命令","slug":"常用命令","count":1,"path":"api/categories/常用命令.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"},{"name":"Docker","slug":"Docker","count":1,"path":"api/tags/Docker.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"东野圭吾选摘","uid":"cd32aca21f1fb5eccdd0b0a556926460","slug":"东野圭吾选摘","date":"2022-04-08T08:06:49.000Z","updated":"2022-04-08T08:36:06.423Z","comments":true,"path":"api/articles/东野圭吾选摘.json","keywords":null,"cover":[],"text":"东野圭吾摘选东野圭吾 虚无的十字架“我看男人太没眼光了，只是因为憧憬结婚，没想到一步错，步步错。” 任何事只从单方面观察，都无法把握真相。 到底有谁可以断言，“这个杀人凶手只要在监狱关多少多少年，就可以改邪归正”，把杀人凶手绑在这种虚无的十字架上，到底有什么意义？ 事到如今，她终...","link":"","photos":[],"count_time":{"symbolsCount":"2.9k","symbolsTime":"3 mins."},"categories":[{"name":"文摘","slug":"文摘","count":3,"path":"api/categories/文摘.json"}],"tags":[{"name":"东野圭吾","slug":"东野圭吾","count":1,"path":"api/tags/东野圭吾.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}