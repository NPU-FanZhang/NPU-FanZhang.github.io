{"title":"Mysql","uid":"7f77c660cadf02b64dd36120e903f5f0","slug":"Mysql","date":"2022-04-07T06:17:50.000Z","updated":"2022-08-31T11:34:19.031Z","comments":true,"path":"api/articles/Mysql.json","keywords":null,"cover":"/svg/mysql.svg","content":"<h1 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h1><p>MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。</p>\n<img src=\"Mysql/%E4%B8%8B%E8%BD%BD.png\" alt=\"下载\" style=\"zoom: 33%;\" />\n\n<p>一条SQL语句的执行流程如下:</p>\n<ol>\n<li><p><strong>建立连接</strong>。先连接到这个数据库上，这时候接待你的就是<strong>连接器</strong>。<strong>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</strong></p>\n<p>在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。</p>\n<ul>\n<li>如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。</li>\n<li>如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。</li>\n</ul>\n<p>这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>\n<hr>\n</li>\n<li><p><strong>查询缓存</strong>。连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：<strong>查询缓存</strong>。</p>\n<p>​    MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之**前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。&#96;key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>\n<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>\n<p>​    查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表。</p>\n<p>需要注意的是，&#96;MySQL 8.0 版本直接将查询缓存的整块功能删掉了**，也就是说 8.0 开始彻底没有这个功能了。</p>\n<hr>\n</li>\n<li><p><strong>语法分析。</strong>如果没有命中查询缓存，就要开始真正执行语句了。</p>\n<p>首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</p>\n<p>你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。</p>\n<p>做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p>\n<hr>\n</li>\n<li><p><strong>语法优化</strong>。<strong>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</strong></p>\n<p>所有的现代数据库都在用<strong>基于成本的优化</strong>（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。<strong>对于联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I&#x2F;O 成本、和内存需求</strong>。</p>\n<p>优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</p>\n<hr>\n</li>\n<li><p>&#96;SQl执行**。</p>\n<p><strong>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限</strong>，如果没有，就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限。</p>\n<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>\n<pre class=\"line-numbers language-mysql\" data-language=\"mysql\"><code class=\"language-mysql\">mysql&gt; select * from T where ID&#x3D;10;</code></pre>\n\n<p>比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>\n<ol>\n<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>\n<li>调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。</li>\n<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>\n</ol>\n<p>至此，这个语句就执行完成了。</p>\n<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。</p>\n<hr>\n</li>\n<li><p><strong>日志记录</strong>。日志记录是数据的一个重要组成部分，这是DBA进行恢复，查错，优化的主要依据。</p>\n<p>日志记录在更新操作上显得尤为重要，Mysql有两个主要日志：&#96;redo log（重做日志）和 binlog（归档日志）**</p>\n<p><code>a. redo Log</code></p>\n<p>举个例子来介绍一下日志的记录方式，如果有人要赊账或者还账的话，掌柜一般有两种做法：</p>\n<ul>\n<li>一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；</li>\n<li><strong>另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。</strong></li>\n</ul>\n<p>在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。</p>\n<p>这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。</p>\n<p>​    而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 &#96;WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。**</p>\n<p>​    当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。</p>\n<p>​    InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。</p>\n<img src=\"Mysql/%E4%B8%8B%E8%BD%BD%20(1).png\" alt=\"下载 (1)\" style=\"zoom: 50%;\" />\n\n<p>有了 redo log，InnoDB 就可以保<strong>证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为</strong>crash-safe<strong>。</strong></p>\n<p><code>b. BinLog</code></p>\n<p>​    上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>\n<p>​    <strong>最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。</strong>而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>\n<p>这两种日志有以下三点不同。</p>\n<ol>\n<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>\n<li><code>redo log 是物理日志**，记录的是“在某个数据页上做了什么修改”；</code>binlog 是逻辑日志**，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>\n<li><code>redo log 是循环写的，空间固定会用完**；</code>binlog 是可以追加写入的**。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>\n</ol>\n<p>以一条更新或插入记录为例,日志的写过程如下:</p>\n<ol>\n<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面<strong>，此时 redo log 处于 prepare 状态。</strong>然后告知执行器执行完成了，随时可以提交事务。</li>\n<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>\n<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 &#96;redo log 改成提交（commit）状态**，更新完成。</li>\n</ol>\n<p>将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是****”两阶段提交”****。</p>\n<p>为什么必须有“两阶段提交”呢？</p>\n<p>这是为了让两份日志之间的逻辑一致。由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。如果当一个日志写完之后,而另外一个未写完,那么就会造成数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>\n</li>\n</ol>\n<h1 id=\"2-事务隔离\"><a href=\"#2-事务隔离\" class=\"headerlink\" title=\"2. 事务隔离\"></a>2. 事务隔离</h1><p>事务的四个特性: ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>\n<ul>\n<li><p><strong>原子性</strong>: 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p>\n<p>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p>\n</li>\n<li><p><strong>一致性</strong>: 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p>\n</li>\n<li><p><strong>隔离性</strong>: 一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p>\n</li>\n<li><p><strong>持久性</strong>: 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p>\n<p>可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。</p>\n</li>\n</ul>\n<hr>\n<p>主要讲事务的隔离性。</p>\n<p>​    <strong>隔离得越严实，效率就会越低。</strong>因此很多时候，我们都要在二者之间寻找一个平衡点。&#96;SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。**</p>\n<ul>\n<li>读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。</li>\n<li>读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。</li>\n<li>可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>\n<li>串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li>\n</ul>\n<p><strong>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</strong></p>\n<p>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</p>\n<p>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</p>\n<p>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</p>\n<p>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</p>\n<hr>\n<p>为什么建议你尽量不要使用长事务。</p>\n<p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p>\n<h3 id=\"实现事务隔离的原理\"><a href=\"#实现事务隔离的原理\" class=\"headerlink\" title=\"实现事务隔离的原理\"></a>实现事务隔离的原理</h3><p><strong>InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。</strong></p>\n<p>InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。</p>\n<ul>\n<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li>\n<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>\n</ul>\n<p>而当前读，总是读取已经提交完成的最新版本。</p>\n<p>你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。</p>\n<h1 id=\"3-索引\"><a href=\"#3-索引\" class=\"headerlink\" title=\"3. 索引\"></a>3. 索引</h1><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是<strong>哈希表、有序数组和搜索树。</strong></p>\n<p>a. <strong>哈希表</strong></p>\n<p><strong>哈希表这种结构适用于只有</strong>等值查询<strong>的场景</strong>，比如 Memcached 及其他一些 NoSQL 引擎。</p>\n<p>b. <strong>有序数组</strong></p>\n<p><strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>\n<p><strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>\n<p>c. <strong>搜索树</strong></p>\n<p><strong>二叉搜索树的查询复杂度是 $O(log_2(N))$</strong> ，为了保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。 <strong>二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</strong></p>\n<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。</p>\n<p><strong>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。</strong>考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>\n<h2 id=\"a-InnoDB-的索引模型\"><a href=\"#a-InnoDB-的索引模型\" class=\"headerlink\" title=\"a. InnoDB 的索引模型\"></a>a. InnoDB 的索引模型</h2><p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，&#96;InnoDB 使用了 B+ 树索引模型**，所以数据都是存储在 B+ 树中的。</p>\n<p>索引类型分为<strong>主键索引</strong>和<strong>非主键索引</strong>。</p>\n<p>主键索引的叶子节点存的是整行数据。在 InnoDB 里，<strong>主键索引也被称为聚簇索引</strong>（clustered index）。</p>\n<p>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，<strong>非主键索引也被称为二级索引</strong>（secondary index）。</p>\n<p>根据上面的索引结构说明，我们来讨论一个问题：<strong>基于主键索引和普通索引的查询有什么区别？</strong></p>\n<ul>\n<li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li>\n<li>如果语句是 select * from T where k&#x3D;5，即<strong>普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</strong></li>\n</ul>\n<p><strong>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>\n<h3 id=\"1-覆盖索引\"><a href=\"#1-覆盖索引\" class=\"headerlink\" title=\"1. 覆盖索引\"></a>1. 覆盖索引</h3><p>由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>\n<p>也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>\n<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>\n<hr>\n<h3 id=\"2-最左前缀\"><a href=\"#2-最左前缀\" class=\"headerlink\" title=\"2. 最左前缀\"></a>2. 最左前缀</h3><p><strong>B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong>关于最左前缀,看下面这个例子:</p>\n<img src=\"Mysql/%E4%B8%8B%E8%BD%BD.jpg\" alt=\"下载\" style=\"zoom:33%;\" />\n\n<ul>\n<li>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</li>\n<li>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</li>\n</ul>\n<hr>\n<h3 id=\"3-索引下推\"><a href=\"#3-索引下推\" class=\"headerlink\" title=\"3. 索引下推\"></a>3. 索引下推</h3><p>在不得不回表时,如果查询语句对联合索引上的其他字段有特别约束,可以先进行筛选再回表。</p>\n<h2 id=\"b-索引选择和实践\"><a href=\"#b-索引选择和实践\" class=\"headerlink\" title=\"b. 索引选择和实践\"></a>b. 索引选择和实践</h2><p>普通索引和唯一索引应该怎么选择。其实，<strong>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。</strong>所以，我建议你<strong>尽量选择普通索引。</strong></p>\n<p>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。</p>\n<p>需要说明的是，<strong>虽然名字叫作 change buffer，实际上它是可以持久化的数据。</strong>也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。</p>\n<p>如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。</p>\n<p>在实际使用中，你会发现，<strong>普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。</strong></p>\n<p>创建索引可以使用的方式有：</p>\n<ol>\n<li>直接创建完整索引，这样可能比较占用空间；</li>\n<li>创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；</li>\n<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>\n<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>\n</ol>\n<p>在实际应用中，你要根据业务字段的特点选择使用哪种方式。</p>\n<h1 id=\"4-锁\"><a href=\"#4-锁\" class=\"headerlink\" title=\"4. 锁\"></a>4. 锁</h1><p><strong>根据加锁的范围，MySQL 里面的锁大致可以分成</strong>全局锁<strong>、</strong>表级锁<strong>和</strong>行锁<strong>三类</strong>。</p>\n<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p>\n<p>但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p>\n<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>\n<h2 id=\"a-全局锁\"><a href=\"#a-全局锁\" class=\"headerlink\" title=\"a. 全局锁\"></a>a. 全局锁</h2><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 &#96;Flush tables with read lock (FTWRL)**。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的写语句会被阻塞。</p>\n<p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。</p>\n<p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。</p>\n<p>但是让整库都只读，听上去就很危险：</p>\n<ul>\n<li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li>\n<li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li>\n</ul>\n<h2 id=\"b-表级锁\"><a href=\"#b-表级锁\" class=\"headerlink\" title=\"b. 表级锁\"></a>b. 表级锁</h2><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>\n<p><strong>表锁的语法是 <code>lock tables … read/write</code>。</strong>与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</p>\n<p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p>\n<p><strong>另一类表级的锁是 MDL（metadata lock)。</strong>&#96;MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。**你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。</p>\n<ul>\n<li><strong>读锁之间不互斥</strong>，因此你可以有多个线程同时对一张表增删改查。</li>\n<li><strong>读写锁之间、写锁之间是互斥的</strong>，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li>\n</ul>\n<h2 id=\"c-行锁\"><a href=\"#c-行锁\" class=\"headerlink\" title=\"c. 行锁\"></a>c. 行锁</h2><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p>\n<h4 id=\"1-两阶段锁\"><a href=\"#1-两阶段锁\" class=\"headerlink\" title=\"1. 两阶段锁\"></a>1. 两阶段锁</h4><p>加锁和解锁分为两个阶段进行。</p>\n<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>\n<p><strong>如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</strong></p>\n<p>两段锁协议可能会造成死锁。</p>\n<p>我们可以主动进行死锁检测，主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。死锁检测要耗费大量的 CPU 资源。</p>\n<p>减少死锁的方案：</p>\n<ul>\n<li><p><strong>如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</strong></p>\n</li>\n<li><p><strong>控制并发度</strong></p>\n</li>\n<li><p>将一行改成逻辑上的多行来减少锁冲突。</p>\n</li>\n</ul>\n","text":"1. 概述MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。 一条SQL语句的执行流程如下: 建立连接。先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。 在完成经典的 ...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"},{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. 概述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">2. 事务隔离</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">实现事务隔离的原理</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">3. 索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-InnoDB-%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">a. InnoDB 的索引模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">1. 覆盖索引</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80\"><span class=\"toc-text\">2. 最左前缀</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8\"><span class=\"toc-text\">3. 索引下推</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E5%92%8C%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">b. 索引选择和实践</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-%E9%94%81\"><span class=\"toc-text\">4. 锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E5%85%A8%E5%B1%80%E9%94%81\"><span class=\"toc-text\">a. 全局锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E8%A1%A8%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">b. 表级锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E8%A1%8C%E9%94%81\"><span class=\"toc-text\">c. 行锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81\"><span class=\"toc-text\">1. 两阶段锁</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"JUC","date":"2022-04-07T12:19:18.000Z","updated":"2022-08-31T12:01:16.910Z","comments":true,"path":"api/articles/JUC.json","keywords":null,"cover":[],"text":"1. JUC 概述所谓JUC是 java.util.concurrent 工具包的简称，这是一个处理线程的工具包，可以实现程序的多线程高并发。 多线程编程的一般步骤: 创建资源类,在资源类创建属性和操作方法。 在资源类操作方法:判断、操作、通知 创建多个线程，调用资源类的操作方法...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{}}