{"title":"TCP/IP面试题","uid":"c975c593c9f6a4e28b749c03dfbcdd4c","slug":"TCP-IP面试题","date":"2022-08-10T03:00:16.000Z","updated":"2022-08-15T13:25:39.107Z","comments":true,"path":"api/articles/TCP-IP面试题.json","keywords":null,"cover":[],"content":"<h2 id=\"TCP-x2F-IP面试题\"><a href=\"#TCP-x2F-IP面试题\" class=\"headerlink\" title=\"TCP&#x2F;IP面试题\"></a>TCP&#x2F;IP面试题</h2><h4 id=\"1-什么是网络分层-OSI和TCP-x2F-IP模型分别是如何分层的\"><a href=\"#1-什么是网络分层-OSI和TCP-x2F-IP模型分别是如何分层的\" class=\"headerlink\" title=\"1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?\"></a>1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?</h4><p>网络为什么要分层？因为，是个复杂的程序都要分层。</p>\n<img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/src=http%253A%252F%252Fwww.pianshen.com%252Fimages%252F44%252F59add44f6248965818a317c82b695f8c.png&refer=http%253A%252F%252Fwww.pianshen-16601212288533.jpeg\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<p>OSI网络模型包括7层:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层</code></pre>\n\n<p>TCP&#x2F;IP模型将实际应用中较为紧密的几层合并在了一起,</p>\n<ul>\n<li>将 <code>物理层和数据链路层合并为网络接口层</code></li>\n<li>将 <code>会话层表示层应用层合并为应用层</code></li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">网络接口层-&gt; 网络层(IP&#x2F;ICMP&#x2F;IGMP&#x2F;ARP&#x2F;RARP)-&gt;传输层(TCP&#x2F;UDP)-&gt;应用层</code></pre>\n\n\n\n<h4 id=\"2-UCP协议报文结构\"><a href=\"#2-UCP协议报文结构\" class=\"headerlink\" title=\"2. UCP协议报文结构\"></a>2. UCP协议报文结构</h4><p>UDP是一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。提供面向事务的简单不可靠信息传送服务。</p>\n<img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220810150027.png\" alt=\"微信截图_20220810150027\" style=\"zoom:67%;\" />\n\n<p>UDP协议的特点:</p>\n<ul>\n<li>UDP提供了<strong>无连接通信</strong>，且不对传送数据包进行可靠性保证，适合于一次传输少量数据，<code>UDP传输的可靠性由应用层负责。</code></li>\n<li>UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并。</li>\n<li>常用的UDP端口号有：<strong>53（DNS）</strong>、69（TFTP）、161（SNMP）</li>\n<li>使用UDP协议包括：TFTP、SNMP、NFS、DNS、BOOTP。</li>\n</ul>\n<h4 id=\"3-TCP协议报文\"><a href=\"#3-TCP协议报文\" class=\"headerlink\" title=\"3. TCP协议报文\"></a>3. TCP协议报文</h4><p>TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，该协议称为<code>传输控制协议（TCP，Transmission Control Protocol）</code></p>\n<img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220810170619.png\" alt=\"微信截图_20220810170619\" style=\"zoom: 80%;\" />\n\n<p>TCP协议的主要特点:</p>\n<ul>\n<li>面向连接；</li>\n<li>可靠通信方式；</li>\n<li>基于流的方式；</li>\n<li>在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销；</li>\n<li>通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。</li>\n</ul>\n<p>为了满足可靠,高效的传输,TCP协议提供以下的策略:</p>\n<ul>\n<li><code>数据分片</code>：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；</li>\n<li><code>到达确认</code>：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；</li>\n<li><code>超时重发</code>：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；</li>\n<li><code>滑动窗口</code>：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，<strong>TCP在滑动窗口的基础上提供流量控制</strong>，防止较快主机致使较慢主机的缓冲区溢出；</li>\n<li><code>失序处理</code>：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；</li>\n<li><code>重复处理</code>：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；</li>\n<li><code>数据校验</code>：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发。</li>\n</ul>\n<h4 id=\"4-IP协议报文\"><a href=\"#4-IP协议报文\" class=\"headerlink\" title=\"4. IP协议报文\"></a>4. IP协议报文</h4><p>IP协议，Internet Protocol ，互联网协议，IP协议<strong>位于网络层</strong>，主要目的是使得网络间能互联通信。</p>\n<p>IP是TCP&#x2F;IP协议族中的核心协议，所有TCP、UDP、ICMP和IGMP数据都是通过IP数据报传输。它为上层提供<code>无状态、无连接、不可靠</code>的服务</p>\n<img src=\"/post/TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/1610045-20200215111054329-2097982803.png\" class=\"\" title=\"img\">\n\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">- 版本号：4bit 指IP协议所使用的版本。版本号为0100，4，即IPv4，版本号为6，即IPv6\n- IP首部长度：4bit 表示IP包头长度，该字段用4位表示。最常见的报头长度是0101即20位，当IP报头长度不是4字节整数倍时，就需要对填充域填充\n- 区分服务: 8bit 现在一般用于支持QoS中差分服务模型，实现网络流量优化\n- 总长度：16bit 指IPv4数据报的总长度。数据报的最大长度为：2*16-1&#x3D;65535字节，当IP数据报超过最大传输单元MTU后，会被分片处理\n- 标识符：16bit 网络中转发的IP报文的长度可以不同，但如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个小的片段才能在链路上传输。将报文分割成多个片段的过程叫做分片主机将数据报分片后，在发送前，会给每一个分片数据报一个ID值，放在16位的标识符字段中。\n- 标志位：3bit 标志字段在IP报头中占3位，\n\t- 第1位作为保留，置0;\n\t- 第2位，分段，有两个不同的取值：该位置0，表示可以分段;该位置1，表示不能分段;\n\t- 第3位，更多分段，同样有两个取值：该位置0，表示这是数据流中的最后一个分段，该位置1，表示数据流未完，后续还有\n- 偏移量：13bit 各个IP分片数据报在发送到目的主机时可能是无序的，所以就需要“偏移量”字段来指明“该分片在原数据报中的位置顺序”\n- 生存时间: 8bit 数据报到达目的地的最大报文跳数,一般为64,每次经过一个路由，TTL–，如果TTL &#x3D;&#x3D; 0时还没到达目的地，那么这个报文就会被丢弃。这个字段主要是为了防止出现路由循环，数据包在一个循环中一直转发，浪费网络资源。\n- 协议: 8bit 表示IP的上层是什么协议，我们熟知的TCP、UDP、ICMP等都是在IP上层的。\n- 首部校验和: 16bit 使用CRC进行校验，鉴别IP首部是否收到损坏，如果损坏直接丢弃，它只校验IP头部\n- 32位源IP地址（Source Address）：表示发送端的IP。\n- 32位目的IP地址（Destination Address）：表示接收端的IP。</code></pre>\n\n<p>IP协议的主要功能有两点: <code>IP信息包的传送</code>和<code>IP信息包的分割与重组。</code></p>\n<ul>\n<li>MTU（Maximum Transmission Unit最大传输单元）是在IP层下面的MAC协议中的概念，MAC协议我们可以理解为是物理层的一些协议，它位于IP协议的下层.因此每个MAC帧其实是IP协议首部 + IP层的有效载荷。</li>\n<li>而MAC帧是有长度限制的，所以就要求IP数据报向下交付时并不是随心所欲想发多长就发多长，如果MAC帧要求MTU为1500字节，而IP数据包总长度有2000字节，那么就需要分片，将原有的IP数据包分成两片，依次发送，对端的主机在接收后，由对端的IP层再完成组装。</li>\n</ul>\n<h4 id=\"5-TCP对比UDP\"><a href=\"#5-TCP对比UDP\" class=\"headerlink\" title=\"5. TCP对比UDP\"></a>5. TCP对比UDP</h4><ul>\n<li>UDP是无连接的;TCP是由连接的</li>\n<li>UDP是不可靠的;TCP是可靠的全双工信道;</li>\n<li>UDP无拥塞控制和流量控制;TCP有拥塞控制和流量控制</li>\n<li>UDP支持一对一,一对多通信;TCP只支持一对一</li>\n<li>UDP面向报文;TCP面向字节流</li>\n<li>UDP首部开销小8字节;TCP首部开销20~60字节</li>\n<li>UDP是无状态的;TCP是有状态的</li>\n</ul>\n<h4 id=\"6-TCP建立连接-–-三次握手\"><a href=\"#6-TCP建立连接-–-三次握手\" class=\"headerlink\" title=\"6. TCP建立连接 – 三次握手\"></a>6. TCP建立连接 – 三次握手</h4><img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220815152627491.png\" alt=\"image-20220815152627491\" style=\"zoom:67%;\" />\n\n<ol>\n<li><code>SYN=1; seq=x;</code> 客户端发送syn包(SYN&#x3D;1,seq&#x3D;x)到服务器，并进入SYN_SENT状态，等待服务器确认；</li>\n<li><code>ACK=1;SYN=1;ack=x+1;seq=y;</code> 服务器收到syn包，必须确认客户的SYN（ack&#x3D;x+1），同时自己也发送一个SYN包（seq&#x3D;y），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>\n<li><code>ACK=1;seq=x+1;ack=y+1;</code> 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;y+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ol>\n<p>​    <code>握手过程中传送的包里不包含数据，但是会在建立连接过程中确定的起始序列号seq。</code>为了防止重复，起始序号一般都是随即开始，并不是从1开始。</p>\n<p>​    三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>\n<h4 id=\"7-TCP断开连接-–-四次挥手\"><a href=\"#7-TCP断开连接-–-四次挥手\" class=\"headerlink\" title=\"7. TCP断开连接 – 四次挥手\"></a>7. TCP断开连接 – 四次挥手</h4><img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220815154825321.png\" alt=\"image-20220815154825321\" style=\"zoom:80%;\" />\n\n<ol>\n<li><code>FIN=1;seq=u;</code> 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。</li>\n<li><code>ACK=1;ack=u+1;seq=v;</code> 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。</li>\n<li>此时,主动方向被动方的数据信道已经关闭,但可以接收数据。</li>\n<li><code>FIN=1;seq=w;ACK=1;ack=u+1;</code> 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>\n<li><code>ACK=1;seq=u+1;ack=w+1;</code> 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。客户端进入<code>TIME_WAIT</code>（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间<code>2MSL</code>后，客户端才进入<code>CLOSED</code>状态。</li>\n</ol>\n<p>为什么TIME_WAIT要等待2MSL？</p>\n<ul>\n<li>保证客户端最后发送的ACK能够到达服务器，帮助其正常关闭。</li>\n</ul>\n<p>由于这个ACK报文段可能会丢失，使得处于LAST_ACK状态的服务器得不到对已发送FIN报文段的确认，从而会触发超时重传。服务器会重发FIN报文段，客户端能保证在2MSL时间内收到来自服务器的重传FIN报文段，从而客户端重新发送ACK应答报文段，并重置2MSL计数。</p>\n<p><code>假如客户端不等待2MSL就之间进入CLOSE状态，那么服务器会一直处于LAST_ACK状态。</code></p>\n<p>当客户端发起建立SYN报文段请求建立新的连接时，服务端会发送RST报文段给客户端，连接建立的过程就会被终止。</p>\n<ul>\n<li>防止已失效的连接请求报文段出现在本连接中。</li>\n</ul>\n<p>TIME_WAIT等待的2MSL时间，确保本连接内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p>\n<p><em>MSL(Maximum Segment LifeTime)是报文最大生成时间，它是任何报文在网络上存在的最长时间，超过这个时间的报文将被丢弃。2MSL时间是从客户端接收到FIN后发送ACK开始计时的。如果在这个时间段内，服务器没有收到ACK应答报文段，会重发FIN报文段，如果客户端收到了FIN报文段，那么2MSL的时间将会被重置。如果在2MSL时间段内，没有收到任何数据报，客户端则会进入CLOSE状态。</em></p>\n<h4 id=\"8-TCP协议的拥塞控制\"><a href=\"#8-TCP协议的拥塞控制\" class=\"headerlink\" title=\"8. TCP协议的拥塞控制\"></a>8. TCP协议的拥塞控制</h4><p>TCP进行拥塞控制的算法有四种，即<code>慢启动</code>、<code>拥塞避免</code>、<code>快重传</code>和<code>快恢复</code>。</p>\n<p>拥塞控制也叫作<code>基于窗口的拥塞控制</code>，为此，发送方维持一个叫做拥塞窗口cwnd(congestion window)的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且在动态的发生变化，发送方让自己的发送窗口等于拥塞窗口 (注：在这里我们假设接受方总是有足够大的缓存空间，因而发送窗口的大小取决于网络的拥塞程度，实际上真正的窗口值 &#x3D; min(接收方窗口，拥塞窗口)</p>\n<ol>\n<li><p>发送方又是如何知道网络中出现了拥塞呢？ </p>\n<p>​    我们知道，当网络中出现了拥塞时，路由器就要丢弃分组，因此只要发送方没有及时收到应当到达的确认报文，也就是说只要出现了超时，就可以猜想网络可能出现了拥塞，(现在通信线路的传输质量一般都很好，因传输出差错而丢弃的概率是很小的(远小于1%)) 因此，<code>判断网络拥塞的依据就是出现了超时。</code></p>\n</li>\n<li><p>如何慢启动?</p>\n<p>主机开始发送数据时，由于并不清楚网路的负荷情况，所以如果立即把大量数据字节注入到网络，那么就有可能引发网络发生拥塞。所以最好的方法是先探测一下，<code>即由小到大逐渐增大发送窗口，也就是说，由小到大(指数增大)逐渐增大拥塞窗口值</code>。</p>\n</li>\n<li><p>如何实现拥塞避免?</p>\n<img src=\"/post/TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220815192350462.png\" class=\"\" title=\"image-20220815192350462\"></li>\n</ol>\n<p><code>为了防止拥塞窗口cwnd增长过大引起网络拥塞</code>，还需要设置一个慢开始门限<code>ssthresh</code>状态变量，sshthresh的用法如下。</p>\n<ul>\n<li>当cwnd &lt; ssthresh时，使用上述的<code>慢开始</code>算法。</li>\n<li>当cwnd &gt; ssthresh时，<code>停止使用慢开始算法而改用拥塞避免算法</code>。</li>\n</ul>\n<p>让拥塞窗口cwnd缓慢的增大，每经过一个往返时间RTT就<code>把发送方的拥塞窗口+1</code>，<code>而不是像慢开始那样成倍的增加</code>。即<strong>加法增大</strong></p>\n<p><code>出现超时时说明网络拥塞!</code></p>\n<ul>\n<li>假设初始ssthresh为16，现在开始执行慢开始，</li>\n<li>当到cwnd &#x3D; 16时，改为拥塞避免算法,即加法增大</li>\n<li>假设当cwnd &#x3D; 24时，出现了网络拥塞，那么执行ssthresh乘法减小，即 ssthresh &#x3D; cwnd &#x2F; 2 &#x3D; 12，</li>\n<li>重新开始执行慢开始(cwnd &#x3D; 1),然后cwnd &#x3D; 12时开始执行拥塞避免。</li>\n</ul>\n<ol start=\"4\">\n<li>为什么要快重传?</li>\n</ol>\n<p><code>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失</code>。</p>\n<p>有时，个别报文段会在网络中丢失，但<code>实际上网络并未发生拥塞</code>，如果发送方迟迟收不到确认，就会产生超时，<code>就会误认为网络发生了拥塞</code>，就导致了上图中重新开始了慢开始，将拥塞窗口cwnd又设置为1，因而降低了传输效率。</p>\n<ol start=\"5\">\n<li>快重传的执行流程?</li>\n</ol>\n<ul>\n<li>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，<code>而是要立即发送确认</code>，即使收到了失序的报文段也要立即发出对已收到的报文段的<code>重复确认</code>。</li>\n</ul>\n<p>​    快重传算法规定，发送方只要一连收到3个重复确认，就知道接收方确实没有收到报文段M3，因而应该立即进行重传(即“快重传”)，这样就不会出现超时 (如果没有快重传，只要发生超时就执行门限ssthresh &#x2F; 2,然后慢开始) ，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的吞吐量提高约20%。</p>\n<ol start=\"6\">\n<li>快恢复执行过程?</li>\n</ol>\n<p>​    <code>当发送方连续收到三个重复确认，就执行快恢复算法，并把慢开始门限ssthresh减半。</code>这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p>\n<p>　　由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p>\n<p>​    在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p>\n<h4 id=\"9-HTTP1-0-x2F-1-1协议报\"><a href=\"#9-HTTP1-0-x2F-1-1协议报\" class=\"headerlink\" title=\"9. HTTP1.0&#x2F;1.1协议报\"></a>9. HTTP1.0&#x2F;1.1协议报</h4><p>HTTP协议报文格式如下</p>\n<img src=\"/post/TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220811200124734.png\" class=\"\" title=\"image-20220811200124734\">\n\n<p>HTTP请求报文:</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">GET &#x2F; HTTP&#x2F;1.1\nAccept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q&#x3D;0.9,zh-CN;q&#x3D;0.8,zh;q&#x3D;0.7\nHost: hackr.jp\nProxy-Connection: keep-alive\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;103.0.0.0 Safari&#x2F;537.36\n</code></pre>\n\n<p>HTTP返回报文</p>\n<pre class=\"line-numbers language-http\" data-language=\"http\"><code class=\"language-http\">HTTP&#x2F;1.1 200 OK\nDate: Thu, 11 Aug 2022 11:56:55 GMT\nServer: Apache\nLast-Modified: Tue, 08 Jan 2013 08:53:29 GMT\nETag: &quot;25e-4d2c3145df440-gzip&quot;\nAccept-Ranges: bytes\nVary: Accept-Encoding,User-Agent\nContent-Encoding: gzip\nContent-Length: 379\nConnection: close\nContent-Type: text&#x2F;html\nProxy-Connection: keep-alive</code></pre>\n\n\n\n<p>HTTP协议有以下特点:</p>\n<ul>\n<li>灵活可扩展:只规定了报文的基本格式，“header+body”等，报文里的各个组成部分都没有做严格的语法语义限制，可以由开发者任意定制。</li>\n<li>可靠传输：因为 HTTP 协议是基于 TCP&#x2F;IP 的，而 TCP 本身是一个“可靠”的传输协议，所以 HTTP 自然也就继承了这个特性，能够在请求方和应答方之间“可靠”地传输数据。</li>\n<li>应用层协议：HTTP 协议是一个应用层的协议。 HTTP 凭借着可携带任意头字段和实体数据的报文结构，以及连接控制、缓存代理等方便易用的特性，一出现就“技压群雄”，迅速成为了应用层里的“明星”协议。只要不太苛求性能，HTTP 几乎可以传递一切东西，满足各种需求，称得上是一个“万能”的协议。</li>\n<li>请求-应答：HTTP 协议使用的是请求 - 应答通信模式。通俗来讲就是“一发一收”，永远是请求方先发起连接和请求，是主动的，而应答方只有在收到请求后才能答复，是被动的，如果没有请求时不会有任何动作。</li>\n<li>无状态：HTTP 协议是无状态的。</li>\n</ul>\n<p>HTTP协议的优点与缺点:</p>\n<p>优点:</p>\n<ul>\n<li>最大的优点是简单、灵活和易于扩展</li>\n<li>成熟的软硬件环境，应用的非常广泛</li>\n<li>HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；</li>\n</ul>\n<p>缺点:</p>\n<ul>\n<li>明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；</li>\n<li>不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；</li>\n<li>性能不算差，但不完全适应现在的互联网，还有很大的提升空间。</li>\n</ul>\n<h4 id=\"10-HTTPS\"><a href=\"#10-HTTPS\" class=\"headerlink\" title=\"10. HTTPS\"></a>10. HTTPS</h4><img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220815193121476.png\" alt=\"image-20220815193121476\" style=\"zoom:80%;\" />\n\n<p>为什么要有 HTTPS？简单的回答是“<strong>因为 HTTP 不安全</strong>”。</p>\n<p>由于 HTTP 天生“明文”的特点，整个传输过程完全透明，任何人都能够在链路中截获、修改或者伪造请求 &#x2F; 响应报文，数据不具有可信性。</p>\n<ul>\n<li>HTTPS 的语法、语义仍然是 HTTP，但把下层的协议由 TCP&#x2F;IP 换成了 SSL&#x2F;TLS；</li>\n<li>通信安全必须同时具备机密性、完整性，身份认证和不可否认这四个特性；</li>\n</ul>\n<p>机密性实现:</p>\n<p>​    机密性的实现通过混合加密,也就是目前HTTPS采用的加密方式。把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</p>\n<p>​    核心就是先通过非对称加密传递对称加密需要的密钥，然后再使用对称加密进行密文的加密与传输。</p>\n<p>完整性实现:</p>\n<p>​    实现完整性的手段主要是<strong>摘要算法</strong>（Digest Algorithm），也就是常说的散列函数、哈希函数（Hash Function）。你可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。常用的算法是 SHA-2；</p>\n<ul>\n<li>身份认证和不可否认实现:</li>\n</ul>\n<p>数字签名是私钥对摘要的加密，可以由公钥解密后验证，实现身份认证和不可否认；公钥的分发需要使用数字证书，必须由 CA 的信任链来验证，否则就是不可信的；</p>\n<p>TLS 握手过程中的关键：</p>\n<ol>\n<li>HTTPS 协议会先与服务器执行 TCP 握手，然后执行 TLS 握手，才能建立安全连接；</li>\n<li>握手的目标是安全地交换对称密钥，需要三个随机数，第三个随机数“Pre-Master”必须加密传输，绝对不能让黑客破解；</li>\n<li>“Hello”消息交换随机数，“Key Exchange”消息交换“Pre-Master”；</li>\n<li>“Change Cipher Spec”之前传输的都是明文，之后都是对称密钥加密的密文。</li>\n</ol>\n<h4 id=\"11-HTTP2\"><a href=\"#11-HTTP2\" class=\"headerlink\" title=\"11. HTTP2\"></a>11. HTTP2</h4><p>由于 HTTPS 已经在安全方面做的非常好了，所以 HTTP&#x2F;2 的唯一目标就是改进性能。</p>\n<ol>\n<li><p>HTTP 协议取消了小版本号，所以 HTTP&#x2F;2 的正式名字不是 2.0；</p>\n</li>\n<li><p>HTTP&#x2F;2 在“语义”上兼容 HTTP&#x2F;1，保留了请求方法、URI 等传统概念；</p>\n</li>\n<li><p><code>HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；</code></p>\n<p>“HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。</p>\n</li>\n<li><p>HTTP&#x2F;2 的消息不再是“Header+Body”的形式，而是分散为多个<code>二进制“帧”；</code></p>\n<img src=\"TCP-IP%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220815194716370.png\" alt=\"image-20220815194716370\" style=\"zoom:50%;\" />\n</li>\n<li><p>HTTP&#x2F;2 <code>使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”</code>，提高连接的利用率；</p>\n<ul>\n<li>流是可并发的，一个 HTTP&#x2F;2 连接上可以同时发出多个流传输数据，也就是并发多请求，实现“多路复用”；</li>\n<li>客户端和服务器都可以创建流，双方互不干扰；</li>\n<li>流是双向的，一个流里面客户端和服务器都可以发送或接收数据帧，也就是一个“请求 - 应答”来回；</li>\n<li>流之间没有固定关系，彼此独立，但流内部的帧是有严格顺序的；</li>\n</ul>\n</li>\n<li><p>HTTP&#x2F;2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。</p>\n</li>\n</ol>\n","feature":true,"text":"TCP&#x2F;IP面试题1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?网络为什么要分层？因为，是个复杂的程序都要分层。 OSI网络模型包括7层: 物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":12,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":2,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"计算机网络","slug":"计算机网络","count":1,"path":"api/tags/计算机网络.json"},{"name":"TCP/IP","slug":"TCP-IP","count":1,"path":"api/tags/TCP-IP.json"},{"name":"HTTP","slug":"HTTP","count":1,"path":"api/tags/HTTP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#TCP-x2F-IP%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">TCP&#x2F;IP面试题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82-OSI%E5%92%8CTCP-x2F-IP%E6%A8%A1%E5%9E%8B%E5%88%86%E5%88%AB%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%86%E5%B1%82%E7%9A%84\"><span class=\"toc-text\">1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-UCP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. UCP协议报文结构</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-TCP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">3. TCP协议报文</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-IP%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87\"><span class=\"toc-text\">4. IP协议报文</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-TCP%E5%AF%B9%E6%AF%94UDP\"><span class=\"toc-text\">5. TCP对比UDP</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-TCP%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-%E2%80%93-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">6. TCP建立连接 – 三次握手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-%E2%80%93-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">7. TCP断开连接 – 四次挥手</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6\"><span class=\"toc-text\">8. TCP协议的拥塞控制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#9-HTTP1-0-x2F-1-1%E5%8D%8F%E8%AE%AE%E6%8A%A5\"><span class=\"toc-text\">9. HTTP1.0&#x2F;1.1协议报</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#10-HTTPS\"><span class=\"toc-text\">10. HTTPS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#11-HTTP2\"><span class=\"toc-text\">11. HTTP2</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Mysql 面试题","uid":"4d0cd99506fa5ed9a6631a984ab7b868","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","updated":"2022-08-10T08:00:49.327Z","comments":true,"path":"api/articles/Mysql 面试题.json","keywords":null,"cover":[],"text":"Mysql 面试题1. B树和B+树的区别?相同点: 都是多路平衡查找树 一个节点中都有多个元素,且有序 不同点: B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中； B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":12,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":2,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"},{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2022-08-09T11:23:04.463Z","updated":"2022-08-10T02:38:24.899Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the ...","link":"","photos":[],"count_time":{"symbolsCount":440,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}