{"title":"Java Visual Machine","uid":"fc14e6deadca9621a12ce14639191e3e","slug":"Java-Visual-Machine","date":"2022-04-07T12:46:48.000Z","updated":"2022-04-08T02:20:00.290Z","comments":true,"path":"api/articles/Java-Visual-Machine.json","keywords":null,"cover":[],"content":"<h1 id=\"JVM-Java-Visual-Machine\"><a href=\"#JVM-Java-Visual-Machine\" class=\"headerlink\" title=\"JVM(Java Visual Machine)\"></a>JVM(Java Visual Machine)</h1><blockquote><p>JVM java二进制字节码运行的环境</p>\n<p>JVM 是java程序可移植性的基石。</p></blockquote>\n<p>好处:</p>\n<ul>\n<li><p>一次编译，到处执行</p>\n</li>\n<li><p>自动内存管理</p>\n</li>\n<li><p>常见错误检查（数组越界检查）</p>\n</li>\n</ul>\n<p>JVM组成部分</p>\n<ul>\n<li>JVM内存结构</li>\n<li>字节码结构</li>\n<li>Java类加载机制</li>\n<li>GC垃圾回收</li>\n</ul>\n<img src=\"/post/Java-Visual-Machine/jvm-overview.png\" class=\"\" title=\"img\">\n\n<img src=\"/post/Java-Visual-Machine/java-jvm-overview.png\" class=\"\" title=\"img\">\n\n<h2 id=\"1-JVM的内存结构\"><a href=\"#1-JVM的内存结构\" class=\"headerlink\" title=\"1. JVM的内存结构\"></a>1. JVM的内存结构</h2><p>JVM 运行时数据区的分类：</p>\n<img src=\"/post/Java-Visual-Machine/007S8ZIlly1gg9kuge8ovj32150tt7cd.jpg\" class=\"\" title=\"img\">\n\n<p>JVM 运行时数据区的结构：</p>\n<img src=\"/post/Java-Visual-Machine/0082zybply1gc6fz21n8kj30u00wpn5v.jpg\" class=\"\" title=\"jvm-framework\">\n\n<ul>\n<li><strong>线程私有</strong>：程序计数器、虚拟机栈、本地方法区</li>\n<li><strong>线程共享</strong>：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）</li>\n</ul>\n<h3 id=\"a-程序计数器\"><a href=\"#a-程序计数器\" class=\"headerlink\" title=\"a. 程序计数器\"></a>a. 程序计数器</h3><blockquote><p>Program Counter Register 程序计数器 (寄存器)</p></blockquote>\n<ul>\n<li>作用:用于保存JVM中下一条所要执行的指令的地址</li>\n<li>特点<ul>\n<li>线程私有<ul>\n<li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li>\n<li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li>\n</ul>\n</li>\n<li>不会存在内存溢出</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"b-虚拟机栈\"><a href=\"#b-虚拟机栈\" class=\"headerlink\" title=\"b. 虚拟机栈\"></a>b. 虚拟机栈</h3><ul>\n<li><p>每个<code>线程</code>运行需要的内存空间，称为<strong>虚拟机栈</strong></p>\n</li>\n<li><p>每个栈由多个<code>栈帧Frame</code>组成，对应着每次调用方法时所占用的内存</p>\n<ul>\n<li>每个栈帧保存着 <code>方法的参数</code>、<code>局部  变量</code>、<code>返回地址</code></li>\n</ul>\n<img src=\"/post/Java-Visual-Machine/image-20220307194959486.png\" class=\"\" title=\"image-20220307194959486\">\n</li>\n<li><p>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong>，对应着栈顶的栈帧。</p>\n</li>\n</ul>\n<p><em><strong>问题辨析</strong></em></p>\n<ul>\n<li>垃圾回收是否涉及栈内存？<ul>\n<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>\n</ul>\n</li>\n<li>栈内存的分配越大越好吗？<ul>\n<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>\n<li>可以使用 <code>-Xss 1M</code> 来指定栈内存大小</li>\n</ul>\n</li>\n<li>方法内的局部变量是否是线程安全的？<ul>\n<li>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<code>线程安全</code>的，因为每个方法都有自己的栈帧，有自己的局部变量内存。</li>\n<li>如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</li>\n</ul>\n</li>\n</ul>\n<p><em><strong>内存溢出</strong></em></p>\n<p><code>Java.lang.stackOverflowError</code> 栈内存溢出</p>\n<p>发生原因</p>\n<ul>\n<li>虚拟机栈中，<strong>栈帧过多</strong>（无限递归）</li>\n<li>每个栈帧<strong>所占用过大</strong></li>\n</ul>\n<p><em><strong>线程运行诊断</strong></em></p>\n<p>CPU占用过高</p>\n<ul>\n<li><p>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程</p>\n<ul>\n<li><strong>top命令，查看是哪个进程</strong>占用CPU过高</li>\n<li><code>ps H -eo pid, tid（线程id）, %cpu | grep [刚才通过top查到的进程号]</code>通过ps命令进一步查看是哪个线程占用CPU过高</li>\n<li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li>\n</ul>\n</li>\n</ul>\n<p>程序长时间计算不出结果</p>\n<ul>\n<li>可能是进程死锁,同样也可以用 <strong>jstack 进程id</strong>  来进行排查</li>\n</ul>\n<h3 id=\"c-本地方法栈\"><a href=\"#c-本地方法栈\" class=\"headerlink\" title=\"c. 本地方法栈\"></a>c. 本地方法栈</h3><p>​    一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法，非常多。</p>\n<h3 id=\"d-堆\"><a href=\"#d-堆\" class=\"headerlink\" title=\"d. 堆\"></a>d. 堆</h3><p><strong>定义</strong></p>\n<p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p>\n<p><strong>特点</strong></p>\n<ul>\n<li><strong>所有线程共享</strong>，堆内存中的对象都需要<strong>考虑线程安全问题</strong></li>\n<li>有垃圾回收机制</li>\n</ul>\n<p><strong>堆内存溢出</strong></p>\n<pre class=\"line-numbers language-shell\" data-language=\"shell\"><code class=\"language-shell\">java.lang.OutofMemoryError ：java heap space. 堆内存溢出\n-Xmx8m  可以设置堆内存大小</code></pre>\n\n<p><strong>堆内存诊断</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">jps\njmap\njconsole\njvirsalvm</code></pre>\n\n\n\n<h3 id=\"e-方法区\"><a href=\"#e-方法区\" class=\"headerlink\" title=\"e. 方法区\"></a>e. 方法区</h3><p>  <strong>方法区（method area）</strong>只是 JVM 规范中定义的一个概念<strong>，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而</strong>永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。</p>\n<p>方法区用于存储已被虚拟机加载的<code>类型信息</code>、<code>常量</code>、<code>静态变量</code>、即时编译器编译后的<code>代码缓存</code>等。</p>\n<p>JDK8以后 取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中,使用元空间代替。</p>\n<p><strong>内存溢出</strong></p>\n<ul>\n<li>1.8以前会导致<strong>永久代</strong>内存溢出</li>\n<li>1.8以后会导致<strong>元空间</strong>内存溢出</li>\n</ul>\n<p><strong>常量池</strong></p>\n<p>常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</p>\n<p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p>\n<p>一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是<code>运行时常量池</code>。</p>\n<h3 id=\"StringTable-串池\"><a href=\"#StringTable-串池\" class=\"headerlink\" title=\"# StringTable 串池\"></a># StringTable 串池</h3><p>1、String table又称为String pool，字符串常量池，其存在于堆中(<strong>1.7之前存在于方法区(永久代)中,jdk1.7之后存放在堆中(因为永久代不常回收)</strong>)。最重要的一点，String table中存储的并不是String类型的对象，存储的而是指向String对象的索引，<strong>真实对象还是存储在堆中。</strong><br>2、此外String table里面不存在相同的两个字符串。<br>3、此外String对象调用intern()方法时，会先在String table中查找是否存在于该对象相同的字符串，若存在直接返回String table中字符串的引用，若不存在则在String table中创建一个与该对象相同的字符串。</p>\n<p><strong>特征</strong></p>\n<ul>\n<li>通过<code>HashTable</code>实现</li>\n<li>用来放字符串对象且里面的<strong>元素不重复</strong></li>\n<li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li>\n<li>利用串池的机制，来避免重复创建字符串对象</li>\n<li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></li>\n<li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li>\n<li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li>\n<li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li>\n<li>StringTable中的数据也会发生垃圾回收。</li>\n</ul>\n<p><strong>StringTable 性能调优</strong></p>\n<ul>\n<li>如果代码中常量较多,可以通过 <code>-XX:StringTableSize = 桶个数</code> 来扩大串池大小而大大加快程序访问速度。</li>\n<li>同样重复字符串较多时,也可以使用将其添加到串池来减少内存。</li>\n</ul>\n<p><strong>intern方法 1.6</strong></p>\n<p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>\n<ul>\n<li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li>\n<li>如果有该字符串对象，则放入失败</li>\n</ul>\n<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>\n<p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p>\n<p><strong>intern方法 1.8</strong></p>\n<p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p>\n<ul>\n<li>如果串池中没有该字符串对象，则放入成功</li>\n<li>如果有该字符串对象，则放入失败</li>\n</ul>\n<p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p>\n<p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p>\n<p>例子1</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 放入常量池中的串池 StringTable\nString s2 &#x3D; &quot;b&quot;; &#x2F;&#x2F; 放入常量池中的串池 StringTable\nString s3 &#x3D; &quot;ab&quot;;&#x2F;&#x2F; 放入常量池中的串池 StringTable\n\nString s4 &#x3D; s1 + s2; &#x2F;&#x2F;新建了对象 等价于下面这句话\n&#x2F;&#x2F; new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()\n&#x2F;&#x2F; new String(&quot;ab&quot;)\n\nString s5 &#x3D; &quot;a&quot; + &quot;b&quot;; &#x2F;&#x2F; 编译期优化 ,发现存在于常量池\nSystem.out.println(s3 ** s4); &#x2F;&#x2F; false\nSystem.out.println(s3 ** s5); &#x2F;&#x2F; true</code></pre>\n\n<p>例子2</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String x &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 此时串池加入 [&quot;ab&quot;]\nString s &#x3D; new String(&quot;a&quot;)+new String(&quot;b&quot;); \n&#x2F;&#x2F; 此时 串池加入[&quot;a&quot;,&quot;b&quot;]   \n&#x2F;&#x2F; 堆内存中加入三个对象 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)  \nString s2 &#x3D; s.intern(); \n&#x2F;&#x2F; 1.8+ 将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则放入,返回串池中的对象地址\n&#x2F;&#x2F; 1.6  将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则把这个对象拷贝一份,放入串池,返回串池中的对象地址\nSystem.out.println(s2 ** x); &#x2F;&#x2F;1.8 true  1.6 true\nSystem.out.println(s ** x);  &#x2F;&#x2F;1.8 false 1.6 false</code></pre>\n\n<p>例子3,对比上面例子2</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s &#x3D; new String(&quot;a&quot;)+new String(&quot;b&quot;); \n&#x2F;&#x2F; 此时 串池加入[&quot;a&quot;,&quot;b&quot;]   \n&#x2F;&#x2F; 堆内存中加入三个对象 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)  \nString s2 &#x3D; s.intern(); \n&#x2F;&#x2F; 1.8+ 将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则放入,返回串池中的对象地址\n&#x2F;&#x2F; 1.6  将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则把这个对象拷贝一份,放入串池(这个对象和原本的对象已经不属于同一个对象),返回串池中的对象地址\nString x &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 此时串池已经有 [&quot;ab&quot;],是 s 的地址,将x的地址给x\nSystem.out.println(s2 ** x); &#x2F;&#x2F;1.8 true  1.6 true\nSystem.out.println(s ** x);  &#x2F;&#x2F;1.8 true  1.6 false</code></pre>\n\n<p>例子4</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String x2 &#x3D; new String(&quot;c&quot;)+new String(&quot;d&quot;); &#x2F;&#x2F; new String(&quot;cd&quot;)\nString x1 &#x3D; &quot;cd&quot;;\nx2.intern();\nSystem.out.println(x1 ** x2);  &#x2F;&#x2F;1.8 false  1.6 false 原因相同 都是因为常量池中已经有ab了</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String x2 &#x3D; new String(&quot;c&quot;)+new String(&quot;d&quot;); &#x2F;&#x2F; new String(&quot;cd&quot;)\nx2.intern();\nString x1 &#x3D; &quot;cd&quot;;\nSystem.out.println(x1 ** x2);  &#x2F;&#x2F;1.8 true  1.6 false 原因不同 1.8由于没有拷贝,所以还相等 1.6由于池中是拷贝的对象,所以不相等.</code></pre>\n\n\n\n\n\n<h3 id=\"Direct-Memory-直接内存\"><a href=\"#Direct-Memory-直接内存\" class=\"headerlink\" title=\"# Direct Memory 直接内存\"></a># Direct Memory 直接内存</h3><p>​    由于Java无法直接调用主机的内存,所以在使用普通的io访问时,会在内存中先开辟一个缓存,然后在java堆内存中也开辟一块缓存,读取访问时,会将系统内存的缓存读取到java堆内存中再进行访问,而这一步实际上是冗余操作,如果可以有办法直接访问主机内存,就可以大大提高大文件的访问速度。</p>\n<p>​    直接内存就是通过java调用系统调用在内存中开辟一块内存，叫直接内存，Java和操作系统都可以直接访问,无需将代码从系统内存复制到Java堆内存，从而提高了效率.</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;&#x2F;通过ByteBuffer申请1M的直接内存\nByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(_1M);</code></pre>\n\n<ul>\n<li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li>\n<li>分配回收成本较高，但读写性能高</li>\n<li>内存不够使用时,会造成OutOfMemory内存溢出错误。</li>\n<li>不受JVM内存回收管理,但会通过unsafe.freeMemory来手动释放</li>\n</ul>\n<p>传统阻塞IO：</p>\n<img src=\"Java-Visual-Machine/20200608150715.png\" alt=\"img\" style=\"zoom:33%;\" />\n\n<p>直接内存：</p>\n<img src=\"Java-Visual-Machine/image-20220308103014317.png\" alt=\"image-20220308103014317\" style=\"zoom:50%;\" />\n\n\n\n\n\n<p><strong>释放原理</strong></p>\n<p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过unsafe.freeMemory来手动释放。</p>\n<p><strong>直接内存的回收机制总结</strong></p>\n<ul>\n<li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li>\n<li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li>\n</ul>\n<h2 id=\"2-GC-Garbage-Collector\"><a href=\"#2-GC-Garbage-Collector\" class=\"headerlink\" title=\"2. GC Garbage Collector\"></a>2. GC Garbage Collector</h2><h3 id=\"a-如何确定一个对象是垃圾呢\"><a href=\"#a-如何确定一个对象是垃圾呢\" class=\"headerlink\" title=\"a. 如何确定一个对象是垃圾呢?\"></a>a. 如何确定一个对象是垃圾呢?</h3><ul>\n<li><p>根可达算法 </p>\n<ul>\n<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>\n<li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>\n<li>可以作为GC Root的对象<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>\n<li>被加锁的对象一般不会被回收</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>引用计数算法</p>\n<p>弊端：循环引用永远不可删除，早期python使用了这种算法。</p>\n</li>\n</ul>\n<h3 id=\"常见引用\"><a href=\"#常见引用\" class=\"headerlink\" title=\"# 常见引用\"></a># 常见引用</h3><ul>\n<li><p>强引用</p>\n<p>被强引用关联的对象不会被回收。</p>\n<p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>\n<p>使用 new 一个新对象的方式来创建强引用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object();</code></pre>\n</li>\n<li><p>软引用</p>\n<p>软引用就是强引用引用的对象,一般不会被回收</p>\n<p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p>\n<p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p>\n<p>使用 SoftReference 类来创建软引用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object();\nSoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);\nobj &#x3D; null;  &#x2F;&#x2F; 使对象只被软引用关联</code></pre>\n</li>\n<li><p>弱引用</p>\n<p><strong>被弱引用关联的对象</strong>一定会被回收，也就是说它只能存活到下一次垃圾回收(发生Full GC)发生之前。</p>\n<p>使用 WeakReference 类来实现弱引用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object();\nWeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);\nobj &#x3D; null;</code></pre>\n\n<p>软引用和弱引用的主要区别就是回收情况,软引用是内存不够才回收,弱引用是下次一定回收.</p>\n</li>\n<li><p>虚引用</p>\n<p>又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。</p>\n<p>为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被回收时收到一个系统通知</strong>。</p>\n<p>使用 PhantomReference 来实现虚引用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object obj &#x3D; new Object();\nPhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);\nobj &#x3D; null; </code></pre>\n</li>\n<li><p>终结器引用</p>\n<p><strong>finalize()</strong></p>\n<p>finalize() 类似 C++ 的<strong>析构函数</strong>，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p>\n<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>\n</li>\n</ul>\n<h3 id=\"b-主要的垃圾回收算法\"><a href=\"#b-主要的垃圾回收算法\" class=\"headerlink\" title=\"b. 主要的垃圾回收算法:\"></a>b. 主要的垃圾回收算法:</h3><ul>\n<li><p>Mark-Sweep(标记清除算法)</p>\n<p>速度快,但会造成内存碎片</p>\n</li>\n<li><p>Copying(拷贝)</p>\n<p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p>\n<p>主要不足是只使用了内存的一半。</p>\n<p>现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。</p>\n<p>HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象</p>\n<p>总有一半内存用不了，速度很快</p>\n</li>\n<li><p>Mark-Compact(标记整理压缩)</p>\n<p>边回收边整理,慢,但不会有内存碎片</p>\n</li>\n</ul>\n<h3 id=\"c-分代垃圾回收\"><a href=\"#c-分代垃圾回收\" class=\"headerlink\" title=\"c. 分代垃圾回收\"></a>c. 分代垃圾回收</h3><img src=\"Java-Visual-Machine/4cf711a8-7ab2-4152-b85c-d5c226733807.png\" alt=\"image\" style=\"zoom:67%;\" />\n\n<p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>\n<p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p>\n<p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong>(复制算法)</p>\n<p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>\n<p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p>\n<p>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>\n<p><strong>Minor GC 和 Full GC</strong></p>\n<ul>\n<li>Minor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。</li>\n<li>Full GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。</li>\n</ul>\n<h3 id=\"内存分配策略\"><a href=\"#内存分配策略\" class=\"headerlink\" title=\"# 内存分配策略\"></a># 内存分配策略</h3><p><strong>1.对象优先在 Eden 分配</strong></p>\n<p>大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p>\n<p><strong>2.大对象直接进入老年代</strong></p>\n<p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p>\n<p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p>\n<p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。</p>\n<p><strong>如果所有的空间都放不下,并且不能回收,就会爆内存溢出。</strong></p>\n<p><strong>3.长期存活的对象进入老年代</strong></p>\n<p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p>\n<p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p>\n<p><strong>4.动态对象年龄判定</strong></p>\n<p>虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p>\n<p><strong>5.空间分配担保</strong></p>\n<p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p>\n<p>如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。</p>\n<h3 id=\"d-垃圾回收器\"><a href=\"#d-垃圾回收器\" class=\"headerlink\" title=\"d. 垃圾回收器\"></a>d. 垃圾回收器</h3><img src=\"Java-Visual-Machine/src=http%253A%252F%252Fwww.pianshen.com%252Fimages%252F800%252F031397643a9d5543102f4174b5556450.png&refer=http%253A%252F%252Fwww.pianshen.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p>1、串行</p>\n<ul>\n<li>单线程</li>\n<li>堆内存较小，适合个人电脑</li>\n<li>Serial SerialOld</li>\n</ul>\n<img src=\"Java-Visual-Machine/20200608151027.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p>\n<p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p>\n<p><strong>Serial 收集器</strong></p>\n<p>Serial收集器是最基本的、发展历史最悠久的收集器</p>\n<p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p>\n<p><strong>ParNew 收集器</strong></p>\n<p>ParNew收集器其实就是Serial收集器的<strong>多线程版本</strong></p>\n<p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p>\n<p><strong>Serial Old 收集器</strong></p>\n<p>Serial Old是Serial收集器的老年代版本</p>\n<p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p>\n<p>2、吞吐量优先</p>\n<ul>\n<li>多线程</li>\n<li>堆内存大，多核CPU</li>\n<li>让单位时间内，STW的时间最短(单次时间可能较长,总时间可能较短)</li>\n</ul>\n<img src=\"Java-Visual-Machine/20200608151039.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p><strong>Parallel Scavenge 收集器</strong></p>\n<p>与吞吐量关系密切，故也称为吞吐量优先收集器</p>\n<p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p>\n<p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p>\n<p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p>\n<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>\n<ul>\n<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>\n<li>XX:GCRatio 直接设置吞吐量的大小</li>\n</ul>\n<p><strong>Parallel Old 收集器</strong></p>\n<p>是Parallel Scavenge收集器的老年代版本</p>\n<p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p>\n<p>3、响应时间优先</p>\n<ul>\n<li>多线程</li>\n<li>堆内存大，单核CPU</li>\n<li>让单次的STW的时间最短（单次时间短,总时间可能较长,用户不可查）</li>\n</ul>\n<p><strong>CMS垃圾回收器</strong></p>\n<p>ConcurrentMarkSweepGC  并发(Concurrent是并发,不是并行) 标记 </p>\n<p>一种以获取<strong>最短回收停顿时间</strong>为目标的<strong><strong>老年代</strong></strong>收集器,配合ParNewGC一起使用</p>\n<p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p>\n<p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务</p>\n<p><strong>CMS收集器的运行过程分为下列4步：</strong></p>\n<p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p>\n<p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p>\n<p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p>\n<p><strong>并发清除</strong>：对标记的对象进行清除回收</p>\n<p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p>\n<h3 id=\"G1-垃圾回收器\"><a href=\"#G1-垃圾回收器\" class=\"headerlink\" title=\"# G1 垃圾回收器\"></a># G1 垃圾回收器</h3><p>G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p>\n<p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p>\n<p>适用场景</p>\n<ul>\n<li>同时注重吞吐量和低延迟（响应时间）</li>\n<li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li>\n<li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li>\n</ul>\n<p>G1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize&#x3D;n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。</p>\n<img src=\"/post/Java-Visual-Machine/java-jvm-gc-g1-1.jpeg\" class=\"\" title=\"img\">\n\n<p>G1垃圾回收阶段:</p>\n<img src=\"Java-Visual-Machine/image-20220308185914200.png\" alt=\"image-20220308185914200\" style=\"zoom:50%;\" />\n\n\n\n<p>1、阶段1 Young Collection</p>\n<p>应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>\n<p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。</p>\n<p>2、阶段2 Young Collection + CM（Concurrent Mark）</p>\n<p>CMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。</p>\n<p>GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。</p>\n<p>并发标记过程中，删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收</p>\n<p>产生漏标问题的条件有两个：</p>\n<ul>\n<li>黑色对象指向了白色对象</li>\n<li>灰色对象指向白色对象的引用消失</li>\n</ul>\n<p>所以要解决漏标问题，打破两个条件之一即可：</p>\n<ul>\n<li><strong>跟踪黑指向白的增加</strong> incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。</li>\n<li><strong>记录灰指向白的消失</strong> SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。</li>\n</ul>\n<p>3、阶段3 Mixed Collection</p>\n<p>年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比IHOP阈值-XX: InitiatingHeap OccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>\n<p>为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。</p>\n<h3 id=\"e-垃圾回收调优\"><a href=\"#e-垃圾回收调优\" class=\"headerlink\" title=\"e. 垃圾回收调优\"></a>e. 垃圾回收调优</h3><pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 通过这个命令可以查看GC的调优指令\nC:\\Users\\Lenovo\\.jdks\\azul-13.0.8\\bin&gt;java -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;</code></pre>\n\n<p><strong>确定目标</strong></p>\n<p>低延迟&#x2F;高吞吐量？ 选择合适的GC</p>\n<ul>\n<li>CMS G1 ZGC</li>\n<li>ParallelGC</li>\n<li>Zing</li>\n</ul>\n<p><strong>最快的GC是不发生GC</strong></p>\n<p>首先排除减少因为自身编写的代码而引发的内存问题</p>\n<ul>\n<li>查看Full GC前后的内存占用，考虑以下几个问题<ul>\n<li>数据是不是太多？</li>\n<li>数据表示是否太臃肿<ul>\n<li>对象图</li>\n<li>对象大小</li>\n</ul>\n</li>\n<li>是否存在内存泄漏</li>\n</ul>\n</li>\n</ul>\n<p><strong>新生代调优</strong></p>\n<ul>\n<li>新生代的特点<ul>\n<li>所有的new操作分配内存都是非常廉价的<ul>\n<li>TLAB</li>\n</ul>\n</li>\n<li>死亡对象回收零代价</li>\n<li>大部分对象用过即死（朝生夕死）</li>\n<li>MInor GC 所用时间远小于Full GC</li>\n</ul>\n</li>\n<li>新生代内存越大越好么？<ul>\n<li>不是<ul>\n<li>新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降</li>\n<li>新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长</li>\n</ul>\n</li>\n<li>新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜</li>\n</ul>\n</li>\n</ul>\n<p><strong>幸存区调优</strong></p>\n<ul>\n<li>幸存区需要能够保存 <strong>当前活跃对象</strong>+<strong>需要晋升的对象</strong></li>\n<li>晋升阈值配置得当，让长时间存活的对象尽快晋升</li>\n</ul>\n<p><strong>老年代调优</strong></p>\n<ul>\n<li>内存越大越好</li>\n<li>先不尝试做调优,如果没触发Full GC ,则说明已经较优,先尝试新生代调优</li>\n<li>观察Full GC时老年代内存占用,调整大小</li>\n</ul>\n<h3 id=\"JVM-GC-面试题\"><a href=\"#JVM-GC-面试题\" class=\"headerlink\" title=\"JVM GC 面试题\"></a>JVM GC 面试题</h3><ol>\n<li>CMS和G1的异同</li>\n<li></li>\n</ol>\n<img src=\"/post/Java-Visual-Machine/image-20220307142520067.png\" class=\"\" title=\"image-20220307142520067\">\n\n\n\n<h2 id=\"3-类加载\"><a href=\"#3-类加载\" class=\"headerlink\" title=\"3. 类加载\"></a>3. 类加载</h2><h3 id=\"a-类字节码\"><a href=\"#a-类字节码\" class=\"headerlink\" title=\"a. 类字节码\"></a>a. 类字节码</h3><p>一个简单的helloworld文件编译后的二进制字节码文件形式如下：</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">[root@VM-4-9-centos java-demo]# javac -parameters -d .  HelloWorld.java \n[root@VM-4-9-centos java-demo]# od -t xC HelloWorld.class\n# 行号是8进制   后面为16进制\n0000000 ca fe ba be 00 00 00 34 00 1f 0a 00 06 00 11 09\n0000020 00 12 00 13 08 00 14 0a 00 15 00 16 07 00 17 07\n0000040 00 18 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29\n0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e\n0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 04 6d 61 69\n0000120 6e 01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67\n0000140 2f 53 74 72 69 6e 67 3b 29 56 01 00 10 4d 65 74\n0000160 68 6f 64 50 61 72 61 6d 65 74 65 72 73 01 00 04\n0000200 61 72 67 73 01 00 0a 53 6f 75 72 63 65 46 69 6c\n0000220 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a\n0000240 61 76 61 0c 00 07 00 08 07 00 19 0c 00 1a 00 1b\n0000260 01 00 0c 48 65 6c 6c 6f 20 77 6f 72 6c 64 21 07\n0000300 00 1c 0c 00 1d 00 1e 01 00 0a 48 65 6c 6c 6f 57\n0000320 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 6e 67\n0000340 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 2f 6c\n0000360 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 75 74\n0000400 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e\n0000420 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 61 2f\n0000440 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 01 00\n0000460 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 61 76\n0000500 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56\n0000520 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07\n0000540 00 08 00 01 00 09 00 00 00 1d 00 01 00 01 00 00\n0000560 00 05 2a b7 00 01 b1 00 00 00 01 00 0a 00 00 00\n0000600 06 00 01 00 00 00 02 00 09 00 0b 00 0c 00 02 00\n0000620 09 00 00 00 25 00 02 00 01 00 00 00 09 b2 00 02\n0000640 12 03 b6 00 04 b1 00 00 00 01 00 0a 00 00 00 0a\n0000660 00 02 00 00 00 05 00 08 00 07 00 0d 00 00 00 05\n0000700 01 00 0e 00 00 00 01 00 0f 00 00 00 02 00 10\n0000717</code></pre>\n\n<p>根据 JVM 规范，<strong>类文件结构</strong>如下</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">#u4 表示长度   后面代表项\nu4 \t\t\t  magic\nu2             minor_version;    \nu2             major_version;    \nu2             constant_pool_count;    \ncp_info        constant_pool[constant_pool_count-1];    \nu2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   \nu2             fields_count;    \nfield_info     fields[fields_count];   \nu2             methods_count;    \nmethod_info    methods[methods_count];    \nu2             attributes_count;    \nattribute_info attributes[attributes_count];Copy</code></pre>\n\n\n\n<p>**魔数 **magic</p>\n<p>u4 magic</p>\n<p>对应字节码文件的0~3个字节</p>\n<p>0000000 <strong>ca fe ba be</strong> 00 00 00 34 00 23 0a 00 06 00 15 09</p>\n<p>**版本 **major_version;  </p>\n<p>0000000 ca fe ba be <strong>00 00 00 34</strong> 00 23 0a 00 06 00 15 09</p>\n<p>34H &#x3D; 52，代表JDK8</p>\n<p><strong>常量池</strong> constant_pool_count;    </p>\n<p>00 23(35) 表示常量池有#1 ~ #34项</p>\n<p>后面的字节码要对照 编码表,比如 0a 00 06 00 15 中 </p>\n<p>0a 表示这是个方法</p>\n<p>00 06 和00 15表示他引用常量池的#6 和 #21来获得方法的 所属类和方法名,后面以此类推。</p>\n<p><strong>访问标识 access_flags 和 继承信息</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">u2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   </code></pre>\n\n\n\n<p><strong>fields信息</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">u2             fields_count;    \nfield_info     fields[fields_count]; </code></pre>\n\n\n\n<p><strong>方法</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">u2             methods_count;    \nmethod_info    methods[methods_count];    </code></pre>\n\n\n\n<p><strong>附加属性</strong></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">u2             attributes_count;    \nattribute_info attributes[attributes_count];Copy</code></pre>\n\n\n\n<h3 id=\"javap-反编译class文件\"><a href=\"#javap-反编译class文件\" class=\"headerlink\" title=\"# javap 反编译class文件\"></a># javap 反编译class文件</h3><pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">[root@VM-4-9-centos java-demo]# javap -v HelloWorld.class \n# 类文件信息\nClassfile &#x2F;java-demo&#x2F;HelloWorld.class\n  Last modified Mar 9, 2022; size 463 bytes\n  MD5 checksum 9d73b329c5539fa860d172779e6ce0eb\n  Compiled from &quot;HelloWorld.java&quot;\npublic class HelloWorld\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\n# 常量池\nConstant pool:\n   #1 &#x3D; Methodref          #6.#17         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n   #2 &#x3D; Fieldref           #18.#19        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;\n   #3 &#x3D; String             #20            &#x2F;&#x2F; Hello world!\n   #4 &#x3D; Methodref          #21.#22        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V\n   #5 &#x3D; Class              #23            &#x2F;&#x2F; HelloWorld\n   #6 &#x3D; Class              #24            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object\n   #7 &#x3D; Utf8               &lt;init&gt;\n   #8 &#x3D; Utf8               ()V\n   #9 &#x3D; Utf8               Code\n  #10 &#x3D; Utf8               LineNumberTable\n  #11 &#x3D; Utf8               main\n  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V\n  #13 &#x3D; Utf8               MethodParameters\n  #14 &#x3D; Utf8               args\n  #15 &#x3D; Utf8               SourceFile\n  #16 &#x3D; Utf8               HelloWorld.java\n  #17 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V\n  #18 &#x3D; Class              #25            &#x2F;&#x2F; java&#x2F;lang&#x2F;System\n  #19 &#x3D; NameAndType        #26:#27        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;\n  #20 &#x3D; Utf8               Hello world!\n  #21 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream\n  #22 &#x3D; NameAndType        #29:#30        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V\n  #23 &#x3D; Utf8               HelloWorld\n  #24 &#x3D; Utf8               java&#x2F;lang&#x2F;Object\n  #25 &#x3D; Utf8               java&#x2F;lang&#x2F;System\n  #26 &#x3D; Utf8               out\n  #27 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;\n  #28 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream\n  #29 &#x3D; Utf8               println\n  #30 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V\n  \n# 方法信息\n&#123;\n# 构造方法\n  public HelloWorld();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1\n         0: aload_0\n         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 2: 0\n# main 方法\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V\n    flags: ACC_PUBLIC, ACC_STATIC   # 访问修饰符\n    Code:\n      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1   # 栈信息\n         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;\n         3: ldc           #3                  &#x2F;&#x2F; String Hello world!\n         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V\n         8: return\n      LineNumberTable:\n        line 5: 0\n        line 7: 8\n    MethodParameters:\n      Name                           Flags\n      args\n&#125;\nSourceFile: &quot;HelloWorld.java&quot;</code></pre>\n\n<p>java字节码文件的执行流程:</p>\n<img src=\"/post/Java-Visual-Machine/image-20220309144619251.png\" class=\"\" title=\"image-20220309144619251\">\n\n<h3 id=\"方法调用\"><a href=\"#方法调用\" class=\"headerlink\" title=\"# 方法调用\"></a># 方法调用</h3><p>编译器会按<strong>从上至下</strong>的顺序，收集所有 {} 代码块和成员变量赋值的代码，<strong>形成新的构造方法</strong>，但<strong>原始构造方法</strong>内的代码<strong>总是在后</strong></p>\n<p>不同方法在调用时，对应的虚拟机指令有所区别</p>\n<ul>\n<li>私有、构造、被final修饰的方法，在调用时都使用<strong>invokespecial</strong>指令</li>\n<li>普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定</li>\n<li>静态方法在调用时使用invokestatic指令</li>\n</ul>\n<h3 id=\"多态原理\"><a href=\"#多态原理\" class=\"headerlink\" title=\"# 多态原理\"></a># 多态原理</h3><p>因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用<strong>invokevirtual</strong>指令</p>\n<p>在执行invokevirtual指令时，经历了以下几个步骤</p>\n<ul>\n<li>先通过栈帧中对象的引用找到对象</li>\n<li>分析对象头，找到对象实际的Class</li>\n<li>Class结构中有<strong>vtable</strong> 虚方法表</li>\n<li>查询vtable找到方法的具体地址</li>\n<li>执行方法的字节码</li>\n</ul>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"# 异常处理\"></a># 异常处理</h3><ul>\n<li><p>可以看到多出来一个 Exception table 的结构，[from, to) 是<strong>前闭后开</strong>（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</p>\n</li>\n<li><p>8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）</p>\n</li>\n<li><p>ﬁnally 中的代码被<strong>复制多份</strong>，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程</p>\n</li>\n<li><p><strong>注意</strong>：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码<strong>只会被执行一次</strong></p>\n</li>\n<li><p>由于 ﬁnally 中的 <strong>ireturn</strong> 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准</p>\n</li>\n<li><p>至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子</p>\n</li>\n<li><p>跟上例中的 ﬁnally 相比，发现<strong>没有 athrow 了</strong>，这告诉我们：如果在 ﬁnally 中出现了 return，会<strong>吞掉异常</strong></p>\n</li>\n<li><p>所以<strong>不要在finally中进行返回操作</strong></p>\n</li>\n</ul>\n<h3 id=\"b-语法糖\"><a href=\"#b-语法糖\" class=\"headerlink\" title=\"b. 语法糖\"></a>b. 语法糖</h3><p>所谓的 <strong>语法糖</strong> ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，<strong>自动生成</strong>和<strong>转换</strong>的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利</p>\n<p><strong>注意</strong>，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的<strong>结果直接就是 class 字节码</strong>，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>\n<h4 id=\"1-默认构造函数\"><a href=\"#1-默认构造函数\" class=\"headerlink\" title=\"1. 默认构造函数\"></a>1. 默认构造函数</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Candy1 &#123;\n&#125;</code></pre>\n\n<p>经过编译期优化后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Candy1 &#123;\n   &#x2F;&#x2F;这个无参构造器是java编译器帮我们加上的\n   public Candy1() &#123;\n      &#x2F;&#x2F;即调用父类 Object 的无参构造方法，即调用 java&#x2F;lang&#x2F;Object.&quot; &lt;init&gt;&quot;:()V\n      super();\n   &#125;\n&#125;</code></pre>\n\n<h4 id=\"2-自动拆装箱\"><a href=\"#2-自动拆装箱\" class=\"headerlink\" title=\"2. 自动拆装箱\"></a>2. 自动拆装箱</h4><p>基本类型和其包装类型的相互转换过程，称为拆装箱</p>\n<p>在JDK 5以后，它们的转换可以在编译期自动完成</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo2 &#123;\n   public static void main(String[] args) &#123;\n      Integer x &#x3D; 1;\n      int y &#x3D; x;\n   &#125;\n&#125;</code></pre>\n\n<p>转换过程如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo2 &#123;\n   public static void main(String[] args) &#123;\n      &#x2F;&#x2F;基本类型赋值给包装类型，称为装箱\n      Integer x &#x3D; Integer.valueOf(1);\n      &#x2F;&#x2F;包装类型赋值给基本类型，称谓拆箱\n      int y &#x3D; x.intValue();\n   &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-泛型集合取值\"><a href=\"#3-泛型集合取值\" class=\"headerlink\" title=\"3. 泛型集合取值\"></a>3. 泛型集合取值</h4><p>泛型也是在 JDK 5 开始加入的特性，但 java 在<strong>编译泛型代码后</strong>会执行 <strong>泛型擦除</strong> 的动作，即泛型信息在编译为字节码之后就<strong>丢失</strong>了，实际的类型都当做了 <strong>Object</strong> 类型来处理：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo3 &#123;\n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n      list.add(10);\n      Integer x &#x3D; list.get(0);\n   &#125;\n&#125;</code></pre>\n\n<p>对应字节码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Code:\n    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1\n       0: new           #2                  &#x2F;&#x2F; class java&#x2F;util&#x2F;ArrayList\n       3: dup\n       4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;ArrayList.&quot;&lt;init&gt;&quot;:()V\n       7: astore_1\n       8: aload_1\n       9: bipush        10\n      11: invokestatic  #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Integer.valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;\n      &#x2F;&#x2F;这里进行了泛型擦除，实际调用的是add(Objcet o)\n      14: invokeinterface #5,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.add:(Ljava&#x2F;lang&#x2F;Object;)Z\n\n      19: pop\n      20: aload_1\n      21: iconst_0\n      &#x2F;&#x2F;这里也进行了泛型擦除，实际调用的是get(Object o)   \n      22: invokeinterface #6,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.get:(I)Ljava&#x2F;lang&#x2F;Object;\n      &#x2F;&#x2F;这里进行了类型转换，将Object转换成了Integer\n      27: checkcast     #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Integer\n      30: astore_2\n      31: returnCopy</code></pre>\n\n<p>所以调用get函数取值时，有一个类型转换的操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Integer x &#x3D; (Integer) list.get(0);</code></pre>\n\n<p>如果要将返回结果赋值给一个int类型的变量，则还有<strong>自动拆箱</strong>的操作</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">int x &#x3D; (Integer) list.get(0).intValue();</code></pre>\n\n\n\n<h4 id=\"4-可变参数\"><a href=\"#4-可变参数\" class=\"headerlink\" title=\"4. 可变参数\"></a>4. 可变参数</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo4 &#123;\n   public static void foo(String... args) &#123;\n      &#x2F;&#x2F;将args赋值给arr，可以看出String...实际就是String[] \n      String[] arr &#x3D; args;\n      System.out.println(arr.length);\n   &#125;\n\n   public static void main(String[] args) &#123;\n      foo(&quot;hello&quot;, &quot;world&quot;);\n   &#125;\n&#125;</code></pre>\n\n<p>可变参数 <strong>String…</strong> args 其实是一个 <strong>String[]</strong> args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo4 &#123;\n   public Demo4 &#123;&#125;\n\n    \n   public static void foo(String[] args) &#123;\n      String[] arr &#x3D; args;\n      System.out.println(arr.length);\n   &#125;\n\n   public static void main(String[] args) &#123;\n      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n   &#125;\n&#125;</code></pre>\n\n<p>注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，<strong>创建了一个空数组</strong>，而不是直接传递的null</p>\n<h4 id=\"5-foreach\"><a href=\"#5-foreach\" class=\"headerlink\" title=\"5. foreach\"></a>5. foreach</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo5 &#123;\n\tpublic static void main(String[] args) &#123;\n        &#x2F;&#x2F;数组赋初值的简化写法也是一种语法糖。\n\t\tint[] arr &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n\t\tfor(int x : arr) &#123;\n\t\t\tSystem.out.println(x);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p>编译器会帮我们转换为</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo5 &#123;\n    public Demo5 &#123;&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tint[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;\n\t\tfor(int i&#x3D;0; i&lt;arr.length; ++i) &#123;\n\t\t\tint x &#x3D; arr[i];\n\t\t\tSystem.out.println(x);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<p><strong>如果是集合使用foreach</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo5 &#123;\n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);\n      for (Integer x : list) &#123;\n         System.out.println(x);\n      &#125;\n   &#125;\n&#125;</code></pre>\n\n<p>集合要使用foreach，需要该集合类实现了<strong>Iterable接口</strong>，因为集合的遍历需要用到<strong>迭代器Iterator</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo5 &#123;\n    public Demo5 &#123;&#125;\n    \n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);\n      &#x2F;&#x2F;获得该集合的迭代器\n      Iterator&lt;Integer&gt; iterator &#x3D; list.iterator();\n      while(iterator.hasNext()) &#123;\n         Integer x &#x3D; iterator.next();\n         System.out.println(x);\n      &#125;\n   &#125;\n&#125;</code></pre>\n\n<h4 id=\"6-switch字符串\"><a href=\"#6-switch字符串\" class=\"headerlink\" title=\"6. switch字符串\"></a>6. switch字符串</h4><pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class Demo6 &#123;\n   public static void main(String[] args) &#123;\n      String str &#x3D; &quot;hello&quot;;\n      switch (str) &#123;\n         case &quot;hello&quot; :\n            System.out.println(&quot;h&quot;);\n            break;\n         case &quot;world&quot; :\n            System.out.println(&quot;w&quot;);\n            break;\n         default:\n            break;\n      &#125;\n   &#125;\n&#125;</code></pre>\n\n<p>在编译器中执行的操作</p>\n<pre class=\"line-numbers language-Java\" data-language=\"Java\"><code class=\"language-Java\">public class Demo6 &#123;\n   public Demo6() &#123;\n      \n   &#125;\n   public static void main(String[] args) &#123;\n      String str &#x3D; &quot;hello&quot;;\n      int x &#x3D; -1;\n      &#x2F;&#x2F;通过字符串的hashCode+value来判断是否匹配\n      switch (str.hashCode()) &#123;\n         &#x2F;&#x2F;hello的hashCode\n         case 99162322 :\n            &#x2F;&#x2F;再次比较，因为字符串的hashCode有可能相等\n            if(str.equals(&quot;hello&quot;)) &#123;\n               x &#x3D; 0;\n            &#125;\n            break;\n         &#x2F;&#x2F;world的hashCode\n         case 11331880 :\n            if(str.equals(&quot;world&quot;)) &#123;\n               x &#x3D; 1;\n            &#125;\n            break;\n         default:\n            break;\n      &#125;\n\n      &#x2F;&#x2F;用第二个switch在进行输出判断\n      switch (x) &#123;\n         case 0:\n            System.out.println(&quot;h&quot;);\n            break;\n         case 1:\n            System.out.println(&quot;w&quot;);\n            break;\n         default:\n            break;\n      &#125;\n   &#125;\n&#125;</code></pre>\n\n<p>过程说明：</p>\n<ul>\n<li>在编译期间，单个的switch被分为了两个<ul>\n<li>第一个用来匹配字符串，并给x赋值<ul>\n<li>字符串的匹配用到了字符串的hashCode，还用到了equals方法</li>\n<li>使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）</li>\n</ul>\n</li>\n<li>第二个用来根据x的值来决定输出语句</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"7-枚举类\"><a href=\"#7-枚举类\" class=\"headerlink\" title=\"7. 枚举类\"></a>7. 枚举类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">enum SEX &#123;\n   MALE, FEMALE;\n&#125;\t</code></pre>\n\n<p>转换后的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final class Sex extends Enum&lt;Sex&gt; &#123;   \n   &#x2F;&#x2F;对应枚举类中的元素\n   public static final Sex MALE;    \n   public static final Sex FEMALE;    \n   private static final Sex[] $VALUES;\n   \n    static &#123;       \n    \t&#x2F;&#x2F;调用构造函数，传入枚举元素的值及ordinal\n    \tMALE &#x3D; new Sex(&quot;MALE&quot;, 0);    \n        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 1);   \n        $VALUES &#x3D; new Sex[]&#123;MALE, FEMALE&#125;; \n   &#125;\n \t\n   &#x2F;&#x2F;调用父类中的方法\n    private Sex(String name, int ordinal) &#123;     \n        super(name, ordinal);    \n    &#125;\n   \n    public static Sex[] values() &#123;  \n        return $VALUES.clone();  \n    &#125;\n    public static Sex valueOf(String name) &#123; \n        return Enum.valueOf(Sex.class, name);  \n    &#125;   \n&#125;</code></pre>\n\n<h4 id=\"8-匿名内部类\"><a href=\"#8-匿名内部类\" class=\"headerlink\" title=\"8. 匿名内部类\"></a>8. 匿名内部类</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(&quot;running...&quot;);\n         &#125;\n      &#125;;\n   &#125;\n&#125;C</code></pre>\n\n<p>转换后的代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      &#x2F;&#x2F;用额外创建的类来创建匿名内部类对象\n      Runnable runnable &#x3D; new Demo8$1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F;创建了一个额外的类，实现了Runnable接口\nfinal class Demo8$1 implements Runnable &#123;\n   public Demo8$1() &#123;&#125;\n\n   @Override\n   public void run() &#123;\n      System.out.println(&quot;running...&quot;);\n   &#125;\n&#125;</code></pre>\n\n<p>如果匿名内部类中引用了<strong>局部变量</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 1;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(x);\n         &#125;\n      &#125;;\n   &#125;\n&#125;</code></pre>\n\n<p>转化后代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 1;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(x);\n         &#125;\n      &#125;;\n   &#125;\n&#125;\n\nfinal class Demo8$1 implements Runnable &#123;\n   &#x2F;&#x2F;多创建了一个变量\n   int val$x;\n   &#x2F;&#x2F;变为了有参构造器\n   public Demo8$1(int x) &#123;\n      this.val$x &#x3D; x;\n   &#125;\n\n   @Override\n   public void run() &#123;\n      System.out.println(val$x);\n   &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"c-类加载机制\"><a href=\"#c-类加载机制\" class=\"headerlink\" title=\"c. 类加载机制\"></a>c. 类加载机制</h3><h4 id=\"1-加载\"><a href=\"#1-加载\" class=\"headerlink\" title=\"1. 加载\"></a>1. 加载</h4><ul>\n<li>将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：<ul>\n<li>_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用</li>\n<li>_super 即父类</li>\n<li>_ﬁelds 即成员变量</li>\n<li>_methods 即方法</li>\n<li>_constants 即常量池</li>\n<li>_class_loader 即类加载器</li>\n<li>_vtable 虚方法表</li>\n<li>_itable 接口方法</li>\n</ul>\n</li>\n<li>如果这个类还有父类没有加载，<strong>先加载父类</strong></li>\n<li>加载和链接可能是<strong>交替运行</strong>的</li>\n<li>instanceKlass保存在<strong>方法区</strong>。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中</li>\n<li>_java_mirror则是保存在<strong>堆内存</strong>中</li>\n<li>InstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址</li>\n<li>类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息</li>\n</ul>\n<h4 id=\"2-链接\"><a href=\"#2-链接\" class=\"headerlink\" title=\"2. 链接\"></a>2. 链接</h4><h5 id=\"a-验证\"><a href=\"#a-验证\" class=\"headerlink\" title=\"a. 验证\"></a>a. 验证</h5><p>验证类是否符合 JVM规范，安全性检查</p>\n<h5 id=\"b-准备\"><a href=\"#b-准备\" class=\"headerlink\" title=\"b. 准备\"></a>b. 准备</h5><p>为 static 变量分配空间，设置默认值</p>\n<ul>\n<li>static变量在 JDK 7 以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了</li>\n<li>static变量在分配空间和赋值是在两个阶段完成的。<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li>\n<li>如果 static 变量是 ﬁnal 的<strong>基本类型</strong>，以及<strong>字符串常量</strong>，那么编译阶段值就确定了，<strong>赋值在准备阶段完成</strong></li>\n<li>如果 static 变量是 ﬁnal 的，但属于<strong>引用类型</strong>，那么赋值也会在<strong>初始化阶段完成</strong></li>\n</ul>\n<h5 id=\"c-解析\"><a href=\"#c-解析\" class=\"headerlink\" title=\"c. 解析\"></a>c. 解析</h5><p>将常量池中的符号引用解析为直接引用</p>\n<ul>\n<li>未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中</li>\n<li>解析以后，会将常量池中的符号引用解析为直接引用</li>\n</ul>\n<h4 id=\"3-初始化\"><a href=\"#3-初始化\" class=\"headerlink\" title=\"3. 初始化\"></a>3. 初始化</h4><p>初始化阶段就是 <strong>执行类构造器clinit()方法的过程</strong>，虚拟机会保证这个类的『构造方法』的线程安全</p>\n<ul>\n<li>clinit()方法是由编译器自动收集类中的所有类变量的<strong>赋值动作和静态语句块</strong>（static{}块）中的语句合并产生的</li>\n</ul>\n<h5 id=\"a-初始化发生时机\"><a href=\"#a-初始化发生时机\" class=\"headerlink\" title=\"a. 初始化发生时机\"></a>a. 初始化发生时机</h5><p><strong>类的初始化的懒惰的</strong>，以下情况会初始化</p>\n<ul>\n<li>main 方法所在的类，总会被首先初始化</li>\n<li>首次访问这个类的静态变量或静态方法时</li>\n<li>子类初始化，如果父类还没初始化，会引发</li>\n<li>子类访问父类的静态变量，只会触发父类的初始化</li>\n<li>Class.forName</li>\n<li>new 会导致初始化</li>\n</ul>\n<p>以下情况不会初始化</p>\n<ul>\n<li>访问类的 static ﬁnal 静态常量（基本类型和字符串）</li>\n<li>类对象.class 不会触发初始化</li>\n<li>创建该类对象的数组</li>\n<li>类加载器的.loadClass方法</li>\n<li>Class.forNamed的参数2为false时</li>\n</ul>\n<p><strong>验证类是否被初始化，可以看改类的静态代码块是否被执行</strong></p>\n<h3 id=\"d-类加载器\"><a href=\"#d-类加载器\" class=\"headerlink\" title=\"d. 类加载器\"></a>d. 类加载器</h3><p>​    Java虚拟机设计团队有意把类加载阶段中的<strong>“通过一个类的全限定名来获取描述该类的二进制字节流”</strong>这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为<strong>“类加载器”</strong>（ClassLoader）类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。</p>\n<p>​    站在Java虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用C++实现(这里仅限于<code>Hotspot</code>，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>\n<p>​    对于任意一个类，都必须由加载它的<strong>类加载器</strong>和这个<strong>类本身</strong>一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：<strong>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等</p>\n<p>以JDK 8为例</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>加载的类</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Bootstrap ClassLoader（启动类加载器）</td>\n<td><code>JAVA_HOME/jre/lib</code></td>\n<td>无法直接访问</td>\n</tr>\n<tr>\n<td>Extension ClassLoader(拓展类加载器)</td>\n<td><code>JAVA_HOME/jre/lib/ext</code></td>\n<td>上级为Bootstrap，<strong>显示为null</strong></td>\n</tr>\n<tr>\n<td>Application ClassLoader(应用程序类加载器)</td>\n<td><code>classpath</code></td>\n<td>上级为Extension</td>\n</tr>\n<tr>\n<td>自定义类加载器</td>\n<td>自定义</td>\n<td>上级为Application</td>\n</tr>\n</tbody></table>\n<h4 id=\"1-启动类加载器\"><a href=\"#1-启动类加载器\" class=\"headerlink\" title=\"1. 启动类加载器\"></a>1. 启动类加载器</h4><p>可通过在控制台输入指令，使得类被启动类加器加载</p>\n<h4 id=\"2-拓展类加载器\"><a href=\"#2-拓展类加载器\" class=\"headerlink\" title=\"2. 拓展类加载器\"></a>2. 拓展类加载器</h4><p>​    如果classpath和 <code>JAVA_HOME/jre/lib/ext</code>下有同名类，加载时会使用<strong>拓展类加载器</strong>加载。</p>\n<p>​    当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。</p>\n<h4 id=\"3-双亲委派模式\"><a href=\"#3-双亲委派模式\" class=\"headerlink\" title=\"3. 双亲委派模式\"></a>3. 双亲委派模式</h4><p>双亲委派模式，即调用类加载器  ClassLoader 的 loadClass 方法时，查找类的规则</p>\n<p>loadClass源码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected Class&lt;?&gt; loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n&#123;\n    synchronized (getClassLoadingLock(name)) &#123;\n        &#x2F;&#x2F; 首先查找该类是否已经被该类加载器加载过了\n        Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n        &#x2F;&#x2F;如果没有被加载过\n        if (c ** null) &#123;\n            long t0 &#x3D; System.nanoTime();\n            try &#123;\n                &#x2F;&#x2F;看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null\n                if (parent !&#x3D; null) &#123;\n                    c &#x3D; parent.loadClass(name, false);\n                &#125; else &#123;\n                    &#x2F;&#x2F;看是否被启动类加载器加载过\n                    c &#x3D; findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n                &#x2F;&#x2F; from the non-null parent class loader\n                &#x2F;&#x2F;捕获异常，但不做任何处理\n            &#125;\n            if (c ** null) &#123;\n                &#x2F;&#x2F;如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常\n                &#x2F;&#x2F;然后让应用类加载器去找classpath下找该类\n                long t1 &#x3D; System.nanoTime();\n                c &#x3D; findClass(name);\n                &#x2F;&#x2F; 记录时间\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            &#125;\n        &#125;\n        if (resolve) &#123;\n            resolveClass(c);\n        &#125;\n        return c;\n    &#125;\n&#125;</code></pre>\n\n<p>于是要显示的调用Classd的forName方法使用一个能加载驱动的加载器加载驱动 </p>\n<h4 id=\"4-自定义类加载器\"><a href=\"#4-自定义类加载器\" class=\"headerlink\" title=\"4. 自定义类加载器\"></a>4. 自定义类加载器</h4><p><strong>使用场景</strong></p>\n<ul>\n<li><strong>想加载非 classpath 随意路径中的类文件</strong></li>\n<li>通过接口来使用实现，希望解耦时，常用在框架设计</li>\n<li>这些<strong>类希望予以隔离，不同应用的同名类都可以加载，不冲突</strong>，常见于 tomcat 容器</li>\n</ul>\n<p><strong>步骤</strong></p>\n<ul>\n<li>继承ClassLoader父类</li>\n<li>要遵从双亲委派机制，重写 ﬁndClass 方法<ul>\n<li>不是重写loadClass方法，否则不会走双亲委派机制</li>\n</ul>\n</li>\n<li>读取类文件的字节码</li>\n<li>调用父类的 deﬁneClass 方法来加载类</li>\n<li>使用者调用该类加载器的 loadClass 方法</li>\n</ul>\n<p><strong>破坏双亲委派模式</strong></p>\n<ul>\n<li>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代<ul>\n<li>建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法</li>\n</ul>\n</li>\n<li>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的<ul>\n<li>如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式</li>\n</ul>\n</li>\n<li>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的<ul>\n<li>这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"4-JVM-运行期优化\"><a href=\"#4-JVM-运行期优化\" class=\"headerlink\" title=\"4. JVM 运行期优化\"></a>4. JVM 运行期优化</h2><h3 id=\"a-分层编译\"><a href=\"#a-分层编译\" class=\"headerlink\" title=\"a. 分层编译\"></a>a. 分层编译</h3><p>JVM 将执行状态分成了 5 个层次：</p>\n<ul>\n<li>0层：解释执行，用解释器将字节码翻译为机器码</li>\n<li>1层：使用 C1 <strong>即时编译器</strong>编译执行（不带 proﬁling）</li>\n<li>2层：使用 C1 即时编译器编译执行（带基本的profiling）</li>\n<li>3层：使用 C1 即时编译器编译执行（带完全的profiling）</li>\n<li>4层：使用 C2 即时编译器编译执行</li>\n</ul>\n<p>proﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等</p>\n<h4 id=\"1-即时编译器（JIT）与解释器的区别\"><a href=\"#1-即时编译器（JIT）与解释器的区别\" class=\"headerlink\" title=\"1. 即时编译器（JIT）与解释器的区别\"></a>1. 即时编译器（JIT）与解释器的区别</h4><ul>\n<li>解释器<ul>\n<li>将字节码<strong>解释</strong>为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>\n<li>是将字节码解释为针对所有平台都通用的机器码</li>\n</ul>\n</li>\n<li>即时编译器<ul>\n<li>将一些字节码<strong>编译</strong>为机器码，并<strong>存入 Code Cache</strong>，下次遇到相同的代码，直接执行，无需再编译</li>\n<li>根据平台类型，生成平台特定的机器码</li>\n</ul>\n</li>\n</ul>\n<p>​    对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 <strong>Interpreter &lt; C1 &lt; C2</strong>，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。</p>\n<h4 id=\"2-C2-JIT-逃逸分析\"><a href=\"#2-C2-JIT-逃逸分析\" class=\"headerlink\" title=\"2. C2 JIT 逃逸分析\"></a>2. C2 JIT 逃逸分析</h4><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术</p>\n<p>逃逸分析的 JVM 参数如下：</p>\n<ul>\n<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>\n<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>\n<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>\n</ul>\n<p>逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。</p>\n<h3 id=\"b-方法内联\"><a href=\"#b-方法内联\" class=\"headerlink\" title=\"b. 方法内联\"></a>b. 方法内联</h3><h4 id=\"1-内联函数\"><a href=\"#1-内联函数\" class=\"headerlink\" title=\"1. 内联函数\"></a>1. 内联函数</h4><p>内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。</p>\n<h4 id=\"2-JVM内联函数\"><a href=\"#2-JVM内联函数\" class=\"headerlink\" title=\"2. JVM内联函数\"></a>2. JVM内联函数</h4><p>C++是否为内联函数由自己决定，Java由<strong>编译器决定</strong>。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字<strong>final修饰</strong> 用来指明那个函数是希望被JVM内联的，如</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public final void doSomething() &#123;  \n        &#x2F;&#x2F; to do something  \n&#125;</code></pre>\n\n<p>总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数</p>\n<p>JVM内建有许多运行时优化。首先<strong>短方法</strong>更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。</p>\n<p>如果JVM监测到一些<strong>小方法被频繁的执行</strong>，它会把方法的调用替换成方法体本身，如：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private int add4(int x1, int x2, int x3, int x4) &#123; \n    &#x2F;&#x2F;这里调用了add2方法\n    return add2(x1, x2) + add2(x3, x4);  \n&#125;  \n\nprivate int add2(int x1, int x2) &#123;  \n    return x1 + x2;  \n&#125;</code></pre>\n\n<p>方法调用被替换后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private int add4(int x1, int x2, int x3, int x4) &#123;  \n    &#x2F;&#x2F;被替换为了方法本身\n    return x1 + x2 + x3 + x4;  \n&#125;</code></pre>\n\n<h3 id=\"4-字段优化\"><a href=\"#4-字段优化\" class=\"headerlink\" title=\"4. 字段优化\"></a>4. 字段优化</h3><p>   字段优化即就是在方法内联时,如果需要进行字段访问,会先将参数等字段存到缓存,访问会加快速度。 </p>\n<h3 id=\"5-反射优化\"><a href=\"#5-反射优化\" class=\"headerlink\" title=\"5. 反射优化\"></a>5. 反射优化</h3><p>​    如果一个方法调用通过反射调用,在多次循环调用(默认15次)后,会由编译器优化为从反射调用变为<strong>正常调用</strong>，即直接调用 Reflect1.foo()。</p>\n<h2 id=\"5-Java-内存模型\"><a href=\"#5-Java-内存模型\" class=\"headerlink\" title=\"5. Java 内存模型\"></a>5. Java 内存模型</h2><p><code>Java内存模型</code>和<code>Java内存结构</code>的区别：</p>\n<ul>\n<li><strong>内存模型-Java Memory Model(JMM)</strong>: JMM定义了一套在<strong>多线程读写共享数据</strong>(成员变量、数组等)时，对数据的可见性、有序性和原子性的规则。</li>\n<li>内存结构：就是程序在运行时，线程的内存划分。</li>\n</ul>\n<h3 id=\"a-原子性\"><a href=\"#a-原子性\" class=\"headerlink\" title=\"a.  原子性\"></a>a.  原子性</h3><p>对于一个静态变量的多线程访问,不同运行可能会产生不同结果,这是为什么呢? </p>\n<p>因为Java中对<strong>静态变量的自增自减操作并不是原子操作</strong>。</p>\n<p>i++的字节码:</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">getstatic\t\ti\t# 获取静态变量值\niconst_1\t\t\t# 准备常量1\nidd\t\t\t\t\t# 自增\nputstatic\t\ti\t# 将修改后值存入静态变量</code></pre>\n\n<p>i–的字节码:</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">getstatic\t\ti\t# 获取静态变量值\niconst_1\t\t\t# 准备常量1\nisub\t\t\t\t# 自减\nputstatic\t\ti\t# 将修改后值存入静态变量</code></pre>\n\n<p>本质上，<strong>静态变量是存储在线程共享内存中的</strong>，不同线程访问切换时，可能会导致上述<strong>字节码不是顺序执行</strong>的，从而导致结果不确定性。</p>\n<h4 id=\"1-解决方案\"><a href=\"#1-解决方案\" class=\"headerlink\" title=\"1. 解决方案\"></a>1. 解决方案</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronized(同步关键字)</code></pre>\n\n<p>语法如下</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">synchronized(对象)&#123;\n\t&#x2F;&#x2F; 要作为原子操作的代码\n&#125;</code></pre>\n\n<ul>\n<li>synchronized 只能给对象加锁,加锁的整个代码块都是原子操作</li>\n<li>可以把synchronized代码块看做一个房间,对象就是房间号,而这个房间同时只能由一个线程进入执行。</li>\n<li>注意 synchronized 语句块既可以保证代码块的<strong>原子性</strong>，也同时保证代码块内变量的<strong>可见性</strong>。</li>\n<li>但缺点是 synchronized 是属于<strong>重量级</strong>操作，性能相对更低。</li>\n</ul>\n<h3 id=\"b-可见性\"><a href=\"#b-可见性\" class=\"headerlink\" title=\"b. 可见性\"></a>b. 可见性</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static Boolean run &#x3D; true;\npublic static void main(String[] args) throws InterruptedException &#123;\n    new Thread(()-&gt;&#123;\n        while (run) &#123;\n            &#x2F;&#x2F;如果run为真，则一直执行\n        &#125;\n    &#125;).start();\n\n    Thread.sleep(1000);\n    System.out.println(&quot;改变run的值为false&quot;);\n    &#x2F;&#x2F;这时想要线程退出,但线程并不会退出\n    run &#x3D; false;\n&#125;</code></pre>\n\n<p>上述线程的循环永远退不出,原因是 <strong>静态变量run的改变在主内存中,子线程将run读取到自己的高速缓存中后,和主线程断绝了同步导致无法停止。</strong></p>\n<img src=\"Java-Visual-Machine/20200608145529.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n<h4 id=\"1-解决方法\"><a href=\"#1-解决方法\" class=\"headerlink\" title=\"1. 解决方法\"></a>1. 解决方法</h4><ul>\n<li>使用<code>volatile</code>易变关键字</li>\n<li>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是<strong>直接操作主存</strong></li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;使用易变关键字\nvolatile static Boolean run &#x3D; true;\npublic static void main(String[] args) throws InterruptedException &#123;\n\tnew Thread(()-&gt;&#123;\n\t\twhile (run) &#123;\n\t\t\t&#x2F;&#x2F;如果run为真，则一直执行\n\t\t&#125;\n\t&#125;).start();\n\n\tThread.sleep(1000);\n\tSystem.out.println(&quot;改变run的值为false&quot;);\n\trun &#x3D; false;\n&#125;</code></pre>\n\n<p><strong>可见性</strong>，它保证的是在多个线程之间，<strong>一个线程对volatile变量的修改对另一个线程可见</strong>， <strong>不能</strong>保证原子性，仅适用在<strong>一个写</strong>线程，<strong>多个读</strong>线程的情况。</p>\n<ul>\n<li><p>如果在前面示例的死循环中加入 <code>System.out.println()</code> 会发现即使不加 <code>volatile</code> 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？</p>\n<ul>\n<li><p>因为println()里面使用了<strong>synchronized</strong>关键字</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void println(String x) &#123;\n\t\t&#x2F;&#x2F;使用了synchronized关键字\n        synchronized (this) &#123;\n            print(x);\n            newLine();\n        &#125;\n    &#125;</code></pre></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"c-有序性\"><a href=\"#c-有序性\" class=\"headerlink\" title=\"c. 有序性\"></a>c. 有序性</h3><p>在执行如下操作时:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static int i;\nstatic int j;\n&#x2F;&#x2F; 在某个线程内执行如下赋值操作\n\ni&#x3D; xxxxxxx; &#x2F;&#x2F; 假设这个指令比较耗时\nj &#x3D; yyy;</code></pre>\n\n<p>JVM 在不影响正确性的情况下,对一些不相关语句的执行顺序进行调整。上面这个例子可能会 先给j赋值再给i赋值。</p>\n<p>这在同一个线程内，不会造成问题，多线程可能会造成错误结果。</p>\n<h4 id=\"1-指令重排\"><a href=\"#1-指令重排\" class=\"headerlink\" title=\"1. 指令重排\"></a>1. 指令重排</h4><p>JVM 会在<strong>不影响正确性</strong>的前提下，可以<strong>调整</strong>语句的执行<strong>顺序</strong></p>\n<p>这种特性称之为『<strong>指令重排</strong>』，<strong>多线程下『指令重排』会影响正确性</strong>。</p>\n<h4 id=\"2-解决办法\"><a href=\"#2-解决办法\" class=\"headerlink\" title=\"2. 解决办法\"></a>2. 解决办法</h4><p><code>volatile修饰</code>的变量，可以<strong>禁用</strong>指令重排</p>\n<ul>\n<li>禁止的是加volatile关键字变量之前的代码被重排序</li>\n</ul>\n<h3 id=\"d-CAS-与原子类\"><a href=\"#d-CAS-与原子类\" class=\"headerlink\" title=\"d. CAS 与原子类\"></a>d. CAS 与原子类</h3><h4 id=\"1-CAS\"><a href=\"#1-CAS\" class=\"headerlink\" title=\"1.CAS\"></a>1.CAS</h4><p>CAS 即 Compare and swap ,它体现了一种乐观锁的思想,比如多个线程要对一个共享的整型变量执行+1操作:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 不断尝试\nwhile(true)&#123;\n    int old &#x3D; 共享变量;     &#x2F;&#x2F; 拿到当前值0\n    int result &#x3D; old + 1;  &#x2F;&#x2F; 在旧值0基础上+1 结果为1\n   \t&#x2F;* \n   \t如果这时候别的线程把共享变量改成5 本线程为1就作废\n   \tcompareAndSwap(old,result) false 重新尝试\n    直到compareAndSwap(old,result)返回true,然后退出循环\n   \t*&#x2F;\n    if(compareAndSwap(old,result))&#123;\n        &#x2F;&#x2F; 成功,退出循环\n    &#125;\n&#125;</code></pre>\n\n<p>获取共享变量时,为了保证该变量的可见性,需要用<code>volatile</code>修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的情况下。</p>\n<ul>\n<li>因为没有使用 synchronized ，所以线程不会陷入阻塞，这是提升效率的因素之一。</li>\n<li>如果竞争激烈，可以想到重试必然发生，反而会影响效率。</li>\n</ul>\n<p>CAS底层依赖一个Unsafe类来直接调用操作系统底层的CAS指令。</p>\n<h4 id=\"2-JUC\"><a href=\"#2-JUC\" class=\"headerlink\" title=\"2.JUC\"></a>2.JUC</h4><p>JUC(java.util.concurrent)中提供了原子操作类,可以提供线程安全的操作。如：AtomicInteger,AtomicBoolean等,他们底层就采用了 CAS+volatile 实现无锁并发。</p>\n<h3 id=\"乐观锁与悲观锁\"><a href=\"#乐观锁与悲观锁\" class=\"headerlink\" title=\"# 乐观锁与悲观锁\"></a># 乐观锁与悲观锁</h3><ul>\n<li>CAS 是基于<strong>乐观锁</strong>的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li>\n<li>synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li>\n</ul>\n<h3 id=\"Synchronized\"><a href=\"#Synchronized\" class=\"headerlink\" title=\"# Synchronized\"></a># Synchronized</h3><p>Java HotSpot JVM中,每个对象都有对象头(class指针,MarkWord),Mark Word 平时存储这个对象的HashCode、分代年龄等，加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。</p>\n<h4 id=\"1-轻量级锁\"><a href=\"#1-轻量级锁\" class=\"headerlink\" title=\"1. 轻量级锁\"></a>1. 轻量级锁</h4><p>​    <strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。</p>\n<p>​    如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录<code>Lock Record</code>的空间用于存储锁对象目前的<code>Mark Word</code>的拷贝。</p>\n<p>​    然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(<code>Mark Word</code>中最后的2bit)00，即表示此对象处于轻量级锁定状态</p>\n<h4 id=\"2-轻量级锁-锁膨胀\"><a href=\"#2-轻量级锁-锁膨胀\" class=\"headerlink\" title=\"2. 轻量级锁-锁膨胀\"></a>2. 轻量级锁-锁膨胀</h4><p>​    轻量级解锁时，会使用原子的CAS操作将<code>Displaced Mark Word</code>替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。</p>\n<h4 id=\"3-重量级锁-自旋\"><a href=\"#3-重量级锁-自旋\" class=\"headerlink\" title=\"3. 重量级锁-自旋\"></a>3. 重量级锁-自旋</h4><p><strong>锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)</strong></p>\n<p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化，如果当前线程在<strong>自旋成功</strong>（<strong>使用锁的线程退出了同步块，</strong>释放了锁****），这时就可以避免线程进入阻塞状态。</p>\n<h4 id=\"4-偏向锁\"><a href=\"#4-偏向锁\" class=\"headerlink\" title=\"4. 偏向锁\"></a>4. 偏向锁</h4><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p>\n<p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p>\n<h3 id=\"e-锁优化原则\"><a href=\"#e-锁优化原则\" class=\"headerlink\" title=\"e. 锁优化原则\"></a>e. 锁优化原则</h3><ol>\n<li>减少上锁时间</li>\n<li>减小锁的粒度-将一个锁拆分为多个锁提高并发度</li>\n<li>锁粗化-多次循环进入锁不如同步块内多次循环</li>\n<li>锁消除-通过JVM逃逸分析,如锁对象的局部变量不会被其他线程访问,就会忽略所有的同步操作。</li>\n<li>读写分离</li>\n</ol>\n","text":"JVM(Java Visual Machine)JVM java二进制字节码运行的环境 JVM 是java程序可移植性的基石。 好处: 一次编译，到处执行 自动内存管理 常见错误检查（数组越界检查） JVM组成部分 JVM内存结构 字节码结构 Java类加载机制 GC垃圾回收 1...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"},{"name":"Java虚拟机","slug":"Java虚拟机","count":1,"path":"api/tags/Java虚拟机.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM-Java-Visual-Machine\"><span class=\"toc-text\">JVM(Java Visual Machine)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-JVM%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1. JVM的内存结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">a. 程序计数器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">b. 虚拟机栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">c. 本地方法栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E5%A0%86\"><span class=\"toc-text\">d. 堆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">e. 方法区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#StringTable-%E4%B8%B2%E6%B1%A0\"><span class=\"toc-text\"># StringTable 串池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Direct-Memory-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\"><span class=\"toc-text\"># Direct Memory 直接内存</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-GC-Garbage-Collector\"><span class=\"toc-text\">2. GC Garbage Collector</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%9E%83%E5%9C%BE%E5%91%A2\"><span class=\"toc-text\">a. 如何确定一个对象是垃圾呢?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E5%BC%95%E7%94%A8\"><span class=\"toc-text\"># 常见引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E4%B8%BB%E8%A6%81%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">b. 主要的垃圾回收算法:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">c. 分代垃圾回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5\"><span class=\"toc-text\"># 内存分配策略</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">d. 垃圾回收器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\"># G1 垃圾回收器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">e. 垃圾回收调优</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JVM-GC-%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">JVM GC 面试题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">3. 类加载</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E7%B1%BB%E5%AD%97%E8%8A%82%E7%A0%81\"><span class=\"toc-text\">a. 类字节码</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#javap-%E5%8F%8D%E7%BC%96%E8%AF%91class%E6%96%87%E4%BB%B6\"><span class=\"toc-text\"># javap 反编译class文件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8\"><span class=\"toc-text\"># 方法调用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%80%81%E5%8E%9F%E7%90%86\"><span class=\"toc-text\"># 多态原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\"># 异常处理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E8%AF%AD%E6%B3%95%E7%B3%96\"><span class=\"toc-text\">b. 语法糖</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1. 默认构造函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1\"><span class=\"toc-text\">2. 自动拆装箱</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E6%B3%9B%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC\"><span class=\"toc-text\">3. 泛型集合取值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">4. 可变参数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-foreach\"><span class=\"toc-text\">5. foreach</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-switch%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">6. switch字符串</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#7-%E6%9E%9A%E4%B8%BE%E7%B1%BB\"><span class=\"toc-text\">7. 枚举类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#8-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">8. 匿名内部类</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">c. 类加载机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">1. 加载</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%93%BE%E6%8E%A5\"><span class=\"toc-text\">2. 链接</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">a. 验证</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#b-%E5%87%86%E5%A4%87\"><span class=\"toc-text\">b. 准备</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#c-%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">c. 解析</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">3. 初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#a-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%91%E7%94%9F%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">a. 初始化发生时机</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">d. 类加载器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">1. 启动类加载器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E6%8B%93%E5%B1%95%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">2. 拓展类加载器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">3. 双亲委派模式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8\"><span class=\"toc-text\">4. 自定义类加载器</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-JVM-%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4. JVM 运行期优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91\"><span class=\"toc-text\">a. 分层编译</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%88JIT%EF%BC%89%E4%B8%8E%E8%A7%A3%E9%87%8A%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1. 即时编译器（JIT）与解释器的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-C2-JIT-%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2. C2 JIT 逃逸分析</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94\"><span class=\"toc-text\">b. 方法内联</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">1. 内联函数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JVM%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">2. JVM内联函数</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%AD%97%E6%AE%B5%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">4. 字段优化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%8F%8D%E5%B0%84%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">5. 反射优化</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">5. Java 内存模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">a.  原子性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">1. 解决方案</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E5%8F%AF%E8%A7%81%E6%80%A7\"><span class=\"toc-text\">b. 可见性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">1. 解决方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%9C%89%E5%BA%8F%E6%80%A7\"><span class=\"toc-text\">c. 有序性</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92\"><span class=\"toc-text\">1. 指令重排</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95\"><span class=\"toc-text\">2. 解决办法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-CAS-%E4%B8%8E%E5%8E%9F%E5%AD%90%E7%B1%BB\"><span class=\"toc-text\">d. CAS 与原子类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-CAS\"><span class=\"toc-text\">1.CAS</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-JUC\"><span class=\"toc-text\">2.JUC</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\"># 乐观锁与悲观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Synchronized\"><span class=\"toc-text\"># Synchronized</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">1. 轻量级锁</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%94%81%E8%86%A8%E8%83%80\"><span class=\"toc-text\">2. 轻量级锁-锁膨胀</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81-%E8%87%AA%E6%97%8B\"><span class=\"toc-text\">3. 重量级锁-自旋</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%81%8F%E5%90%91%E9%94%81\"><span class=\"toc-text\">4. 偏向锁</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-%E9%94%81%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">e. 锁优化原则</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Git基础","uid":"7972c32d39f314ccb6f804289f8a291c","slug":"Git基础","date":"2022-04-07T13:36:21.000Z","updated":"2022-04-07T13:43:22.527Z","comments":true,"path":"api/articles/Git基础.json","keywords":null,"cover":[],"text":"分布式版本控制系统 简单理论四个工作区域： 工作目录 暂存区（Index\\Stage） 仓库区（Repository） 远程仓库（Remote） 基本配置$ git config -l 查看基础配置 本地存放位置 Git\\etc\\gitconfig中 $ git config -...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"JUC","date":"2022-04-07T12:19:18.000Z","updated":"2022-04-08T09:27:51.114Z","comments":true,"path":"api/articles/JUC.json","keywords":null,"cover":[],"text":"1. JUC 概述所谓JUC是 java.util.concurrent 工具包的简称，这是一个处理线程的工具包，可以实现程序的多线程高并发。 多线程编程的一般步骤: 创建资源类,在资源类创建属性和操作方法。 在资源类操作方法:判断、操作、通知 创建多个线程，调用资源类的操作方法...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":9,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}