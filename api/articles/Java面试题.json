{"title":"Java面试题","uid":"e551e8b61cca027580338cf7a83d4c1a","slug":"Java面试题","date":"2022-08-30T08:08:03.000Z","updated":"2022-08-31T08:54:57.797Z","comments":true,"path":"api/articles/Java面试题.json","keywords":null,"cover":"/svg/java.svg","content":"<p style=\"text-align: center; font-size:32px;font-weight:bold;\">JAVA面试题</p>\n\n<hr>\n<h5 id=\"1-finalize-方法有什么特点\"><a href=\"#1-finalize-方法有什么特点\" class=\"headerlink\" title=\"1. finalize()方法有什么特点?\"></a>1. <code>finalize()</code>方法有什么特点?</h5><p><code>finalize()</code>方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用<code>finalize()</code>，而且只有在<strong>下一次</strong>垃圾收集过程中，才会真正回收对象的内存。如果大量对象都重写了<code>finalize()</code>方法,有可能会造成内存溢出,因为实际的内存回收是在下次的gc执行的时候。</p>\n<p>在绝大多数情况下,<strong>不需要</strong>重写<code>finalize()</code>方法</p>\n<h5 id=\"2-软引用是什么\"><a href=\"#2-软引用是什么\" class=\"headerlink\" title=\"2. 软引用是什么?\"></a>2. 软引用是什么?</h5><h5 id=\"3-介绍一下ThreadLocal是什么-有什么特点\"><a href=\"#3-介绍一下ThreadLocal是什么-有什么特点\" class=\"headerlink\" title=\"3. 介绍一下ThreadLocal是什么?有什么特点?\"></a>3. 介绍一下ThreadLocal是什么?有什么特点?</h5><p>​    ThreadLocal叫做<strong>线程变量</strong>,意思是ThreadLocal中<strong>填充的变量</strong>属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>\n<p>ThreadLocal的设计</p>\n<ol>\n<li>在JDK早期的设计中，每个ThreadLocal都有一个map对象，将线程作为map对象的key，要存储的变量作为map的value，但是现在已经不是这样了。</li>\n<li>JDK8之后，<strong>每个Thread维护一个ThreadLocalMap对象，这个Map的key是ThreadLocal实例本身，value是存储的值要隔离的变量，是泛型，</strong>其具体过程如下：<ul>\n<li>每个Thread线程内部都有一个Map（ThreadLocalMap::threadlocals）;</li>\n<li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）;</li>\n<li>Thread内部的Map由ThreadLocal维护，由ThreadLocal负责向map获取和设置变量值;</li>\n<li>对于不同的线程，每次获取副本值时，别的线程不能获取当前线程的副本值，就形成了数据之间的隔离。</li>\n<li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存使用，早期的ThreadLocal并不会自动销毁。 <strong>这也是为什么使用弱引用 WeakReference</strong></li>\n</ul>\n</li>\n</ol>\n<p>要保证ThreadLocal不发生内存泄漏:</p>\n<ol>\n<li>设计上使用了WeakReference</li>\n<li>使用完ThreadLocal，调用其remove方法删除对应的Entry或者使用完ThreadLocal</li>\n</ol>\n<p>使用ThreadLocal的好处</p>\n<ol>\n<li>保存每个线程绑定的数据，在需要的地方可以直接获取，避免直接传递参数带来的代码耦合问题；</li>\n<li>各个线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。</li>\n</ol>\n<p>常见的使用场景:</p>\n<ul>\n<li><p>场景一：在重入方法中替代参数的显式传递</p>\n<p> 假如在我们的业务方法中需要调用其他方法，同时其他方法都需要用到同一个对象时，可以使用ThreadLocal替代参数的传递或者static静态全局变量。这是因为使用参数传递造成代码的耦合度高，使用静态全局变量在多线程环境下不安全。当该对象用ThreadLocal包装过后，就可以保证在该线程中独此一份，同时和其他线程隔离。</p>\n<p> 例如在Spring的<code>@Transaction</code>事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</p>\n</li>\n<li><p>场景二：全局存储用户信息</p>\n</li>\n<li><p>场景三：解决线程安全问题</p>\n</li>\n</ul>\n<h5 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h5>","text":"JAVA面试题 1. finalize()方法有什么特点?finalize()方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。如...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-finalize-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1. finalize()方法有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%BD%AF%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2. 软引用是什么?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3. 介绍一下ThreadLocal是什么?有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4\"><span class=\"toc-text\">4.</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Mysql 面试题","uid":"4d0cd99506fa5ed9a6631a984ab7b868","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","updated":"2022-08-31T11:34:26.457Z","comments":true,"path":"api/articles/Mysql 面试题.json","keywords":null,"cover":"/svg/mysql.svg","text":"Mysql 面试题1. B树和B+树的区别?相同点: 都是多路平衡查找树 一个节点中都有多个元素,且有序 不同点: B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中； B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"},{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}