{"title":"Java面试题","uid":"e551e8b61cca027580338cf7a83d4c1a","slug":"Java面试题","date":"2022-08-30T08:08:03.000Z","updated":"2022-09-06T06:56:55.887Z","comments":true,"path":"api/articles/Java面试题.json","keywords":null,"cover":"/svg/java.svg","content":"<p style=\"text-align: center; font-size:32px;font-weight:bold;\">JAVA面试题</p>\n\n<hr>\n<h5 id=\"1-finalize-方法有什么特点\"><a href=\"#1-finalize-方法有什么特点\" class=\"headerlink\" title=\"1. finalize()方法有什么特点?\"></a>1. <code>finalize()</code>方法有什么特点?</h5><p><code>finalize()</code>方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用<code>finalize()</code>，而且只有在<strong>下一次</strong>垃圾收集过程中，才会真正回收对象的内存。如果大量对象都重写了<code>finalize()</code>方法,有可能会造成内存溢出,因为实际的内存回收是在下次的gc执行的时候。</p>\n<p>在绝大多数情况下,<strong>不需要</strong>重写<code>finalize()</code>方法</p>\n<h5 id=\"2-软引用是什么\"><a href=\"#2-软引用是什么\" class=\"headerlink\" title=\"2. 软引用是什么?\"></a>2. 软引用是什么?</h5><h5 id=\"3-介绍一下ThreadLocal是什么-有什么特点\"><a href=\"#3-介绍一下ThreadLocal是什么-有什么特点\" class=\"headerlink\" title=\"3. 介绍一下ThreadLocal是什么?有什么特点?\"></a>3. 介绍一下ThreadLocal是什么?有什么特点?</h5><p>​    ThreadLocal叫做<strong>线程变量</strong>,意思是ThreadLocal中<strong>填充的变量</strong>属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>\n<p>ThreadLocal的设计</p>\n<ol>\n<li>在JDK早期的设计中，每个ThreadLocal都有一个map对象，将线程作为map对象的key，要存储的变量作为map的value，但是现在已经不是这样了。</li>\n<li>JDK8之后，<strong>每个Thread维护一个ThreadLocalMap对象，这个Map的key是ThreadLocal实例本身，value是存储的值要隔离的变量，是泛型，</strong>其具体过程如下：<ul>\n<li>每个Thread线程内部都有一个Map（ThreadLocalMap::threadlocals）;</li>\n<li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）;</li>\n<li>Thread内部的Map由ThreadLocal维护，由ThreadLocal负责向map获取和设置变量值;</li>\n<li>对于不同的线程，每次获取副本值时，别的线程不能获取当前线程的副本值，就形成了数据之间的隔离。</li>\n<li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存使用，早期的ThreadLocal并不会自动销毁。 <strong>这也是为什么使用弱引用 WeakReference</strong></li>\n</ul>\n</li>\n</ol>\n<p>要保证ThreadLocal不发生内存泄漏:</p>\n<ol>\n<li>设计上使用了WeakReference</li>\n<li>使用完ThreadLocal，调用其remove方法删除对应的Entry或者使用完ThreadLocal</li>\n</ol>\n<p>使用ThreadLocal的好处</p>\n<ol>\n<li>保存每个线程绑定的数据，在需要的地方可以直接获取，避免直接传递参数带来的代码耦合问题；</li>\n<li>各个线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。</li>\n</ol>\n<p>常见的使用场景:</p>\n<ul>\n<li><p>场景一：在重入方法中替代参数的显式传递</p>\n<p> 假如在我们的业务方法中需要调用其他方法，同时其他方法都需要用到同一个对象时，可以使用ThreadLocal替代参数的传递或者static静态全局变量。这是因为使用参数传递造成代码的耦合度高，使用静态全局变量在多线程环境下不安全。当该对象用ThreadLocal包装过后，就可以保证在该线程中独此一份，同时和其他线程隔离。</p>\n<p> 例如在Spring的<code>@Transaction</code>事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</p>\n</li>\n<li><p>场景二：全局存储用户信息</p>\n</li>\n<li><p>场景三：解决线程安全问题</p>\n</li>\n</ul>\n<h5 id=\"4-Java创建对象有几种方式？\"><a href=\"#4-Java创建对象有几种方式？\" class=\"headerlink\" title=\"4.  Java创建对象有几种方式？\"></a>4.  Java创建对象有几种方式？</h5><p> java中提供了以下四种创建对象的方式:</p>\n<ul>\n<li><p>new创建新对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">StringBuilder builder &#x3D; new StringBuilder();</code></pre>\n</li>\n<li><p>通过反射机制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;HashMap&gt; aClass &#x3D; HashMap.class;\nHashMap map1 &#x3D; aClass.newInstance(); &#x2F;&#x2F; 方法一 废弃\nHashMap map2 &#x3D; aClass.getConstructor().newInstance(); &#x2F;&#x2F; 调用构造器</code></pre>\n</li>\n<li><p>采用clone机制 </p>\n<p>通过Clone创建对象，首先要在实体类中<strong>必须先实现Cloneable接口</strong>并复写Object的clone方法（因为Object的这个方法是protected的，你若不复写，外部也调用不了呀）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HashMap map1 &#x3D; new HashMap&lt;Integer, Integer&gt;();\nHashMap o &#x3D; (HashMap) map1.clone(); &#x2F;&#x2F; 不调用构造器\no.put(1, 2);</code></pre>\n</li>\n<li><p>通过序列化机制 不调用构造器</p>\n</li>\n</ul>\n<h5 id=\"5-深拷贝浅拷贝的区别\"><a href=\"#5-深拷贝浅拷贝的区别\" class=\"headerlink\" title=\"5. 深拷贝浅拷贝的区别\"></a>5. 深拷贝浅拷贝的区别</h5><p>浅拷贝：对基本数据类型进行值传递，<strong>对引用数据类型进行引用传递般的拷贝</strong>，此为浅拷贝。</p>\n<p>深拷贝：对基本数据类型进行值传递，<strong>对引用数据类型，创建一个新的对象，并复制其内容</strong>，此为深拷贝。</p>\n<h5 id=\"6-BIO、NIO、AIO-有什么区别？\"><a href=\"#6-BIO、NIO、AIO-有什么区别？\" class=\"headerlink\" title=\"6. BIO、NIO、AIO 有什么区别？\"></a>6. BIO、NIO、AIO 有什么区别？</h5><ul>\n<li>BIO：<code>Block IO</code> 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>\n<li>NIO：<code>New IO</code> 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>\n<li>AIO：<code>Asynchronous IO</code> 是 NIO 的升级，也叫 NIO2，实现了<strong>异步非堵塞 IO</strong> ，异步 IO 的操作基于事件和回调机制。</li>\n</ul>\n<h5 id=\"7-synchronized-和-ReentrantLock-有什么不同？\"><a href=\"#7-synchronized-和-ReentrantLock-有什么不同？\" class=\"headerlink\" title=\"7.  synchronized 和 ReentrantLock 有什么不同？\"></a>7.  synchronized 和 ReentrantLock 有什么不同？</h5><p>相似点  </p>\n<p>   这两种同步方式有很多相似之处，<strong>它们都是加锁方式同步，而且都是阻塞式的同步</strong>，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.</p>\n<p>区别  </p>\n<ul>\n<li><p>这两种方式最大区别就是对于Synchronized来说，它是Java语言的关键字，是原生语法层面的互斥，需要jvm实现。</p>\n</li>\n<li><p>而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成。</p>\n</li>\n</ul>\n<p>​    <code>synchronized</code>经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。 </p>\n<p>​    由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：  </p>\n<ul>\n<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。    </li>\n<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。    </li>\n<li>锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。</li>\n</ul>\n<h5 id=\"8-说说进程和线程的区别？\"><a href=\"#8-说说进程和线程的区别？\" class=\"headerlink\" title=\"8.  说说进程和线程的区别？\"></a>8.  说说进程和线程的区别？</h5><ol>\n<li>进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。    </li>\n<li>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）    </li>\n<li>线程上下文的切换比进程上下文切换要快很多。    <ol>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。    </li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"9-熟悉CAS原理？有什么缺点？\"><a href=\"#9-熟悉CAS原理？有什么缺点？\" class=\"headerlink\" title=\"9. 熟悉CAS原理？有什么缺点？\"></a>9. 熟悉CAS原理？有什么缺点？</h5><p>CAS叫做<code>CompareAndSwap</code>，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：   </p>\n<ol>\n<li>变量内存地址，V表示    </li>\n<li>旧的预期值，A表示    </li>\n<li>准备设置的新值，B表示</li>\n</ol>\n<p><strong>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</strong> </p>\n<blockquote><p>CAS有三个缺点:</p>\n<p><strong>ABA问题</strong>:ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。 </p>\n<p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。  </p>\n<p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。  </p>\n<p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。  </p></blockquote>\n<h5 id=\"10-内存分配和回收原则\"><a href=\"#10-内存分配和回收原则\" class=\"headerlink\" title=\"10. 内存分配和回收原则\"></a>10. 内存分配和回收原则</h5><p>Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>\n<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p>\n<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>\n<ol>\n<li>新生代内存(Young Generation)</li>\n<li>老生代(Old Generation)</li>\n<li>永久代(Permanent Generation)</li>\n</ol>\n<img src=\"/post/Java%E9%9D%A2%E8%AF%95%E9%A2%98/hotspot-heap-structure.41533631.png\" class=\"\" title=\"hotspot-heap-structure\">\n\n<p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存。</strong> </p>\n<p>对象分配过程:</p>\n<ul>\n<li><p>对象优先在 Eden 区分配</p>\n<p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 <code>Minor GC。</code></p>\n</li>\n<li><p>大对象直接进入老年代</p>\n<p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>\n<p>大对象直接进入老年代主要是<strong>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</strong></p>\n</li>\n<li><p>长期存活的对象将进入老年代</p>\n<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p>\n<p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p>\n</li>\n</ul>\n<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>\n<p>部分收集 (Partial GC)：</p>\n<ul>\n<li>新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；</li>\n<li>老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>\n<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>\n</ul>\n<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p>\n<h5 id=\"11-判断对象死亡的方法\"><a href=\"#11-判断对象死亡的方法\" class=\"headerlink\" title=\"11. 判断对象死亡的方法?\"></a>11. 判断对象死亡的方法?</h5><ol>\n<li>引用计数法</li>\n</ol>\n<p>给对象中添加一个引用计数器：</p>\n<ul>\n<li>每当有一个地方引用它，计数器就加 1；</li>\n<li>当引用失效，计数器就减 1；</li>\n<li>任何时候计数器为 0 的对象就是不可能再被使用的。</li>\n</ul>\n<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p>\n<ol start=\"2\">\n<li>可达性分析算法</li>\n</ol>\n<p>通过一系列的称为 “<code>GC Roots</code>” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p>\n<p><strong>哪些对象可以作为 GC Roots 呢？</strong></p>\n<ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>\n<li>本地方法栈(Native 方法)中引用的对象</li>\n<li>方法区中类静态属性引用的对象</li>\n<li>方法区中常量引用的对象</li>\n<li>所有被同步锁持有的对象</li>\n</ul>\n<p><strong>对象可以被回收，就代表一定会被回收吗？</strong></p>\n<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>\n<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>\n<blockquote><p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。</p></blockquote>\n<h5 id=\"12-垃圾回收算法有哪些？\"><a href=\"#12-垃圾回收算法有哪些？\" class=\"headerlink\" title=\"12. 垃圾回收算法有哪些？\"></a>12. 垃圾回收算法有哪些？</h5><ol>\n<li>标记-清除算法</li>\n</ol>\n<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>\n<ul>\n<li><p><strong>效率问题</strong></p>\n</li>\n<li><p><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></p>\n</li>\n</ul>\n<ol start=\"2\">\n<li>标记-复制算法</li>\n</ol>\n<p>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>\n<ol start=\"3\">\n<li>标记-整理算法</li>\n</ol>\n<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>\n<ol start=\"4\">\n<li>分代收集算法</li>\n</ol>\n<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>\n<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>\n<h5 id=\"13\"><a href=\"#13\" class=\"headerlink\" title=\"13.\"></a>13.</h5>","text":"JAVA面试题 1. finalize()方法有什么特点?finalize()方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。如...","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-finalize-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1. finalize()方法有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%BD%AF%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2. 软引用是什么?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3. 介绍一下ThreadLocal是什么?有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">4.  Java创建对象有几种方式？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5. 深拷贝浅拷贝的区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">6. BIO、NIO、AIO 有什么区别？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">7.  synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">8.  说说进程和线程的区别？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-%E7%86%9F%E6%82%89CAS%E5%8E%9F%E7%90%86%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">9. 熟悉CAS原理？有什么缺点？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#10-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">10. 内存分配和回收原则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#11-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%AD%BB%E4%BA%A1%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">11. 判断对象死亡的方法?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#12-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\"><span class=\"toc-text\">12. 垃圾回收算法有哪些？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#13\"><span class=\"toc-text\">13.</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"项目亮点","uid":"da8e06681356f7590e60f2c8a230b7d7","slug":"项目亮点","date":"2022-09-01T08:06:49.000Z","updated":"2022-09-02T06:55:26.937Z","comments":true,"path":"api/articles/项目亮点.json","keywords":null,"cover":null,"text":"a. IM即时通信项目1. 消息发送过程中可能出现不可靠的情况1. A --发消息--&gt; Server --转发--&gt; B 2. A &lt;-- 确认 -- Server &lt;--确认-- B 第一部分中可能丢失消息的场景有下面这些。 如果用户 A 在把消息发送...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"项目","slug":"项目","count":1,"path":"api/tags/项目.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"Mysql 面试题","uid":"4d0cd99506fa5ed9a6631a984ab7b868","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","updated":"2022-08-31T11:34:26.457Z","comments":true,"path":"api/articles/Mysql 面试题.json","keywords":null,"cover":"/svg/mysql.svg","text":"Mysql 面试题1. B树和B+树的区别?相同点: 都是多路平衡查找树 一个节点中都有多个元素,且有序 不同点: B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中； B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"},{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}