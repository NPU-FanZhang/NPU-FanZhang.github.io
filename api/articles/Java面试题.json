{"title":"Java面试题","uid":"e551e8b61cca027580338cf7a83d4c1a","slug":"Java面试题","date":"2022-08-30T08:08:03.000Z","updated":"2022-09-05T09:12:42.461Z","comments":true,"path":"api/articles/Java面试题.json","keywords":null,"cover":"/svg/java.svg","content":"<p style=\"text-align: center; font-size:32px;font-weight:bold;\">JAVA面试题</p>\n\n<hr>\n<h5 id=\"1-finalize-方法有什么特点\"><a href=\"#1-finalize-方法有什么特点\" class=\"headerlink\" title=\"1. finalize()方法有什么特点?\"></a>1. <code>finalize()</code>方法有什么特点?</h5><p><code>finalize()</code>方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用<code>finalize()</code>，而且只有在<strong>下一次</strong>垃圾收集过程中，才会真正回收对象的内存。如果大量对象都重写了<code>finalize()</code>方法,有可能会造成内存溢出,因为实际的内存回收是在下次的gc执行的时候。</p>\n<p>在绝大多数情况下,<strong>不需要</strong>重写<code>finalize()</code>方法</p>\n<h5 id=\"2-软引用是什么\"><a href=\"#2-软引用是什么\" class=\"headerlink\" title=\"2. 软引用是什么?\"></a>2. 软引用是什么?</h5><h5 id=\"3-介绍一下ThreadLocal是什么-有什么特点\"><a href=\"#3-介绍一下ThreadLocal是什么-有什么特点\" class=\"headerlink\" title=\"3. 介绍一下ThreadLocal是什么?有什么特点?\"></a>3. 介绍一下ThreadLocal是什么?有什么特点?</h5><p>​    ThreadLocal叫做<strong>线程变量</strong>,意思是ThreadLocal中<strong>填充的变量</strong>属于当前线程，该变量对其他线程而言是隔离的，也就是说该变量是当前线程独有的变量。ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>\n<p>ThreadLocal的设计</p>\n<ol>\n<li>在JDK早期的设计中，每个ThreadLocal都有一个map对象，将线程作为map对象的key，要存储的变量作为map的value，但是现在已经不是这样了。</li>\n<li>JDK8之后，<strong>每个Thread维护一个ThreadLocalMap对象，这个Map的key是ThreadLocal实例本身，value是存储的值要隔离的变量，是泛型，</strong>其具体过程如下：<ul>\n<li>每个Thread线程内部都有一个Map（ThreadLocalMap::threadlocals）;</li>\n<li>Map里面存储ThreadLocal对象（key）和线程的变量副本（value）;</li>\n<li>Thread内部的Map由ThreadLocal维护，由ThreadLocal负责向map获取和设置变量值;</li>\n<li>对于不同的线程，每次获取副本值时，别的线程不能获取当前线程的副本值，就形成了数据之间的隔离。</li>\n<li>当Thread销毁的时候，ThreadLocalMap也会随之销毁，减少内存使用，早期的ThreadLocal并不会自动销毁。 <strong>这也是为什么使用弱引用 WeakReference</strong></li>\n</ul>\n</li>\n</ol>\n<p>要保证ThreadLocal不发生内存泄漏:</p>\n<ol>\n<li>设计上使用了WeakReference</li>\n<li>使用完ThreadLocal，调用其remove方法删除对应的Entry或者使用完ThreadLocal</li>\n</ol>\n<p>使用ThreadLocal的好处</p>\n<ol>\n<li>保存每个线程绑定的数据，在需要的地方可以直接获取，避免直接传递参数带来的代码耦合问题；</li>\n<li>各个线程之间的数据相互隔离却又具备并发性，避免同步方式带来的性能损失。</li>\n</ol>\n<p>常见的使用场景:</p>\n<ul>\n<li><p>场景一：在重入方法中替代参数的显式传递</p>\n<p> 假如在我们的业务方法中需要调用其他方法，同时其他方法都需要用到同一个对象时，可以使用ThreadLocal替代参数的传递或者static静态全局变量。这是因为使用参数传递造成代码的耦合度高，使用静态全局变量在多线程环境下不安全。当该对象用ThreadLocal包装过后，就可以保证在该线程中独此一份，同时和其他线程隔离。</p>\n<p> 例如在Spring的<code>@Transaction</code>事务声明的注解中就使用ThreadLocal保存了当前的Connection对象，避免在本次调用的不同方法中使用不同的Connection对象。</p>\n</li>\n<li><p>场景二：全局存储用户信息</p>\n</li>\n<li><p>场景三：解决线程安全问题</p>\n</li>\n</ul>\n<h5 id=\"4-Java创建对象有几种方式？\"><a href=\"#4-Java创建对象有几种方式？\" class=\"headerlink\" title=\"4.  Java创建对象有几种方式？\"></a>4.  Java创建对象有几种方式？</h5><p> java中提供了以下四种创建对象的方式:</p>\n<ul>\n<li><p>new创建新对象</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">StringBuilder builder &#x3D; new StringBuilder();</code></pre>\n</li>\n<li><p>通过反射机制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Class&lt;HashMap&gt; aClass &#x3D; HashMap.class;\nHashMap map1 &#x3D; aClass.newInstance(); &#x2F;&#x2F; 方法一 废弃\nHashMap map2 &#x3D; aClass.getConstructor().newInstance(); &#x2F;&#x2F; 调用构造器</code></pre>\n</li>\n<li><p>采用clone机制 通过Clone创建对象，首先要在实体类中<strong>必须先实现Cloneable接口</strong>并复写Object的clone方法（因为Object的这个方法是protected的，你若不复写，外部也调用不了呀）。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">HashMap map1 &#x3D; new HashMap&lt;Integer, Integer&gt;();\nHashMap o &#x3D; (HashMap) map1.clone(); &#x2F;&#x2F; 不调用构造器\no.put(1, 2);</code></pre>\n</li>\n<li><p>通过序列化机制 不调用构造器</p>\n</li>\n</ul>\n<h5 id=\"5-深拷贝浅拷贝的区别\"><a href=\"#5-深拷贝浅拷贝的区别\" class=\"headerlink\" title=\"5. 深拷贝浅拷贝的区别\"></a>5. 深拷贝浅拷贝的区别</h5><p>浅拷贝：对基本数据类型进行值传递，<strong>对引用数据类型进行引用传递般的拷贝</strong>，此为浅拷贝。</p>\n<p>深拷贝：对基本数据类型进行值传递，<strong>对引用数据类型，创建一个新的对象，并复制其内容</strong>，此为深拷贝。</p>\n<h5 id=\"6-BIO、NIO、AIO-有什么区别？\"><a href=\"#6-BIO、NIO、AIO-有什么区别？\" class=\"headerlink\" title=\"6. BIO、NIO、AIO 有什么区别？\"></a>6. BIO、NIO、AIO 有什么区别？</h5><ul>\n<li>BIO：<code>Block IO</code> 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>\n<li>NIO：<code>New IO</code> 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>\n<li>AIO：<code>Asynchronous IO</code> 是 NIO 的升级，也叫 NIO2，实现了<strong>异步非堵塞 IO</strong> ，异步 IO 的操作基于事件和回调机制。</li>\n</ul>\n<h5 id=\"7-synchronized-和-ReentrantLock-有什么不同？\"><a href=\"#7-synchronized-和-ReentrantLock-有什么不同？\" class=\"headerlink\" title=\"7.  synchronized 和 ReentrantLock 有什么不同？\"></a>7.  synchronized 和 ReentrantLock 有什么不同？</h5><p>相似点  </p>\n<p>   这两种同步方式有很多相似之处，<strong>它们都是加锁方式同步，而且都是阻塞式的同步</strong>，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.</p>\n<p>区别  </p>\n<ul>\n<li><p>这两种方式最大区别就是对于Synchronized来说，它是Java语言的关键字，是原生语法层面的互斥，需要jvm实现。</p>\n</li>\n<li><p>而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成。</p>\n</li>\n</ul>\n<p>​    <code>synchronized</code>经过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。 </p>\n<p>​    由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：  </p>\n<ul>\n<li>等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。    </li>\n<li>公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。    </li>\n<li>锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象。</li>\n</ul>\n<h5 id=\"8-说说进程和线程的区别？\"><a href=\"#8-说说进程和线程的区别？\" class=\"headerlink\" title=\"8.  说说进程和线程的区别？\"></a>8.  说说进程和线程的区别？</h5><ol>\n<li>进程是一个“执行中的程序”，是系统进行资源分配和调度的一个独立单位。    </li>\n<li>线程是进程的一个实体，一个进程中拥有多个线程，线程之间共享地址空间和其它资源（所以通信和同步等操作线程比进程更加容易）    </li>\n<li>线程上下文的切换比进程上下文切换要快很多。    <ol>\n<li>进程切换时，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置。    </li>\n<li>线程切换仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作。</li>\n</ol>\n</li>\n</ol>\n<h5 id=\"9-熟悉CAS原理？有什么缺点？\"><a href=\"#9-熟悉CAS原理？有什么缺点？\" class=\"headerlink\" title=\"9. 熟悉CAS原理？有什么缺点？\"></a>9. 熟悉CAS原理？有什么缺点？</h5><p>CAS叫做<code>CompareAndSwap</code>，比较并交换，主要是通过处理器的指令来保证操作的原子性，它包含三个操作数：   </p>\n<ol>\n<li>变量内存地址，V表示    </li>\n<li>旧的预期值，A表示    </li>\n<li>准备设置的新值，B表示</li>\n</ol>\n<p><strong>当执行CAS指令时，只有当V等于A时，才会用B去更新V的值，否则就不会执行更新操作。</strong> </p>\n<p> CAS有三个缺点:</p>\n<p>   <strong>ABA问题</strong>:ABA的问题指的是在CAS更新的过程中，当读取到的值是A，然后准备赋值的时候仍然是A，但是实际上有可能A的值被改成了B，然后又被改回了A，这个CAS更新的漏洞就叫做ABA。只是ABA的问题大部分场景下都不影响并发的最终效果。 </p>\n<p>Java中有AtomicStampedReference来解决这个问题，他加入了预期标志和更新后标志两个字段，更新时不光检查值，还要检查当前的标志是否等于预期标志，全部相等的话才会更新。  </p>\n<p><strong>循环时间长开销大</strong>：自旋CAS的方式如果长时间不成功，会给CPU带来很大的开销。  </p>\n<p><strong>只能保证一个共享变量的原子操作</strong>：只对一个共享变量操作可以保证原子性，但是多个则不行，多个可以通过AtomicReference来处理或者使用锁synchronized实现。  </p>\n","text":"JAVA面试题 1. finalize()方法有什么特点?finalize()方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。如...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-finalize-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1. finalize()方法有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%BD%AF%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">2. 软引用是什么?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">3. 介绍一下ThreadLocal是什么?有什么特点?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F\"><span class=\"toc-text\">4.  Java创建对象有几种方式？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">5. 深拷贝浅拷贝的区别</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">6. BIO、NIO、AIO 有什么区别？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#7-synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F\"><span class=\"toc-text\">7.  synchronized 和 ReentrantLock 有什么不同？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-%E8%AF%B4%E8%AF%B4%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">8.  说说进程和线程的区别？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#9-%E7%86%9F%E6%82%89CAS%E5%8E%9F%E7%90%86%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">9. 熟悉CAS原理？有什么缺点？</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"项目亮点","uid":"da8e06681356f7590e60f2c8a230b7d7","slug":"项目亮点","date":"2022-09-01T08:06:49.000Z","updated":"2022-09-02T06:55:26.937Z","comments":true,"path":"api/articles/项目亮点.json","keywords":null,"cover":null,"text":"a. IM即时通信项目1. 消息发送过程中可能出现不可靠的情况1. A --发消息--&gt; Server --转发--&gt; B 2. A &lt;-- 确认 -- Server &lt;--确认-- B 第一部分中可能丢失消息的场景有下面这些。 如果用户 A 在把消息发送...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"项目","slug":"项目","count":1,"path":"api/tags/项目.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"Mysql 面试题","uid":"4d0cd99506fa5ed9a6631a984ab7b868","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","updated":"2022-08-31T11:34:26.457Z","comments":true,"path":"api/articles/Mysql 面试题.json","keywords":null,"cover":"/svg/mysql.svg","text":"Mysql 面试题1. B树和B+树的区别?相同点: 都是多路平衡查找树 一个节点中都有多个元素,且有序 不同点: B+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中； B+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"},{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}