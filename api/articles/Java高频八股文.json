{"title":"Java高频八股文","uid":"73914c70a525ea7d633ba7d52ba12831","slug":"Java高频八股文","date":"2022-05-05T13:42:50.000Z","updated":"2022-05-06T09:01:52.586Z","comments":true,"path":"api/articles/Java高频八股文.json","keywords":null,"cover":null,"content":"<h1 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h1><h2 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h2><p>比较基础,注意边界问题和mid的计算 <code>mid = (l + r) &gt;&gt;&gt; 1;</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBinarySearch &#123;\n    &#x2F;*\n     *  搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深\n     * *&#x2F;\n    public static void main(String[] args) &#123;\n        int[] arr &#x3D; &#123;1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50&#125;;\n        int tar &#x3D; 47;\n        int l &#x3D; 0, r &#x3D; arr.length - 1;\n        while (l &lt;&#x3D; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt;&gt; 1;\n            if (arr[mid] &#x3D;&#x3D; tar) &#123;\n                System.out.println(mid);\n                return;\n            &#125;\n            if (arr[mid] &lt; tar) &#123;\n                l &#x3D; mid + 1;\n            &#125; else &#123;\n                r &#x3D; mid - 1;\n            &#125;\n        &#125;\n        System.out.println(-1);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"2-排序算法\"><a href=\"#2-排序算法\" class=\"headerlink\" title=\"2. 排序算法\"></a>2. 排序算法</h2><h3 id=\"a-冒泡排序\"><a href=\"#a-冒泡排序\" class=\"headerlink\" title=\"a. 冒泡排序\"></a>a. 冒泡排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 冒泡排序: 稳定\n* 可优化的点:\n* 1. 每轮判断是否有序,如果有序了就不需要再进行冒泡\n* 2. 每轮冒泡记录最后一次交换的位置,该位置之后的肯定已经有序,下轮只需要排序到记录的位置\n* *&#x2F;\npublic static void bubbling(int[] arr) &#123;\n    int n &#x3D; arr.length - 1;\n    while (true) &#123;\n        &#x2F;&#x2F; 最后一次交换的位置\n        int last &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                &#x2F;&#x2F; 如果不发生交换,就说明不需要再进行后面的冒泡\n                int temp &#x3D; arr[j];\n                arr[j] &#x3D; arr[j + 1];\n                arr[j + 1] &#x3D; temp;\n                last &#x3D; j;\n            &#125;\n        &#125;\n        n &#x3D; last;\n        if (last &#x3D;&#x3D; 0) break;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"b-选择排序\"><a href=\"#b-选择排序\" class=\"headerlink\" title=\"b. 选择排序\"></a>b. 选择排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 选择排序\n* 不稳定、\n* *&#x2F;\npublic static void selection(int[] arr) &#123;\n    int n &#x3D; arr.length;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int mIdx &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n - i; j++) &#123;\n            if (arr[mIdx] &lt; arr[j]) &#123;\n                mIdx &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; arr[mIdx];\n        arr[mIdx] &#x3D; arr[n - i - 1];\n        arr[n - i - 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"c-插入排序\"><a href=\"#c-插入排序\" class=\"headerlink\" title=\"c. 插入排序\"></a>c. 插入排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 插入排序 稳定\n* 性能略高于选择\n* 将数组分为已经由于和无序两部分,\n* 每次从无序选择一个元素,然后在有序部分找到合适插入位置\n* *&#x2F;\npublic static void insert(int[] arr) &#123;\n    int n &#x3D; arr.length;\n\n    for (int i &#x3D; 1; i &lt; n; i++) &#123;\n        int temp &#x3D; arr[i];\n        int j &#x3D; i - 1;\n\n        while (j &gt;&#x3D; 0) &#123;\n            if (arr[j] &gt;&#x3D; temp) &#123;\n                arr[j + 1] &#x3D; arr[j];\n            &#125; else break;\n            j--;\n        &#125;\n        arr[j + 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p>利用 <strong>选择和插入排序在数组有序的情况下时间复杂度较低的特性</strong><br>将数组分为不同的组(比如按下标的奇偶来分),</p>\n<p>代码略</p>\n<h3 id=\"d-快速排序\"><a href=\"#d-快速排序\" class=\"headerlink\" title=\"d. 快速排序\"></a>d. 快速排序</h3><p>快排有两种典型实现:</p>\n<ul>\n<li>单边快速排序 lomuto实现</li>\n<li>双边快速排序</li>\n</ul>\n<p>代码主体分为两部分:</p>\n<p>第一部分为递归调用划分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void quickSort(int[] arr, int l, int h) &#123;\n    if (l &gt;&#x3D; h) return;\n    int p &#x3D; partition2(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n&#125;</code></pre>\n\n<p>第二部分有两种实现</p>\n<p>单边循环快排实现:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*lomuto实现 单边循环快排*&#x2F;\npublic static int partition(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[h];\n    int i &#x3D; l;\n    &#x2F;&#x2F; i j 都是从左边出发,往最后面进行搜索,i代表小于pv的数的边界,j寻找小于pv的数\n    &#x2F;&#x2F; j 一搜到就进行交换\n    for (int j &#x3D; l; j &lt; h; j++) &#123;\n        if (arr[j] &lt; pv) &#123;\n            int temp &#x3D; arr[j];\n            arr[j] &#x3D; arr[i];\n            arr[i] &#x3D; temp;\n            i++;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; pv和最后的i交换\n    int temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[h];\n    arr[h] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n<p>双边循环快排</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*双边循环快排*&#x2F;\npublic static int partition2(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[l];\n    int i &#x3D; l, j &#x3D; h;\n    while (i &lt; j) &#123;\n        &#x2F;&#x2F; 必须先从后往前找\n        while (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;&#x2F;&#x2F; 不能将j--写在while;里,会出现短路运算\n        &#x2F;&#x2F; 这里等于号要特别注意  刚开始 i指向的就是pv位置\n        while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; pv) i++;\n\n        int temp &#x3D; arr[i];\n        arr[i] &#x3D; arr[j];\n        arr[j] &#x3D; temp;\n    &#125;\n\n    int temp &#x3D; arr[l];\n    arr[l] &#x3D; arr[i];\n    arr[i] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"3-集合类\"><a href=\"#3-集合类\" class=\"headerlink\" title=\"3. 集合类\"></a>3. 集合类</h2><h3 id=\"a-ArrayList\"><a href=\"#a-ArrayList\" class=\"headerlink\" title=\"a. ArrayList\"></a>a. ArrayList</h3><p>扩容机制:</p>\n<ul>\n<li>因为懒加载,无参初始化容量为0,第一次使用add添加会扩容为10</li>\n<li>如果使用<code>addAll(arr)</code>,扩容至 <code>max&#123;arr的大小,1.5倍&#125;</code></li>\n<li>空间不够时,会扩容1.5倍 <code>size = size+(size&gt;&gt;1)</code></li>\n</ul>\n<p>Iterator迭代器遍历修改问题:</p>\n<ul>\n<li><code>Fail-Fast</code> 一旦发现遍历过程中其他人修改,立即抛出异常。典型代表 <code>ArrayList</code></li>\n<li><code>Fail-Safe</code> 遍历过程中发现有人修改,会促使遍历完成，比如在遍历过程中添加元素，添加的元素并不会在这次遍历访问到。(本质就是在遇到修改时,先拷贝一份用以遍历,再修改一份,遍历完成后拷贝给原来集合) 典型代表 <code>CopyOnWriteArrayList</code></li>\n</ul>\n<h3 id=\"b-LinkedList-vs-ArrayList\"><a href=\"#b-LinkedList-vs-ArrayList\" class=\"headerlink\" title=\"b. LinkedList vs ArrayList\"></a>b. LinkedList vs ArrayList</h3><ul>\n<li><p>LinkedList</p>\n<ul>\n<li>基于双向链表,无需连续内存</li>\n<li>随机访问慢</li>\n<li>头尾插入删除快</li>\n<li>需要额外内存保存节点信息</li>\n</ul>\n</li>\n<li><p>ArrayList</p>\n<ul>\n<li>基于数组实现,需要连续内存</li>\n<li>随机访问快</li>\n<li>尾部插入,删除的性能可以</li>\n<li>其他部分插入删除都需要移动数据,性能会降低</li>\n<li>可以利用CPU缓存,局部性原理</li>\n</ul>\n</li>\n</ul>\n<p><strong>多数情况下,ArrayList的性能都要高于LinkedList</strong></p>\n<h3 id=\"c-HashMap\"><a href=\"#c-HashMap\" class=\"headerlink\" title=\"c. HashMap\"></a>c. HashMap</h3><p>底层实现，1.7和1.8的不同</p>\n<ul>\n<li>1.7 数组+链表</li>\n<li>1.8 数组+（链表|红黑树）</li>\n</ul>\n<p>[注意] 在链表树化时,需要满足两个条件: 1. 数组长度要大于64  2.链表长度大于8(在hash足够随机的情况下,服从泊松分布,选择8时再树化的概率只有0.00000006)</p>\n<ul>\n<li>条件1 的原因是因为数组扩容时,可能会让链表缩短 </li>\n<li>红黑树用来避免DoS攻击,防止链表超长时性能下降,树化应该是偶然情况</li>\n</ul>\n<p>[退化为链表的情况]:</p>\n<ol>\n<li>扩容时拆分树,树元素个数 &lt;&#x3D; 6 时会退化为链表</li>\n<li>remove树节点时,若<code>root||root.left||root.right||root.left.left 有一个为 null</code>时,会退化为链表</li>\n</ol>\n<h4 id=\"索引的计算\"><a href=\"#索引的计算\" class=\"headerlink\" title=\"索引的计算\"></a>索引的计算</h4><ol>\n<li><p>索引如何计算</p>\n<p>先计算对象的 <code>hashCode()</code>,再调用HashMap的<code>hash()</code>进行二次哈希,最后 <code>&amp;(capacity-1)</code>得到索引</p>\n</li>\n<li><p>有了HashCode为什么还要二次hash()?</p>\n<p>二次<code>hash()</code>是为了综合高位数据,让hash分布更加均匀</p>\n</li>\n<li><p>数组容量为什么是2的n次幂?</p>\n<p>计算索引时,如果容量是2的n次幂,可以使用位与运算代替取模,效率更高</p>\n<p>扩容时,<code>hash&amp;oldCap==0</code>的元素留在原来的位置,其他的<code>新位置=旧位置+oldCap</code></p>\n</li>\n</ol>\n<h1 id=\"二、并发篇\"><a href=\"#二、并发篇\" class=\"headerlink\" title=\"二、并发篇\"></a>二、并发篇</h1><h1 id=\"三、虚拟机\"><a href=\"#三、虚拟机\" class=\"headerlink\" title=\"三、虚拟机\"></a>三、虚拟机</h1><h1 id=\"四、框架篇\"><a href=\"#四、框架篇\" class=\"headerlink\" title=\"四、框架篇\"></a>四、框架篇</h1>","feature":true,"text":"一、Java基础1. 二分查找比较基础,注意边界问题和mid的计算 mid = (l + r) &gt;&gt;&gt; 1; public class MyBinarySearch &#123; &#x2F;* * 搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":10,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"集合类","slug":"集合类","count":1,"path":"api/tags/集合类.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">一、Java基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">1. 二分查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">a. 冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">b. 选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">c. 插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">d. 快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">3. 集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-ArrayList\"><span class=\"toc-text\">a. ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-LinkedList-vs-ArrayList\"><span class=\"toc-text\">b. LinkedList vs ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-HashMap\"><span class=\"toc-text\">c. HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">索引的计算</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E7%AF%87\"><span class=\"toc-text\">二、并发篇</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">三、虚拟机</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%A1%86%E6%9E%B6%E7%AF%87\"><span class=\"toc-text\">四、框架篇</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"B站网友的奇妙发言","uid":"b57cd9d792371efee42384e9cc2f9aee","slug":"B站网友的奇妙发言","date":"2022-05-05T06:46:30.000Z","updated":"2022-05-06T03:10:09.232Z","comments":true,"path":"api/articles/B站网友的奇妙发言.json","keywords":null,"cover":null,"text":"鬼火一响，爹妈白养。 弯道快才是快，谁直线不会加油？ 弯道快才逝快，谁吃席不会夹菜？ ","link":"","photos":[],"count_time":{"symbolsCount":43,"symbolsTime":"1 mins."},"categories":[{"name":"奇妙发言","slug":"奇妙发言","count":1,"path":"api/categories/奇妙发言.json"}],"tags":[{"name":"搞笑","slug":"搞笑","count":1,"path":"api/tags/搞笑.json"},{"name":"语录","slug":"语录","count":1,"path":"api/tags/语录.json"},{"name":"歇后语","slug":"歇后语","count":1,"path":"api/tags/歇后语.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}