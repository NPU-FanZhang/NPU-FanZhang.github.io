{"title":"Java高频八股文","uid":"73914c70a525ea7d633ba7d52ba12831","slug":"Java高频八股文","date":"2022-05-05T13:42:50.000Z","updated":"2022-05-10T14:05:04.873Z","comments":true,"path":"api/articles/Java高频八股文.json","keywords":null,"cover":null,"content":"<h1 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h1><h2 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h2><p>比较基础,注意边界问题和mid的计算 <code>mid = (l + r) &gt;&gt;&gt; 1;</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBinarySearch &#123;\n    &#x2F;*\n     *  搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深\n     * *&#x2F;\n    public static void main(String[] args) &#123;\n        int[] arr &#x3D; &#123;1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50&#125;;\n        int tar &#x3D; 47;\n        int l &#x3D; 0, r &#x3D; arr.length - 1;\n        while (l &lt;&#x3D; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt;&gt; 1;\n            if (arr[mid] &#x3D;&#x3D; tar) &#123;\n                System.out.println(mid);\n                return;\n            &#125;\n            if (arr[mid] &lt; tar) &#123;\n                l &#x3D; mid + 1;\n            &#125; else &#123;\n                r &#x3D; mid - 1;\n            &#125;\n        &#125;\n        System.out.println(-1);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"2-排序算法\"><a href=\"#2-排序算法\" class=\"headerlink\" title=\"2. 排序算法\"></a>2. 排序算法</h2><h3 id=\"a-冒泡排序\"><a href=\"#a-冒泡排序\" class=\"headerlink\" title=\"a. 冒泡排序\"></a>a. 冒泡排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 冒泡排序: 稳定\n* 可优化的点:\n* 1. 每轮判断是否有序,如果有序了就不需要再进行冒泡\n* 2. 每轮冒泡记录最后一次交换的位置,该位置之后的肯定已经有序,下轮只需要排序到记录的位置\n* *&#x2F;\npublic static void bubbling(int[] arr) &#123;\n    int n &#x3D; arr.length - 1;\n    while (true) &#123;\n        &#x2F;&#x2F; 最后一次交换的位置\n        int last &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                &#x2F;&#x2F; 如果不发生交换,就说明不需要再进行后面的冒泡\n                int temp &#x3D; arr[j];\n                arr[j] &#x3D; arr[j + 1];\n                arr[j + 1] &#x3D; temp;\n                last &#x3D; j;\n            &#125;\n        &#125;\n        n &#x3D; last;\n        if (last &#x3D;&#x3D; 0) break;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"b-选择排序\"><a href=\"#b-选择排序\" class=\"headerlink\" title=\"b. 选择排序\"></a>b. 选择排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 选择排序\n* 不稳定、\n* *&#x2F;\npublic static void selection(int[] arr) &#123;\n    int n &#x3D; arr.length;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int mIdx &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n - i; j++) &#123;\n            if (arr[mIdx] &lt; arr[j]) &#123;\n                mIdx &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; arr[mIdx];\n        arr[mIdx] &#x3D; arr[n - i - 1];\n        arr[n - i - 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"c-插入排序\"><a href=\"#c-插入排序\" class=\"headerlink\" title=\"c. 插入排序\"></a>c. 插入排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 插入排序 稳定\n* 性能略高于选择\n* 将数组分为已经由于和无序两部分,\n* 每次从无序选择一个元素,然后在有序部分找到合适插入位置\n* *&#x2F;\npublic static void insert(int[] arr) &#123;\n    int n &#x3D; arr.length;\n\n    for (int i &#x3D; 1; i &lt; n; i++) &#123;\n        int temp &#x3D; arr[i];\n        int j &#x3D; i - 1;\n\n        while (j &gt;&#x3D; 0) &#123;\n            if (arr[j] &gt;&#x3D; temp) &#123;\n                arr[j + 1] &#x3D; arr[j];\n            &#125; else break;\n            j--;\n        &#125;\n        arr[j + 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p>利用 <strong>选择和插入排序在数组有序的情况下时间复杂度较低的特性</strong><br>将数组分为不同的组(比如按下标的奇偶来分),</p>\n<p>代码略</p>\n<h3 id=\"d-快速排序\"><a href=\"#d-快速排序\" class=\"headerlink\" title=\"d. 快速排序\"></a>d. 快速排序</h3><p>快排有两种典型实现:</p>\n<ul>\n<li>单边快速排序 lomuto实现</li>\n<li>双边快速排序</li>\n</ul>\n<p>代码主体分为两部分:</p>\n<p>第一部分为递归调用划分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void quickSort(int[] arr, int l, int h) &#123;\n    if (l &gt;&#x3D; h) return;\n    int p &#x3D; partition2(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n&#125;</code></pre>\n\n<p>第二部分有两种实现</p>\n<p>单边循环快排实现:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*lomuto实现 单边循环快排*&#x2F;\npublic static int partition(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[h];\n    int i &#x3D; l;\n    &#x2F;&#x2F; i j 都是从左边出发,往最后面进行搜索,i代表小于pv的数的边界,j寻找小于pv的数\n    &#x2F;&#x2F; j 一搜到就进行交换\n    for (int j &#x3D; l; j &lt; h; j++) &#123;\n        if (arr[j] &lt; pv) &#123;\n            int temp &#x3D; arr[j];\n            arr[j] &#x3D; arr[i];\n            arr[i] &#x3D; temp;\n            i++;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; pv和最后的i交换\n    int temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[h];\n    arr[h] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n<p>双边循环快排</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*双边循环快排*&#x2F;\npublic static int partition2(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[l];\n    int i &#x3D; l, j &#x3D; h;\n    while (i &lt; j) &#123;\n        &#x2F;&#x2F; 必须先从后往前找\n        while (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;&#x2F;&#x2F; 不能将j--写在while;里,会出现短路运算\n        &#x2F;&#x2F; 这里等于号要特别注意  刚开始 i指向的就是pv位置\n        while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; pv) i++;\n\n        int temp &#x3D; arr[i];\n        arr[i] &#x3D; arr[j];\n        arr[j] &#x3D; temp;\n    &#125;\n\n    int temp &#x3D; arr[l];\n    arr[l] &#x3D; arr[i];\n    arr[i] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"3-集合类\"><a href=\"#3-集合类\" class=\"headerlink\" title=\"3. 集合类\"></a>3. 集合类</h2><h3 id=\"a-ArrayList\"><a href=\"#a-ArrayList\" class=\"headerlink\" title=\"a. ArrayList\"></a>a. ArrayList</h3><p>扩容机制:</p>\n<ul>\n<li>因为懒加载,无参初始化容量为0,第一次使用add添加会扩容为10</li>\n<li>如果使用<code>addAll(arr)</code>,扩容至 <code>max&#123;arr的大小,1.5倍&#125;</code></li>\n<li>空间不够时,会扩容1.5倍 <code>size = size+(size&gt;&gt;1)</code></li>\n</ul>\n<p>Iterator迭代器遍历修改问题:</p>\n<ul>\n<li><code>Fail-Fast</code> 一旦发现遍历过程中其他人修改,立即抛出异常。典型代表 <code>ArrayList</code></li>\n<li><code>Fail-Safe</code> 遍历过程中发现有人修改,会促使遍历完成，比如在遍历过程中添加元素，添加的元素并不会在这次遍历访问到。(本质就是在遇到修改时,先拷贝一份用以遍历,再修改一份,遍历完成后拷贝给原来集合) 典型代表 <code>CopyOnWriteArrayList</code></li>\n</ul>\n<h3 id=\"b-LinkedList-vs-ArrayList\"><a href=\"#b-LinkedList-vs-ArrayList\" class=\"headerlink\" title=\"b. LinkedList vs ArrayList\"></a>b. LinkedList vs ArrayList</h3><ul>\n<li><p>LinkedList</p>\n<ul>\n<li>基于双向链表,无需连续内存</li>\n<li>随机访问慢</li>\n<li>头尾插入删除快</li>\n<li>需要额外内存保存节点信息</li>\n</ul>\n</li>\n<li><p>ArrayList</p>\n<ul>\n<li>基于数组实现,需要连续内存</li>\n<li>随机访问快</li>\n<li>尾部插入,删除的性能可以</li>\n<li>其他部分插入删除都需要移动数据,性能会降低</li>\n<li>可以利用CPU缓存,局部性原理</li>\n</ul>\n</li>\n</ul>\n<p><strong>多数情况下,ArrayList的性能都要高于LinkedList</strong></p>\n<h3 id=\"c-HashMap\"><a href=\"#c-HashMap\" class=\"headerlink\" title=\"c. HashMap\"></a>c. HashMap</h3><p>底层实现，1.7和1.8的不同</p>\n<ul>\n<li>1.7 数组+链表</li>\n<li>1.8 数组+（链表|红黑树）</li>\n</ul>\n<p>[注意] 在链表树化时,需要满足两个条件: 1. 数组长度要大于64  2.链表长度大于8(在hash足够随机的情况下,服从泊松分布,选择8时再树化的概率只有0.00000006)</p>\n<ul>\n<li>条件1 的原因是因为数组扩容时,可能会让链表缩短 </li>\n<li>红黑树用来避免DoS攻击,防止链表超长时性能下降,树化应该是偶然情况</li>\n</ul>\n<p>[退化为链表的情况]:</p>\n<ol>\n<li>扩容时拆分树,树元素个数 &lt;&#x3D; 6 时会退化为链表</li>\n<li>remove树节点时,若<code>root||root.left||root.right||root.left.left 有一个为 null</code>时,会退化为链表</li>\n</ol>\n<p>[二次哈希]</p>\n<p>在获得HashCode之后,还会进行<code>hashCode = (hashCode ^ (hashCode&gt;&gt;&gt;16))%Cap</code>,这样可以让分布更加均匀</p>\n<h4 id=\"索引的计算\"><a href=\"#索引的计算\" class=\"headerlink\" title=\"索引的计算\"></a>索引的计算</h4><ol>\n<li><p>索引如何计算</p>\n<p>先计算对象的 <code>hashCode()</code>,再调用HashMap的<code>hash()</code>进行二次哈希,最后 <code>&amp;(capacity-1)</code>得到索引</p>\n</li>\n<li><p>有了HashCode为什么还要二次hash()?</p>\n<p>二次<code>hash()</code>是为了综合高位数据,让hash分布更加均匀</p>\n</li>\n<li><p>数组容量为什么是2的n次幂?</p>\n<p>计算索引时,如果容量是2的n次幂,可以使用位与运算代替取模,效率更高</p>\n<p>扩容时,<code>hash&amp;oldCap==0</code>的元素留在原来的位置,其他的<code>新位置=旧位置+oldCap</code></p>\n</li>\n</ol>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><ol>\n<li><p>0.75f的负载因子是权衡那俩个方面?</p>\n<ul>\n<li>权衡了map容量和搜索速度两方面</li>\n</ul>\n</li>\n<li><p>多线程下会有什么问题?</p>\n<ul>\n<li><p>1.7 下会出现死链问题</p>\n</li>\n<li><p>1.7 1.8 可能出现数据丢失问题,比如两个线程在添加元素的时刻进行了线程切换,就会丢失某个线程的结果。</p>\n</li>\n</ul>\n</li>\n<li><p>作为key的变量有什么条件？</p>\n<p>1)必须实现<code>hashCode()</code>函数和<code>equals()</code>函数</p>\n<p>2)必须是不可变的对象,不然可能会导致放入后因为修改而找不到</p>\n</li>\n<li><p>String的<code>hashCode()</code>是如何设计的?</p>\n<p>hash的目标是尽可能的均匀，每一位字符根据下标i，实现 ch*31的i次幂,最后相加为整个字符串的hashCode。</p>\n<p>因为31有较好的散列特性，并且31在运算上可以进行位运算优化</p>\n</li>\n</ol>\n<h2 id=\"4-枚举类型\"><a href=\"#4-枚举类型\" class=\"headerlink\" title=\"4. 枚举类型\"></a>4. 枚举类型</h2><p>一个枚举类编译后的代码如下</p>\n<p>枚举类:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">enum Sex &#123;\n    MALE, FEMALE;\n&#125;</code></pre>\n\n<p>编译后字节码对应的类:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final class Sex extends Enum&lt;Sex&gt; &#123;\n    public static final Sex MALE;\n    public static final Sex FEMALE;\n\n    private Sex(String name, int ordinal) &#123;\n        super(name, ordinal);\n    &#125;\n    static &#123;\n        MALE &#x3D; new Sex(&quot;MALE&quot;, 0);\n        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 0);\n        $VALUES &#x3D; $values();\n    &#125;\n\n    private static final Sex[] $VALUES;\n\n    private static Sex[] $values() &#123;\n        return new Sex[]&#123;MALE, FEMALE&#125;;\n    &#125;\n\n    public static Sex valueOf(String value) &#123;\n        return Enum.valueOf(Sex.class, value);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"5-单例模式\"><a href=\"#5-单例模式\" class=\"headerlink\" title=\"5. 单例模式\"></a>5. 单例模式</h2><p>单例模式：一个类只能实现一个实例。</p>\n<h3 id=\"5种实现方式\"><a href=\"#5种实现方式\" class=\"headerlink\" title=\"5种实现方式\"></a>5种实现方式</h3><ol>\n<li>饿汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n * 1. 饿汉式\n * 唯一实例会提前创建,在类调用时就会创建\n * 可能会通过以下方法破坏单例\n * a. 通过反射,调用私有构造,可以在构造方法中预防\n * b. 实现了Serializable接口的类,通过反序列化破坏单例,实现readResolve()预防\n * c. unsafe破坏单例 无法预防\n * *&#x2F;\n&#x2F;&#x2F; 实现序列化接口可以通过反序列化\npublic static class Singleton1 implements Serializable &#123;\n\n    &#x2F;&#x2F; 私有构造\n    private Singleton1() &#123;\n        &#x2F;&#x2F; 预防反射破坏单例\n        if (INSTANCE !&#x3D; null) &#123;\n            throw new RuntimeException(&quot;单例对象不能重复创建&quot;);\n        &#125;\n        System.out.println(&quot;private Singleton&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 唯一实现\n    private static final Singleton1 INSTANCE &#x3D; new Singleton1();\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton1 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; 防止反序列化破坏单例\n\n    public Object readResolve() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>枚举饿汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 2. 枚举饿汉式\n* a. 通过反射,无法进行破坏\n* b. 也无法通过反序列化破坏单例\n* c. unsafe破坏单例 无法预防\n* *&#x2F;\npublic enum Singleton2 &#123;\n    INSTANCE;\n    Singleton2() &#123;\n        System.out.println(&quot;private Singleton2&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton2 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>懒汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 3. 懒汉式\n* 在第一次调用 getInstance 才会初始化\n* *&#x2F;\nclass Singleton3 &#123;\n    private static Singleton3 INSTANCE &#x3D; null;\n\n    private Singleton3() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 加上synchronized防止多线程同时进入 INSTANCE &#x3D; new Singleton3();\n    public static synchronized Singleton3 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            INSTANCE &#x3D; new Singleton3();\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>DCL懒汉式</li>\n</ol>\n<p>[注意] 加volatile来防止指令重排序问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 4. DCL懒汉式\n* 方法三 synchronized 加载静态方法上,相当于加在Singleton4.class上,每次调用这个类都会加锁\n* 多线程下效率过低,创建单例后其实可以避免每次加锁\n* *&#x2F;\nclass Singleton4 &#123;\n    &#x2F;*\n    * 双检查锁要加 volatile\n    * volatile解决共享变量的 可见性和有序性的问题\n    * JVM在将代码编译为字节码后,在执行时,可能会因为优化而改变指令的执行顺序(指令重排序)\n    * 在单线程情况可以正常执行,但是多线程就有可能出现问题\n    * *&#x2F;\n    private static volatile Singleton4 INSTANCE &#x3D; null;\n\n    private Singleton4() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n    &#x2F;&#x2F; 双检查锁机制\n    public static Singleton4 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton4.class) &#123;\n                if (INSTANCE &#x3D;&#x3D; null) &#123;\n                    INSTANCE &#x3D; new Singleton4();\n                &#125;\n            &#125;\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>内部类懒汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 5. 内部类懒汉式\n* 第一次调用getInstance才会触发内部类的加载链接初始化\n* *&#x2F;\nclass Singleton5 &#123;\n    private Singleton5() &#123;\n        System.out.println(&quot;private Singleton5&quot;);\n    &#125;\n\n    private static class Holder &#123;\n        static Singleton5 INSTANCE &#x3D; new Singleton5();\n    &#125;\n\n    public static Singleton5 getInstance() &#123;\n        return Holder.INSTANCE;\n    &#125;\n    &#x2F;&#x2F; .. 其他方法\n&#125;</code></pre>\n\n\n\n<h2 id=\"小知识点\"><a href=\"#小知识点\" class=\"headerlink\" title=\"小知识点\"></a>小知识点</h2><ol>\n<li>static变量的初始化会被JVM放入静态代码块中,静态代码块中的代码不用考虑多线程的并发问题,有JVM控制。</li>\n</ol>\n<h1 id=\"二、并发篇\"><a href=\"#二、并发篇\" class=\"headerlink\" title=\"二、并发篇\"></a>二、并发篇</h1><p>本篇详细内容可以参考<a href=\"https://zhang-f4n.github.io/post/JUC,%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9\">https://zhang-f4n.github.io/post/JUC,这里主要介绍面试考点</a></p>\n<h2 id=\"1-线程状态\"><a href=\"#1-线程状态\" class=\"headerlink\" title=\"1. 线程状态\"></a>1. 线程状态</h2><p>操作系统5种状态</p>\n<h2 id=\"2-线程池核心参数\"><a href=\"#2-线程池核心参数\" class=\"headerlink\" title=\"2. 线程池核心参数\"></a>2. 线程池核心参数</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t&#x2F;&#x2F; 常驻线程数量 可以为0\n                          int maximumPoolSize,\t\t\t\t&#x2F;&#x2F; 最大线程数量\n                          long keepAliveTime,\t\t\t\t&#x2F;&#x2F; 线程存活时间\n                          TimeUnit unit,\t\t\t\t\t&#x2F;&#x2F; 存活时间单位\n                          BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 阻塞队列\n                          ThreadFactory threadFactory,\t\t  &#x2F;&#x2F; 线程工厂,用于创建线程,为线程提供名字\n                          RejectedExecutionHandler handler) &#123;&#125; &#x2F;&#x2F; 拒绝策略,当线程池爆满时的拒绝接收线程的策略\n    \n&#x2F;&#x2F; 线程池的使用\nExecutorService threadPool &#x3D; new ThreadPoolExecutor(\n    2,\n    5,\n    2L,\n    TimeUnit.SECONDS,\n    new ArrayBlockingQueue&lt;&gt;(3),\n    Executors.defaultThreadFactory(),\n    new ThreadPoolExecutor.AbortPolicy());\n&#x2F;&#x2F; 自定义线程池使用\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为5的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        threadPool.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool.shutdown();\n&#125;</code></pre>\n\n<p><code>RejectedExecutionHandler</code> 线程池的饱和拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>\n<ul>\n<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>\n<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>\n<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>\n</ul>\n<hr>\n<h2 id=\"3-HashTable-和-ConcurrentHashMap\"><a href=\"#3-HashTable-和-ConcurrentHashMap\" class=\"headerlink\" title=\"3. HashTable 和 ConcurrentHashMap\"></a>3. HashTable 和 ConcurrentHashMap</h2><ol>\n<li>HashTable 和 ConcurrentHashMap都是线程安全的Map集合,键值不能为空</li>\n<li>HashTable 并发度低,这个Hashtable公共一把锁,同一时刻,只能由一个线程操作它</li>\n<li>ConcurrentHashMap<ul>\n<li>1.8之前 使用 segment + 数组 + 链表的形式,每个Segment对应一把锁,多个线程访问不同的segment不会冲突</li>\n<li>1.8开始 将数组的每个头节点作为锁,如果多个线程访问的头结点不同,则不会冲突</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-小知识点\"><a href=\"#4-小知识点\" class=\"headerlink\" title=\"4. 小知识点\"></a>4. 小知识点</h2><p>a. 对比 <code>sleep(long)</code> 和 <code>wait(long)</code></p>\n<p> <code>sleep(long)</code> 和 <code>wait(long)</code>的效果都是让当前线程暂时放弃CPU的使用权,进入阻塞状态</p>\n<ul>\n<li>方法归属不同:<ul>\n<li>sleep是 Thread 的静态方法</li>\n<li>wait 是 Object 的成员方法,每个对象都有</li>\n</ul>\n</li>\n<li>醒来时机不同<ul>\n<li>都会在等待相应的毫秒数后醒来,都可以被打断(<code>interrupt</code>)唤醒</li>\n<li>wait还可以被<code>notify</code>唤醒,<code>wait()</code>如果不唤醒就会一直等待下去</li>\n</ul>\n</li>\n<li>锁特性不同<ul>\n<li>wait方法必须先获取wait对象锁,sleep无此限制</li>\n<li>wait方法执行后会释放对象锁,<code>允许其他线程获得该对象锁</code></li>\n<li>sleep如果在<code>synchronized</code>代码块中执行,并<code>不会释放对象锁</code></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyWaitSleep &#123;\n    static final Object LOCK &#x3D; new Object();\n    public static void main(String[] args) throws InterruptedException &#123;\n&#x2F;&#x2F;        illegalWait();\n        waiting();\n    &#125;\n    private static void illegalWait() throws InterruptedException &#123;\n&#x2F;&#x2F;        LOCK.wait(); 报错 须配合 对象锁\n        synchronized (LOCK) &#123; &#x2F;&#x2F; wait 锁必须配合 对象锁 使用,不然会报错\n            LOCK.wait();\n        &#125;\n    &#125;\n    private static void waiting() throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(() -&gt; &#123;\n            synchronized (LOCK)&#123;\n                try &#123;\n                    System.out.println(&quot;t1 -- &gt; waiting&quot;);\n                    Thread.sleep(5000L);&#x2F;&#x2F; 不会释放LOCK锁\n                    LOCK.wait(5000L); &#x2F;&#x2F; 会释放LOCK锁\n                &#125;catch (InterruptedException e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;t1&quot;);\n        t1.start();\n&#x2F;&#x2F;        t1.interrupt();&#x2F;&#x2F; 可以用来强制唤醒\n        Thread.sleep(100);\n        synchronized (LOCK)&#123;&#x2F;&#x2F; 如果t1 内使用 sleep,那么就得等待\n            System.out.println(&quot;main&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>b. 对比 <code>lock</code> 和 <code>synchronized</code></p>\n<ul>\n<li>语法层面<ul>\n<li><code>synchronized</code> 是关键字,用c++实现的</li>\n<li>Lock是接口,由jdk提供</li>\n<li><code>synchronized</code> 退出同步代码块会自动释放,Lock需要调用unlock释放</li>\n</ul>\n</li>\n<li>功能层面<ul>\n<li>都是悲观锁,都具备互斥,同步,锁重入功能</li>\n<li>Lock 提供了许多 synchronized 不具备的功能,例如获取等待状态,公平锁,可打断,可超时,多条件变量</li>\n<li>Lock有很多不同的实现,<code>ReentrantLock</code>,<code>ReentrantReadWriteLock</code></li>\n</ul>\n</li>\n<li>性能层面<ul>\n<li>没有竞争是,synchronized有许多优化,比如偏向锁,轻量级锁,性能不赖</li>\n<li>竞争激烈时,Lock的实现通常会提供更好的性能</li>\n</ul>\n</li>\n</ul>\n<p>c. <code>volatile</code> 能否保证线程安全</p>\n<p>线程安全要考虑三个方面: 可见性、有序性、原子性</p>\n<ul>\n<li>可见性：一个线程对共享变量修改，另外一个线程能看到最新结果</li>\n<li>有序性：一个线程内代码按编写的顺序执行</li>\n<li>原子性：一个线程内多行代码以一个整体执行，并不能保证原子性</li>\n</ul>\n<p><code>volatile</code> 能够保证共享变量的可见性与有序性,并不能保证原子性。</p>\n<p>d. java 中的悲观锁和乐观锁</p>\n<p>悲观锁的代表是 <code>synchronized</code>和<code>Lock</code>锁</p>\n<ul>\n<li>核心思想[线程只要占有了锁,才能操作共享变量,每次只有一个线程占锁成功,获取锁失败的线程,都得等待]</li>\n<li>线程从运行到阻塞,再从阻塞到唤醒,涉及线程上下文切换,如果频繁发生,影响性能</li>\n<li>实际上,线程获取synchronized和lock锁时,如果锁已经被占用,会重试,减少阻塞机会</li>\n</ul>\n<p>乐观锁代表是<code>AtomicInteger</code>,使用cas来保证原子性</p>\n<ul>\n<li>核心思想是[无须加锁,不断重试,但是只有一个线程能成功修改,直到重试成功]</li>\n<li>需要多核支持,且线程数不能超过核数</li>\n<li>线程一直运行,不需要阻塞,因此不涉及上下文切换</li>\n</ul>\n<p>cas-&gt;CompareAndSet,比较后赋值,在最后的赋值前对比拿到的值是否和进入时拿到的值一致,不一致就false,一致才赋值</p>\n<p>在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。</p>\n<h1 id=\"三、虚拟机\"><a href=\"#三、虚拟机\" class=\"headerlink\" title=\"三、虚拟机\"></a>三、虚拟机</h1><h1 id=\"四、框架篇\"><a href=\"#四、框架篇\" class=\"headerlink\" title=\"四、框架篇\"></a>四、框架篇</h1>","feature":true,"text":"一、Java基础1. 二分查找比较基础,注意边界问题和mid的计算 mid = (l + r) &gt;&gt;&gt; 1; public class MyBinarySearch &#123; &#x2F;* * 搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":10,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"集合类","slug":"集合类","count":1,"path":"api/tags/集合类.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">一、Java基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">1. 二分查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">a. 冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">b. 选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">c. 插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">d. 快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">3. 集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-ArrayList\"><span class=\"toc-text\">a. ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-LinkedList-vs-ArrayList\"><span class=\"toc-text\">b. LinkedList vs ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-HashMap\"><span class=\"toc-text\">c. HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">索引的计算</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">其他问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">4. 枚举类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5. 单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">5种实现方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">小知识点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E7%AF%87\"><span class=\"toc-text\">二、并发篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">1. 线程状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2. 线程池核心参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-HashTable-%E5%92%8C-ConcurrentHashMap\"><span class=\"toc-text\">3. HashTable 和 ConcurrentHashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">4. 小知识点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">三、虚拟机</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E6%A1%86%E6%9E%B6%E7%AF%87\"><span class=\"toc-text\">四、框架篇</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"B站网友的奇妙发言","uid":"b57cd9d792371efee42384e9cc2f9aee","slug":"B站网友的奇妙发言","date":"2022-05-05T06:46:30.000Z","updated":"2022-05-06T03:10:09.232Z","comments":true,"path":"api/articles/B站网友的奇妙发言.json","keywords":null,"cover":null,"text":"鬼火一响，爹妈白养。 弯道快才是快，谁直线不会加油？ 弯道快才逝快，谁吃席不会夹菜？ ","link":"","photos":[],"count_time":{"symbolsCount":43,"symbolsTime":"1 mins."},"categories":[{"name":"奇妙发言","slug":"奇妙发言","count":1,"path":"api/categories/奇妙发言.json"}],"tags":[{"name":"搞笑","slug":"搞笑","count":1,"path":"api/tags/搞笑.json"},{"name":"语录","slug":"语录","count":1,"path":"api/tags/语录.json"},{"name":"歇后语","slug":"歇后语","count":1,"path":"api/tags/歇后语.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true}}