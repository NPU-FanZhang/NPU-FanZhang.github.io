{"title":"Java高频八股文","uid":"73914c70a525ea7d633ba7d52ba12831","slug":"Java高频八股文","date":"2022-05-05T13:42:50.000Z","updated":"2022-06-01T08:58:04.346Z","comments":true,"path":"api/articles/Java高频八股文.json","keywords":null,"cover":[],"content":"<h1 id=\"一、Java基础\"><a href=\"#一、Java基础\" class=\"headerlink\" title=\"一、Java基础\"></a>一、Java基础</h1><h2 id=\"1-二分查找\"><a href=\"#1-二分查找\" class=\"headerlink\" title=\"1. 二分查找\"></a>1. 二分查找</h2><p>比较基础,注意边界问题和mid的计算 <code>mid = (l + r) &gt;&gt;&gt; 1;</code></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyBinarySearch &#123;\n    &#x2F;*\n     *  搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深\n     * *&#x2F;\n    public static void main(String[] args) &#123;\n        int[] arr &#x3D; &#123;1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50&#125;;\n        int tar &#x3D; 47;\n        int l &#x3D; 0, r &#x3D; arr.length - 1;\n        while (l &lt;&#x3D; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt;&gt; 1;\n            if (arr[mid] &#x3D;&#x3D; tar) &#123;\n                System.out.println(mid);\n                return;\n            &#125;\n            if (arr[mid] &lt; tar) &#123;\n                l &#x3D; mid + 1;\n            &#125; else &#123;\n                r &#x3D; mid - 1;\n            &#125;\n        &#125;\n        System.out.println(-1);\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"2-排序算法\"><a href=\"#2-排序算法\" class=\"headerlink\" title=\"2. 排序算法\"></a>2. 排序算法</h2><h3 id=\"a-冒泡排序\"><a href=\"#a-冒泡排序\" class=\"headerlink\" title=\"a. 冒泡排序\"></a>a. 冒泡排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 冒泡排序: 稳定\n* 可优化的点:\n* 1. 每轮判断是否有序,如果有序了就不需要再进行冒泡\n* 2. 每轮冒泡记录最后一次交换的位置,该位置之后的肯定已经有序,下轮只需要排序到记录的位置\n* *&#x2F;\npublic static void bubbling(int[] arr) &#123;\n    int n &#x3D; arr.length - 1;\n    while (true) &#123;\n        &#x2F;&#x2F; 最后一次交换的位置\n        int last &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                &#x2F;&#x2F; 如果不发生交换,就说明不需要再进行后面的冒泡\n                int temp &#x3D; arr[j];\n                arr[j] &#x3D; arr[j + 1];\n                arr[j + 1] &#x3D; temp;\n                last &#x3D; j;\n            &#125;\n        &#125;\n        n &#x3D; last;\n        if (last &#x3D;&#x3D; 0) break;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"b-选择排序\"><a href=\"#b-选择排序\" class=\"headerlink\" title=\"b. 选择排序\"></a>b. 选择排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 选择排序\n* 不稳定、\n* *&#x2F;\npublic static void selection(int[] arr) &#123;\n    int n &#x3D; arr.length;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int mIdx &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n - i; j++) &#123;\n            if (arr[mIdx] &lt; arr[j]) &#123;\n                mIdx &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; arr[mIdx];\n        arr[mIdx] &#x3D; arr[n - i - 1];\n        arr[n - i - 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"c-插入排序\"><a href=\"#c-插入排序\" class=\"headerlink\" title=\"c. 插入排序\"></a>c. 插入排序</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 插入排序 稳定\n* 性能略高于选择\n* 将数组分为已经由于和无序两部分,\n* 每次从无序选择一个元素,然后在有序部分找到合适插入位置\n* *&#x2F;\npublic static void insert(int[] arr) &#123;\n    int n &#x3D; arr.length;\n\n    for (int i &#x3D; 1; i &lt; n; i++) &#123;\n        int temp &#x3D; arr[i];\n        int j &#x3D; i - 1;\n\n        while (j &gt;&#x3D; 0) &#123;\n            if (arr[j] &gt;&#x3D; temp) &#123;\n                arr[j + 1] &#x3D; arr[j];\n            &#125; else break;\n            j--;\n        &#125;\n        arr[j + 1] &#x3D; temp;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h4><p>利用 <strong>选择和插入排序在数组有序的情况下时间复杂度较低的特性</strong><br>将数组分为不同的组(比如按下标的奇偶来分),</p>\n<p>代码略</p>\n<h3 id=\"d-快速排序\"><a href=\"#d-快速排序\" class=\"headerlink\" title=\"d. 快速排序\"></a>d. 快速排序</h3><p>快排有两种典型实现:</p>\n<ul>\n<li>单边快速排序 lomuto实现</li>\n<li>双边快速排序</li>\n</ul>\n<p>代码主体分为两部分:</p>\n<p>第一部分为递归调用划分</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void quickSort(int[] arr, int l, int h) &#123;\n    if (l &gt;&#x3D; h) return;\n    int p &#x3D; partition2(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n&#125;</code></pre>\n\n<p>第二部分有两种实现</p>\n<p>单边循环快排实现:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*lomuto实现 单边循环快排*&#x2F;\npublic static int partition(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[h];\n    int i &#x3D; l;\n    &#x2F;&#x2F; i j 都是从左边出发,往最后面进行搜索,i代表小于pv的数的边界,j寻找小于pv的数\n    &#x2F;&#x2F; j 一搜到就进行交换\n    for (int j &#x3D; l; j &lt; h; j++) &#123;\n        if (arr[j] &lt; pv) &#123;\n            int temp &#x3D; arr[j];\n            arr[j] &#x3D; arr[i];\n            arr[i] &#x3D; temp;\n            i++;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; pv和最后的i交换\n    int temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[h];\n    arr[h] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n<p>双边循环快排</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*双边循环快排*&#x2F;\npublic static int partition2(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[l];\n    int i &#x3D; l, j &#x3D; h;\n    while (i &lt; j) &#123;\n        &#x2F;&#x2F; 必须先从后往前找\n        while (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;&#x2F;&#x2F; 不能将j--写在while;里,会出现短路运算\n        &#x2F;&#x2F; 这里等于号要特别注意  刚开始 i指向的就是pv位置\n        while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; pv) i++;\n\n        int temp &#x3D; arr[i];\n        arr[i] &#x3D; arr[j];\n        arr[j] &#x3D; temp;\n    &#125;\n\n    int temp &#x3D; arr[l];\n    arr[l] &#x3D; arr[i];\n    arr[i] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;</code></pre>\n\n\n\n\n\n<h2 id=\"3-集合类\"><a href=\"#3-集合类\" class=\"headerlink\" title=\"3. 集合类\"></a>3. 集合类</h2><h3 id=\"a-ArrayList\"><a href=\"#a-ArrayList\" class=\"headerlink\" title=\"a. ArrayList\"></a>a. ArrayList</h3><p>扩容机制:</p>\n<ul>\n<li>因为懒加载,无参初始化容量为0,第一次使用add添加会扩容为10</li>\n<li>如果使用<code>addAll(arr)</code>,扩容至 <code>max&#123;arr的大小,1.5倍&#125;</code></li>\n<li>空间不够时,会扩容1.5倍 <code>size = size+(size&gt;&gt;1)</code></li>\n</ul>\n<p>Iterator迭代器遍历修改问题:</p>\n<ul>\n<li><code>Fail-Fast</code> 一旦发现遍历过程中其他人修改,立即抛出异常。典型代表 <code>ArrayList</code></li>\n<li><code>Fail-Safe</code> 遍历过程中发现有人修改,会促使遍历完成，比如在遍历过程中添加元素，添加的元素并不会在这次遍历访问到。(本质就是在遇到修改时,先拷贝一份用以遍历,再修改一份,遍历完成后拷贝给原来集合) 典型代表 <code>CopyOnWriteArrayList</code></li>\n</ul>\n<h3 id=\"b-LinkedList-vs-ArrayList\"><a href=\"#b-LinkedList-vs-ArrayList\" class=\"headerlink\" title=\"b. LinkedList vs ArrayList\"></a>b. LinkedList vs ArrayList</h3><ul>\n<li><p>LinkedList</p>\n<ul>\n<li>基于双向链表,无需连续内存</li>\n<li>随机访问慢</li>\n<li>头尾插入删除快</li>\n<li>需要额外内存保存节点信息</li>\n</ul>\n</li>\n<li><p>ArrayList</p>\n<ul>\n<li>基于数组实现,需要连续内存</li>\n<li>随机访问快</li>\n<li>尾部插入,删除的性能可以</li>\n<li>其他部分插入删除都需要移动数据,性能会降低</li>\n<li>可以利用CPU缓存,局部性原理</li>\n</ul>\n</li>\n</ul>\n<p><strong>多数情况下,ArrayList的性能都要高于LinkedList</strong></p>\n<h3 id=\"c-HashMap\"><a href=\"#c-HashMap\" class=\"headerlink\" title=\"c. HashMap\"></a>c. HashMap</h3><p>底层实现，1.7和1.8的不同</p>\n<ul>\n<li>1.7 数组+链表</li>\n<li>1.8 数组+（链表|红黑树）</li>\n</ul>\n<p>[注意] 在链表树化时,需要满足两个条件: 1. 数组长度要大于64  2.链表长度大于8(在hash足够随机的情况下,服从泊松分布,选择8时再树化的概率只有0.00000006)</p>\n<ul>\n<li>条件1 的原因是因为数组扩容时,可能会让链表缩短 </li>\n<li>红黑树用来避免DoS攻击,防止链表超长时性能下降,树化应该是偶然情况</li>\n</ul>\n<p>[退化为链表的情况]:</p>\n<ol>\n<li>扩容时拆分树,树元素个数 &lt;&#x3D; 6 时会退化为链表</li>\n<li>remove树节点时,若<code>root||root.left||root.right||root.left.left 有一个为 null</code>时,会退化为链表</li>\n</ol>\n<p>[二次哈希]</p>\n<p>在获得HashCode之后,还会进行<code>hashCode = (hashCode ^ (hashCode&gt;&gt;&gt;16))%Cap</code>,这样可以让分布更加均匀</p>\n<h4 id=\"索引的计算\"><a href=\"#索引的计算\" class=\"headerlink\" title=\"索引的计算\"></a>索引的计算</h4><ol>\n<li><p>索引如何计算</p>\n<p>先计算对象的 <code>hashCode()</code>,再调用HashMap的<code>hash()</code>进行二次哈希,最后 <code>&amp;(capacity-1)</code>得到索引</p>\n</li>\n<li><p>有了HashCode为什么还要二次hash()?</p>\n<p>二次<code>hash()</code>是为了综合高位数据,让hash分布更加均匀</p>\n</li>\n<li><p>数组容量为什么是2的n次幂?</p>\n<p>计算索引时,如果容量是2的n次幂,可以使用位与运算代替取模,效率更高</p>\n<p>扩容时,<code>hash&amp;oldCap==0</code>的元素留在原来的位置,其他的<code>新位置=旧位置+oldCap</code></p>\n</li>\n</ol>\n<h4 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h4><ol>\n<li><p>0.75f的负载因子是权衡那俩个方面?</p>\n<ul>\n<li>权衡了map容量和搜索速度两方面</li>\n</ul>\n</li>\n<li><p>多线程下会有什么问题?</p>\n<ul>\n<li><p>1.7 下会出现死链问题</p>\n</li>\n<li><p>1.7 1.8 可能出现数据丢失问题,比如两个线程在添加元素的时刻进行了线程切换,就会丢失某个线程的结果。</p>\n</li>\n</ul>\n</li>\n<li><p>作为key的变量有什么条件？</p>\n<p>1)必须实现<code>hashCode()</code>函数和<code>equals()</code>函数</p>\n<p>2)必须是不可变的对象,不然可能会导致放入后因为修改而找不到</p>\n</li>\n<li><p>String的<code>hashCode()</code>是如何设计的?</p>\n<p>hash的目标是尽可能的均匀，每一位字符根据下标i，实现 ch*31的i次幂,最后相加为整个字符串的hashCode。</p>\n<p>因为31有较好的散列特性，并且31在运算上可以进行位运算优化</p>\n</li>\n</ol>\n<h2 id=\"4-枚举类型\"><a href=\"#4-枚举类型\" class=\"headerlink\" title=\"4. 枚举类型\"></a>4. 枚举类型</h2><p>一个枚举类编译后的代码如下</p>\n<p>枚举类:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">enum Sex &#123;\n    MALE, FEMALE;\n&#125;</code></pre>\n\n<p>编译后字节码对应的类:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final class Sex extends Enum&lt;Sex&gt; &#123;\n    public static final Sex MALE;\n    public static final Sex FEMALE;\n\n    private Sex(String name, int ordinal) &#123;\n        super(name, ordinal);\n    &#125;\n    static &#123;\n        MALE &#x3D; new Sex(&quot;MALE&quot;, 0);\n        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 0);\n        $VALUES &#x3D; $values();\n    &#125;\n\n    private static final Sex[] $VALUES;\n\n    private static Sex[] $values() &#123;\n        return new Sex[]&#123;MALE, FEMALE&#125;;\n    &#125;\n\n    public static Sex valueOf(String value) &#123;\n        return Enum.valueOf(Sex.class, value);\n    &#125;\n&#125;\n</code></pre>\n\n\n\n<h2 id=\"5-单例模式\"><a href=\"#5-单例模式\" class=\"headerlink\" title=\"5. 单例模式\"></a>5. 单例模式</h2><p>单例模式：一个类只能实现一个实例。</p>\n<h3 id=\"5种实现方式\"><a href=\"#5种实现方式\" class=\"headerlink\" title=\"5种实现方式\"></a>5种实现方式</h3><ol>\n<li>饿汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n * 1. 饿汉式\n * 唯一实例会提前创建,在类调用时就会创建\n * 可能会通过以下方法破坏单例\n * a. 通过反射,调用私有构造,可以在构造方法中预防\n * b. 实现了Serializable接口的类,通过反序列化破坏单例,实现readResolve()预防\n * c. unsafe破坏单例 无法预防\n * *&#x2F;\n&#x2F;&#x2F; 实现序列化接口可以通过反序列化\npublic static class Singleton1 implements Serializable &#123;\n\n    &#x2F;&#x2F; 私有构造\n    private Singleton1() &#123;\n        &#x2F;&#x2F; 预防反射破坏单例\n        if (INSTANCE !&#x3D; null) &#123;\n            throw new RuntimeException(&quot;单例对象不能重复创建&quot;);\n        &#125;\n        System.out.println(&quot;private Singleton&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 唯一实现\n    private static final Singleton1 INSTANCE &#x3D; new Singleton1();\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton1 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; 防止反序列化破坏单例\n\n    public Object readResolve() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"2\">\n<li>枚举饿汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 2. 枚举饿汉式\n* a. 通过反射,无法进行破坏\n* b. 也无法通过反序列化破坏单例\n* c. unsafe破坏单例 无法预防\n* *&#x2F;\npublic enum Singleton2 &#123;\n    INSTANCE;\n    Singleton2() &#123;\n        System.out.println(&quot;private Singleton2&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton2 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"3\">\n<li>懒汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 3. 懒汉式\n* 在第一次调用 getInstance 才会初始化\n* *&#x2F;\nclass Singleton3 &#123;\n    private static Singleton3 INSTANCE &#x3D; null;\n\n    private Singleton3() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 加上synchronized防止多线程同时进入 INSTANCE &#x3D; new Singleton3();\n    public static synchronized Singleton3 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            INSTANCE &#x3D; new Singleton3();\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"4\">\n<li>DCL懒汉式</li>\n</ol>\n<p>[注意] 加volatile来防止指令重排序问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 4. DCL懒汉式\n* 方法三 synchronized 加载静态方法上,相当于加在Singleton4.class上,每次调用这个类都会加锁\n* 多线程下效率过低,创建单例后其实可以避免每次加锁\n* *&#x2F;\nclass Singleton4 &#123;\n    &#x2F;*\n    * 双检查锁要加 volatile\n    * volatile解决共享变量的 可见性和有序性的问题\n    * JVM在将代码编译为字节码后,在执行时,可能会因为优化而改变指令的执行顺序(指令重排序)\n    * 在单线程情况可以正常执行,但是多线程就有可能出现问题\n    * *&#x2F;\n    private static volatile Singleton4 INSTANCE &#x3D; null;\n\n    private Singleton4() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n    &#x2F;&#x2F; 双检查锁机制\n    public static Singleton4 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton4.class) &#123;\n                if (INSTANCE &#x3D;&#x3D; null) &#123;\n                    INSTANCE &#x3D; new Singleton4();\n                &#125;\n            &#125;\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;</code></pre>\n\n<ol start=\"5\">\n<li>内部类懒汉式</li>\n</ol>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n* 5. 内部类懒汉式\n* 第一次调用getInstance才会触发内部类的加载链接初始化\n* *&#x2F;\nclass Singleton5 &#123;\n    private Singleton5() &#123;\n        System.out.println(&quot;private Singleton5&quot;);\n    &#125;\n\n    private static class Holder &#123;\n        static Singleton5 INSTANCE &#x3D; new Singleton5();\n    &#125;\n\n    public static Singleton5 getInstance() &#123;\n        return Holder.INSTANCE;\n    &#125;\n    &#x2F;&#x2F; .. 其他方法\n&#125;</code></pre>\n\n\n\n<h2 id=\"6-易混知识点\"><a href=\"#6-易混知识点\" class=\"headerlink\" title=\"6. 易混知识点\"></a>6. 易混知识点</h2><h3 id=\"a-重载和重写的区别\"><a href=\"#a-重载和重写的区别\" class=\"headerlink\" title=\"a. 重载和重写的区别\"></a>a. 重载和重写的区别</h3><p><strong>重载</strong> : 发生在同一个类中,方法名必须相同, 参数类型不同,个数不同,顺序不同</p>\n<p>[ 注意 ]返回值不同,访问修饰符不同不算重载</p>\n<p><strong>重写</strong> :  发生在父子类中, 方法名,参数列表必须相同,返回值范围小于等于父类,抛出异常的范围小于等于父类,访问修饰符范围大于等于父类,如果父类方法访问修饰符为private,则子类就不能重写该方法</p>\n<h3 id=\"b-接口和抽象类的区别\"><a href=\"#b-接口和抽象类的区别\" class=\"headerlink\" title=\"b. 接口和抽象类的区别\"></a>b. 接口和抽象类的区别</h3><ul>\n<li>抽象类 可以存在普通成员函数,而 接口 中只能存在 <code>public abstract</code> 方法</li>\n<li>抽象类 成员变量可以是各种类型,而 接口 中的成员变量只能是 <code>public static final</code></li>\n<li>抽象类 只能继承一个, 接口 可以多实现</li>\n</ul>\n<p>概念上:</p>\n<ul>\n<li><p>抽象类: 是对类本质的抽象 is-a 的关系</p>\n<ul>\n<li>设计目的: 代码复用</li>\n<li>抽象类不允许被实例化出来</li>\n</ul>\n</li>\n<li><p>接口: 是对类的行为的约束 like-a 的关系</p>\n<ul>\n<li>核心: 是定义行为</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"c-List和Set的区别\"><a href=\"#c-List和Set的区别\" class=\"headerlink\" title=\"c. List和Set的区别\"></a>c. List和Set的区别</h3><ul>\n<li>List：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出 所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素 </li>\n<li>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元 素，在逐一遍历各个元素</li>\n</ul>\n<h2 id=\"小知识点\"><a href=\"#小知识点\" class=\"headerlink\" title=\"小知识点\"></a>小知识点</h2><ol>\n<li>static变量的初始化会被JVM放入静态代码块中,静态代码块中的代码不用考虑多线程的并发问题,有JVM控制。</li>\n</ol>\n<h1 id=\"二、并发篇\"><a href=\"#二、并发篇\" class=\"headerlink\" title=\"二、并发篇\"></a>二、并发篇</h1><p>本篇详细内容可以参考<a href=\"https://zhang-f4n.github.io/post/JUC,%E8%BF%99%E9%87%8C%E4%B8%BB%E8%A6%81%E4%BB%8B%E7%BB%8D%E9%9D%A2%E8%AF%95%E8%80%83%E7%82%B9\">https://zhang-f4n.github.io/post/JUC,这里主要介绍面试考点</a></p>\n<p>并发三大特性: 原子性 可见性 有序性</p>\n<h2 id=\"1-线程状态\"><a href=\"#1-线程状态\" class=\"headerlink\" title=\"1. 线程状态\"></a>1. 线程状态</h2><p>操作系统5种状态</p>\n<h2 id=\"2-线程池核心参数\"><a href=\"#2-线程池核心参数\" class=\"headerlink\" title=\"2. 线程池核心参数\"></a>2. 线程池核心参数</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t&#x2F;&#x2F; 常驻线程数量 可以为0\n                          int maximumPoolSize,\t\t\t\t&#x2F;&#x2F; 最大线程数量\n                          long keepAliveTime,\t\t\t\t&#x2F;&#x2F; 线程存活时间\n                          TimeUnit unit,\t\t\t\t\t&#x2F;&#x2F; 存活时间单位\n                          BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 阻塞队列\n                          ThreadFactory threadFactory,\t\t  &#x2F;&#x2F; 线程工厂,用于创建线程,为线程提供名字\n                          RejectedExecutionHandler handler) &#123;&#125; &#x2F;&#x2F; 拒绝策略,当线程池爆满时的拒绝接收线程的策略\n    \n&#x2F;&#x2F; 线程池的使用\nExecutorService threadPool &#x3D; new ThreadPoolExecutor(\n    2,\n    5,\n    2L,\n    TimeUnit.SECONDS,\n    new ArrayBlockingQueue&lt;&gt;(3),\n    Executors.defaultThreadFactory(),\n    new ThreadPoolExecutor.AbortPolicy());\n&#x2F;&#x2F; 自定义线程池使用\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为5的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        threadPool.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool.shutdown();\n&#125;</code></pre>\n\n<p><code>RejectedExecutionHandler</code> 线程池的饱和拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>\n<ul>\n<li><code>AbortPolicy</code>: 直接抛出异常，默认策略；</li>\n<li><code>CallerRunsPolicy</code>: 用调用者所在的线程来执行任务；</li>\n<li><code>DiscardOldestPolicy</code>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li><code>DiscardPolicy</code>: 直接丢弃任务；</li>\n</ul>\n<hr>\n<h2 id=\"3-HashTable-和-ConcurrentHashMap\"><a href=\"#3-HashTable-和-ConcurrentHashMap\" class=\"headerlink\" title=\"3. HashTable 和 ConcurrentHashMap\"></a>3. HashTable 和 ConcurrentHashMap</h2><ol>\n<li>HashTable 和 ConcurrentHashMap都是线程安全的Map集合,键值不能为空</li>\n<li>HashTable 并发度低,这个Hashtable公共一把锁,同一时刻,只能由一个线程操作它</li>\n<li>ConcurrentHashMap<ul>\n<li>1.8之前 使用 segment + 数组 + 链表的形式,每个Segment对应一把锁,多个线程访问不同的segment不会冲突</li>\n<li>1.8开始 将数组的每个头节点作为锁,如果多个线程访问的头结点不同,则不会冲突</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"4-ThreadLocal\"><a href=\"#4-ThreadLocal\" class=\"headerlink\" title=\"4. ThreadLocal\"></a>4. ThreadLocal</h2><p><code>ThreadLocal</code> 可以实现[资源对象]的线程隔离,让每个线程各用各的[资源对象],避免引发线程安全问题,同时实现了<strong>线程内的资源共享(不同方法都可以访问)</strong></p>\n<p>「线程内资源共享 线程间资源隔离」</p>\n<p>其原理就是，每一个线程内都有ThreadLocalMap类型的成员变量，用来存储资源对象</p>\n<ul>\n<li>调用set方法时，以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中</li>\n<li>调用get方法，以ThreadLocal自己作为key，到当前线程中查找相关联的资源值</li>\n<li>调用remove方法，就是以ThreadLocal自己作为key，移除当前线程相关的资源值</li>\n</ul>\n<ol>\n<li>为什么ThreadLocalMap中的key要设计为弱引用?<ul>\n<li>Thread可能长时间运行,如果key不再使用,需要在内存不足时去释放占用的内存</li>\n<li>但GC仅仅是让key的内存释放,后续还要根据key是否为null来进一步释放值的内存,释放的时机有<ul>\n<li>获取key时发现 null key</li>\n<li>set key时,会使用启发式扫描, 清理临近的null key,启发次数与元素个数,是否发现null key</li>\n<li>remove时(推荐) ,一般ThreadLocal作为静态变量,GC无法回收</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"5-小知识点\"><a href=\"#5-小知识点\" class=\"headerlink\" title=\"5. 小知识点\"></a>5. 小知识点</h2><p>a. 对比 <code>sleep(long)</code> 和 <code>wait(long)</code></p>\n<p> <code>sleep(long)</code> 和 <code>wait(long)</code>的效果都是让当前线程暂时放弃CPU的使用权,进入阻塞状态</p>\n<ul>\n<li>方法归属不同:<ul>\n<li>sleep是 Thread 的静态方法</li>\n<li>wait 是 Object 的成员方法,每个对象都有</li>\n</ul>\n</li>\n<li>醒来时机不同<ul>\n<li>都会在等待相应的毫秒数后醒来,都可以被打断(<code>interrupt</code>)唤醒</li>\n<li>wait还可以被<code>notify</code>唤醒,<code>wait()</code>如果不唤醒就会一直等待下去</li>\n</ul>\n</li>\n<li>锁特性不同<ul>\n<li>wait方法必须先获取wait对象锁,sleep无此限制</li>\n<li>wait方法执行后会释放对象锁,<code>允许其他线程获得该对象锁</code></li>\n<li>sleep如果在<code>synchronized</code>代码块中执行,并<code>不会释放对象锁</code></li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyWaitSleep &#123;\n    static final Object LOCK &#x3D; new Object();\n    public static void main(String[] args) throws InterruptedException &#123;\n&#x2F;&#x2F;        illegalWait();\n        waiting();\n    &#125;\n    private static void illegalWait() throws InterruptedException &#123;\n&#x2F;&#x2F;        LOCK.wait(); 报错 须配合 对象锁\n        synchronized (LOCK) &#123; &#x2F;&#x2F; wait 锁必须配合 对象锁 使用,不然会报错\n            LOCK.wait();\n        &#125;\n    &#125;\n    private static void waiting() throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(() -&gt; &#123;\n            synchronized (LOCK)&#123;\n                try &#123;\n                    System.out.println(&quot;t1 -- &gt; waiting&quot;);\n                    Thread.sleep(5000L);&#x2F;&#x2F; 不会释放LOCK锁\n                    LOCK.wait(5000L); &#x2F;&#x2F; 会释放LOCK锁\n                &#125;catch (InterruptedException e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;t1&quot;);\n        t1.start();\n&#x2F;&#x2F;        t1.interrupt();&#x2F;&#x2F; 可以用来强制唤醒\n        Thread.sleep(100);\n        synchronized (LOCK)&#123;&#x2F;&#x2F; 如果t1 内使用 sleep,那么就得等待\n            System.out.println(&quot;main&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p>b. 对比 <code>lock</code> 和 <code>synchronized</code></p>\n<ul>\n<li>语法层面<ul>\n<li><code>synchronized</code> 是关键字,用c++实现的</li>\n<li>Lock是接口,由jdk提供</li>\n<li><code>synchronized</code> 退出同步代码块会自动释放,Lock需要调用unlock释放</li>\n</ul>\n</li>\n<li>功能层面<ul>\n<li>都是悲观锁,都具备互斥,同步,锁重入功能</li>\n<li>Lock 提供了许多 synchronized 不具备的功能,例如获取等待状态,公平锁,可打断,可超时,多条件变量</li>\n<li>Lock有很多不同的实现,<code>ReentrantLock</code>,<code>ReentrantReadWriteLock</code></li>\n</ul>\n</li>\n<li>性能层面<ul>\n<li>没有竞争是,synchronized有许多优化,比如偏向锁,轻量级锁,性能不赖</li>\n<li>竞争激烈时,Lock的实现通常会提供更好的性能</li>\n</ul>\n</li>\n</ul>\n<p>c. <code>volatile</code> 能否保证线程安全</p>\n<p>线程安全要考虑三个方面: 可见性、有序性、原子性</p>\n<ul>\n<li>可见性：一个线程对共享变量修改，另外一个线程能看到最新结果</li>\n<li>有序性：一个线程内代码按编写的顺序执行</li>\n<li>原子性：一个线程内多行代码以一个整体执行，并不能保证原子性</li>\n</ul>\n<p><code>volatile</code> 能够保证共享变量的可见性与有序性,并不能保证原子性。</p>\n<p>d. java 中的悲观锁和乐观锁</p>\n<p>悲观锁的代表是 <code>synchronized</code>和<code>Lock</code>锁</p>\n<ul>\n<li>核心思想[线程只要占有了锁,才能操作共享变量,每次只有一个线程占锁成功,获取锁失败的线程,都得等待]</li>\n<li>线程从运行到阻塞,再从阻塞到唤醒,涉及线程上下文切换,如果频繁发生,影响性能</li>\n<li>实际上,线程获取synchronized和lock锁时,如果锁已经被占用,会重试,减少阻塞机会</li>\n</ul>\n<p>乐观锁代表是<code>AtomicInteger</code>,使用cas来保证原子性</p>\n<ul>\n<li>核心思想是[无须加锁,不断重试,但是只有一个线程能成功修改,直到重试成功]</li>\n<li>需要多核支持,且线程数不能超过核数</li>\n<li>线程一直运行,不需要阻塞,因此不涉及上下文切换</li>\n</ul>\n<p>cas-&gt;CompareAndSet,比较后赋值,在最后的赋值前对比拿到的值是否和进入时拿到的值一致,不一致就false,一致才赋值</p>\n<p>在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。</p>\n<h1 id=\"三、虚拟机\"><a href=\"#三、虚拟机\" class=\"headerlink\" title=\"三、虚拟机\"></a>三、虚拟机</h1><h2 id=\"1-Java-虚拟机内存结构\"><a href=\"#1-Java-虚拟机内存结构\" class=\"headerlink\" title=\"1. Java 虚拟机内存结构\"></a>1. Java 虚拟机内存结构</h2><img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220518154004861.png\" alt=\"image-20220518154004861\" style=\"zoom: 67%;\" />\n\n\n\n<p>a. 这些内存区域中,哪些会产生内存溢出?</p>\n<p>不会产生内存溢出的区域:<strong>程序计数器</strong></p>\n<p>会出现内存溢出的区域分为两类:</p>\n<ul>\n<li>出现<code>OutOfMemoryError</code><ul>\n<li>堆内存耗尽    - 对象太多,但又不能回收会报错</li>\n<li>方法区内存耗尽 - 加载的类越来越多,很多框架会在运行期间动态产生新的类</li>\n<li>虚拟机栈累计   - 每个线程最多1M内存,线程越来越多,但又未销毁时会出现溢出</li>\n</ul>\n</li>\n<li>出现<code>StackOverFlowError</code><ul>\n<li>虚拟机栈内部 - 方法调用次数过多(比如递归)</li>\n</ul>\n</li>\n</ul>\n<p>b. 方法区、永久代、元空间之间的关系</p>\n<ul>\n<li>方法区: 方法区是JVM规范中的一种定义,是一块存储元数据,方法字节码,即时编译器需要的信息的内存</li>\n<li>永久代: 是HotSpot虚拟机对JVM的实现(1.8之前)</li>\n<li>元空间: 是HotSpot虚拟机对JVM的实现,使用本地内存保存这些信息(1.8之后)</li>\n</ul>\n<p>c. Java虚拟机内存参数</p>\n<p>[ 注意 ]这里指的是堆内存</p>\n<ul>\n<li><p><code>-Xmx 10240M</code>  虚拟机最大内存</p>\n</li>\n<li><p><code>-Xms 10240M</code>  虚拟机最小内存</p>\n</li>\n<li><p><code>-Xmn 5120M</code>   虚拟机新生代内存大小</p>\n</li>\n<li><p><code>-XX:MaxNewSize</code> 新生代最大大小</p>\n</li>\n<li><p><code>-XX:NewSize</code>    常用的新生代大小</p>\n</li>\n<li><p><code>-XX:SurvivorRatio=4</code>  伊甸园区和幸存者者内存比例</p>\n</li>\n<li><p><code>-XX:NewRatio=2</code>  老年代和新生代内存的比例</p>\n</li>\n</ul>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220518163404485.png\" alt=\"image-20220518163404485\" style=\"zoom:67%;\" />\n\n\n\n<h2 id=\"2-垃圾回收\"><a href=\"#2-垃圾回收\" class=\"headerlink\" title=\"2. 垃圾回收\"></a>2. 垃圾回收</h2><ol>\n<li><p>标记清除</p>\n<ul>\n<li><p>从 GC Root 出发,能访问到的都标记,标记的都不清除</p>\n</li>\n<li><p>会产生内存碎片</p>\n</li>\n</ul>\n</li>\n<li><p>标记整理 - 常用于老年代</p>\n<ul>\n<li>和标记清除一样,但会在最后进行内存移动整理,避免产生内存碎片</li>\n<li>但是移动过程耗时</li>\n</ul>\n</li>\n<li><p>标记复制 - 常用于新生代,因为新生代对象存活少</p>\n<ul>\n<li>多开辟一半内存,在整理过程中,不清理的部分整体复制到另外一部分,不用考虑是否需要清理等问题(提高了整理效率)</li>\n<li>但是内存利用率低了</li>\n</ul>\n</li>\n</ol>\n<p>a. 谈谈GC和分代回收算法</p>\n<p>GC特点:</p>\n<ul>\n<li>GC的目的在于实现对于无用对象内存的自动释放,减少内存碎片,加快内存分配速度</li>\n<li>GC回收的区域是<strong>堆内存</strong>,不包括虚拟机栈,栈内存在方法调用结束会自动释放内存</li>\n<li>判断无用对象,使用的是 <strong>可达性分析算法</strong> ,用 <strong>三色标记法</strong> 来标记存活对象,回收未标记对象</li>\n<li>GC的具体实现被称为 <strong>垃圾回收器</strong> ,如 并行垃圾回收器 、 CMS 、G1</li>\n<li>GC大部分采用了 <strong>分代回收思想</strong>,理论依据是根据大部分对象朝生夕灭,用完立刻回收,另有少部分对象长时间存活,每次很难回收,根据这两类对象的特性将回收区域分为 <strong>新生代</strong> 和 <strong>老年代</strong> ,不用区域使用不同的回收策略</li>\n<li>GC依据回收的规模,可以分为 <strong>Minor GC</strong>,<strong>Mixed GC</strong>,<strong>Full GC</strong></li>\n</ul>\n<p>分代回收:</p>\n<ul>\n<li>伊甸园 eden: 初始的对象都分配在这里,与幸存者区合称新生代</li>\n<li>幸存者区 survivor: 当伊甸园内存不足,回收后的幸存对象到这里,分为 from 和 to ,采用 标记复制算法</li>\n<li>老年代 old: 当幸存者对象熬过几次回收(最多15次),晋升到老年代(幸存区内存不足或大对象会导致提前晋升)</li>\n</ul>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/4cf711a8-7ab2-4152-b85c-d5c226733807.png\" alt=\"image\" style=\"zoom:80%;\" />\n\n<p>GC规模:</p>\n<ul>\n<li>minorGC 发生在新生代,时间短</li>\n<li>MixedGC 新生代+老年代部分区域回收,G1收集器特有</li>\n<li>FullGC 新生代+老年代完整垃圾回收,时间长,应尽量避免</li>\n</ul>\n<p>b.三色标记和并发漏标问题</p>\n<p>用三种颜色记录对象的标记状态:</p>\n<ul>\n<li>黑色 - 已经完成标记</li>\n<li>灰色 - 正在标记中</li>\n<li>白色 - 还未标记处理</li>\n</ul>\n<p>标记的过程,就像广度优先搜索一样,在初始时都是白色,在逐次的标记时,慢慢实现对所有的对象标记,最后剩下的白色对象全部进行清理。</p>\n<p>漏标问题的产生：</p>\n<ul>\n<li>多线程之前：由于线程和GC工作是不会并行的，所以不会产生漏标问题。</li>\n<li>多线程情况下： 由于线程和GC可能并行工作，可能会出现在GC标记过程中，引用关系发生变化的情况，导致对象漏标<ul>\n<li>在GC运行时，白色对象被引用的黑色节点，由于黑色节点已经处理过，导致其没有被标记而清理</li>\n</ul>\n</li>\n</ul>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220519142426944.png\" alt=\"image-20220519142426944\" style=\"zoom:67%;\" />\n\n<p>漏标的解决方案 - 原理是记录发生变化的对象:</p>\n<ol>\n<li><p>增量更新 increment Update </p>\n<p>只要赋值发生变化,被赋值的对象就被记录,然后会重新扫描这些赋值的对象</p>\n</li>\n<li><p>原始快照 Snapshot At The Beginning SATB</p>\n<ul>\n<li>新加的对象会被记录</li>\n<li>被删除引用关系对象也被记录</li>\n</ul>\n</li>\n</ol>\n<p>c. Parallel GC</p>\n<ul>\n<li>eden 内存不足时发生Minor GC,标记复制STW</li>\n<li>old 内存不足时发生Full GC ,标记整理STW</li>\n<li><strong>吞吐量高</strong>,但是会STW,在STW时采用多线程回收垃圾,所以叫Parallel GC</li>\n</ul>\n<p>d. CMS - ConcurrentMarkSweep GC</p>\n<ul>\n<li>old<strong>并发标记</strong>,重新标记时会STW,<strong>并发清除</strong></li>\n<li>Failback Full GC,失败时会触发Full GC</li>\n<li>注重<strong>响应时间</strong></li>\n</ul>\n<p>e. G1 GC</p>\n<ul>\n<li><strong>兼顾响应时间和吞吐量</strong></li>\n<li>划分多个区域,每个区域都当做 eden、survivor、old、humongous</li>\n<li>新生代回收: eden内存不足 标记复制 STW</li>\n<li>并发标记(old 占比达到45%以上): old并发标记,不会暂停,但是漏标时,重新标记会需要STW</li>\n<li>混合收集: 并发标记完成,开始混合收集,参与复制的有eden、survivor、old、其中old会根据 <strong>暂停时间目标</strong>,选择部分回收价值高的区域,复制时会STW</li>\n<li>Failback Full GC</li>\n</ul>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220519152043053.png\" alt=\"image-20220519152043053\" style=\"zoom:67%;\" />\n\n\n\n<h2 id=\"3-内存溢出问题\"><a href=\"#3-内存溢出问题\" class=\"headerlink\" title=\"3. 内存溢出问题\"></a>3. 内存溢出问题</h2><p>a. 误用线程池导致内存溢出,怎么解决?</p>\n<ul>\n<li><p>使用<code>newFixedThreadPool()</code>导致</p>\n<ul>\n<li>此函数有等待队列,在线程池满时,再来新的任务,会加到任务等待队列(没有设置上限)后,过多会导致堆内存溢出。</li>\n</ul>\n<p>解决方案： 不使用官方工具类的线程池，或者自己对任务队列进行限制</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ExecutorService executorService &#x3D; Executors.newFixedThreadPool(2);\nwhile (true) &#123;\n    executorService.submit(() -&gt; &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(30);\n        &#125; catch (InterruptedException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;);\n&#125;</code></pre>\n</li>\n<li><p>使用 <code>newCachedThreadPool()</code>导致</p>\n<ul>\n<li>此线程池中有急救线程,上限很大,可能在使用过程中过多的创建线程导致线程池溢出。</li>\n</ul>\n<p>解决方法： 不使用官方工具类的线程池，或者自己对救急线程数目上限进行限制</p>\n</li>\n</ul>\n<p>b. 查询数据量太大,导致内存溢出,怎么解决?</p>\n<p>生产环境中，比如在编写findAll方法时,对象数据过大,会导致内存溢出</p>\n<p>解决方案: 在查询时进行限制,如添加limit,保证在内存允许范围内</p>\n<p>c. 动态生成类,导致内存溢出,怎么解决?</p>\n<p>比如在执行自己写的脚本时,如果自己写的类加载器等没有结束时,类就不能释放,如果不断生成类,就会导致MetaSpace(元空间&#x2F;方法区)溢出</p>\n<p>解决方案:将类加载器不要设置为static等,缩短生命周期,让它可以被GC回收</p>\n<h2 id=\"4-类加载过程、双亲委派机制\"><a href=\"#4-类加载过程、双亲委派机制\" class=\"headerlink\" title=\"4. 类加载过程、双亲委派机制\"></a>4. 类加载过程、双亲委派机制</h2><p>类加载过程分为三个阶段:</p>\n<ul>\n<li>加载<ul>\n<li>将类的字节码载入<strong>方法区</strong>,创建类.class对象</li>\n<li>如果类的父类没有加载,先加载父类</li>\n<li>加载是懒执行(用到时才会触发类加载)</li>\n</ul>\n</li>\n<li>链接<ul>\n<li>验证 - 验证类是否符合Class规范,合法性,安全性检查</li>\n<li>准备 - 为static变量分配空间,设置默认值 (并不会进行构造初始化,final会赋值)</li>\n<li>解析 - 将常量池的符号引用解析为直接引用</li>\n</ul>\n</li>\n<li>初始化<ul>\n<li>执行静态代码块 与 非final静态变量的赋值</li>\n<li>初始化为懒执行</li>\n</ul>\n</li>\n</ul>\n<p>[ 注意 ] </p>\n<ul>\n<li>final static 修饰的<strong>基本类型</strong>的调用,不会触发类的加载</li>\n<li>final static 修饰的<strong>引用类型</strong>的调用,会触发类的加载</li>\n</ul>\n<p>双亲委派机制:</p>\n<p>指优先委派上级类加载器进行加载,如果上级类加载器</p>\n<ul>\n<li>能找到这个类,由上级加载,<strong>加载后的类也对下级类加载器可见</strong></li>\n<li>找不着这个类,则下级类加载器才有资格执行加载 <strong>下级加载的类对上级不可见</strong></li>\n</ul>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220519203053913.png\" alt=\"image-20220519203053913\" style=\"zoom: 50%;\" />\n\n\n\n<ol>\n<li><p>能不能自己写个类叫 <code>java.lang.System</code>?</p>\n<p>不能。</p>\n<ul>\n<li>假设自己的类加载器使用双亲委派，那么就会先由Bootstrap加载系统的<code>java.lang.System</code>,导致自己的加载失败</li>\n<li>如果自己的类加载器不使用双亲委派,那么自己的类加载器加载假冒的<code>java.lang.System</code>时,需要先加载 <code>java.lang.Object</code>,而未使用双亲委派,会找不到而失败</li>\n<li>实际上, 自己定义的类加载器加载以<code>java.</code>开头的包时,就会报安全异常,jdk9之后更是编译也无法通过</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 这是ClassLoader中一段检查的代码\nif (!checkName(name))\n    throw new NoClassDefFoundError(&quot;IllegalName: &quot; + name);\n\n&#x2F;&#x2F; Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias\n&#x2F;&#x2F; relies on the fact that spoofing is impossible if a class has a name\n&#x2F;&#x2F; of the form &quot;java.*&quot;\nif ((name !&#x3D; null) &amp;&amp; name.startsWith(&quot;java.&quot;)\n    &amp;&amp; this !&#x3D; getBuiltinPlatformClassLoader()) &#123;\n    throw new SecurityException\n        (&quot;Prohibited package name: &quot; +\n         name.substring(0, name.lastIndexOf(&#39;.&#39;)));\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"5-引用类型和finalize关键字\"><a href=\"#5-引用类型和finalize关键字\" class=\"headerlink\" title=\"5. 引用类型和finalize关键字\"></a>5. 引用类型和finalize关键字</h2><p>引用类型分为哪几类?</p>\n<ol>\n<li>强引用<ul>\n<li>普通变量赋值即为强引用,如 <code>A a = new A();</code></li>\n<li>通过<code>GC ROOT</code>引用链,如果强引用不到该对象,该对象才会被回收</li>\n</ul>\n</li>\n<li>软引用(SoftReference)<ul>\n<li>例如: <code>SoftReference a = new SoftReference(new A());</code></li>\n<li>如果仅有软引用该对象,首次垃圾回收不会回收该对象,如果内存依然不足,再次回收才会回收软引用对象</li>\n<li>软引用只是需要配合引用队列来释放</li>\n<li>典型的例子是反射对象</li>\n</ul>\n</li>\n<li>弱引用(WeakReference)<ul>\n<li>例如:<code>WeakReference a = new WeakReference(new A());</code></li>\n<li>如果仅有弱引用引用该对象,只要发生垃圾回收,就会释放该对象</li>\n<li>弱引用需要配和引用队列来释放</li>\n<li>典型例子就是 ThreadLocalMap 中的 Entry对象</li>\n</ul>\n</li>\n<li>虚引用(PhantomReference)<ul>\n<li>例如: <code>PhantomReference a = new PhantomReference(new A());</code></li>\n<li>必须配合引用队列一起使用,当虚引用引用的对象被回收,会将虚引用对象入队,由Reference Handler线程释放其关联的外部资源</li>\n<li>典型例子就是 Cleaner 释放 DirectByteBuffer 占用的直接内存</li>\n</ul>\n</li>\n</ol>\n<img src=\"Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220519210026917.png\" alt=\"image-20220519210026917\" style=\"zoom:67%;\" />\n\n<p>[ 注意 ] 前面所说的弱引用,虚引用,配合引用队列使用,都是为了找到哪些Java对象被回收,从而进行他对他们关联的资源进一步的清理,为了简化API难度,从 java9 开始引入 Cleaner 对象</p>\n<p>谈谈对finalize的理解?</p>\n<p>finalize() 是Object中的一个方法, 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 <code>try-finally</code> 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。java9之后已经被标注为 <code>@Deprecated</code></p>\n<ul>\n<li>finalize方法调用次序并不固定</li>\n<li>创建了Finalizer线程(守护线程)来实现回收</li>\n<li>finalize方法中出现异常并不会中断</li>\n<li>垃圾回收并不会立刻执行finalize方法,会先加入一个unfinalized队列,然后按序执行finalize方法,然后再进行垃圾回收</li>\n</ul>\n<p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。</p>\n<img src=\"/post/Java%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%96%87/image-20220519213900113.png\" class=\"\" title=\"image-20220519213900113\">\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","text":"一、Java基础1. 二分查找比较基础,注意边界问题和mid的计算 mid = (l + r) &gt;&gt;&gt; 1; public class MyBinarySearch &#123; &#x2F;* * 搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深...","link":"","photos":[],"count_time":{"symbolsCount":"21k","symbolsTime":"19 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":11,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"集合类","slug":"集合类","count":1,"path":"api/tags/集合类.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80\"><span class=\"toc-text\">一、Java基础</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE\"><span class=\"toc-text\">1. 二分查找</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 排序算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">a. 冒泡排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">b. 选择排序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">c. 插入排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">希尔排序</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">d. 快速排序</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">3. 集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-ArrayList\"><span class=\"toc-text\">a. ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-LinkedList-vs-ArrayList\"><span class=\"toc-text\">b. LinkedList vs ArrayList</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-HashMap\"><span class=\"toc-text\">c. HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">索引的计算</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">其他问题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">4. 枚举类型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">5. 单例模式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">5种实现方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%98%93%E6%B7%B7%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">6. 易混知识点</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">a. 重载和重写的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">b. 接口和抽象类的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-List%E5%92%8CSet%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">c. List和Set的区别</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">小知识点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81%E5%B9%B6%E5%8F%91%E7%AF%87\"><span class=\"toc-text\">二、并发篇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">1. 线程状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">2. 线程池核心参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-HashTable-%E5%92%8C-ConcurrentHashMap\"><span class=\"toc-text\">3. HashTable 和 ConcurrentHashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-ThreadLocal\"><span class=\"toc-text\">4. ThreadLocal</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9\"><span class=\"toc-text\">5. 小知识点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA\"><span class=\"toc-text\">三、虚拟机</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">1. Java 虚拟机内存结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">2. 垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3. 内存溢出问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E3%80%81%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">4. 类加载过程、双亲委派机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%92%8Cfinalize%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">5. 引用类型和finalize关键字</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"疑难杂症","uid":"739ea830e013671a7c881bb81994b122","slug":"疑难杂症","date":"2022-05-13T07:48:56.000Z","updated":"2022-05-27T05:11:20.389Z","comments":true,"path":"api/articles/疑难杂症.json","keywords":null,"cover":[],"text":"a. 编译器相关问题1. Pycharm 使用 Matplotlib 绘制动图，在PyCharm中显示绘制的动图问题.[解决办法]：在设置中将在PyCharm内部显示取消掉。 b. Windows 有关设置1. 修改Windows11默认的文件夹图标这个UP主提供了解决方案,ht...","link":"","photos":[],"count_time":{"symbolsCount":340,"symbolsTime":"1 mins."},"categories":[{"name":"疑难杂症","slug":"疑难杂症","count":1,"path":"api/categories/疑难杂症.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"},{"name":"编译器","slug":"编译器","count":1,"path":"api/tags/编译器.json"},{"name":"IDEA","slug":"IDEA","count":1,"path":"api/tags/IDEA.json"},{"name":"PyCharm","slug":"PyCharm","count":1,"path":"api/tags/PyCharm.json"},{"name":"Spring","slug":"Spring","count":1,"path":"api/tags/Spring.json"},{"name":"Windows","slug":"Windows","count":1,"path":"api/tags/Windows.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"feature":true},"next_post":{"title":"B站网友的奇妙发言","uid":"b57cd9d792371efee42384e9cc2f9aee","slug":"B站网友的奇妙发言","date":"2022-05-05T06:46:30.000Z","updated":"2022-06-17T08:56:40.024Z","comments":true,"path":"api/articles/B站网友的奇妙发言.json","keywords":null,"cover":null,"text":"手冲是我和牛子的相互欺骗。 鬼火一响，爹妈白养。 弯道快才是快，谁直线不会加油？ 弯道快才逝快，谁吃席不会夹菜？ 我系一个保安 保卫一方平安 爱吃小熊饼干 上班只为下班 喜欢业主小丹 小时候是喜欢成绩好的女生，大一点开始喜欢漂亮的女生，然后是文静的女生，然后是丰满的女性，然后是青...","link":"","photos":[],"count_time":{"symbolsCount":188,"symbolsTime":"1 mins."},"categories":[{"name":"奇妙发言","slug":"奇妙发言","count":1,"path":"api/categories/奇妙发言.json"}],"tags":[{"name":"搞笑","slug":"搞笑","count":1,"path":"api/tags/搞笑.json"},{"name":"语录","slug":"语录","count":1,"path":"api/tags/语录.json"},{"name":"歇后语","slug":"歇后语","count":1,"path":"api/tags/歇后语.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}