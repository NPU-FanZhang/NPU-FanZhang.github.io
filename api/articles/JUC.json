{"title":"JUC","uid":"696c711dc425c21ecfe6691bc40887b7","slug":"JUC","date":"2022-04-07T12:19:18.000Z","updated":"2022-04-08T09:27:51.114Z","comments":true,"path":"api/articles/JUC.json","keywords":null,"cover":[],"content":"<h1 id=\"1-JUC-概述\"><a href=\"#1-JUC-概述\" class=\"headerlink\" title=\"1. JUC 概述\"></a>1. JUC 概述</h1><p>所谓JUC是 <strong>java.util.concurrent</strong> 工具包的简称，这是一个处理线程的工具包，<strong>可以实现程序的多线程高并发。</strong></p>\n<p><strong>多线程编程的一般步骤:</strong></p>\n<ol>\n<li>创建资源类,在资源类创建属性和操作方法。</li>\n<li>在资源类操作方法:判断、操作、通知</li>\n<li>创建多个线程，调用资源类的操作方法。</li>\n<li>防止虚拟唤醒问题</li>\n</ol>\n<p><strong>多线程锁的演变</strong></p>\n<ul>\n<li>无锁：多线程抢夺资源</li>\n<li><code>synchronized</code>和<code>ReentrantLock</code>，都是独占，每次只可以一个操作，不能共享</li>\n<li><code>ReentrantReadWriteLock</code>，读读可以共享，提升性能，但是不能多人写。缺点：造成死锁（一直读，不能写），读进程不能写，写进程可以读。</li>\n<li>写锁降级为读锁（一般等级写锁高于读锁）</li>\n</ul>\n<h2 id=\"a-进程和线程\"><a href=\"#a-进程和线程\" class=\"headerlink\" title=\"a. 进程和线程\"></a>a. 进程和线程</h2><h3 id=\"1-进程（Process）\"><a href=\"#1-进程（Process）\" class=\"headerlink\" title=\"1. 进程（Process）\"></a>1. 进程（<em>Process</em>）</h3><ul>\n<li>计算机中的<strong>程序关于某数据集合上的一次运行活动</strong></li>\n<li><strong>进程是线程的容器</strong></li>\n<li>程序是指令、数据及其组织形式的描述，进程是程序的实体</li>\n<li><strong>系统进行资源分配和调度的基本单位</strong>，是操作系统结构的基础</li>\n</ul>\n<h3 id=\"2-线程（Thread）\"><a href=\"#2-线程（Thread）\" class=\"headerlink\" title=\"2. 线程（Thread）\"></a>2. 线程（<em>Thread</em>）</h3><ul>\n<li>操作系统能够进行<strong>运算调度的最小单位</strong></li>\n<li>被包含在进程之中，是进程中的实际运作单位</li>\n<li>一条线程指的是进程中一个单一顺序的控制流</li>\n</ul>\n<p><strong>通俗易懂理解</strong></p>\n<ol>\n<li>进程代表一个程序的执行，而线程是程序中的某个单元执行流</li>\n<li>程序一旦运行就是进程；<strong>进程是资源分配的最小单位</strong>而<strong>线程是程序执行的最小单位</strong>。一个进程中可以并发多个线程，每条线程并行执行不同的任务</li>\n</ol>\n<h2 id=\"b-线程的状态\"><a href=\"#b-线程的状态\" class=\"headerlink\" title=\"b. 线程的状态\"></a>b. 线程的状态</h2><p>通过线程枚举类的状态可以看到,线程的状态有: <strong>创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）</strong></p>\n\n\n\n\n<h2 id=\"c-串行、并行和并发\"><a href=\"#c-串行、并行和并发\" class=\"headerlink\" title=\"c. 串行、并行和并发\"></a>c. 串行、并行和并发</h2><p><strong>串行(serial)</strong>:表示所有任务都一一按先后顺序进行<br><strong>并行(parallel)</strong>:同时取得多个任务，并同时去执行所取得的这些任务<br><strong>并发(concurrent)</strong>:多个程序可以同时运行、也可以是多进程同时运行或多指令可以同时运行,但并发不一定并行，也可以说<strong>并发事件之间不一定要同一时刻发生。</strong> </p>\n<p><strong>通俗易懂的理解</strong>  </p>\n<ul>\n<li>并发是同一时刻多个线程在访问同一个资源</li>\n<li>并行是多项工作一起执行，之后再汇总</li>\n</ul>\n<p>举例比如：多个人访问同个网址，为多个线程访问一个网址，多对一此为并发。而并行是多个工作一起执行，每个工作都是一个资源一个线程。之后合并起来就是一个并行工作</p>\n<p><strong>结合以上的搭配可以产生多路复用或异步的方式</strong></p>\n<p>实际上，<strong>对于单核心 CPU 来说，同一时刻只能运行一个线程。</strong>所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会</p>\n<h2 id=\"d-wait和sleep的区别\"><a href=\"#d-wait和sleep的区别\" class=\"headerlink\" title=\"d. wait和sleep的区别\"></a>d. wait和sleep的区别</h2><ul>\n<li>wait: Object 的方法，会释放锁，调用它的前提是当前线程占有锁(即代码要在 synchronized 中)</li>\n<li>sleep: Thread 的静态方法，任何对象实例都能调用。<strong>不会释放锁，也不需要占用锁</strong></li>\n</ul>\n<p>相同点 : 都可以被 interrupted 方法中断,在哪里等待,就在哪里恢复</p>\n<h2 id=\"e-管程\"><a href=\"#e-管程\" class=\"headerlink\" title=\"e. 管程\"></a>e. 管程</h2><p><strong>管程在java中是锁</strong>，在操作系统中是monitor监视器</p>\n<p>代表一种同步机制，同一时间内只能有一个线程访问且被保护数据</p>\n<p>比如jvm的同步基于进入和退出，是管程对象实现</p>\n<ul>\n<li>每个对象都有一个monitor管程对象，都会随着java的对象进行创建和销毁</li>\n<li>管程对象对临界区加锁和解锁</li>\n</ul>\n<p>大意就是进加锁，退是解锁，通过管程对象管理。</p>\n<h1 id=\"2-Synchronized\"><a href=\"#2-Synchronized\" class=\"headerlink\" title=\"2. Synchronized\"></a>2. <em>Synchronized</em></h1><p><strong>造成线程安全主要原因是因为数据共享</strong>，为了解决这种情况，引出 synchronized，它是 Java 中的关键字，是一种<strong>同步锁</strong>（对方法或者代码块中存在共享数据的操作）。</p>\n<p><strong>修饰对象的方式</strong></p>\n<ul>\n<li>修饰代码块</li>\n<li>修饰方法</li>\n<li>修饰静态方法</li>\n<li>修饰一个类</li>\n</ul>\n<p><strong>一个简单的例子</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class sync &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket &#x3D; new Ticket();\n        &#x2F;*2个售票员售出30张票*&#x2F;\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller1&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller2&quot;).start();\n    &#125;\n    static class Ticket &#123;\n        public int number &#x3D; 30;\n        public synchronized void sale() &#123;\n            if (number &gt; 0)\n                System.out.println(Thread.currentThread().getName() + &quot;买了1张票&quot; + &quot;,剩余&quot; + (--number) + &quot;张票&quot;);\n            else System.out.println(Thread.currentThread().getName() + &quot;没买到&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">seller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\n...\nseller1买了1张票,剩余2张票\nseller1买了1张票,剩余1张票\nseller1买了1张票,剩余0张票\n&#x2F;&#x2F; synchronized不能响应中断,所以访问共享资源时,会在一个线程执行完再执行下一个\nseller1没买到\nseller1没买到\n...\nseller3没买到\nseller3没买到\nseller3没买到\n...\nseller2没买到\nseller2没买到</code></pre>\n\n<p>在实现<code>sale()</code>方法时,加上<code>synchronized</code>关键字,不能响应中断,当第一个线程进入后,访问共享资源时,只有当线程结束才会释放；不加<code>synchronized</code>关键字，两个线程会同时进入这个方法。</p>\n<h1 id=\"3-创建线程的方式\"><a href=\"#3-创建线程的方式\" class=\"headerlink\" title=\"3. 创建线程的方式\"></a>3. 创建线程的方式</h1><p>实际上只有一种方式,就是<strong>构造Thread类</strong>,其他的是衍生出来的。</p>\n<p>构造Thread类，又衍生出两种方式，一是<strong>继承Thread类</strong>，二是<strong>实现Runnable接口</strong>，但无论是那种方式，<strong>最终也要创建Thread类的对象或其子类对象。</strong></p>\n<h2 id=\"a-继承-Thread-类\"><a href=\"#a-继承-Thread-类\" class=\"headerlink\" title=\"a. 继承 Thread 类\"></a>a. 继承 <em>Thread</em> 类</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;----&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\npublic class ThreadDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Thread.currentThread().getName() + &quot; &#96;&#x3D; main&quot;);\n        MyThread myThread &#x3D; new MyThread();\n        myThread.start();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"b-实现-Runnable接口\"><a href=\"#b-实现-Runnable接口\" class=\"headerlink\" title=\"b. 实现 Runnable接口\"></a>b. 实现 <em>Runnable</em>接口</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class InheritedInterface &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;--- in Runnable ---&quot;);\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new MyThread());\n        t1.start();\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"c-实现-Callable-接口\"><a href=\"#c-实现-Callable-接口\" class=\"headerlink\" title=\"c. 实现 Callable 接口\"></a>c. 实现 <em>Callable</em> 接口</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class MyThread implements Callable&lt;String&gt; &#123;\n    @Override\n    public String call() throws Exception &#123;\n        System.out.println(Thread.currentThread().getName());\n        return &quot;hello world&quot;;\n    &#125;\n&#125;\n\npublic class ThreadDemo &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        FutureTask futureTask &#x3D; new FutureTask(new MyThread());\n        Thread thread &#x3D; new Thread(futureTask);\n        thread.start();\n        &#x2F;&#x2F; 获取返回值\n        System.out.println(futureTask.get());\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"d-使用线程池\"><a href=\"#d-使用线程池\" class=\"headerlink\" title=\"d. 使用线程池\"></a>d. 使用线程池</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 一池多线程\nExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);  &#x2F;&#x2F; 实际生产中,自定义线程池来进行线程创建\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为3的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n        threadPool1.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool1.shutdown();\n&#125;</code></pre>\n\n\n\n<h2 id=\"Runbale与Callable的区别\"><a href=\"#Runbale与Callable的区别\" class=\"headerlink\" title=\"* Runbale与Callable的区别\"></a>* Runbale与Callable的区别</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static class MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        \n    &#125;\n&#125;\nprivate static class MyThreadCall implements Callable&#123;\n    @Override\n    public Object call() throws Exception &#123;\n        return null;\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>Callable实现的方法是call(),Runnable实现的方法是run().</li>\n<li>Callable的任务执行后有返回值，而Runnable的任务没有返回值</li>\n<li>call方法可以抛出异常，run方法不可以</li>\n<li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>\n</ul>\n<h1 id=\"4-Lock-接口\"><a href=\"#4-Lock-接口\" class=\"headerlink\" title=\"4. Lock 接口\"></a>4. Lock 接口</h1><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Lock &#123;\n\tvoid lock();\n\tvoid lockInterruptibly() throws InterruptedException;\n\tboolean tryLock();\n\tboolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n\tvoid unlock();\n\tCondition newCondition();\n&#125;</code></pre>\n\n<p>Lock接口为锁和等待条件提供一个框架的接口和类，不同于内置同步和监视器。</p>\n<p>Lock是接口，可通过实现类同步访问，多个接口实现类：可重入锁等。</p>\n<ul>\n<li><p><strong>ReentrantLock(可重入锁)</strong> 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更多的方法</p>\n</li>\n<li><p><strong>ReentrantReadWriteLock</strong> 里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和 writeLock()用来获取读锁和写锁<br><strong>writeLock()</strong>;来获取读锁<br><strong>readLock()</strong>;获取写锁</p>\n</li>\n</ul>\n<p><strong>一个Lock锁的例子</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class sync &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket &#x3D; new Ticket();\n        &#x2F;*3个售票员售出30张票*&#x2F;\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller1&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller2&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller3&quot;).start();\n    &#125;\n\n    static class Ticket &#123;\n        public int number &#x3D; 30;\n        private final ReentrantLock lock &#x3D; new ReentrantLock();\n\n        public void sale() &#123;\n            &#x2F;&#x2F; 加锁\n            lock.lock();\n            try &#123;\n                if (number &gt; 0)\n                    System.out.println(Thread.currentThread().getName() + &quot;买了1张票&quot; + &quot;,剩余&quot; + (--number) + &quot;张票&quot;);\n                else System.out.println(Thread.currentThread().getName() + &quot;没买到&quot;);\n            &#125; finally &#123;\n                &#x2F;&#x2F; 解锁 为了避免解锁前出现异常而导致没有解锁,需放入finally中\n                lock.unlock();\n            &#125;\n\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">seller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller1买了1张票,剩余25张票\nseller1买了1张票,剩余24张票\n...&#x2F;&#x2F; lock可以响应中断,所以也有其他线程能买到票\nseller3买了1张票,剩余6张票\nseller3买了1张票,剩余5张票\nseller3买了1张票,剩余4张票\nseller3买了1张票,剩余3张票\nseller3买了1张票,剩余2张票\nseller3买了1张票,剩余1张票\nseller3买了1张票,剩余0张票\nseller3没买到\nseller3没买到\nseller3没买到\nseller3没买到\n...</code></pre>\n\n\n\n<p><strong>Lock与<em>synchronized</em>的区别</strong></p>\n<ul>\n<li>lock不是Java语言内置的,synchronized是Java语言的关键字,因此是内置特性。</li>\n<li>lock和synchronized的很大不同时，<strong>synchronized是自动的上锁和释放锁，而lock需要用户去手动释放锁，否则可能会死锁。</strong></li>\n<li><strong>发生异常时,synchronized会自动释放锁,而lock不会，所以unlock解锁需要放在try&#x2F;finally的finally语句块中。</strong></li>\n<li>lock可以让等待锁的线程响应中断,而synchronized不行,线程会一直等待下去。</li>\n<li>lock可以知道有没有成功获得锁,而synchronized不行。</li>\n<li>资源竞争不激烈时,两者性能差不多;资源竞争激烈时,lock性能高很多。</li>\n</ul>\n<h1 id=\"5-线程间通信\"><a href=\"#5-线程间通信\" class=\"headerlink\" title=\"5. 线程间通信\"></a>5. 线程间通信</h1><p>线程间通信的模型有两种：<strong>共享内存</strong>和<strong>消息传递</strong></p>\n<h2 id=\"a-synchronized实现线程同步\"><a href=\"#a-synchronized实现线程同步\" class=\"headerlink\" title=\"a. synchronized实现线程同步\"></a>a. synchronized实现线程同步</h2><p><strong>一个线程synchronized实现通信的例子</strong></p>\n<p>实现一个由两个线程操作同一个变量,交换进行01切换的类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class communication &#123;\n    public static void main(String[] args) &#123;\n        Share share &#x3D; new Share();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;AA&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;BB&quot;).start();\n    &#125;\n\n    &#x2F;*实现一个由两个线程操作同一个变量,进行01切换的类*&#x2F;\n    static class Share &#123;\n        private int number &#x3D; 0;\n        public synchronized void add() throws InterruptedException &#123;\n            &#x2F;&#x2F; 不是0时进行等待\n            if (number !&#x3D; 0) this.wait();\n            number++;\n            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n            &#x2F;&#x2F; 通知其他线程\n            this.notifyAll();\n        &#125;\n        public synchronized void minus() throws InterruptedException &#123;\n            if (number !&#x3D; 1) this.wait();\n            number--;\n            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n            &#x2F;&#x2F; 通知其他线程\n            this.notifyAll();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">AA::1\nBB::0\nAA::1\nBB::0\nAA::1\nBB::0</code></pre>\n\n<p>如果在方法中不加synchronized,会报错<strong>java.lang.IllegalMonitorStateException</strong></p>\n<p><strong>java.lang.IllegalMonitorStateException</strong>是在调用object的<strong>wait</strong>和<strong>notify</strong>，<strong>notifyAll</strong>方法的时候可能会出现的异常。 </p>\n<p>在调用上述三个方法的时候，线程必须获得该对象的<strong>对象级别锁</strong>，换句话说，出现这个异常的原因是因为，<strong>调用wait和notify，notifyAll的对象没有在同步方法（synchronized修饰的方法）或者同步代码块（synchronized（x）{}）中。</strong></p>\n<p>wait()和notify()方法的调用必须具有内置锁 synchronized(this) 的代码块内或同步方法才能调用，否则就会报该错误。</p>\n<p><strong>如果用了显式锁 Lock 就不要用 wait() 和 notify() 了，它们是两套加锁机制，不能混着用的。</strong></p>\n<h3 id=\"虚假唤醒问题\"><a href=\"#虚假唤醒问题\" class=\"headerlink\" title=\"* 虚假唤醒问题\"></a>* 虚假唤醒问题</h3><p>如果再添加两个线程去操作变量,可能会造成虚假唤醒问题。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Share share &#x3D; new Share();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.add();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;AA&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.minus();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;BB&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.add();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;CC&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.minus();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;DD&quot;).start();\n&#125;\nAA::1\nDD::0\nCC::1\nBB::0\nCC::1\nBB::0\nCC::1\nBB::0\nDD::-1  &#x2F;&#x2F; 出现了-1\nAA::0\nAA::1\nDD::0</code></pre>\n\n<p>如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">while(number !&#x3D; 0) &#123; &#x2F;&#x2F;判断number值是否是0，如果不是0，等待\n    this.wait(); &#x2F;&#x2F;在哪里睡，就在哪里醒\n&#125;</code></pre>\n\n<p><strong>实现中断和虚假唤醒是可能的，需要将 this.wait() 其while方法用在循环中</strong></p>\n<h2 id=\"b-Lock-实现线程通信\"><a href=\"#b-Lock-实现线程通信\" class=\"headerlink\" title=\"b. Lock 实现线程通信\"></a>b. Lock 实现线程通信</h2><p>使用lock进行线程间通信,需要配合<strong>Condition接口</strong>使用。</p>\n<p><strong>Condition的作用是对锁进行更精确的控制。</strong></p>\n<p>Condition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。</p>\n<p><strong>condition可以通俗的理解为条件队列。</strong>当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待&#x2F;通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。</p>\n<p>不同的是，<strong>Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；</strong>而<strong>Condition是需要与”互斥锁”&#x2F;“共享锁”捆绑使用的。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Condition &#123;\n\t&#x2F;&#x2F; 造成当前线程在接到信号或被中断之前一直处于等待状态。\n\tvoid await()\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。\n    boolean await(long time, TimeUnit unit)\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。\n    long awaitNanos(long nanosTimeout)\n    &#x2F;&#x2F; 造成当前线程在接到信号之前一直处于等待状态。\n    void awaitUninterruptibly()\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。\n    boolean awaitUntil(Date deadline)\n    &#x2F;&#x2F; 唤醒一个等待线程。\n    void signal()\n    &#x2F;&#x2F; 唤醒所有等待线程。\n    void signalAll()\n&#125;</code></pre>\n\n\n\n<h3 id=\"1-Lock-实现简单互斥操作。\"><a href=\"#1-Lock-实现简单互斥操作。\" class=\"headerlink\" title=\"1. Lock 实现简单互斥操作。\"></a>1. Lock 实现简单互斥操作。</h3><p>lock实现一个由四个线程操作同一个变量,进行01切换的类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LockCommunication &#123;\n    public static void main(String[] args) &#123;\n        Share share &#x3D; new Share();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;AA&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;BB&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;CC&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;DD&quot;).start();\n    &#125;\n\n    &#x2F;*lock实现一个由四个线程操作同一个变量,进行01切换的类*&#x2F;\n    static class Share &#123;\n        private int number &#x3D; 0;\n        &#x2F;&#x2F; 新建锁对象\n        private ReentrantLock lock &#x3D; new ReentrantLock();\n        &#x2F;&#x2F;  \n        private Condition condition &#x3D; lock.newCondition();\n        &#x2F;&#x2F; +1\n        public void add() throws InterruptedException &#123;\n            lock.lock();\n            try &#123;\n                while (number !&#x3D; 0) &#123;\n                    condition.await();\n                &#125;\n                number++;\n                System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n                &#x2F;&#x2F; 通知全部\n                condition.signalAll();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;-1\n        public void minus() throws InterruptedException &#123;\n\n            lock.lock();\n            try &#123;\n                while (number !&#x3D; 1) &#123;\n                    condition.await();\n                &#125;\n                number--;\n                System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n                condition.signalAll();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h3 id=\"2-Lock实现线程间通信定制化（自定义执行顺序）\"><a href=\"#2-Lock实现线程间通信定制化（自定义执行顺序）\" class=\"headerlink\" title=\"2. Lock实现线程间通信定制化（自定义执行顺序）\"></a>2. Lock实现线程间通信定制化（自定义执行顺序）</h3><p>实现一个三个线程按顺序轮换执行即A-&gt;B-&gt;C-&gt;A-&gt;B-&gt;C….</p>\n<p>实现思路就是用一个信号flag来控制。</p>\n<img src=\"JUC/image-20220328203526194.png\" alt=\"image-20220328203526194\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;* lock 实现一个三个线程按顺序轮换执行即A-&gt;B-&gt;C-&gt;A-&gt;B-&gt;C....*&#x2F;\nstatic class Custom &#123;\n    &#x2F;&#x2F; 1--&gt;A 2--&gt;B 3--&gt;C\n    private int flag &#x3D; 1;\n    private ReentrantLock lock &#x3D; new ReentrantLock();\n    &#x2F;&#x2F; 创建三个 condition\n    private Condition c1 &#x3D; lock.newCondition();\n    private Condition c2 &#x3D; lock.newCondition();\n    private Condition c3 &#x3D; lock.newCondition();\n    &#x2F;&#x2F; 打印3轮 参数为第几轮\n    public void print3(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 1) c1.await();\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 2;\n            &#x2F;&#x2F; 通知c2\n            c2.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n    public void print6(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 2) c2.await();\n            for (int i &#x3D; 0; i &lt; 6; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 3;\n            &#x2F;&#x2F; 通知c3\n            c3.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n    public void print9(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 3) c3.await();\n            for (int i &#x3D; 0; i &lt; 9; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 1;\n            &#x2F;&#x2F; 通知c1\n            c1.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h1 id=\"6-集合线程安全\"><a href=\"#6-集合线程安全\" class=\"headerlink\" title=\"6. 集合线程安全\"></a>6. 集合线程安全</h1><h2 id=\"a-ArrayList线程不安全问题\"><a href=\"#a-ArrayList线程不安全问题\" class=\"headerlink\" title=\"a. ArrayList线程不安全问题\"></a>a. ArrayList线程不安全问题</h2><p>打开ArrayList的源码,以add方法为例,显然他并没有使用<strong>synchronized</strong>或者<strong>lock</strong>进行并发控制,</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n *&#x2F;\nprivate void add(E e, Object[] elementData, int s) &#123;\n    if (s &#96; elementData.length)\n        elementData &#x3D; grow();\n    elementData[s] &#x3D; e;\n    size &#x3D; s + 1;\n&#125;</code></pre>\n\n<p>编写一个多线程同时进行插入操作的程序,很容易会出现以下错误<strong>ConcurrentModificationException</strong>并发修改异常。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n        new Thread(() -&gt; &#123;\n            list.add(UUID.randomUUID().toString().substring(0,8));\n            System.out.println(list);\n        &#125;, String.valueOf(i)).start();\n    &#125;\n&#125;</code></pre>\n\n<img src=\"JUC/image-20220330205045709.png\" alt=\"image-20220330205045709\" style=\"zoom: 50%;\" />\n\n<p>常用的解决方案：</p>\n<img src=\"JUC/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpem9uZ3hpYW8=,size_16,color_FFFFFF,t_70.png\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\" />\n\n<ol>\n<li><p>使用<strong>Vector</strong>,是线程安全的，但是由于使用了synchronized同步锁，导致同一时间内只有一个线程能访问，效率较低。比较古老，JDK1.0 时期的解决方案。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; list &#x3D; new Vector&lt;&gt;();</code></pre>\n</li>\n<li><p>使用**Collections.synchronizedList()**来解决,也比较古老</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());</code></pre>\n</li>\n<li><p>使用<strong>CopyOnWrite</strong>;<strong>使用CopyOnWrite（写时复制）技术解决了这个问题，这一般需要很大的内存开销。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">List&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)\n*&#x2F;\npublic boolean add(E e) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        Object[] elements &#x3D; getArray();\n        int len &#x3D; elements.length;\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n        newElements[len] &#x3D; e;\n        setArray(newElements);\n        return true;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;</code></pre></li>\n</ol>\n<h2 id=\"b-HashSet-x2F-HashMap线程不安全问题\"><a href=\"#b-HashSet-x2F-HashMap线程不安全问题\" class=\"headerlink\" title=\"b. HashSet&#x2F;HashMap线程不安全问题\"></a>b. HashSet&#x2F;HashMap线程不安全问题</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();\nfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n    new Thread(() -&gt; &#123;\n        set.add(UUID.randomUUID().toString().substring(0, 8));\n        System.out.println(set);\n    &#125;, String.valueOf(i)).start();\n&#125;</code></pre>\n\n<p>在执行后,同样也会出现 <strong>java.util.ConcurrentModificationException</strong>异常</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Exception in thread &quot;19&quot; java.util.ConcurrentModificationException\n\tat java.base&#x2F;java.util.HashMap$HashIterator.nextNode(HashMap.java:1495)\n\tat java.base&#x2F;java.util.HashMap$KeyIterator.next(HashMap.java:1518)\n\tat java.base&#x2F;java.util.AbstractCollection.toString(AbstractCollection.java:456)\n\tat java.base&#x2F;java.lang.String.valueOf(String.java:3352)\n\tat java.base&#x2F;java.io.PrintStream.println(PrintStream.java:977)\n\tat collect.lambda$main$0(collect.java:21)\n\tat java.base&#x2F;java.lang.Thread.run(Thread.java:830)</code></pre>\n\n<p>同样也可以使用 <strong>Collections.synchronizedSet()</strong> <strong>CopyOnWriteArraySet</strong> 解决并发问题。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Set&lt;String&gt; set &#x3D; Collections.synchronizedSet(new HashSet&lt;&gt;());\nSet&lt;String&gt; set &#x3D; new CopyOnWriteArraySet&lt;&gt;();</code></pre>\n\n\n\n<p><strong>HashMap</strong></p>\n<p>HashSet底层通过HashMap实现,<strong>HashSet通过给HashMap中的&lt;K,V&gt;的V给一个默认值PERSENT来生成HashSet。</strong></p>\n<p><strong>ArrayList扩容默认一半，HashMap扩容默认一倍。</strong></p>\n<p>可以使用<strong>ConcurrentHashMap</strong> <strong>Collections.synchronizedMap()</strong> 来解决并发问题。</p>\n<p><strong>ConcurrentHashMap</strong>在多线程编程中，将会是非常常用的类。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Map&lt;String,String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();\nMap&lt;String,String&gt; map &#x3D; Collections.synchronizedMap(new HashMap&lt;String, String&gt;());</code></pre>\n\n\n\n<h1 id=\"7-多线程锁\"><a href=\"#7-多线程锁\" class=\"headerlink\" title=\"7. 多线程锁\"></a>7. 多线程锁</h1><p>这里重点关注的是线程执行顺序问题,锁是如何影响线程的执行顺序的。</p>\n<h2 id=\"a-8种加锁情况\"><a href=\"#a-8种加锁情况\" class=\"headerlink\" title=\"a. 8种加锁情况\"></a>a. 8种加锁情况</h2><p><strong>synchronized实现同步的基础：java中的每一个对象都可以作为锁。</strong>this和class也是一种对象。</p>\n<p>具体表现为一下3中形式。</p>\n<ul>\n<li><pre><code> 对于普通同步方法，锁是当前实例对象，锁的是当前对象this，\n</code></pre>\n</li>\n<li><pre><code> 对于同步方法块，锁的是synchronized括号里配置的对象。\n</code></pre>\n</li>\n<li><pre><code> 对于静态同步方法，锁是当前类的class对象\n</code></pre>\n</li>\n</ul>\n<p>下面的程序,<strong>默认先创建线程sendA,再创建线程sendB</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LockProblem &#123;\n    static class Phone &#123;\n        public synchronized void sendA() throws Exception &#123;\n            &#x2F;&#x2F;TimeUnit.SECONDS.sleep(2);\n            System.out.println(&quot;---sendA---&quot;);\n        &#125;\n        public synchronized void sendB() throws Exception &#123;\n            System.out.println(&quot;---sendB---&quot;);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<ol>\n<li><p>标准访问时,执行顺序如何? <strong>不一定,取决于操作系统,但一般先start的先执行</strong></p>\n<p><strong>synchronized加给普通方法,是锁的类对象,即This指针。</strong></p>\n<p>对象锁</p>\n<ul>\n<li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，<strong>某一个时刻内，只能有唯一一个线程去访问这些synchronized方法。</strong></li>\n<li>锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Phone phone &#x3D; new Phone();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendA();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;A&quot;).start();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendB();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;B&quot;).start();</code></pre>\n</li>\n<li><p>A方法内先设置暂停2秒方法,执行顺序如何? <strong>先打印A,B等待A执行结束后打印B</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;</code></pre>\n\n<p>这是由于sendA方法加了synchronized,<strong>而sendA先抢到了这把对象锁，所以会在A打印结束后再打印B，即B要等待A完成才会执行。</strong></p>\n</li>\n<li><p>新增一个普通方法(不加synchronized),执行顺序如何?<strong>先执行普通方法</strong></p>\n<p>普通方法为加锁,并非共享资源,不存在争抢。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public void sayHello()&#123;\n    System.out.println(&quot;---Hello---&quot;);\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendA();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;A&quot;).start();\n\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sayHello();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;B&quot;).start();</code></pre>\n</li>\n<li><p>两个资源类,分别执行时,哪个先执行?<strong>先打印B,A sleep结束后打印A</strong></p>\n<p><strong>两个资源类生成的是两个锁，互相无关</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Phone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\n\nphone.sendA();\nphone2.sendB();</code></pre>\n</li>\n<li><p>两个<strong>静态</strong>同步方法,<strong>一个资源类</strong>,哪个先执行? <strong>先打印A,B等待A完成后执行</strong></p>\n<p><strong>锁的是类,即.class文件,和第六种锁相似,生成再多的类对象,公用的是一个锁</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\n\npublic static synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;</code></pre>\n</li>\n<li><p>两个<strong>静态</strong>同步方法,<strong>两个资源类</strong>,哪个先执行? <strong>先打印A,B等待A完成后执行</strong></p>\n<p><strong>锁的是类,即.class文件,和第六种锁相似,生成再多的类对象,公用的是一个锁</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\n\npublic static synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;\nPhone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\n\nphone.sendA();\nphone2.sendB();</code></pre>\n\n\n</li>\n<li><p>1个静态同步方法,1个普通同步方法,1个资源类,哪个先执行? <strong>先打印B,A sleep结束后打印A</strong></p>\n<p><strong>对象和类都有锁，两把锁互相不冲突，所以B先打印，等A sleep结束后打印A。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\npublic synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;\nphone.sendA();\nphone.sendB();</code></pre>\n</li>\n<li><p>1个静态同步方法,1个普通同步方法,2个资源类,哪个先执行? <strong>先打印B,A sleep结束后打印A。</strong></p>\n<p>对象和类都有锁，两把锁互相不冲突，所以B先打印，等A sleep结束后打印A。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Phone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\nphone.sendA();\nphone2.sendB();</code></pre></li>\n</ol>\n<h2 id=\"b-公平锁和非公平锁\"><a href=\"#b-公平锁和非公平锁\" class=\"headerlink\" title=\"b. 公平锁和非公平锁\"></a>b. 公平锁和非公平锁</h2><ul>\n<li><strong>公平锁</strong>：效率相对低</li>\n<li><strong>非公平锁</strong>：效率高，但是线程容易饿死</li>\n</ul>\n<p><strong>ReentrantLock(true)<strong>为</strong>公平锁</strong><br><strong>ReentrantLock(false)<strong>为</strong>非公平锁</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125;\npublic ReentrantLock(boolean fair) &#123;\n    sync &#x3D; fair ? new FairSync() : new NonfairSync();\n&#125;</code></pre>\n\n<p><strong>公平锁的源码,很简单，它创建了一个访问的循环队列,队列中有线程就排队等候。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Sync object for fair locks\n*&#x2F;\nstatic final class FairSync extends Sync &#123;\n    private static final long serialVersionUID &#x3D; -3000897897090466540L;\n    &#x2F;**\n         * Fair version of tryAcquire.  Don&#39;t grant access unless\n         * recursive call or no waiters or is first.\n         *&#x2F;\n    @ReservedStackAccess\n    protected final boolean tryAcquire(int acquires) &#123;\n        final Thread current &#x3D; Thread.currentThread();\n        int c &#x3D; getState();\n        if (c &#96; 0) &#123;\n            if (!hasQueuedPredecessors() &amp;&amp;\n                compareAndSetState(0, acquires)) &#123;\n                setExclusiveOwnerThread(current);\n                return true;\n            &#125;\n        &#125;\n        else if (current &#96; getExclusiveOwnerThread()) &#123;\n            int nextc &#x3D; c + acquires;\n            if (nextc &lt; 0)\n                throw new Error(&quot;Maximum lock count exceeded&quot;);\n            setState(nextc);\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;</code></pre>\n\n\n\n<p><strong>非公平锁的情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final ReentrantLock lock &#x3D; new ReentrantLock(false);</code></pre>\n\n<p>之前实现的买表实例,非公平锁的情况下,seller2和seller3都不能买到票，票全都被线程1买走了。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">seller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller1买了1张票,剩余25张票\nseller1买了1张票,剩余24张票\nseller1买了1张票,剩余23张票\nseller1买了1张票,剩余22张票\nseller1买了1张票,剩余21张票\n...\nseller2没买到\n...\nseller3没买到</code></pre>\n\n\n\n<p><strong>公平锁的情况</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private final ReentrantLock lock &#x3D; new ReentrantLock(true);</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">seller1买了1张票,剩余29张票\nseller2买了1张票,剩余28张票\nseller3买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller2买了1张票,剩余25张票\nseller3买了1张票,剩余24张票\nseller1买了1张票,剩余23张票\nseller2买了1张票,剩余22张票\nseller3买了1张票,剩余21张票\n...</code></pre>\n\n<h2 id=\"c-可重入锁\"><a href=\"#c-可重入锁\" class=\"headerlink\" title=\"c. 可重入锁\"></a>c. 可重入锁</h2><p><strong>可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。</strong></p>\n<p><strong>可重入锁的意义之一在于防止死锁。</strong></p>\n<p>实现原理是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。</p>\n<p>如果同一个线程再次请求这个锁，计数器将递增；</p>\n<p>每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。</p>\n<p>Synchronized(隐式) 和 Lock(显式) 都是可重入锁。</p>\n<p><strong>可重入的实例</strong></p>\n<p>由此可见,加锁过程中可以重复进入这个锁对象,而不会说</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;synchronized\nObject o &#x3D; new Object();\nnew Thread(() -&gt; &#123;\n    synchronized (o) &#123;\n        System.out.println(Thread.currentThread().getName()+&quot;外层&quot;);\n        synchronized (o)&#123;\n            System.out.println(Thread.currentThread().getName()+&quot;中层&quot;);\n            synchronized (o)&#123;\n                System.out.println(Thread.currentThread().getName()+&quot;内层&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;, &quot;t1&quot;).start();</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;lock\nReentrantLock lock &#x3D; new ReentrantLock();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        lock.lock();\n        System.out.println(Thread.currentThread().getName() + &quot;外层&quot;);\n        try &#123;\n            lock.lock();\n            System.out.println(Thread.currentThread().getName() + &quot;内层&quot;);\n        &#125; finally &#123;\n            &#x2F;&#x2F; 内部是自己的锁不释放锁也可以正常执行,这也是可重入锁的特点\n            &#x2F;&#x2F; 但是内部是其他的锁不释放则不行 \n\t\t   &#x2F;&#x2F; lock.unlock();\n        &#125;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;, &quot;t2&quot;).start();</code></pre>\n\n\n\n<h1 id=\"8-死锁\"><a href=\"#8-死锁\" class=\"headerlink\" title=\"8. 死锁\"></a>8. 死锁</h1><p><strong>两个或以上的进程因为争夺资源而造成互相等待资源的现象称为死锁。</strong>如果没有外力的作用，他们一般不能再执行下去</p>\n<img src=\"JUC/format,f_auto.png\" alt=\"img\" style=\"zoom:67%;\" />\n\n\n\n<p><strong>产生死锁的必要条件</strong>：</p>\n<ul>\n<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>\n<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>\n<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>\n<li>环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。</li>\n</ul>\n<p><strong>查看进程堆栈信息的指令</strong></p>\n<ul>\n<li>windows  <strong>jps</strong></li>\n<li>Linux   <strong>ps -ef</strong></li>\n</ul>\n<h1 id=\"9-Callable-接口\"><a href=\"#9-Callable-接口\" class=\"headerlink\" title=\"9. Callable 接口\"></a>9. <em>Callable</em> 接口</h1><p>对比<em>Callable</em>接口和Runnable接口</p>\n<ul>\n<li>Callable实现的方法是call(),Runnable实现的方法是run().</li>\n<li>Callable的任务执行后有返回值，而Runnable的任务没有返回值</li>\n<li>call方法可以抛出异常，run方法不可以</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class InheritedInterface &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;--- in Runnable ---&quot;);\n        &#125;\n    &#125;\n    private static class MyThreadCall implements Callable&lt;String&gt; &#123;\n        @Override\n        public String call() throws Exception &#123;\n            System.out.println(&quot;--- in Callable ---&quot;);\n            return &quot;Callable Return&quot;;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new MyThread());\n        FutureTask futureTask &#x3D; new FutureTask(new MyThreadCall());\n        Thread t2 &#x3D; new Thread(futureTask);\n        t1.start();\n        t2.start();\n        System.out.println(futureTask.get());\n    &#125;\n&#125;</code></pre>\n\n<p><strong>通过Thread创建线程</strong></p>\n<ul>\n<li><p>Runnable <strong>Thread t1 &#x3D; new Thread(new MyThread());</strong></p>\n</li>\n<li><p>Callable <strong>Thread t2 &#x3D; new Thread(new FutureTask(new MyThreadCall()));</strong></p>\n<p>不可以通过**new Thread(new MyThread2());**创建线程,因为Thread的构造函数中没有Callable接口的参数设置<br>直接替换不可以，只能用下面这种线程创建方法<br>（找一个类，即和Runnable接口有关系，又和Callable接口有关系）</p>\n</li>\n</ul>\n<img src=\"JUC/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpem9uZ3hpYW8=,size_16,color_FFFFFF,t_70.png\" alt=\"在这里插入图片描述\" style=\"zoom:67%;\" />\n\n<p>发现Runnable接口有实现类FutureTask（中间对象）,FutureTask的构造函数有Callable参数，通过FutureTask创建线程对象</p>\n<p>也可以使用lamda表达式来简写</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;lam表达式\nFutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(()-&gt;&#123;\n    System.out.println(Thread.currentThread().getName()+&quot; come in callable&quot;);\n    return 1024;\n&#125;);</code></pre>\n\n\n\n<p><strong>如果两个线程都调用了同一个FutureTask,那么FutureTask中的call方法只会执行一次</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">FutureTask futureTask &#x3D; new FutureTask(new MyThreadCall());\nnew Thread(futureTask,&quot;A&quot;),start();\nnew Thread(futureTask,&quot;B&quot;),start();</code></pre>\n\n\n\n<p><strong>Callable返回值</strong></p>\n<p>Callable接口返回值通过 <strong>futureTask.get()<strong>来调用,只要调用</strong>futureTask.get()</strong>,主线程就要阻塞等待线程执行完毕,因此:<strong>一般放在最后调用线程的返回值,为了尽量让线程计算完再获取返回值</strong></p>\n<ul>\n<li>**get()**获取结果</li>\n<li>**isDone()**判断是否计算结束</li>\n</ul>\n<h1 id=\"10-辅助类\"><a href=\"#10-辅助类\" class=\"headerlink\" title=\"10. 辅助类\"></a>10. 辅助类</h1><h2 id=\"a-减少计数-CountDownLatch\"><a href=\"#a-减少计数-CountDownLatch\" class=\"headerlink\" title=\"a. 减少计数 CountDownLatch\"></a>a. 减少计数 <em>CountDownLatch</em></h2><p>CountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。</p>\n<p>如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws InterruptedException &#123;\n    &#x2F;*实现5个同学陆续离开教室,全部离开后锁门*&#x2F;\n    &#x2F;*设置计数器*&#x2F;\n    CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        new Thread(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;离开&quot;);\n            &#x2F;&#x2F; 计数器 -1\n            countDownLatch.countDown();\n        &#125;, &quot;No.&quot; + i).start();\n    &#125;\n    &#x2F;&#x2F;等待\n    countDownLatch.await();\n    System.out.println(Thread.currentThread().getName()+&quot;锁门&quot;);\n&#125; \nNo.0离开\nNo.2离开\nNo.3离开\nNo.1离开\nNo.4离开\nmain锁门</code></pre>\n\n\n\n<h2 id=\"b-循环栅栏-CyclicBarrier\"><a href=\"#b-循环栅栏-CyclicBarrier\" class=\"headerlink\" title=\"b. 循环栅栏 CyclicBarrier\"></a>b. 循环栅栏 <em>CyclicBarrier</em></h2><p>该类是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点，会执行定义的代码。</p>\n<p>在设计一组固定大小的线程的程序中，这些线程必须互相等待，这个类很有用，因为barrier在释放等待线程后可以重用，所以称为循环barrier</p>\n<p>下面这个例子中:</p>\n<ul>\n<li>每7个线程执行后,定义的 <code>new CyclicBarrier(NUMBER, () -&gt; &#123;System.out.println(&quot;---集齐7颗龙珠召唤神龙---&quot;);&#125;);</code>中的代码才会执行。</li>\n<li>只有前面7个线程都执行完毕，后面的一轮线程才会开始执行</li>\n<li><strong>cyclicBarrier.await</strong>();之后的代码必须等达到CyclicBarrier的屏障才会执行</li>\n<li><strong>await</strong>()在所有的参与者都已经在此barrier上调用await方法之前，一直等待。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;* 集齐7颗龙珠召唤神龙 *&#x2F;\nfinal int NUMBER &#x3D; 7;\nCyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(NUMBER, () -&gt; &#123;\n    System.out.println(&quot;---集齐7颗龙珠召唤神龙---&quot;);\n&#125;);\n\n&#x2F;&#x2F; 集齐龙珠的过程\nfor (int i &#x3D; 0; i &lt; 15; i++) &#123;\n    new Thread(() -&gt; &#123;\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;星龙珠已收集.&quot;);\n            &#x2F;&#x2F; 等待\n            cyclicBarrier.await();\n            &#x2F;&#x2F; cyclicBarrier.await();之后的代码必须等达到CyclicBarrier的屏障才会执行\n            System.out.println(&quot;WDNMD&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (BrokenBarrierException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;, String.valueOf(i + 1)).start();\n&#125;\n1星龙珠已收集.\n3星龙珠已收集.\n2星龙珠已收集.\n4星龙珠已收集.\n5星龙珠已收集.\n6星龙珠已收集.\n7星龙珠已收集.\n8星龙珠已收集.\n---集齐7颗龙珠召唤神龙---\n9星龙珠已收集.\nWDNMD\n10星龙珠已收集.\n11星龙珠已收集.\n12星龙珠已收集.\nWDNMD\nWDNMD\nWDNMD\n13星龙珠已收集.\nWDNMD\nWDNMD\nWDNMD\n15星龙珠已收集.\n14星龙珠已收集.\n---集齐7颗龙珠召唤神龙---\nWDNMD\nWDNMD\n...</code></pre>\n\n\n\n<h2 id=\"c-信号灯-Semaphore\"><a href=\"#c-信号灯-Semaphore\" class=\"headerlink\" title=\"c. 信号灯 Semaphore\"></a>c. 信号灯 <em>Semaphore</em></h2><p>一个计数信号量，从概念上将，信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后在获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动</p>\n<p><strong>具体常用的构造方法有</strong>：<br>Semaphore(int permits)创建具有给定的许可数和非公平的公平设置的Semapore</p>\n<p><strong>具体常用的方法有</strong>：<br>acquire()从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断<br>release()释放一个许可，将其返回给信号量</p>\n<p>设置许可数量Semaphore semaphore &#x3D; new Semaphore(3);<br>一般acquire(）都会抛出异常，release在finally中执行</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*Semaphore实现6辆汽车停到3个停车位*&#x2F;\n&#x2F;&#x2F; 构造函数传参为许可数量\nSemaphore semaphore &#x3D; new Semaphore(3);\n\nfor (int i &#x3D; 0; i &lt; 6; i++) &#123;\n    new Thread(() -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F; 获取许可\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了车位&quot;);\n            &#x2F;&#x2F; 随机停车时间\n            TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n            System.out.println(Thread.currentThread().getName() + &quot;离开了车位&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放\n            semaphore.release();\n        &#125;\n    &#125;, i + &quot;号车&quot;).start();\n&#125;\n1号车抢到了车位\n0号车抢到了车位\n2号车抢到了车位\n0号车--离开了车位\n2号车--离开了车位\n3号车抢到了车位\n4号车抢到了车位\n1号车--离开了车位\n5号车抢到了车位\n5号车--离开了车位\n4号车--离开了车位\n3号车--离开了车位</code></pre>\n\n\n\n<h1 id=\"11-读写锁\"><a href=\"#11-读写锁\" class=\"headerlink\" title=\"11. 读写锁\"></a>11. 读写锁</h1><p><strong>悲观锁</strong>：单独每个人完成事情的时候，执行上锁解锁。解决并发中的问题，不支持并发操作，只能一个一个操作，效率低<br><strong>乐观锁</strong>：每执行一件事情，都会比较数据版本号，谁先提交，谁先提交版本号</p>\n<p><strong>表锁</strong>：整个表操作，不会发生死锁<br><strong>行锁</strong>：每个表中的单独一行进行加锁，会发生死锁</p>\n<p><strong>读锁</strong>：<strong>共享锁（可以有多个人读），会发生死锁</strong><br><strong>写锁</strong>：<strong>独占锁（只能有一个人写），会发生死锁</strong></p>\n<p>读写锁：一个资源可以被多个读线程访问，也可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读共享</p>\n<p><strong>编程方式</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建读写锁对象\nprivate ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n&#x2F;&#x2F;添加写锁\nrwLock.writeLock().lock();\n&#x2F;&#x2F; 释放锁\nrwLock.writeLock().unlock();\n&#x2F;&#x2F; 添加读锁\nrwLock.readLock().lock();\n&#x2F;&#x2F; 释放读锁\nrwLock.readLock().unlock();</code></pre>\n\n\n\n<p><strong>模拟一个读写Map的实例</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class WriteReadLock &#123;\n    public static void main(String[] args) &#123;\n        MyCache myCache &#x3D; new MyCache();\n        &#x2F;&#x2F;  创建线程放数据\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            final int num &#x3D; i;\n            new Thread(() -&gt; &#123;\n                myCache.put(num + &quot;&quot;, num + &quot;&quot;);\n            &#125;, String.valueOf(i)).start();\n        &#125;\n\n        &#x2F;&#x2F;  创建线程取数据\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            final int num &#x3D; i;\n            new Thread(() -&gt; &#123;\n                myCache.get(num + &quot;&quot;);\n            &#125;, String.valueOf(i)).start();\n        &#125;\n    &#125;\n    static class MyCache &#123;\n        &#x2F;&#x2F; 创建Map集合\n        private Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        private ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n\n        &#x2F;&#x2F; 放数据\n        public void put(String key, Object val) &#123;\n            &#x2F;&#x2F;添加写锁\n            rwLock.writeLock().lock();\n\n            try &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 正在进行写操作 &quot; + key);\n                TimeUnit.MICROSECONDS.sleep(300);\n                map.put(key, val);\n                System.out.println(Thread.currentThread().getName() + &quot; 写完了 &quot; + key);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                &#x2F;&#x2F; 释放锁\n                rwLock.writeLock().unlock();\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 取数据\n        public Object get(String key) &#123;\n            &#x2F;&#x2F; 添加读锁\n            rwLock.readLock().lock();\n\n            Object res &#x3D; null;\n            try &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 正在进行读操作 &quot; + key);\n                TimeUnit.MICROSECONDS.sleep(300);\n                res &#x3D; map.get(key);\n                System.out.println(Thread.currentThread().getName() + &quot; 读完了 &quot; + key);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                &#x2F;&#x2F; 释放读锁\n                rwLock.readLock().unlock();\n            &#125;\n            return res;\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<p>不加读写锁之前,出现<strong>读写不互斥,未写完就读</strong>等问题</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">2 正在进行读操作 2\n1 正在进行读操作 1\n2 正在进行写操作 2\n0 正在进行读操作 0\n0 正在进行写操作 0\n1 正在进行写操作 1\n2 读完了 2\t\t\t&#x2F;&#x2F; 还未写完就读了\n1 读完了 1\n0 写完了 0\n2 写完了 2\n0 读完了 0\n1 写完了 1</code></pre>\n\n<p>加了锁之后</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">1 正在进行读操作 1   &#x2F;&#x2F; 读操作并发\n0 正在进行读操作 0\t  &#x2F;&#x2F; 读操作并发\n2 正在进行读操作 2   &#x2F;&#x2F; 读操作并发\n2 读完了 2\n1 读完了 1\n0 读完了 0\n1 正在进行写操作 1   &#x2F;&#x2F; 写操作独占\n1 写完了 1\n2 正在进行写操作 2   &#x2F;&#x2F; 写操作独占\n2 写完了 2\n0 正在进行写操作 0   &#x2F;&#x2F; 写操作独占\n0 写完了 0</code></pre>\n\n\n\n<h2 id=\"锁降级\"><a href=\"#锁降级\" class=\"headerlink\" title=\"* 锁降级\"></a>* 锁降级</h2><p><strong>将写锁降为读锁。</strong>降级后读锁不能升级为写锁。</p>\n<p>JDK8中对锁降级的说明:<strong>获取写锁后,在写锁释放之前,可以获得读锁。</strong>而读锁过程中不能获得写锁。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\nReentrantReadWriteLock.ReadLock readLock &#x3D; rwLock.readLock();\nReentrantReadWriteLock.WriteLock writeLock &#x3D; rwLock.writeLock();\n\n&#x2F;&#x2F; 锁降级\n\n&#x2F;&#x2F; 获取写锁\nwriteLock.lock();\nSystem.out.println(&quot;---Write---&quot;);\n\n&#x2F;&#x2F; 获取读锁\nreadLock.lock();\nSystem.out.println(&quot;---Read---&quot;);\n\nwriteLock.unlock();\nreadLock.unlock();\n\n&#x2F;&#x2F;------结果----------\n&#x2F;&#x2F; ---Write---  \n&#x2F;&#x2F; ---Read---\n\n&#x2F;&#x2F; 如果读锁中获得写锁\n&#x2F;&#x2F; 获取读锁\nreadLock.lock();\nSystem.out.println(&quot;---Read---&quot;);\n&#x2F;&#x2F; 获取写锁\nwriteLock.lock();\nSystem.out.println(&quot;---Write---&quot;);\n\nreadLock.unlock();\nwriteLock.unlock();\n\n&#x2F;&#x2F; ----结果----\n---Read---\n写不能执行</code></pre>\n\n\n\n<h1 id=\"12-阻塞队列\"><a href=\"#12-阻塞队列\" class=\"headerlink\" title=\"12. 阻塞队列\"></a>12. 阻塞队列</h1>\n\n<p><strong>阻塞队列是共享队列（多线程操作），一端输入，一端输出</strong>,不能无限放队列，满了之后就会进入阻塞，取出也同理</p>\n<ul>\n<li>当队列是空的，从队列中获取元素的操作将会被阻塞</li>\n<li>当队列是满的，从队列中添加元素的操作将会被阻塞</li>\n<li>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</li>\n<li>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增</li>\n</ul>\n<p>使用阻塞队列<em>BlockingQueue</em>好处在于<strong>不用关心真实的线程的阻塞与唤醒过程,不用关心实现细节.</strong></p>\n\n\n<h2 id=\"a-阻塞队列的分类\"><a href=\"#a-阻塞队列的分类\" class=\"headerlink\" title=\"a. 阻塞队列的分类\"></a>a. 阻塞队列的分类</h2><ol>\n<li><p><strong>ArrayBlockingQueue</strong>  <strong>基于数组的阻塞队列</strong>,由数组结构组成的有界阻塞队列</p>\n<p>ArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，无法并行</p>\n</li>\n<li><p><strong>LinkedBlockingQueue</strong>  <strong>基于链表的阻塞队列</strong><br><strong>由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列</strong></p>\n</li>\n</ol>\n<p>  之所以能够高效的处理并发数据，还因为其<strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步</strong>，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</p>\n<ol start=\"3\">\n<li><p>DelayQueue 使用优先级队列实现的延迟无界阻塞队列</p>\n<p><strong>DelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。</strong>DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞</p>\n</li>\n<li><p>PriorityBlockingQueue 基于优先级的阻塞队列<br>支持优先级排序的无界阻塞队列,<strong>不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong></p>\n</li>\n<li><p>SynchronousQueue 一种无缓冲的等待队列<br>相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区）<br>不存储元素的阻塞队列，也即单个元素的队列</p>\n<p>声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。<br><strong>公平模式和非公平模式的区别:</strong><br><strong>• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞</strong><br><strong>多余的生产者和消费者，从而体系整体的公平策略；</strong><br><strong>• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者</strong></p>\n<p><strong>而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理</strong></p>\n</li>\n<li><p>LinkedTransferQueue 由链表结构组成的无界阻塞 TransferQueue 队列<br>由链表组成的无界阻塞队列</p>\n<p>预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，生成一个节点（节点元素为 null）入队，消费者线程被等待在这个节点上，生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回</p>\n</li>\n<li><p>LinkedBlockingDeque由链表结构组成的双向阻塞队列</p>\n<p>阻塞有两种情况</p>\n<p>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException异常<br>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数</p>\n</li>\n</ol>\n<h2 id=\"b-阻塞队列使用\"><a href=\"#b-阻塞队列使用\" class=\"headerlink\" title=\"b. 阻塞队列使用\"></a>b. 阻塞队列使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BlockingQueue queue &#x3D; new ArrayBlockingQueue&lt;String&gt;(3);\n&#x2F;&#x2F; 第一组\nqueue.add(&quot;a&quot;);  &#x2F;&#x2F; 向队列中加元素\nqueue.offer(&quot;c&quot;, 100, TimeUnit.SECONDS); &#x2F;&#x2F; 设置超时失效\nqueue.element(); &#x2F;&#x2F; 返回队列头元素\nqueue.remove();  &#x2F;&#x2F; 移除队列头\n&#x2F;&#x2F; 第二组\nqueue.offer(&quot;a&quot;); \nqueue.poll();\nqueue.peek();\n&#x2F;&#x2F; 第三组\nqueue.put(&quot;a&quot;);  &#x2F;&#x2F; 超过容量阻塞\nqueue.take();       &#x2F;&#x2F; 空了会阻塞</code></pre>\n\n\n\n<h1 id=\"13-线程池-ThreadPool\"><a href=\"#13-线程池-ThreadPool\" class=\"headerlink\" title=\"13. 线程池 ThreadPool\"></a>13. 线程池 <em>ThreadPool</em></h1><p><strong>线程池</strong>：一种线程使用模式。<strong>线程过多会带来调度开销，进而影响缓存局部性和整体性能。</strong>而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。</p>\n<p>线程池不仅能够保证内核的充分利用，还能防止过分调度。</p>\n<p><strong>线程池特点：</strong></p>\n<ul>\n<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>\n<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>\n<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<p><strong>线程池框架：</strong></p>\n<p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 <strong>Executor</strong>，<strong>Executors</strong>，<strong>ExecutorService</strong>，<strong>ThreadPoolExecutor</strong> 这几个类。</p>\n<img src=\"JUC/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Nzg3MjI4OA**,size_16,color_FFFFFF,t_70.png\" alt=\"在这里插入图片描述\" style=\"zoom:50%;\" />\n\n<p>线程池根据容量特点可以分为三类：</p>\n<p>这三类都使用的是 <strong>ThreadPoolExecutor</strong> 来创建的线程池。</p>\n<ul>\n<li><p>一池N线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 一池多线程\nExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);</code></pre>\n</li>\n<li><p>一池一线程</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 一池一线程\nExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();</code></pre>\n</li>\n<li><p>线程池可扩容</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 线程池可扩容\nExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();</code></pre></li>\n</ul>\n<p>线程池使用实例</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    &#x2F;&#x2F; 一池多线程\n    ExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为3的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            threadPool1.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool1.shutdown();\n    &#125;\n\n    &#x2F;&#x2F; 一池一线程\n    ExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为1的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n            threadPool2.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool2.shutdown();\n    &#125;\n\n    &#x2F;&#x2F; 线程池可扩容\n    ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为1的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 155; i++) &#123;\n            threadPool3.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool3.shutdown();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h2 id=\"a-ThreadPoolExecutor-参数含义\"><a href=\"#a-ThreadPoolExecutor-参数含义\" class=\"headerlink\" title=\"a. ThreadPoolExecutor 参数含义\"></a>a. <em>ThreadPoolExecutor</em> 参数含义</h2><p>一池N线程、一池一线程、线程池可扩容, 这三个底层都是通过<em><strong>ThreadPoolExecutor</strong></em>实现线程池创建的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n* parameters.\n*\n* @param corePoolSize the number of threads to keep in the pool, even\n*        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set\n* @param maximumPoolSize the maximum number of threads to allow in the\n*        pool\n* @param keepAliveTime when the number of threads is greater than\n*        the core, this is the maximum time that excess idle threads\n*        will wait for new tasks before terminating.\n* @param unit the time unit for the &#123;@code keepAliveTime&#125; argument\n* @param workQueue the queue to use for holding tasks before they are\n*        executed.  This queue will hold only the &#123;@code Runnable&#125;\n*        tasks submitted by the &#123;@code execute&#125; method.\n* @param threadFactory the factory to use when the executor\n*        creates a new thread\n* @param handler the handler to use when execution is blocked\n*        because the thread bounds and queue capacities are reached\n* @throws IllegalArgumentException if one of the following holds:&lt;br&gt;\n*         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;\n*         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;\n*         &#123;@code maximumPoolSize &lt;&#x3D; 0&#125;&lt;br&gt;\n*         &#123;@code maximumPoolSize &lt; corePoolSize&#125;\n* @throws NullPointerException if &#123;@code workQueue&#125;\n*         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null\n*&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t&#x2F;&#x2F; 常驻线程数量\n                          int maximumPoolSize,\t\t\t\t&#x2F;&#x2F; 最大线程数量\n                          long keepAliveTime,\t\t\t\t&#x2F;&#x2F; 线程存活时间\n                          TimeUnit unit,\t\t\t\t\t&#x2F;&#x2F; 存活时间单位\n                          BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 阻塞队列\n                          ThreadFactory threadFactory,\t\t  &#x2F;&#x2F; 线程工厂,用于创建线程\n                          RejectedExecutionHandler handler) &#123;  &#x2F;&#x2F; 拒绝策略,当线程池爆满时的拒绝接收线程的策略\n    if (corePoolSize &lt; 0 ||\n        maximumPoolSize &lt;&#x3D; 0 ||\n        maximumPoolSize &lt; corePoolSize ||\n        keepAliveTime &lt; 0)\n        throw new IllegalArgumentException();\n    if (workQueue &#96; null || threadFactory &#96; null || handler &#96; null)\n        throw new NullPointerException();\n    this.corePoolSize &#x3D; corePoolSize;\n    this.maximumPoolSize &#x3D; maximumPoolSize;\n    this.workQueue &#x3D; workQueue;\n    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);\n    this.threadFactory &#x3D; threadFactory;\n    this.handler &#x3D; handler;\n&#125;</code></pre>\n\n\n\n<p><strong>RejectedExecutionHandler</strong> 线程池的饱和拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:</p>\n<ul>\n<li><strong>AbortPolicy</strong>: 直接抛出异常，默认策略；</li>\n<li><strong>CallerRunsPolicy</strong>: 用调用者所在的线程来执行任务；</li>\n<li><strong>DiscardOldestPolicy</strong>: 丢弃阻塞队列中靠最前的任务，并执行当前任务；</li>\n<li><strong>DiscardPolicy</strong>: 直接丢弃任务；</li>\n</ul>\n<h2 id=\"b-线程池工作流程\"><a href=\"#b-线程池工作流程\" class=\"headerlink\" title=\"b. 线程池工作流程\"></a>b. 线程池工作流程</h2><img src=\"JUC/src=http%253A%252F%252Fimg-blog.csdnimg.cn%252Fimg_convert%252F9d1d48bb7eccdb04a9cfacf61cc6a376.png&refer=http%253A%252F%252Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto\" alt=\"img\" style=\"zoom: 67%;\" />\n\n<p>1.在创建了线程池后,等待提交过来的任务请求.</p>\n<p>2.当调用execute()方法添加一个请求任务时,线程池就会做如下判断:</p>\n<p> 2.1 如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务</p>\n<p> 2.2 如果正在运行的线程数量大于或等于corePoolSize,那么将这个任务放入队列</p>\n<p> 2.3 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize,那么还是要创建非核心线程立刻运行这个任务</p>\n<p> 2.4 如果对队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会<strong>启动饱和拒绝策略来执行.</strong></p>\n<p>3.当一个线程完成任务时,它会从队列中取下一个任务来执行.</p>\n<p>4.当一个线程无事可做超过一定的时间(keepAliveTime)时,线程池会判断:</p>\n<p> 4.1 如果当前运行的线程数大于corePoolSize,那么这个线程就会被停掉</p>\n<p> 4.2 所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小</p>\n<h2 id=\"c-自定义线程池\"><a href=\"#c-自定义线程池\" class=\"headerlink\" title=\"c. 自定义线程池\"></a>c. 自定义线程池</h2><p>实际在开发中不使用Executors创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽风险</p>\n<p><strong>Executors线程池的弊端:</strong></p>\n<ul>\n<li><strong>FixedThreadPool</strong>和<strong>SingleThreadExecutor</strong> 允许的请求队列长度为<strong>Integer.MAX_VALUE(0x7fffffff);*<em><strong>可能会造成大量的请求堆积</strong>,导致</em>*OOM</strong>.</li>\n<li><strong>CachedThreadPool</strong>和 <strong>ScheduledThreadPoolExecutor</strong> 允许创建线程数量为 <strong>Integer.MAX_VALUE(0x7fffffff);</strong>,<strong>可能会创建大量线程</strong>,导致<strong>OOM</strong>.</li>\n</ul>\n<p><strong>如何自定义线程池</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">ExecutorService threadPool &#x3D; new ThreadPoolExecutor(\n    corePoolSize 2,\n    maximumPoolSize 5,\n    keepAliveTime 2L,\n    TimeUnit.SECONDS,\n    new ArrayBlockingQueue&lt;&gt;(3),\n    Executors.defaultThreadFactory(),\n    new ThreadPoolExecutor.AbortPolicy());\n\n&#x2F;&#x2F; 自定义线程池使用\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为5的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        threadPool.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool.shutdown();\n&#125;</code></pre>\n\n\n\n\n\n<h1 id=\"14-拆分-Fork-合并-Join-框架\"><a href=\"#14-拆分-Fork-合并-Join-框架\" class=\"headerlink\" title=\"14. 拆分(Fork)合并(Join)框架\"></a>14. 拆分(Fork)合并(Join)框架</h1><p>Fork&#x2F;Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p>\n<p>将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，该算法相当于递归，二分。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class ForkJoinDemo &#123;\n    static class fibonacci extends RecursiveTask&lt;Integer&gt; &#123;\n        final int n;\n        &#x2F;&#x2F; 创建有参构造\n        fibonacci(int n) &#123; this.n &#x3D; n; &#125;\n        @Override\n        protected Integer compute() &#123;\n            if (n &lt;&#x3D; 1) return n;\n            fibonacci f1 &#x3D; new fibonacci(n - 1);\n            f1.fork();\n            fibonacci f2 &#x3D; new fibonacci(n - 2);\n            return f2.compute() + f1.join();\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建任务对象\n        fibonacci f &#x3D; new fibonacci(10);\n        &#x2F;&#x2F; 创建分支合并池对象\n        ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();\n        ForkJoinTask&lt;Integer&gt; forkJoinTask &#x3D; forkJoinPool.submit(f);\n        &#x2F;&#x2F; 获取合并之后的结果\n        Integer res &#x3D; forkJoinTask.get();\n        System.out.println(res);\n        &#x2F;&#x2F; 关闭池对象\n        forkJoinPool.shutdown();\n    &#125;\n&#125;</code></pre>\n\n\n\n<h1 id=\"15-CompletableFuture-异步回调\"><a href=\"#15-CompletableFuture-异步回调\" class=\"headerlink\" title=\"15. CompletableFuture 异步回调\"></a>15. <em>CompletableFuture</em> 异步回调</h1><p>CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息</p>\n<p><strong>类中的具体引用类以及接口：</strong></p>\n<img src=\"/post/JUC/image-20220402113342236.png\" class=\"\" title=\"image-20220402113342236\">\n\n<p>CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的CompletableFuture 类</p>\n<p>异步调用没有返回值方法runAsync<br>异步调用有返回值方法supplyAsync</p>\n<p>主线程调用 get 方法会阻塞</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CompletableFutureDemo &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 异步调用 无返回值\n        CompletableFuture&lt;Void&gt; completableFuture &#x3D; CompletableFuture.runAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;--异步调用 无返回值&quot;);\n        &#125;);\n        completableFuture.get();\n\n        &#x2F;&#x2F; 异步调用 有返回值\n        CompletableFuture&lt;Integer&gt; completableFuture1 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;----异步调用 有返回值&quot;);\n            int i  &#x3D;1 &#x2F; 0;\n            return 1024;\n        &#125;);\n        completableFuture1.whenComplete((t, u) -&gt; &#123;\n            System.out.println(&quot;--t&#x3D;&quot; + t);\n            System.out.println(&quot;--u&#x3D;&quot; + u);\n        &#125;).get();\n    &#125;\n&#125;\nForkJoinPool.commonPool-worker-19--异步调用 无返回值\nForkJoinPool.commonPool-worker-19----异步调用 有返回值\n--t&#x3D;null &#x2F;&#x2F; 没异常为 1024 即返回值\n--u&#x3D;java.util.concurrent.CompletionException: java.lang.ArithmeticException: &#x2F; by zero\nException in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: &#x2F; by zero\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2070)\n\tat CompletableFutureDemo.main(CompletableFutureDemo.java:21)\nCaused by: java.lang.ArithmeticException: &#x2F; by zero\n\tat CompletableFutureDemo.lambda$main$1(CompletableFutureDemo.java:15)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1771)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1763)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)</code></pre>\n\n\n\n\n\n","text":"1. JUC 概述所谓JUC是 java.util.concurrent 工具包的简称，这是一个处理线程的工具包，可以实现程序的多线程高并发。 多线程编程的一般步骤: 创建资源类,在资源类创建属性和操作方法。 在资源类操作方法:判断、操作、通知 创建多个线程，调用资源类的操作方法...","link":"","photos":[],"count_time":{"symbolsCount":"52k","symbolsTime":"47 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JUC","slug":"JUC","count":1,"path":"api/tags/JUC.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-JUC-%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">1. JUC 概述</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">a. 进程和线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%BF%9B%E7%A8%8B%EF%BC%88Process%EF%BC%89\"><span class=\"toc-text\">1. 进程（Process）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%BA%BF%E7%A8%8B%EF%BC%88Thread%EF%BC%89\"><span class=\"toc-text\">2. 线程（Thread）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">b. 线程的状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E4%B8%B2%E8%A1%8C%E3%80%81%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91\"><span class=\"toc-text\">c. 串行、并行和并发</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#d-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">d. wait和sleep的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#e-%E7%AE%A1%E7%A8%8B\"><span class=\"toc-text\">e. 管程</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Synchronized\"><span class=\"toc-text\">2. Synchronized</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. 创建线程的方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB\"><span class=\"toc-text\">a. 继承 Thread 类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E5%AE%9E%E7%8E%B0-Runnable%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">b. 实现 Runnable接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">c. 实现 Callable 接口</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#d-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">d. 使用线程池</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Runbale%E4%B8%8ECallable%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">* Runbale与Callable的区别</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Lock-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">4. Lock 接口</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">5. 线程间通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-synchronized%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5\"><span class=\"toc-text\">a. synchronized实现线程同步</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">* 虚假唤醒问题</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-Lock-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1\"><span class=\"toc-text\">b. Lock 实现线程通信</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Lock-%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E4%BA%92%E6%96%A5%E6%93%8D%E4%BD%9C%E3%80%82\"><span class=\"toc-text\">1. Lock 实现简单互斥操作。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Lock%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%AE%9A%E5%88%B6%E5%8C%96%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%89\"><span class=\"toc-text\">2. Lock实现线程间通信定制化（自定义执行顺序）</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-%E9%9B%86%E5%90%88%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">6. 集合线程安全</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-ArrayList%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">a. ArrayList线程不安全问题</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-HashSet-x2F-HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">b. HashSet&#x2F;HashMap线程不安全问题</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%94%81\"><span class=\"toc-text\">7. 多线程锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-8%E7%A7%8D%E5%8A%A0%E9%94%81%E6%83%85%E5%86%B5\"><span class=\"toc-text\">a. 8种加锁情况</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81\"><span class=\"toc-text\">b. 公平锁和非公平锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81\"><span class=\"toc-text\">c. 可重入锁</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">8. 死锁</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-Callable-%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">9. Callable 接口</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-%E8%BE%85%E5%8A%A9%E7%B1%BB\"><span class=\"toc-text\">10. 辅助类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E5%87%8F%E5%B0%91%E8%AE%A1%E6%95%B0-CountDownLatch\"><span class=\"toc-text\">a. 减少计数 CountDownLatch</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F-CyclicBarrier\"><span class=\"toc-text\">b. 循环栅栏 CyclicBarrier</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E4%BF%A1%E5%8F%B7%E7%81%AF-Semaphore\"><span class=\"toc-text\">c. 信号灯 Semaphore</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-%E8%AF%BB%E5%86%99%E9%94%81\"><span class=\"toc-text\">11. 读写锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%94%81%E9%99%8D%E7%BA%A7\"><span class=\"toc-text\">* 锁降级</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#12-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97\"><span class=\"toc-text\">12. 阻塞队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">a. 阻塞队列的分类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">b. 阻塞队列使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#13-%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPool\"><span class=\"toc-text\">13. 线程池 ThreadPool</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-ThreadPoolExecutor-%E5%8F%82%E6%95%B0%E5%90%AB%E4%B9%89\"><span class=\"toc-text\">a. ThreadPoolExecutor 参数含义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">b. 线程池工作流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0\"><span class=\"toc-text\">c. 自定义线程池</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#14-%E6%8B%86%E5%88%86-Fork-%E5%90%88%E5%B9%B6-Join-%E6%A1%86%E6%9E%B6\"><span class=\"toc-text\">14. 拆分(Fork)合并(Join)框架</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#15-CompletableFuture-%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83\"><span class=\"toc-text\">15. CompletableFuture 异步回调</span></a></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Java Visual Machine","uid":"fc14e6deadca9621a12ce14639191e3e","slug":"Java-Visual-Machine","date":"2022-04-07T12:46:48.000Z","updated":"2022-04-08T02:20:00.290Z","comments":true,"path":"api/articles/Java-Visual-Machine.json","keywords":null,"cover":[],"text":"JVM(Java Visual Machine)JVM java二进制字节码运行的环境 JVM 是java程序可移植性的基石。 好处: 一次编译，到处执行 自动内存管理 常见错误检查（数组越界检查） JVM组成部分 JVM内存结构 字节码结构 Java类加载机制 GC垃圾回收 1...","link":"","photos":[],"count_time":{"symbolsCount":"40k","symbolsTime":"37 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"Java虚拟机","slug":"Java虚拟机","count":1,"path":"api/tags/Java虚拟机.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"Mysql","uid":"7f77c660cadf02b64dd36120e903f5f0","slug":"Mysql","date":"2022-04-07T06:17:50.000Z","updated":"2022-08-31T11:34:19.031Z","comments":true,"path":"api/articles/Mysql.json","keywords":null,"cover":"/svg/mysql.svg","text":"1. 概述MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。 一条SQL语句的执行流程如下: 建立连接。先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。 在完成经典的 ...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":13,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Mysql","slug":"Mysql","count":3,"path":"api/tags/Mysql.json"},{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}