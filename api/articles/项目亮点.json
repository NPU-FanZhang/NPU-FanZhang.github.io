{"title":"项目亮点","uid":"da8e06681356f7590e60f2c8a230b7d7","slug":"项目亮点","date":"2022-09-01T08:06:49.000Z","updated":"2022-09-02T06:55:26.937Z","comments":true,"path":"api/articles/项目亮点.json","keywords":null,"cover":null,"content":"<h3 id=\"a-IM即时通信项目\"><a href=\"#a-IM即时通信项目\" class=\"headerlink\" title=\"a. IM即时通信项目\"></a><strong>a. IM即时通信项目</strong></h3><h5 id=\"1-消息发送过程中可能出现不可靠的情况\"><a href=\"#1-消息发送过程中可能出现不可靠的情况\" class=\"headerlink\" title=\"1. 消息发送过程中可能出现不可靠的情况\"></a>1. 消息发送过程中可能出现不可靠的情况</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">1. A --发消息--&gt; Server --转发--&gt; B\n2. A &lt;-- 确认 -- Server &lt;--确认-- B</code></pre>\n\n<p>第一部分中可能丢失消息的场景有下面这些。</p>\n<ul>\n<li>如果用户 A 在把消息发送到 IM 服务器的过程中，由于网络不通等原因失败了；</li>\n<li>IM 服务器接收到消息进行服务端存储时失败了；</li>\n<li>用户 A 等待 IM 服务器一定的超时时间，但 IM 服务器一直没有返回结果，</li>\n</ul>\n<p>接下来，他可以通过重试等方式来弥补，注意这里可能会导致发送重复消息的问题。</p>\n<p>客户端在超时时间内没有收到响应然后重试，但实际上，请求可能已经在服务端成功处理了，只是响应慢了，因此这种情况需要服务端有去重逻辑，一般发送端针对同一条重试消息有一个唯一的 ID，便于服务端去重使用。</p>\n<p>第二部分 消息在 IM 服务器存储完后，响应用户 A 告知消息发送成功了，然后 IM 服务器把消息推送给用户 B 的在线设备。</p>\n<ul>\n<li>服务器掉电可能导致消息未能发给B</li>\n<li>数据链路出错也可能导致消息不能发给B</li>\n<li>用户 B 的设备在把消息写入本地 DB 时，出现异常导致没能成功入库，这种情况下，由于网络层面实际上已经成功投递了，但用户 B 却看不到消息。所以比较难处理。</li>\n</ul>\n<p>业界一般参考 TCP 协议的 ACK 机制，实现一套业务层的 ACK 协议。</p>\n<h5 id=\"2-解决消息不可靠的方案\"><a href=\"#2-解决消息不可靠的方案\" class=\"headerlink\" title=\"2. 解决消息不可靠的方案\"></a>2. 解决消息不可靠的方案</h5><p>如何解决消息在传输过程中丢失?</p>\n<blockquote><p>解决这个问题的常用策略其实也是参考了 TCP 协议的重传机制。类似的，IM 服务器的“等待 ACK 队列”一般都会维护一个超时计时器，一定时间内如果没有收到用户 B 回的 ACK 包，会从“等待 ACK 队列”中重新取出那条消息进行重推。</p></blockquote>\n<p>如何解决消息重复推送的问题?就是 ACK 包丢失导致的服务端重传，可能会让接收方收到重复推送的消息。</p>\n<blockquote><p>服务端推送消息时携带一个 Sequence ID，Sequence ID 在本次连接会话中需要唯一，针对同一条重推的消息 Sequence ID 不变，接收方根据这个唯一的 Sequence ID 来进行业务层的去重，这样经过去重后，对于用户 B 来说，看到的还是接收到一条消息，不影响使用体验。</p></blockquote>\n<h5 id=\"3-消息的时序性不保证会产生什么问题\"><a href=\"#3-消息的时序性不保证会产生什么问题\" class=\"headerlink\" title=\"3. 消息的时序性不保证会产生什么问题?\"></a>3. 消息的时序性不保证会产生什么问题?</h5><p>如果发送方和接收方的消息收发都是单线程操作，并且和 IM 服务端都只有唯一的一个 TCP 连接，来进行消息传输，IM 服务端也只有一个线程来处理消息接收和消息推送。这种场景下，消息的时序一致性是比较容易能得到保障的。</p>\n<p>但在实际的后端工程实现上，由于单发送方、单接收方、单处理线程的模型吞吐量和效率都太低，基本上不太可能存在。</p>\n<p>更多的场景下，我们可能需要面对的是多发送方、多接收方、服务端多线程并发处理的情况。</p>\n<p>这种情况下,很容易导致接收到的消息顺序无法保证。对于点对点的聊天场景，时序一致性需要保证接收方的接收顺序和发送方的发出顺序一致；而对于群组聊天，时序一致性保证的是群里所有接收人看到的消息展现顺序都一样。</p>\n<h5 id=\"4-消息的时序性如何保证\"><a href=\"#4-消息的时序性如何保证\" class=\"headerlink\" title=\"4. 消息的时序性如何保证?\"></a>4. 消息的时序性如何保证?</h5><p>对于如何保持消息的时序一致性的关键点在于：需要找到一个时序基准来标识每一条消息的顺序。</p>\n<p>这个时序基准可以通过全局的序号生成器来确定。常见的实现方式包括支持单调自增序号的资源生成，或者分布式时间相关的 ID 生成服务生成。两种方式各有一些限制</p>\n<p>有了通过时序基准确定的消息序号，由于 IM 服务器差异和多线程处理的方式，不能保证服务端的消息一定能按顺序推到接收方。我们可以通过“服务端包内整流”机制来保证需要“严格有序”批量消息的正确执行；或者，接收方根据消息序号来进行消息本地整流，从而确保多接收方的最终一致性。</p>\n<h5 id=\"5-聊天的安全性如何保证？\"><a href=\"#5-聊天的安全性如何保证？\" class=\"headerlink\" title=\"5. 聊天的安全性如何保证？\"></a>5. 聊天的安全性如何保证？</h5><p>从三个维度来描述消息的安全性：消息传输安全性、消息存储安全性、消息内容安全性。</p>\n<ul>\n<li><p>消息传输安全性</p>\n<ul>\n<li><p>访问入口安全</p>\n<p>比较常见的问题就是 DNS 劫持，使用HttpDNS来直接去权威DNS服务器获取地址,而不走LocalDNS缓存</p>\n</li>\n<li><p>传输链路安全</p>\n<p>比较常见的有:中断、截获、篡改、伪造 使用 TLS 传输层加密协议和多通道传输来解决</p>\n</li>\n</ul>\n</li>\n<li><p>消息存储安全性。</p>\n<p>针对账号密码的存储安全可以通过“高强度单向散列算法”和“加盐”机制来提升加密密码可逆性；对于追求极致安全性的即时消息场景并且政策允许的情况下，服务端应该尽量不存储消息内容，并且采用“端到端加密”方式来提供更加安全的消息传输保护。</p>\n</li>\n<li><p>消息内容安全性。</p>\n<p>针对消息内容的安全识别可以依托“敏感词库”“图片识别”“OCR 和语音转文字”“外链爬虫抓取分析”等多种手段，并且配合“联动惩罚处置”来进行风险识别的后置闭环。</p>\n</li>\n</ul>\n<h5 id=\"6-为什么需要心跳机制\"><a href=\"#6-为什么需要心跳机制\" class=\"headerlink\" title=\"6. 为什么需要心跳机制?\"></a>6. 为什么需要心跳机制?</h5><p>​    “长连接”底层使用的 TCP 连接并不是一个真正存在的物理连接，实际上只是一个无感知的虚拟连接，中间链路的断开连接的两端不会感知到，因此维护好这个“长连接”一个关键的问题在于能够让这个“长连接”能够在中间链路出现问题时，让连接的两端能快速得到通知，然后通过“重连”来重新建立新的可用连接</p>\n<p>为什么需要心跳机制?</p>\n<ul>\n<li>降低服务端无效的资源开销</li>\n</ul>\n<p>​    实现消息的“服务端推送”，是因为我们针对每一台上线的设备，都会在 IM 服务端维护相应的“用户设备”和“网络连接”这么一个映射关系，如果 IM 服务端无法感知到这些连接的异常情况，会导致的一个问题是：IM 服务端可能维护了大量“无效的连接”，从而导致严重的连接句柄的资源浪费；</p>\n<ul>\n<li>支持客户端断线重连</li>\n</ul>\n<p>​    对于客户端发出心跳包，如果在一定的超时时间内（考虑到网络传输具有一定的延迟性，这个超时时间至少要大于一个心跳的间隔），比如连续两次发送心跳包，都没有收到 IM 服务端的响应，那么客户端可以认为和服务端的长连接不可用，这时客户端可以断线重连。</p>\n<p>​    导致服务端没有响应的原因可能是和服务端的网络在中间环节被断开，也可能是服务器负载过高无法响应心跳包，不管什么情况，这种场景下断线重连是很有必要的，它能够让客户端快速自动维护连接的可用性。</p>\n<ul>\n<li>连接保活</li>\n</ul>\n<p>维护一条“高可用”的长连接，还有一个重要的任务就是<strong>尽量让建立的长连接存活时间更长</strong>。</p>\n<p>这里你可能会问：难道在用户网络和中间路由网络都正常的情况下，长连接还可能会被杀死？</p>\n<p>答案是：确实会。</p>\n<p>运营商在分配IP时,会通过NAT网络地址转换,NAT本身的实现机制并没有什么不妥，问题在于很多运营商为了节省资源和降低自身网关的压力，对于一段时间没有数据收发的连接，运营商会将它们从 NAT 映射表中清除掉，而且这个清除动作也不会被手机端和 IM 服务端感知到。</p>\n<h5 id=\"8-如何用心跳机制保证长连接\"><a href=\"#8-如何用心跳机制保证长连接\" class=\"headerlink\" title=\"8. 如何用心跳机制保证长连接?\"></a>8. 如何用心跳机制保证长连接?</h5><p><strong>应用层心跳实际上就是客户端每隔一定时间间隔，向 IM 服务端发送一个业务层的数据包告知自身存活。</strong></p>\n<p>如果 IM 服务端在一定时间内没有收到心跳包，就认定客户端由于某种原因连接不可达了，此时就会从 IM 服务端把这个连接断开，同时清除相应分配的其他资源。</p>\n<p>逻辑顺序:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">服务器启动 \n    -&gt; Spring启动 \n    -&gt; 容器加载 \n    -&gt; Netty服务启动 -&gt; 建立http协议 -&gt; http协议升级至webSocket协议(其实是在netty管道中处理) \n    -&gt; 消息发送 \n    -&gt; \n    \n客户端启动 -&gt; 登入 -&gt; 消息单发\t-&gt; 登出\n    \t\t\t -&gt; 消息群发</code></pre>\n\n\n\n<h5 id=\"协议升级过程\"><a href=\"#协议升级过程\" class=\"headerlink\" title=\"协议升级过程\"></a>协议升级过程</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"></code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<h3 id=\"b-技术论坛项目\"><a href=\"#b-技术论坛项目\" class=\"headerlink\" title=\"b. 技术论坛项目\"></a><strong>b. 技术论坛项目</strong></h3><p>​    完成了一些基本的发帖，登录，回复，点赞等功能</p>\n<p>​    做完这个项目之后，我发现 </p>\n<h3 id=\"c-无人集群搜索能力评估方法\"><a href=\"#c-无人集群搜索能力评估方法\" class=\"headerlink\" title=\"c. 无人集群搜索能力评估方法\"></a><strong>c. 无人集群搜索能力评估方法</strong></h3><p>​    </p>\n<h4 id=\"WebSocket\"><a href=\"#WebSocket\" class=\"headerlink\" title=\"WebSocket\"></a>WebSocket</h4><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议。</p>\n<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n","text":"a. IM即时通信项目1. 消息发送过程中可能出现不可靠的情况1. A --发消息--&gt; Server --转发--&gt; B 2. A &lt;-- 确认 -- Server &lt;--确认-- B 第一部分中可能丢失消息的场景有下面这些。 如果用户 A 在把消息发送...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"项目","slug":"项目","count":1,"path":"api/tags/项目.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-IM%E5%8D%B3%E6%97%B6%E9%80%9A%E4%BF%A1%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">a. IM即时通信项目</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8E%B0%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">1. 消息发送过程中可能出现不可靠的情况</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%A7%A3%E5%86%B3%E6%B6%88%E6%81%AF%E4%B8%8D%E5%8F%AF%E9%9D%A0%E7%9A%84%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">2. 解决消息不可靠的方案</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%B6%88%E6%81%AF%E7%9A%84%E6%97%B6%E5%BA%8F%E6%80%A7%E4%B8%8D%E4%BF%9D%E8%AF%81%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">3. 消息的时序性不保证会产生什么问题?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%B6%88%E6%81%AF%E7%9A%84%E6%97%B6%E5%BA%8F%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81\"><span class=\"toc-text\">4. 消息的时序性如何保证?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E8%81%8A%E5%A4%A9%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%EF%BC%9F\"><span class=\"toc-text\">5. 聊天的安全性如何保证？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">6. 为什么需要心跳机制?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#8-%E5%A6%82%E4%BD%95%E7%94%A8%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BF%9D%E8%AF%81%E9%95%BF%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">8. 如何用心跳机制保证长连接?</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8D%8F%E8%AE%AE%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">协议升级过程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-%E6%8A%80%E6%9C%AF%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE\"><span class=\"toc-text\">b. 技术论坛项目</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-%E6%97%A0%E4%BA%BA%E9%9B%86%E7%BE%A4%E6%90%9C%E7%B4%A2%E8%83%BD%E5%8A%9B%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">c. 无人集群搜索能力评估方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#WebSocket\"><span class=\"toc-text\">WebSocket</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java面试题","uid":"e551e8b61cca027580338cf7a83d4c1a","slug":"Java面试题","date":"2022-08-30T08:08:03.000Z","updated":"2022-09-05T09:12:42.461Z","comments":true,"path":"api/articles/Java面试题.json","keywords":null,"cover":"/svg/java.svg","text":"JAVA面试题 1. finalize()方法有什么特点?finalize()方法的作用类似于C++中的析构函数,为对象创造最后一次逃脱死亡的机会。一旦垃圾收集器准备好释放对象占用的存储空间，首先调用finalize()，而且只有在下一次垃圾收集过程中，才会真正回收对象的内存。如...","link":"","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":14,"path":"api/categories/互联网八股.json"},{"name":"面试题","slug":"互联网八股/面试题","count":3,"path":"api/categories/互联网八股/面试题.json"}],"tags":[{"name":"java","slug":"java","count":1,"path":"api/tags/java.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}