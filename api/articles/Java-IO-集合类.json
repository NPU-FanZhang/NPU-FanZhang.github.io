{"title":"Java IO/集合类","uid":"21192bc96d4d1e6c92e0c329a20feea9","slug":"Java-IO-集合类","date":"2022-04-08T02:22:24.000Z","updated":"2022-04-08T02:26:43.455Z","comments":true,"path":"api/articles/Java-IO-集合类.json","keywords":null,"cover":[],"content":"<h1 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h1><blockquote><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p></blockquote>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"a-Set\"><a href=\"#a-Set\" class=\"headerlink\" title=\"a. Set\"></a>a. Set</h3><p>Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素</p>\n<p>用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。</p>\n<h4 id=\"1-HashSet\"><a href=\"#1-HashSet\" class=\"headerlink\" title=\"1. HashSet\"></a>1. HashSet</h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>\n<p>HashSet是通过对HashMap进行了一层包装而实现的,也就是说<em>HashSet</em>里面有一个<em>HashMap</em>(适配器模式)。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//HashSet是对HashMap的简单包装</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">HashSet</span>&lt;E&gt;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> HashMap&lt;E,Object&gt; map;<span class=\"comment\">//HashSet里面有一个HashMap</span></span><br><span class=\"line\">    <span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">HashSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;<span class=\"comment\">//简单的方法转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.put(e, PRESENT)**<span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-TreeSet\"><a href=\"#2-TreeSet\" class=\"headerlink\" title=\"2. TreeSet\"></a>2. TreeSet</h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>\n<p><em>TreeSet</em>和<em>TreeMap</em>二者在Java里有着相同的实现，<strong>TreeSet仅仅是对TreeMap做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)。</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// TreeSet是对TreeMap的简单包装</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TreeSet</span>&lt;E&gt; <span class=\"keyword\">extends</span> <span class=\"title class_\">AbstractSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">NavigableSet</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> NavigableMap&lt;E,Object&gt; m;</span><br><span class=\"line\">    <span class=\"comment\">// Dummy value to associate with an Object in the backing Map</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">PRESENT</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">TreeSet</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.m = <span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>&lt;E,Object&gt;();<span class=\"comment\">// TreeSet里面有一个TreeMap</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m.put(e, PRESENT)**<span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"3-LinkedHashSet\"><a href=\"#3-LinkedHashSet\" class=\"headerlink\" title=\"3. LinkedHashSet\"></a>3. LinkedHashSet</h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p>\n<p><em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LinkedHashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">extends</span> <span class=\"title class_\">HashSet</span>&lt;E&gt;</span><br><span class=\"line\">    <span class=\"keyword\">implements</span> <span class=\"title class_\">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable &#123;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">    <span class=\"comment\">// LinkedHashSet里面有一个LinkedHashMap</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">LinkedHashSet</span><span class=\"params\">(<span class=\"type\">int</span> initialCapacity, <span class=\"type\">float</span> loadFactor)</span> &#123;</span><br><span class=\"line\">        map = <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">add</span><span class=\"params\">(E e)</span> &#123;<span class=\"comment\">//简单的方法转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> map.put(e, PRESENT)**<span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"b-List\"><a href=\"#b-List\" class=\"headerlink\" title=\"b. List\"></a>b. List</h3><p>List 是一个接口，它继承于<code>Collection</code>的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。</p>\n<h4 id=\"1-ArrayList\"><a href=\"#1-ArrayList\" class=\"headerlink\" title=\"1. ArrayList\"></a>1. ArrayList</h4><p>基于动态数组实现，支持随机访问。</p>\n<p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<code>数组实现</code>。</p>\n<p>每个<em>ArrayList</em>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。</p>\n<p>前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的<code>数组是一个Object数组</code>，以便能够容纳任何类型的对象。</p>\n<p><code>add(int index, E e)</code> 需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<p><code>trimToSize()</code> 将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p>\n<h5 id=\"自动扩容机制\"><a href=\"#自动扩容机制\" class=\"headerlink\" title=\"自动扩容机制\"></a>自动扩容机制</h5><p>数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用<code>ensureCapacity</code>来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>\n<p><strong>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。</strong>这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>\n<p>扩容操作最终是通过<code>grow()</code>方法完成的,其核心代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* Increases the capacity to ensure that it can hold at least the</span></span><br><span class=\"line\"><span class=\"comment\">* number of elements specified by the minimum capacity argument.</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> minCapacity the desired minimum capacity</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">grow</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// overflow-conscious code</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">oldCapacity</span> <span class=\"operator\">=</span> elementData.length;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">newCapacity</span> <span class=\"operator\">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - minCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = minCapacity;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        newCapacity = hugeCapacity(minCapacity);</span><br><span class=\"line\">    <span class=\"comment\">// minCapacity is usually close to size, so this is a win:</span></span><br><span class=\"line\">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"title function_\">hugeCapacity</span><span class=\"params\">(<span class=\"type\">int</span> minCapacity)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (minCapacity &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutOfMemoryError</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class=\"line\">        Integer.MAX_VALUE :</span><br><span class=\"line\">    MAX_ARRAY_SIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"2-LinkedList\"><a href=\"#2-LinkedList\" class=\"headerlink\" title=\"2. LinkedList\"></a>2. LinkedList</h4><p>基于<code>双向链表</code>实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。</p>\n<p>不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Node</span>&lt;E&gt; &#123;</span><br><span class=\"line\">    E item;</span><br><span class=\"line\">    Node&lt;E&gt; next;</span><br><span class=\"line\">    Node&lt;E&gt; prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = element;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.next = next;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.prev = prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-Vector\"><a href=\"#3-Vector\" class=\"headerlink\" title=\"3. Vector\"></a>3. Vector</h4><p>和 ArrayList 类似，但它是线程安全的。</p>\n<h4 id=\"4-Stack-和-Queue\"><a href=\"#4-Stack-和-Queue\" class=\"headerlink\" title=\"4. Stack 和 Queue\"></a>4. Stack 和 Queue</h4><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类(它是个接口名字)。</p>\n<p>当需要使用栈时，<strong>Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em></strong>；</p>\n<p>既然<em>Queue</em>只是一个接口，*<em>当需要使用队列时也就首选</em>ArrayDeque<em>了(次选是</em>LinkedList*)**。</p>\n<h4 id=\"5-Deque\"><a href=\"#5-Deque\" class=\"headerlink\" title=\"5. Deque\"></a>5. <em>Deque</em></h4><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。</p>\n<p><em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即**循环数组(circular array)**，也就是说数组的任何一点都可能被看作起点或者终点。</p>\n<p>**<em>ArrayDeque</em>是非线程安全的(not thread-safe)**，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>\n<p>其中,JDK中对于双端队列的插入很有一套:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addFirst(E e)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">addFirst</span><span class=\"params\">(E e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e ** <span class=\"literal\">null</span>)<span class=\"comment\">//不允许放入null</span></span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">NullPointerException</span>();</span><br><span class=\"line\">    elements[head = (head - <span class=\"number\">1</span>) &amp; (elements.length - <span class=\"number\">1</span>)] = e;<span class=\"comment\">//2.下标是否越界</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (head ** tail)<span class=\"comment\">//1.空间是否够用</span></span><br><span class=\"line\">        doubleCapacity();<span class=\"comment\">//扩容</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>\n<p>下标越界的处理: <code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍(扩容决定的)，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数(其实只可能是-1)，则相当于对其取相对于<code>elements.length</code>的补码。</p>\n<p><strong>扩容原理</strong></p>\n<p>其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/ArrayDeque_doubleCapacity.png\" alt=\"ArrayDeque_doubleCapacity.png\" style=\"zoom: 50%;\" />\n\n<p>图中我们看到，<strong>为了保持循环数组的性质,复制分两次进行，第一次复制<em>head</em>右边的元素，第二次复制<em>head</em>左边的元素。</strong></p>\n<hr>\n<h3 id=\"c-Queue\"><a href=\"#c-Queue\" class=\"headerlink\" title=\"c. Queue\"></a>c. Queue</h3><p>Queue有两种常见的实现，LinkedList和PriorityQueue</p>\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>前面已经介绍过。</p>\n<h4 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列。</p>\n<p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，<strong>也可以通过构造时传入的比较器</strong>(<em>Comparator</em>，类似于C++的仿函数)。</p>\n<p>​    Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是<strong>通过完全二叉树(<em>complete binary tree</em>)实现的</strong>小顶堆**(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。**</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/PriorityQueue_base.png\" alt=\"PriorityQueue_base.png\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">leftNo = parentNo*<span class=\"number\">2</span>+<span class=\"number\">1</span></span><br><span class=\"line\">rightNo = parentNo*<span class=\"number\">2</span>+<span class=\"number\">2</span></span><br><span class=\"line\">parentNo = (nodeNo-<span class=\"number\">1</span>)/<span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。源码中实现调整结构的代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//siftUp()</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">siftUp</span><span class=\"params\">(<span class=\"type\">int</span> k, E x)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (k &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">parent</span> <span class=\"operator\">=</span> (k - <span class=\"number\">1</span>) &gt;&gt;&gt; <span class=\"number\">1</span>;<span class=\"comment\">//parentNo = (nodeNo-1)/2</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">e</span> <span class=\"operator\">=</span> queue[parent];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (comparator.compare(x, (E) e) &gt;= <span class=\"number\">0</span>)<span class=\"comment\">//调用比较器的比较方法</span></span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        queue[k] = e;</span><br><span class=\"line\">        k = parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    queue[k] = x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>添加元素时,先默认添加到末尾,然后调整结构;删除堆顶元素时,先默认将最后一个元素放置到堆顶,然后再进行调整。</strong></p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"a-HashMap-JDK7\"><a href=\"#a-HashMap-JDK7\" class=\"headerlink\" title=\"a. HashMap-JDK7\"></a>a. HashMap-JDK7</h3><p>基于哈希表实现。</p>\n<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。*<em><strong>Java7 HashMap采用的是冲突链表方式</strong>。</em>*</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/HashMap_base.png\" alt=\"HashMap_base\" style=\"zoom: 50%;\" />\n\n<p>​    HashMap的<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。<strong>因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</strong></p>\n<p>​    有两个参数可以影响<em>HashMap</em>的性能: <code>初始容量(inital capacity)</code>和<code>负载系数(load factor)</code>。初始容量指定了初始<code>table</code>的大小，负<strong>载系数用来指定自动扩容的临界值。</strong>当<code>entry</code>的数量超过<code>capacity * load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p>\n<p><strong>hashCode()方法决定了对象会被放到哪个bucket里，</strong></p>\n<p><strong>当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。</strong></p>\n<p><strong>所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override  hashCode()和equals()方法。</strong></p>\n<p>​    <code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。 算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// HashMap 查找</span></span><br><span class=\"line\"><span class=\"comment\">//getEntry()方法</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> Entry&lt;K,V&gt; <span class=\"title function_\">getEntry</span><span class=\"params\">(Object key)</span> &#123;</span><br><span class=\"line\">\t......</span><br><span class=\"line\">\t<span class=\"type\">int</span> <span class=\"variable\">hash</span> <span class=\"operator\">=</span> (key ** <span class=\"literal\">null</span>) ? <span class=\"number\">0</span> : hash(key);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = table[hash&amp;(table.length-<span class=\"number\">1</span>)];<span class=\"comment\">//得到冲突链表</span></span><br><span class=\"line\">         e != <span class=\"literal\">null</span>; e = e.next) &#123;<span class=\"comment\">//依次遍历冲突链表中的每个entry</span></span><br><span class=\"line\">        Object k;</span><br><span class=\"line\">        <span class=\"comment\">//依据equals()方法判断是否相等</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash ** hash &amp;&amp;</span><br><span class=\"line\">            ((k = e.key) ** key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>​    <code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addEntry()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">addEntry</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">int</span> bucketIndex)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"literal\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">//自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"literal\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">//hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class=\"line\">    table[bucketIndex] = <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>&lt;&gt;(hash, key, value, e);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"b-HashMap-JDK8\"><a href=\"#b-HashMap-JDK8\" class=\"headerlink\" title=\"b. HashMap-JDK8+\"></a>b. HashMap-JDK8+</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以<strong>其由 <strong>数组+链表+红黑树</strong> 组成</strong>。</p>\n<p>根据 Java7 HashMap 的介绍，我们知道，<strong>查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</strong></p>\n<p>为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素达到了 8 个时，会将链表转换为</strong>红黑树<strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</strong></p>\n<p>来一张图简单示意一下吧：</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/java-collection-hashmap8.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<p>简单分析一下插入操作的过程:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> V <span class=\"title function_\">put</span><span class=\"params\">(K key, V value)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class=\"line\"><span class=\"comment\">// 第五个参数 evict 我们这里不关心</span></span><br><span class=\"line\"><span class=\"keyword\">final</span> V <span class=\"title function_\">putVal</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">boolean</span> onlyIfAbsent,</span></span><br><span class=\"line\"><span class=\"params\">               <span class=\"type\">boolean</span> evict)</span> &#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"type\">int</span> n, i;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class=\"line\">    <span class=\"comment\">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) ** <span class=\"literal\">null</span> || (n = tab.length) ** <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"comment\">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) ** <span class=\"literal\">null</span>)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;<span class=\"comment\">// 数组该位置有数据</span></span><br><span class=\"line\">        Node&lt;K,V&gt; e; K k;</span><br><span class=\"line\">        <span class=\"comment\">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (p.hash ** hash &amp;&amp;</span><br><span class=\"line\">            ((k = p.key) ** key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">            e = p;</span><br><span class=\"line\">        <span class=\"comment\">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (p <span class=\"keyword\">instanceof</span> TreeNode)</span><br><span class=\"line\">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class=\"built_in\">this</span>, tab, hash, key, value);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 到这里，说明数组该位置上是一个链表</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">binCount</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; ; ++binCount) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> ((e = p.next) ** <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                    p.next = newNode(hash, key, value, <span class=\"literal\">null</span>);</span><br><span class=\"line\">                    <span class=\"comment\">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个</span></span><br><span class=\"line\">                    <span class=\"comment\">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for 1st</span></span><br><span class=\"line\">                        treeifyBin(tab, hash);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 如果在该链表中找到了&quot;相等&quot;的 key(** 或 equals)</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.hash ** hash &amp;&amp;</span><br><span class=\"line\">                    ((k = e.key) ** key || (key != <span class=\"literal\">null</span> &amp;&amp; key.equals(k))))</span><br><span class=\"line\">                    <span class=\"comment\">// 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                p = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;</span></span><br><span class=\"line\">        <span class=\"comment\">// 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">V</span> <span class=\"variable\">oldValue</span> <span class=\"operator\">=</span> e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!onlyIfAbsent || oldValue ** <span class=\"literal\">null</span>)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            afterNodeAccess(e);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ++modCount;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt; threshold)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    afterNodeInsertion(evict);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>\n<hr>\n<h3 id=\"c-TreeMap\"><a href=\"#c-TreeMap\" class=\"headerlink\" title=\"c. TreeMap\"></a>c. TreeMap</h3><p>基于红黑树实现。</p>\n<p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p>\n<p>出于性能原因，<em>TreeMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成(wrapped)同步的:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">SortedMap</span> <span class=\"variable\">m</span> <span class=\"operator\">=</span> Collections.synchronizedSortedMap(<span class=\"keyword\">new</span> <span class=\"title class_\">TreeMap</span>(...));</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h3 id=\"d-HashTable\"><a href=\"#d-HashTable\" class=\"headerlink\" title=\"d. HashTable\"></a>d. HashTable</h3><p>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>\n<h3 id=\"e-LinkedHashMap\"><a href=\"#e-LinkedHashMap\" class=\"headerlink\" title=\"e. LinkedHashMap\"></a>e. LinkedHashMap</h3><p><strong>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</strong></p>\n<p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。</p>\n<p><strong>可将LinkedHashMap看作采用linked list增强的HashMap。</strong></p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/LinkedHashMap_base.png\" alt=\"LinkedHashMap_base.png\" style=\"zoom:67%;\" />\n\n\n\n<p>​    事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，二者唯一的区别是<strong>LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。</strong>上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是<code>entry</code>的插入顺序。</p>\n<p>​    除了可以保迭代历顺序，这种结构还有一个好处 : <strong>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>\n<p>​    出于性能原因，<em>LinkedHashMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成(wrapped)同步的:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Map m = Collections.synchronizedMap(new LinkedHashMap(...));</span><br></pre></td></tr></table></figure>\n\n<p>与HashMap不同的是,对插入和删除操作来说:</p>\n<ol>\n<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入(或删除)到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入(或删除)到冲突链表的头部。</li>\n<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入(或删除)到双向链表的尾部。</li>\n</ol>\n<p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// LinkedHashMap.addEntry()</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"title function_\">addEntry</span><span class=\"params\">(<span class=\"type\">int</span> hash, K key, V value, <span class=\"type\">int</span> bucketIndex)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((size &gt;= threshold) &amp;&amp; (<span class=\"literal\">null</span> != table[bucketIndex])) &#123;</span><br><span class=\"line\">        resize(<span class=\"number\">2</span> * table.length);<span class=\"comment\">// 自动扩容，并重新哈希</span></span><br><span class=\"line\">        hash = (<span class=\"literal\">null</span> != key) ? hash(key) : <span class=\"number\">0</span>;</span><br><span class=\"line\">        bucketIndex = hash &amp; (table.length-<span class=\"number\">1</span>);<span class=\"comment\">// hash%table.length</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 1.在冲突链表头部插入新的entry</span></span><br><span class=\"line\">    HashMap.Entry&lt;K,V&gt; old = table[bucketIndex];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = <span class=\"keyword\">new</span> <span class=\"title class_\">Entry</span>&lt;&gt;(hash, key, value, old);</span><br><span class=\"line\">    table[bucketIndex] = e;</span><br><span class=\"line\">    <span class=\"comment\">// 2.在双向链表的尾部插入新的entry</span></span><br><span class=\"line\">    e.addBefore(header);</span><br><span class=\"line\">    size++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"I-x2F-O\"><a href=\"#I-x2F-O\" class=\"headerlink\" title=\"I&#x2F;O\"></a>I&#x2F;O</h1><h2 id=\"a-本地IO\"><a href=\"#a-本地IO\" class=\"headerlink\" title=\"a. 本地IO\"></a>a. 本地IO</h2><h3 id=\"1-IO理解分类-从传输方式上\"><a href=\"#1-IO理解分类-从传输方式上\" class=\"headerlink\" title=\"1. IO理解分类 - 从传输方式上\"></a>1. IO理解分类 - 从传输方式上</h3><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p>\n<ul>\n<li>字节流</li>\n<li>字符流</li>\n</ul>\n<p><code>字节</code>是个计算机看的，<code>字符</code>才是给人看的</p>\n<h3 id=\"2-字节流和字符流的区别\"><a href=\"#2-字节流和字符流的区别\" class=\"headerlink\" title=\"2. 字节流和字符流的区别\"></a>2. 字节流和字符流的区别</h3><ul>\n<li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)</li>\n<li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li>\n</ul>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/image-20220311172058164.png\" alt=\"image-20220311172058164\" style=\"zoom:50%;\" />\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  流的体系结构</span></span><br><span class=\"line\"><span class=\"comment\"> *  抽象基类             节点流                缓存流</span></span><br><span class=\"line\"><span class=\"comment\"> *  InputStream         FileInputStream     BufferedInputStream</span></span><br><span class=\"line\"><span class=\"comment\"> *  OutputStream        FileOutputStream    BufferedOutputSteam</span></span><br><span class=\"line\"><span class=\"comment\"> *  Reader              FileReader          BufferedReader</span></span><br><span class=\"line\"><span class=\"comment\"> *  Writer              FileWriter          BufferedWriter</span></span><br><span class=\"line\"><span class=\"comment\"> * */</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-FileReader\"><a href=\"#3-FileReader\" class=\"headerlink\" title=\"3. FileReader\"></a>3. FileReader</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 测试 FileReader</span></span><br><span class=\"line\"><span class=\"comment\">// 为了保证资源一定可以被关闭,使用try-catch-finally来关闭资源</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFileReader</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">FileReader</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 实例化File类对象</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview\\\\hello.txt&quot;</span>); <span class=\"comment\">// 路径相较于当前工程</span></span><br><span class=\"line\">        <span class=\"comment\">// 2. 提供具体的流</span></span><br><span class=\"line\">        fr = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file);</span><br><span class=\"line\">        <span class=\"comment\">// 3. 数据的读入过程</span></span><br><span class=\"line\">        <span class=\"comment\">// RETURN The character read, or -1 if the end of the stream has been reached</span></span><br><span class=\"line\">        <span class=\"comment\">// 返回一个读入的字符,如果到达文件末尾返回-1</span></span><br><span class=\"line\">        <span class=\"type\">int</span> data;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((data = fr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.print((<span class=\"type\">char</span>) data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 4. 关闭流操作</span></span><br><span class=\"line\">            <span class=\"comment\">// JVM 虽然有垃圾回收机制,但对于物理连接无能为力,比如: 数据库连接、输入输出流、Socket</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fr != <span class=\"literal\">null</span>) fr.close();</span><br><span class=\"line\">            <span class=\"comment\">// 因为 fr可能在前面由于打开失败而为null,不能直接close</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">testFileReader1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">FileReader</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//hello.txt&quot;</span>);</span><br><span class=\"line\">        fr = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(file);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] cBuf = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        <span class=\"comment\">// RETURN   The number of characters read,</span></span><br><span class=\"line\">        <span class=\"comment\">//          or -1 if the end of the stream has been reached</span></span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = fr.read(cBuf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//错误写法1</span></span><br><span class=\"line\">            <span class=\"comment\">//System.out.println(Arrays.toString(cBuf));//</span></span><br><span class=\"line\">            <span class=\"comment\">//错误写法2</span></span><br><span class=\"line\">            <span class=\"comment\">//for (int i = 0; i &lt; cBuf.length; i++) &#123;</span></span><br><span class=\"line\">            <span class=\"comment\">//   System.out.print(cBuf[i]);</span></span><br><span class=\"line\">            <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">            <span class=\"comment\">// 正确1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">                System.out.print(cBuf[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 正确2</span></span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(cBuf, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">            System.out.print(s);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fr != <span class=\"literal\">null</span>) fr.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-FileWriter\"><a href=\"#4-FileWriter\" class=\"headerlink\" title=\"4. FileWriter\"></a>4. FileWriter</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t<span class=\"comment\">// 从内存中写出数据到磁盘的文件里。</span></span><br><span class=\"line\">\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     *  输出操作 对应File可以不存在,会自动创建,不会爆异常</span></span><br><span class=\"line\"><span class=\"comment\">     *          如果存在,可以根据第二个参数确定是否追加,默认不追加,进行覆盖</span></span><br><span class=\"line\"><span class=\"comment\">     *          FileWriter fw = new FileWriter(file,false/true);</span></span><br><span class=\"line\"><span class=\"comment\">     * */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">TestFileWriter</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">FileWriter</span> <span class=\"variable\">fw</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">file</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//helloWriter.txt&quot;</span>);</span><br><span class=\"line\">        System.out.println(file.getAbsolutePath());</span><br><span class=\"line\">        <span class=\"comment\">// file文件本身没有写出的能力,</span></span><br><span class=\"line\">        fw = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(file, <span class=\"literal\">false</span>);</span><br><span class=\"line\">        fw.write(<span class=\"string\">&quot;Fuck F4N!&quot;</span>);</span><br><span class=\"line\">        fw.write(<span class=\"string\">&quot;2022-3-11&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fw != <span class=\"literal\">null</span>) fw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-复制操作\"><a href=\"#5-复制操作\" class=\"headerlink\" title=\"5. 复制操作\"></a>5. 复制操作</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对文件的读写,做一个复制操作</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">TestFileReaderWriter</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">FileReader</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">FileWriter</span> <span class=\"variable\">fw</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">srcFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//hello.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">destFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//helloWriter.txt&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">        fr = <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(srcFile);</span><br><span class=\"line\">        fw = <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(destFile,<span class=\"literal\">true</span>);</span><br><span class=\"line\">        <span class=\"type\">char</span>[] cBuf = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = fr.read(cBuf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fw.write(cBuf, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fw != <span class=\"literal\">null</span>) fw.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fr != <span class=\"literal\">null</span>) fr.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"6-FileInputOutputStream处理图片\"><a href=\"#6-FileInputOutputStream处理图片\" class=\"headerlink\" title=\"6. FileInputOutputStream处理图片\"></a>6. FileInputOutputStream处理图片</h3><p>处理图片、视频等需要用字节流，字节流处理字符可能出现乱码问题，尤其是中文。但<strong>实际上，如果只进行复制操作，而在程序中不进行加工，就没什么影响。</strong></p>\n<p>文本文件：.txt .java .c .cpp …</p>\n<p>非文本文件: .jpg .mp3 .doc .ppt …</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">// 使用字节流处理图片</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">ImgTestFileInputOutputStream</span>   <span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">FileInputStream</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fw</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">srcFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//testimg.jpg&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">destFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//copyimg.jpg&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        fr = <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(srcFile);</span><br><span class=\"line\">        fw = <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(destFile);</span><br><span class=\"line\">        <span class=\"type\">byte</span>[] cBuf = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">5</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = fr.read(cBuf)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            fw.write(cBuf, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fw != <span class=\"literal\">null</span>) fw.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fr != <span class=\"literal\">null</span>) fr.close();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-缓冲流\"><a href=\"#7-缓冲流\" class=\"headerlink\" title=\"7. 缓冲流\"></a>7. 缓冲流</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedInputStream</span><br><span class=\"line\">BufferedOutputSteam</span><br><span class=\"line\">BufferedReader</span><br><span class=\"line\">BufferedWriter</span><br></pre></td></tr></table></figure>\n\n<p><strong>缓冲流使用要先套接到已有的”流”之上</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//testimg.jpg&quot;</span>)));</span><br></pre></td></tr></table></figure>\n\n<p>如果使用<code>BufferedReader</code>和<code>BufferedWriter</code>,可以使用String进行读取。</p>\n<p>开发会优先使用缓冲流， 因为<strong>缓冲流内部提供了缓冲区</strong> ，速度会快很多。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">TestBufferStream</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*非文本文件的复制*/</span></span><br><span class=\"line\">    <span class=\"type\">BufferedInputStream</span> <span class=\"variable\">bis</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"type\">BufferedOutputStream</span> <span class=\"variable\">bos</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 造文件</span></span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">srcFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//testimg.jpg&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">File</span> <span class=\"variable\">destFile</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//CopyIMG.jpg&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 造节点流</span></span><br><span class=\"line\">        <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(srcFile);</span><br><span class=\"line\">        <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(destFile);</span><br><span class=\"line\">        <span class=\"comment\">// 造缓冲流</span></span><br><span class=\"line\">        bis = <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedInputStream</span>(fis);</span><br><span class=\"line\">        bos = <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedOutputStream</span>(fos);</span><br><span class=\"line\">        <span class=\"comment\">// 简写</span></span><br><span class=\"line\">        <span class=\"comment\">// bis = new BufferedInputStream(new FileInputStream(new File(&quot;Interview//IO//testimg&quot; +</span></span><br><span class=\"line\">        <span class=\"comment\">//                    &quot;.jpg&quot;)));</span></span><br><span class=\"line\">        <span class=\"comment\">// bos = new BufferedOutputStream(new FileOutputStream(new File(&quot;Interview//IO//CopyIMG&quot; +</span></span><br><span class=\"line\">        <span class=\"comment\">//                    &quot;.jpg&quot;)));</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] buffer = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = bis.read(buffer)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            bos.write(buffer, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 资源关闭</span></span><br><span class=\"line\">        <span class=\"comment\">// 先关外层的流,再关内层的流</span></span><br><span class=\"line\">        bis.close();</span><br><span class=\"line\">        bos.close();</span><br><span class=\"line\">        <span class=\"comment\">// 其实,关闭外层流时,会自动关闭内层流,也就是说下面的内层的流可以省略</span></span><br><span class=\"line\">        <span class=\"comment\">// fis.close();</span></span><br><span class=\"line\">        <span class=\"comment\">// fos.close();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-统计一个文件中字符出现次数\"><a href=\"#8-统计一个文件中字符出现次数\" class=\"headerlink\" title=\"8. 统计一个文件中字符出现次数\"></a>8. 统计一个文件中字符出现次数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 统计 comment.txt中每个字符出现的次数</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">wordCount</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"type\">BufferedReader</span> <span class=\"variable\">br</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//comment.txt&quot;</span>)));</span><br><span class=\"line\">    <span class=\"type\">BufferedWriter</span> <span class=\"variable\">bw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//commentCount.txt&quot;</span>)));</span><br><span class=\"line\">    HashMap&lt;Character, Integer&gt; hashMap = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">    <span class=\"type\">int</span> ch;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((ch = br.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> (<span class=\"type\">char</span>) ch;</span><br><span class=\"line\">        hashMap.put(c, hashMap.getOrDefault(c, <span class=\"number\">0</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    br.close();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Map.Entry&lt;Character, Integer&gt; en : hashMap.entrySet()) &#123;</span><br><span class=\"line\">        <span class=\"type\">char</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> en.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (c)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27; &#x27;</span>:</span><br><span class=\"line\">                bw.write(<span class=\"string\">&quot;空格 = &quot;</span>+en.getValue());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\t&#x27;</span>:</span><br><span class=\"line\">                bw.write(<span class=\"string\">&quot;tab = &quot;</span>+en.getValue());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\r&#x27;</span>:</span><br><span class=\"line\">                bw.write(<span class=\"string\">&quot;回车 = &quot;</span>+en.getValue());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>:</span><br><span class=\"line\">                bw.write(<span class=\"string\">&quot;换行 = &quot;</span>+en.getValue());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                bw.write(c+<span class=\"string\">&quot; = &quot;</span>+en.getValue());</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        bw.newLine();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bw.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-转换流\"><a href=\"#9-转换流\" class=\"headerlink\" title=\"9. 转换流\"></a>9. 转换流</h3><p><strong>转换流提供了 字节流 到 字符流 的转换。</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/*</span><br><span class=\"line\"> *  转换流:</span><br><span class=\"line\"> *  InputStreamReader ： 将一个字节的输入流 转换为 字符 的输入流</span><br><span class=\"line\"> *  OutputStreamWriter ：将一个字符的输出流 转换为 字节 的输出流</span><br><span class=\"line\"> *  实现了 字节流 到 字符流之间的转换。</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  从 字节 --&gt; 字符 是一种解码</span><br><span class=\"line\"> *  从 字符 --&gt; 字节 是一种编码</span><br><span class=\"line\"> *</span><br><span class=\"line\"> *  这个过程存在字符集的设置问题</span><br><span class=\"line\"> * */</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 实现字节流到输入流的转换 */</span></span><br><span class=\"line\">    <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;Interview//IO//comment.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;Interview//IO//commentGBK.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 参数二指明字符集,根据读取的文件字符集来确定</span></span><br><span class=\"line\">    <span class=\"type\">InputStreamReader</span> <span class=\"variable\">isr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(fis, <span class=\"string\">&quot;UTF-8&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">OutputStreamWriter</span> <span class=\"variable\">osw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OutputStreamWriter</span>(fos, <span class=\"string\">&quot;GBK&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">char</span>[] cbuf = <span class=\"keyword\">new</span> <span class=\"title class_\">char</span>[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> len;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((len = isr.read(cbuf)) !   = -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(cbuf, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">        System.out.print(s);</span><br><span class=\"line\">        osw.write(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    isr.close();</span><br><span class=\"line\">    osw.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-标准的输入输出流\"><a href=\"#10-标准的输入输出流\" class=\"headerlink\" title=\"10. 标准的输入输出流\"></a>10. 标准的输入输出流</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> *  标准的输入流</span></span><br><span class=\"line\"><span class=\"comment\"> *  System.in: 标准的输入流,默认从键盘输入</span></span><br><span class=\"line\"><span class=\"comment\"> *  System.out: 标准的输出流,默认从控制台输出</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> *  System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入输出的流</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 实现一个输入转为大写的程序</span></span><br><span class=\"line\"><span class=\"comment\">// 1. 用Scanner实现</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 用System.in实现</span></span><br><span class=\"line\"><span class=\"comment\">//    System.in --&gt; 转换流 --&gt; BufferedReader 的 readLine()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">InputStreamReader</span> <span class=\"variable\">isr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InputStreamReader</span>(System.in);</span><br><span class=\"line\"><span class=\"type\">BufferedReader</span> <span class=\"variable\">br</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">BufferedReader</span>(isr);</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> br.readLine();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"string\">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class=\"string\">&quot;exit&quot;</span>.equalsIgnoreCase(s) )&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;EXIT.&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.println(s.toUpperCase());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">br.close();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"11-打印流\"><a href=\"#11-打印流\" class=\"headerlink\" title=\"11. 打印流\"></a>11. 打印流</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打印流</span></span><br><span class=\"line\"><span class=\"comment\">// PrintStream PrintWriter</span></span><br><span class=\"line\"><span class=\"comment\">// 它们提供了一系列的 print println方法</span></span><br><span class=\"line\"><span class=\"comment\">// 可以使用System.setOut()设置答应的目标,默认为显示器</span></span><br><span class=\"line\"><span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">File</span>(<span class=\"string\">&quot;Interview//IO//hello.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">PrintStream</span> <span class=\"variable\">stream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PrintStream</span>(fos);</span><br><span class=\"line\"><span class=\"comment\">// 把输入目的地改为文件,而不是显示器</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (stream != <span class=\"literal\">null</span>) System.setOut(stream);</span><br><span class=\"line\">System.out.println();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"12-数据流\"><a href=\"#12-数据流\" class=\"headerlink\" title=\"12. 数据流\"></a>12. 数据流</h3><p>主要是为了 <strong>为了方便操作Java语言中的基本类型和 String</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//        DataInputStream 套接到 InputStream</span></span><br><span class=\"line\"><span class=\"comment\">//        DataOutputStream 套接到 OutputStream</span></span><br><span class=\"line\"><span class=\"type\">DataOutputStream</span> <span class=\"variable\">dos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;Interview//IO//hello.txt&quot;</span>));</span><br><span class=\"line\">dos.writeUTF(<span class=\"string\">&quot;中国&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 刷新操作 flush-冲洗</span></span><br><span class=\"line\">dos.flush();</span><br><span class=\"line\">dos.writeInt(<span class=\"number\">23</span>);</span><br><span class=\"line\">dos.flush();</span><br><span class=\"line\">dos.writeBoolean(<span class=\"literal\">true</span>);</span><br><span class=\"line\">dos.close();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">DataInputStream</span> <span class=\"variable\">dis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DataInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;Interview//IO//hello.txt&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">country</span> <span class=\"operator\">=</span> dis.readUTF();</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">age</span> <span class=\"operator\">=</span> dis.readInt();</span><br><span class=\"line\"><span class=\"type\">boolean</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> dis.readBoolean();</span><br><span class=\"line\">System.out.println(country+<span class=\"string\">&quot; &quot;</span>+age+<span class=\"string\">&quot; &quot;</span>+b);</span><br><span class=\"line\">dis.close();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"13-对象流\"><a href=\"#13-对象流\" class=\"headerlink\" title=\"13. 对象流:\"></a>13. 对象流:</h3><p><code>ObjectInputStream</code>和<code>ObjectOutputStream</code></p>\n<ul>\n<li>用以存储和读取 对象类型 和 基本类型 的处理流</li>\n<li>通过 <code>序列化</code> 与 <code>反序列化</code> 来进行对对象数据的 保存、传输、读取。</li>\n<li><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 static和transient 修饰的成员变量</li>\n<li>对象序列化 : 将内存中的Java对象转换为平台无关的二进制流 这样就可以将对象进行与平台无关的 传输和保存</li>\n<li>实现了Serializable接口的对象 可以转化为 字节数据</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Object 类型的写入</span></span><br><span class=\"line\"><span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">oos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;Interview//IO//Object.dat&quot;</span>));</span><br><span class=\"line\">oos.writeObject(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;我爱北京&quot;</span>));</span><br><span class=\"line\">oos.flush();</span><br><span class=\"line\">oos.close();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object 读入</span></span><br><span class=\"line\"><span class=\"type\">ObjectInputStream</span> <span class=\"variable\">ois</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(<span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;Interview//IO//Object.dat&quot;</span>));</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span>(String) ois.readObject();</span><br><span class=\"line\">System.out.println(str);</span><br><span class=\"line\">ois.close();</span><br></pre></td></tr></table></figure>\n\n<p>自定义对象实现 <code>Serializable接口</code> 来进行序列化和反序列化,需要提供一个<code>serialVersionUID</code>来进行一个标识,确保可以还原和区分。与此同时，<strong>必须保证自定义的类的属性字段也都可以序列化</strong>，基础类型默认可以序列化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 序列版本号</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">long</span> <span class=\"variable\">serialVersionUID</span> <span class=\"operator\">=</span> <span class=\"number\">46516164984L</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Person&#123;&quot;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;name=&#x27;&quot;</span> + name + <span class=\"string\">&#x27;\\&#x27;&#x27;</span> +</span><br><span class=\"line\">            <span class=\"string\">&quot;, age=&quot;</span> + age +</span><br><span class=\"line\">            <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Person</span><span class=\"params\">(String name, <span class=\"type\">int</span> age)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>serialVersionUID</code>使用来表示类的不同版本间的兼容性，如果没有显示定义，JVM会自动生成一个，但这样可能会在修改类时产生问题，导致序列化失败。  </p>\n<h3 id=\"14-随机存取文件流\"><a href=\"#14-随机存取文件流\" class=\"headerlink\" title=\"14. 随机存取文件流\"></a>14. 随机存取文件流</h3><p><code>RandomAccessFile</code> 直接继承 Object , 随机存取文件流的特殊指出在于 <strong>既可以作为输入流,也可以作为输出流</strong>。</p>\n<p>如果文件已经存在,写时会从头进行覆盖。</p>\n<ul>\n<li>可以使用<code>seek()</code>函数进行指针的移动。</li>\n<li>要实现插入需要先将后面的数据向后移动再插入。</li>\n</ul>\n<p>如果文件不存在，则会自动创建。</p>\n<h3 id=\"基本知识点汇总\"><a href=\"#基本知识点汇总\" class=\"headerlink\" title=\"基本知识点汇总\"></a>基本知识点汇总</h3><ol>\n<li><p>流的三种分类方式</p>\n<ul>\n<li>流向: 输入流、输出流</li>\n<li>数据单位：字节流、字符流</li>\n<li>流的角色：节点流、处理流</li>\n</ul>\n</li>\n<li><p>写出4个IO流中的抽象基类,4个文件流,4个缓冲流</p>\n<p>抽象基类:</p>\n<ul>\n<li>InputStream</li>\n<li>OutputStream</li>\n<li>Reader</li>\n<li>Writer</li>\n</ul>\n<p>文件流:</p>\n<ul>\n<li>FileReader</li>\n<li>FileWriter</li>\n<li>FileInputStream</li>\n<li>FileOutputStream</li>\n</ul>\n<p>缓冲流:</p>\n<ul>\n<li>BufferedReader</li>\n<li>BufferedWriter</li>\n<li>BufferedInputStream</li>\n<li>BufferedOutputStream</li>\n</ul>\n<p>转换流:<code>InputSteamReader</code> <code>OutputStreamWriter</code></p>\n</li>\n<li><p>字符流和字节流分别的使用情景</p>\n<p>字节流: 主要用来处理非文本文件</p>\n<p>字符流: 主要用来处理文本文件</p>\n</li>\n</ol>\n<h2 id=\"b-BIO-NIO-AIO-异同\"><a href=\"#b-BIO-NIO-AIO-异同\" class=\"headerlink\" title=\"b. BIO NIO AIO 异同\"></a>b. BIO NIO AIO 异同</h2><p>BIO: <code>同步阻塞型</code>。 服务器为客户端一个连接一个线程，数据未准备好时阻塞。</p>\n<ul>\n<li>适用于连接数目少，并固定的架构，这种方式对服务器资源要求比较高，低并发的情况下。JDK1.4之前的唯一选择</li>\n</ul>\n<p>NIO: <code>同步非阻塞型</code>。由一个中央选择器进行IO请求的接收，并<code>轮询访问</code>是否有已经准备好的IO请求，有就会去处理。</p>\n<ul>\n<li>适用于连接数目较多，但单个连接比较短的情况，比如聊天服务器、弹幕系统、服务器通讯等.JDK1.4开始支持</li>\n</ul>\n<p>AIO: <code>异步非阻塞</code>。客户端IO请求先由操作系统(OS)进行处理,数据处理好后<code>通知服务器</code>处理程序来进行处理。</p>\n<ul>\n<li>适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持</li>\n</ul>\n<p>在文中我们一再说明JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO，这个从JAVA AIO框架的部分类设计上就可以看出来。</p>\n<table>\n<thead>\n<tr>\n<th>BIO</th>\n<th>NIO</th>\n<th>AIO</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Socket</code></td>\n<td><code>SocketChannel</code></td>\n<td><code>AsynchronousSocketChannel</code></td>\n</tr>\n<tr>\n<td><code>ServerSocket</code></td>\n<td><code>ServerSocketChannel</code></td>\n<td><code>AsynchornousServerSocketChannel</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"c-Unix-IO-类型\"><a href=\"#c-Unix-IO-类型\" class=\"headerlink\" title=\"c. Unix IO 类型\"></a>c. Unix IO 类型</h2><p>一个输入操作通常包括两个阶段:</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>​    对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 下有五种 I&#x2F;O 模型:</p>\n<ul>\n<li>阻塞式 I&#x2F;O</li>\n<li>非阻塞式 I&#x2F;O</li>\n<li>I&#x2F;O 复用(select 和 poll)</li>\n<li>信号驱动式 I&#x2F;O(SIGIO)</li>\n<li>异步 I&#x2F;O(AIO)</li>\n</ul>\n<h3 id=\"1-阻塞式IO\"><a href=\"#1-阻塞式IO\" class=\"headerlink\" title=\"1. 阻塞式IO\"></a>1. 阻塞式IO</h3><p><strong>应用进程被阻塞</strong>，直到数据复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此<strong>阻塞不意味着整个操作系统都被阻塞</strong>。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的<strong>执行效率会比较高。</strong></p>\n<h3 id=\"2-非阻塞式-I-x2F-O\"><a href=\"#2-非阻塞式-I-x2F-O\" class=\"headerlink\" title=\"2. 非阻塞式 I&#x2F;O\"></a>2. 非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是<strong>需要不断的执行系统调用来获知 I&#x2F;O 是否完成</strong>，这种方式称为<code>轮询(polling)</code>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型是比较<strong>低效</strong>的。</p>\n<h3 id=\"3-I-x2F-O-复用\"><a href=\"#3-I-x2F-O-复用\" class=\"headerlink\" title=\"3. I&#x2F;O 复用\"></a>3. I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p>\n<p>它可以让<strong>单个进程具有处理多个 I&#x2F;O 事件的能力</strong>。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<h3 id=\"4-信号驱动-I-x2F-O\"><a href=\"#4-信号驱动-I-x2F-O\" class=\"headerlink\" title=\"4. 信号驱动 I&#x2F;O\"></a>4. 信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说<strong>等待数据阶段应用进程是非阻塞的</strong>。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p><strong>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高</strong>。</p>\n<h3 id=\"5-异步-I-x2F-O\"><a href=\"#5-异步-I-x2F-O\" class=\"headerlink\" title=\"5. 异步 I&#x2F;O\"></a>5. 异步 I&#x2F;O</h3><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>\n<h2 id=\"e-BIO\"><a href=\"#e-BIO\" class=\"headerlink\" title=\"e. BIO\"></a>e. BIO</h2><p>BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，<strong>应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；</strong>另一方面，<strong>操作系统收到请求后，也会等待数据完成</strong>，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。</p>\n<ul>\n<li><code>阻塞IO</code> 和 <code>非阻塞IO</code></li>\n</ul>\n<p>​    这两个概念是<code>程序级别</code>的。主要描述的是<strong>程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题</strong>: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>\n<ul>\n<li><code>同步IO</code> 和 <code>非同步IO</code></li>\n</ul>\n<p>​    这两个概念是<code>操作系统级别</code>的。主要描述的是<strong>操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题</strong>: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>\n<h3 id=\"1-传统BIO\"><a href=\"#1-传统BIO\" class=\"headerlink\" title=\"1. 传统BIO\"></a>1. 传统BIO</h3><p>以前大多数网络通信方式都是阻塞模式的，即:</p>\n<ul>\n<li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li>\n<li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li>\n</ul>\n<h3 id=\"2-传统的BIO的问题\"><a href=\"#2-传统的BIO的问题\" class=\"headerlink\" title=\"2. 传统的BIO的问题\"></a>2. 传统的BIO的问题</h3><ul>\n<li>同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。</li>\n<li>由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。</li>\n</ul>\n<h3 id=\"3-多线程方式-伪异步方式\"><a href=\"#3-多线程方式-伪异步方式\" class=\"headerlink\" title=\"3. 多线程方式 - 伪异步方式\"></a>3. 多线程方式 - 伪异步方式</h3><p>上面说的情况是服务器只有一个线程的情况，那么读者会直接提出我们可以使用多线程技术来解决这个问题:</p>\n<ul>\n<li>当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</li>\n<li>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式&#x2F;观察模式(等其他设计模式)通知主线程。</li>\n</ul>\n<p>但是使用线程来解决这个问题实际上是有<strong>局限性</strong>的:</p>\n<ul>\n<li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，<strong>实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来</strong>(下文的示例代码和debug过程我们可以明确看到这一点)</li>\n<li><strong>在linux系统中，可以创建的线程是有限的。</strong>我们可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</li>\n<li>创建一个线程是有较大的资源消耗的。</li>\n<li>如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。</li>\n</ul>\n<p><strong>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。</strong></p>\n<p>即: 异步IO模式 就是为了解决这样的并发性存在的。</p>\n<h2 id=\"f-NIO\"><a href=\"#f-NIO\" class=\"headerlink\" title=\"f. NIO\"></a>f. NIO</h2><p>通俗理解: NIO 是可以做到用一个线程来处理多个请求的操作。假如有1000个请求，可以根据实际情况，分配20~80个线程来进行处理，不需要像阻塞式IO非要分配1000个线程。</p>\n<img src=\"/post/Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/image-20220315154500329.png\" class=\"\" title=\"image-20220315154500329\">\n\n<p>新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，<strong>提供了高速的、面向块的 I&#x2F;O。</strong></p>\n<p>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>\n<ul>\n<li><p>面向流的 I&#x2F;O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</p>\n</li>\n<li><p>面向块的 I&#x2F;O <strong>一次处理一个数据块</strong>，按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</p>\n</li>\n</ul>\n<p>I&#x2F;O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>\n<p>NIO 与普通 I&#x2F;O 的区别主要有以下两点:</p>\n<ul>\n<li><strong>NIO 是非阻塞的</strong></li>\n<li><strong>NIO 面向块，I&#x2F;O 面向流</strong></li>\n</ul>\n<h3 id=\"1-通道与缓冲区\"><a href=\"#1-通道与缓冲区\" class=\"headerlink\" title=\"1. 通道与缓冲区\"></a>1. 通道与缓冲区</h3><p>通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。</p>\n<p>通道与流的不同之处在于，<strong>流只能在一个方向上移动</strong>(一个流必须是 InputStream 或者 OutputStream 的子类)，而<strong>通道是双向的，可以用于读、写或者同时用于读写。</strong></p>\n<p>通道包括以下类型:</p>\n<ul>\n<li><strong>FileChannel: 从文件中读写数据；</strong></li>\n<li>DatagramChannel: 通过 UDP 读写网络中数据；</li>\n<li>SocketChannel: 通过 TCP 读写网络中数据；</li>\n<li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>\n</ul>\n<hr>\n<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>\n<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>\n<p>缓冲区包括以下类型:</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<hr>\n<p>使用 NIO 快速复制文件的实例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">FILE_PATH</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;Interview//NIO//&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    <span class=\"comment\">/*输入字节流*/</span></span><br><span class=\"line\">    <span class=\"type\">FileInputStream</span> <span class=\"variable\">fin</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(FILE_PATH + <span class=\"string\">&quot;hello.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*输入通道*/</span></span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">fcin</span> <span class=\"operator\">=</span> fin.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">/*输出管道*/</span></span><br><span class=\"line\">    <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fout</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(FILE_PATH + <span class=\"string\">&quot;out.txt&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*输出字节流*/</span></span><br><span class=\"line\">    <span class=\"type\">FileChannel</span> <span class=\"variable\">fcout</span> <span class=\"operator\">=</span> fout.getChannel();</span><br><span class=\"line\">    <span class=\"comment\">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class=\"line\">    <span class=\"type\">ByteBuffer</span> <span class=\"variable\">buffer</span> <span class=\"operator\">=</span> ByteBuffer.allocateDirect(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">read</span> <span class=\"operator\">=</span> fcin.read(buffer);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (read ** -<span class=\"number\">1</span>) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"comment\">/*切换读写*/</span></span><br><span class=\"line\">        buffer.flip();</span><br><span class=\"line\">        <span class=\"comment\">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class=\"line\">        fcout.write(buffer);</span><br><span class=\"line\">        <span class=\"comment\">/* 清空缓冲区 */</span></span><br><span class=\"line\">        buffer.clear();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    fcout.close();</span><br><span class=\"line\">    fcin.close();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"2-Selector-选择器\"><a href=\"#2-Selector-选择器\" class=\"headerlink\" title=\"2. Selector(选择器)\"></a>2. Selector(选择器)</h3><p>有Selector选择器来在收到访问后,轮询的查找是否已经有准备好的IO请求可以进行返回处理,如果有,则去单独阻塞的处理请求。</p>\n<h3 id=\"3-NIO-IO多路复用详解\"><a href=\"#3-NIO-IO多路复用详解\" class=\"headerlink\" title=\"3. NIO - IO多路复用详解\"></a>3. NIO - IO多路复用详解</h3><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p>\n<table>\n<thead>\n<tr>\n<th>IO模型</th>\n<th align=\"left\">相对性能</th>\n<th>关键思路</th>\n<th>操作系统</th>\n<th>JAVA支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select</td>\n<td align=\"left\">较高</td>\n<td>Reactor</td>\n<td>windows&#x2F;Linux</td>\n<td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td>\n</tr>\n<tr>\n<td>poll</td>\n<td align=\"left\">较高</td>\n<td>Reactor</td>\n<td>Linux</td>\n<td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td>\n</tr>\n<tr>\n<td>epoll</td>\n<td align=\"left\">高</td>\n<td>Reactor&#x2F;Proactor</td>\n<td>Linux</td>\n<td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td>\n</tr>\n<tr>\n<td>kqueue</td>\n<td align=\"left\">高</td>\n<td>Proactor</td>\n<td>Linux</td>\n<td>目前JAVA的版本不支持</td>\n</tr>\n</tbody></table>\n<p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p>\n<h2 id=\"g-AIO\"><a href=\"#g-AIO\" class=\"headerlink\" title=\"g. AIO\"></a>g. AIO</h2><p><code>异步非阻塞</code>。客户端IO请求先由操作系统(OS)进行处理,数据处理好后<code>通知服务器</code>处理程序来进行处理。</p>\n<p>当进行读写操作时，只需要直接调用API的read和write方法即可，这两种方法均是异步的。</p>\n<ul>\n<li>适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持</li>\n</ul>\n","text":"集合类容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。 Collectiona. SetSet:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 用于存储...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Collection\"><span class=\"toc-text\">Collection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-Set\"><span class=\"toc-text\">a. Set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-HashSet\"><span class=\"toc-text\">1. HashSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-TreeSet\"><span class=\"toc-text\">2. TreeSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-LinkedHashSet\"><span class=\"toc-text\">3. LinkedHashSet</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-List\"><span class=\"toc-text\">b. List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ArrayList\"><span class=\"toc-text\">1. ArrayList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">自动扩容机制</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-LinkedList\"><span class=\"toc-text\">2. LinkedList</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Vector\"><span class=\"toc-text\">3. Vector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Stack-%E5%92%8C-Queue\"><span class=\"toc-text\">4. Stack 和 Queue</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Deque\"><span class=\"toc-text\">5. Deque</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Queue\"><span class=\"toc-text\">c. Queue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PriorityQueue\"><span class=\"toc-text\">PriorityQueue</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-HashMap-JDK7\"><span class=\"toc-text\">a. HashMap-JDK7</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-HashMap-JDK8\"><span class=\"toc-text\">b. HashMap-JDK8+</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-TreeMap\"><span class=\"toc-text\">c. TreeMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-HashTable\"><span class=\"toc-text\">d. HashTable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-LinkedHashMap\"><span class=\"toc-text\">e. LinkedHashMap</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#I-x2F-O\"><span class=\"toc-text\">I&#x2F;O</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E6%9C%AC%E5%9C%B0IO\"><span class=\"toc-text\">a. 本地IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-IO%E7%90%86%E8%A7%A3%E5%88%86%E7%B1%BB-%E4%BB%8E%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E4%B8%8A\"><span class=\"toc-text\">1. IO理解分类 - 从传输方式上</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. 字节流和字符流的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-FileReader\"><span class=\"toc-text\">3. FileReader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-FileWriter\"><span class=\"toc-text\">4. FileWriter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5. 复制操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-FileInputOutputStream%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">6. FileInputOutputStream处理图片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">7. 缓冲流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">8. 统计一个文件中字符出现次数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">9. 转换流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E6%A0%87%E5%87%86%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">10. 标准的输入输出流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E6%89%93%E5%8D%B0%E6%B5%81\"><span class=\"toc-text\">11. 打印流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">12. 数据流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E5%AF%B9%E8%B1%A1%E6%B5%81\"><span class=\"toc-text\">13. 对象流:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81\"><span class=\"toc-text\">14. 随机存取文件流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">基本知识点汇总</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-BIO-NIO-AIO-%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">b. BIO NIO AIO 异同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-Unix-IO-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">c. Unix IO 类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%98%BB%E5%A1%9E%E5%BC%8FIO\"><span class=\"toc-text\">1. 阻塞式IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-I-x2F-O\"><span class=\"toc-text\">2. 非阻塞式 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-I-x2F-O-%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">3. I&#x2F;O 复用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-I-x2F-O\"><span class=\"toc-text\">4. 信号驱动 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%BC%82%E6%AD%A5-I-x2F-O\"><span class=\"toc-text\">5. 异步 I&#x2F;O</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#e-BIO\"><span class=\"toc-text\">e. BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E7%BB%9FBIO\"><span class=\"toc-text\">1. 传统BIO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E7%BB%9F%E7%9A%84BIO%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2. 传统的BIO的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F-%E4%BC%AA%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. 多线程方式 - 伪异步方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#f-NIO\"><span class=\"toc-text\">f. NIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%80%9A%E9%81%93%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">1. 通道与缓冲区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Selector-%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">2. Selector(选择器)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-NIO-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">3. NIO - IO多路复用详解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#g-AIO\"><span class=\"toc-text\">g. AIO</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Linux基础","uid":"144f0b4d9b9f80ea377106e9c6a54a45","slug":"Linux基础","date":"2022-04-08T03:19:19.000Z","updated":"2022-04-08T03:25:19.742Z","comments":true,"path":"api/articles/Linux基础.json","keywords":null,"cover":[],"text":" Linux简介​ Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到 Minix 和 Unix 思想的启发，是一个基于 POSIX 的多用户、多任务、支持...","link":"","photos":[],"count_time":{"symbolsCount":"41k","symbolsTime":"37 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"},{"name":"Linux命令","slug":"Linux命令","count":1,"path":"api/tags/Linux命令.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"Git基础","uid":"7972c32d39f314ccb6f804289f8a291c","slug":"Git基础","date":"2022-04-07T13:36:21.000Z","updated":"2022-04-07T13:43:22.527Z","comments":true,"path":"api/articles/Git基础.json","keywords":null,"cover":[],"text":"分布式版本控制系统 简单理论四个工作区域： 工作目录 暂存区（Index\\Stage） 仓库区（Repository） 远程仓库（Remote） 基本配置$ git config -l 查看基础配置 本地存放位置 Git\\etc\\gitconfig中 12345678910111...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}