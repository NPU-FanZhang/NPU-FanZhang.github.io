{"title":"Java IO/集合类","uid":"21192bc96d4d1e6c92e0c329a20feea9","slug":"Java-IO-集合类","date":"2022-04-08T02:22:24.000Z","updated":"2022-04-08T02:26:43.455Z","comments":true,"path":"api/articles/Java-IO-集合类.json","keywords":null,"cover":[],"content":"<h1 id=\"集合类\"><a href=\"#集合类\" class=\"headerlink\" title=\"集合类\"></a>集合类</h1><blockquote><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。</p></blockquote>\n<h2 id=\"Collection\"><a href=\"#Collection\" class=\"headerlink\" title=\"Collection\"></a>Collection</h2><h3 id=\"a-Set\"><a href=\"#a-Set\" class=\"headerlink\" title=\"a. Set\"></a>a. Set</h3><p>Set:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素</p>\n<p>用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。</p>\n<h4 id=\"1-HashSet\"><a href=\"#1-HashSet\" class=\"headerlink\" title=\"1. HashSet\"></a>1. HashSet</h4><p>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>\n<p>HashSet是通过对HashMap进行了一层包装而实现的,也就是说<em>HashSet</em>里面有一个<em>HashMap</em>(适配器模式)。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;HashSet是对HashMap的简单包装\npublic class HashSet&lt;E&gt;\n&#123;\n\t......\n\tprivate transient HashMap&lt;E,Object&gt; map;&#x2F;&#x2F;HashSet里面有一个HashMap\n    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT &#x3D; new Object();\n    public HashSet() &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n    &#125;\n    ......\n    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换\n        return map.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;</code></pre>\n\n\n\n<h4 id=\"2-TreeSet\"><a href=\"#2-TreeSet\" class=\"headerlink\" title=\"2. TreeSet\"></a>2. TreeSet</h4><p>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>\n<p><em>TreeSet</em>和<em>TreeMap</em>二者在Java里有着相同的实现，<strong>TreeSet仅仅是对TreeMap做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; TreeSet是对TreeMap的简单包装\npublic class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;\n    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable\n&#123;\n\t......\n    private transient NavigableMap&lt;E,Object&gt; m;\n    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT &#x3D; new Object();\n    public TreeSet() &#123;\n        this.m &#x3D; new TreeMap&lt;E,Object&gt;();&#x2F;&#x2F; TreeSet里面有一个TreeMap\n    &#125;\n    ......\n    public boolean add(E e) &#123;\n        return m.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;\n</code></pre>\n\n\n\n\n\n<h4 id=\"3-LinkedHashSet\"><a href=\"#3-LinkedHashSet\" class=\"headerlink\" title=\"3. LinkedHashSet\"></a>3. LinkedHashSet</h4><p>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p>\n<p><em>LinkedHashSet</em>是对<em>LinkedHashMap</em>的简单包装，对<em>LinkedHashSet</em>的函数调用都会转换成合适的<em>LinkedHashMap</em>方法，因此<em>LinkedHashSet</em>的实现非常简单，这里不再赘述。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedHashSet&lt;E&gt;\n    extends HashSet&lt;E&gt;\n    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;\n    ......\n    &#x2F;&#x2F; LinkedHashSet里面有一个LinkedHashMap\n    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;\n        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);\n    &#125;\n\t......\n    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换\n        return map.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;</code></pre>\n\n\n\n\n\n<hr>\n<h3 id=\"b-List\"><a href=\"#b-List\" class=\"headerlink\" title=\"b. List\"></a>b. List</h3><p>List 是一个接口，它继承于<code>Collection</code>的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。</p>\n<h4 id=\"1-ArrayList\"><a href=\"#1-ArrayList\" class=\"headerlink\" title=\"1. ArrayList\"></a>1. ArrayList</h4><p>基于动态数组实现，支持随机访问。</p>\n<p>ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<code>数组实现</code>。</p>\n<p>每个<em>ArrayList</em>都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。</p>\n<p>前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的<code>数组是一个Object数组</code>，以便能够容纳任何类型的对象。</p>\n<p><code>add(int index, E e)</code> 需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。</p>\n<p><code>trimToSize()</code> 将底层数组的容量调整为当前列表保存的实际元素的大小的功能。</p>\n<h5 id=\"自动扩容机制\"><a href=\"#自动扩容机制\" class=\"headerlink\" title=\"自动扩容机制\"></a>自动扩容机制</h5><p>数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用<code>ensureCapacity</code>来手动增加ArrayList实例的容量，以减少递增式再分配的数量。</p>\n<p><strong>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。</strong>这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。</p>\n<p>扩容操作最终是通过<code>grow()</code>方法完成的,其核心代码如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n* Increases the capacity to ensure that it can hold at least the\n* number of elements specified by the minimum capacity argument.\n*\n* @param minCapacity the desired minimum capacity\n*&#x2F;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F; overflow-conscious code\n    int oldCapacity &#x3D; elementData.length;\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n    MAX_ARRAY_SIZE;\n&#125;</code></pre>\n\n\n\n\n\n<h4 id=\"2-LinkedList\"><a href=\"#2-LinkedList\" class=\"headerlink\" title=\"2. LinkedList\"></a>2. LinkedList</h4><p>基于<code>双向链表</code>实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。</p>\n<p>不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>\n<pre class=\"line-numbers language-JAVA\" data-language=\"JAVA\"><code class=\"language-JAVA\">private static class Node&lt;E&gt; &#123;\n    E item;\n    Node&lt;E&gt; next;\n    Node&lt;E&gt; prev;\n\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item &#x3D; element;\n        this.next &#x3D; next;\n        this.prev &#x3D; prev;\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"3-Vector\"><a href=\"#3-Vector\" class=\"headerlink\" title=\"3. Vector\"></a>3. Vector</h4><p>和 ArrayList 类似，但它是线程安全的。</p>\n<h4 id=\"4-Stack-和-Queue\"><a href=\"#4-Stack-和-Queue\" class=\"headerlink\" title=\"4. Stack 和 Queue\"></a>4. Stack 和 Queue</h4><p>Java里有一个叫做<em>Stack</em>的类，却没有叫做<em>Queue</em>的类(它是个接口名字)。</p>\n<p>当需要使用栈时，<strong>Java已不推荐使用<em>Stack</em>，而是推荐使用更高效的<em>ArrayDeque</em></strong>；</p>\n<p>既然<em>Queue</em>只是一个接口，*<em>当需要使用队列时也就首选</em>ArrayDeque<em>了(次选是</em>LinkedList*)**。</p>\n<h4 id=\"5-Deque\"><a href=\"#5-Deque\" class=\"headerlink\" title=\"5. Deque\"></a>5. <em>Deque</em></h4><p><em>Deque</em>的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。</p>\n<p><em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即**循环数组(circular array)**，也就是说数组的任何一点都可能被看作起点或者终点。</p>\n<p>**<em>ArrayDeque</em>是非线程安全的(not thread-safe)**，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入<code>null</code>元素。</p>\n<p>其中,JDK中对于双端队列的插入很有一套:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;addFirst(E e)\npublic void addFirst(E e) &#123;\n    if (e ** null)&#x2F;&#x2F;不允许放入null\n        throw new NullPointerException();\n    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界\n    if (head ** tail)&#x2F;&#x2F;1.空间是否够用\n        doubleCapacity();&#x2F;&#x2F;扩容\n&#125;</code></pre>\n\n<p><strong>空间问题是在插入之后解决的</strong>，因为<code>tail</code>总是指向下一个可插入的空位，也就意味着<code>elements</code>数组至少有一个空位，所以插入元素的时候不用考虑空间问题。</p>\n<p>下标越界的处理: <code>head = (head - 1) &amp; (elements.length - 1)</code>就可以了，<strong>这段代码相当于取余，同时解决了<code>head</code>为负值的情况</strong>。因为<code>elements.length</code>必需是<code>2</code>的指数倍(扩容决定的)，<code>elements - 1</code>就是二进制低位全<code>1</code>，跟<code>head - 1</code>相与之后就起到了取模的作用，如果<code>head - 1</code>为负数(其实只可能是-1)，则相当于对其取相对于<code>elements.length</code>的补码。</p>\n<p><strong>扩容原理</strong></p>\n<p>其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/ArrayDeque_doubleCapacity.png\" alt=\"ArrayDeque_doubleCapacity.png\" style=\"zoom: 50%;\" />\n\n<p>图中我们看到，<strong>为了保持循环数组的性质,复制分两次进行，第一次复制<em>head</em>右边的元素，第二次复制<em>head</em>左边的元素。</strong></p>\n<hr>\n<h3 id=\"c-Queue\"><a href=\"#c-Queue\" class=\"headerlink\" title=\"c. Queue\"></a>c. Queue</h3><p>Queue有两种常见的实现，LinkedList和PriorityQueue</p>\n<h4 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h4><p>前面已经介绍过。</p>\n<h4 id=\"PriorityQueue\"><a href=\"#PriorityQueue\" class=\"headerlink\" title=\"PriorityQueue\"></a>PriorityQueue</h4><p>基于堆结构实现，可以用它来实现优先队列。</p>\n<p><strong>优先队列的作用是能保证每次取出的元素都是队列中权值最小的</strong>(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，<strong>也可以通过构造时传入的比较器</strong>(<em>Comparator</em>，类似于C++的仿函数)。</p>\n<p>​    Java中<em>PriorityQueue</em>实现了<em>Queue</em>接口，不允许放入<code>null</code>元素；其通过堆实现，具体说是<strong>通过完全二叉树(<em>complete binary tree</em>)实现的</strong>小顶堆**(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为<em>PriorityQueue</em>的底层实现。**</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/PriorityQueue_base.png\" alt=\"PriorityQueue_base.png\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">leftNo &#x3D; parentNo*2+1\nrightNo &#x3D; parentNo*2+2\nparentNo &#x3D; (nodeNo-1)&#x2F;2</code></pre>\n\n<p>新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。源码中实现调整结构的代码如下:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;siftUp()\nprivate void siftUp(int k, E x) &#123;\n    while (k &gt; 0) &#123;\n        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2\n        Object e &#x3D; queue[parent];\n        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法\n            break;\n        queue[k] &#x3D; e;\n        k &#x3D; parent;\n    &#125;\n    queue[k] &#x3D; x;\n&#125;</code></pre>\n\n<p><strong>添加元素时,先默认添加到末尾,然后调整结构;删除堆顶元素时,先默认将最后一个元素放置到堆顶,然后再进行调整。</strong></p>\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><h3 id=\"a-HashMap-JDK7\"><a href=\"#a-HashMap-JDK7\" class=\"headerlink\" title=\"a. HashMap-JDK7\"></a>a. HashMap-JDK7</h3><p>基于哈希表实现。</p>\n<p>根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。*<em><strong>Java7 HashMap采用的是冲突链表方式</strong>。</em>*</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/HashMap_base.png\" alt=\"HashMap_base\" style=\"zoom: 50%;\" />\n\n<p>​    HashMap的<code>put()</code>和<code>get()</code>方法可以在常数时间内完成。但在对<em>HashMap</em>进行迭代时，需要遍历整个table以及后面跟的冲突链表。<strong>因此对于迭代比较频繁的场景，不宜将<em>HashMap</em>的初始大小设的过大。</strong></p>\n<p>​    有两个参数可以影响<em>HashMap</em>的性能: <code>初始容量(inital capacity)</code>和<code>负载系数(load factor)</code>。初始容量指定了初始<code>table</code>的大小，负<strong>载系数用来指定自动扩容的临界值。</strong>当<code>entry</code>的数量超过<code>capacity * load_factor</code>时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。</p>\n<p>将对象放入到<em>HashMap</em>或<em>HashSet</em>中时，有两个方法需要特别关心: <code>hashCode()</code>和<code>equals()</code>。</p>\n<p><strong>hashCode()方法决定了对象会被放到哪个bucket里，</strong></p>\n<p><strong>当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。</strong></p>\n<p><strong>所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override  hashCode()和equals()方法。</strong></p>\n<p>​    <code>get(Object key)</code>方法根据指定的<code>key</code>值返回对应的<code>value</code>，该方法调用了<code>getEntry(Object key)</code>得到相应的<code>entry</code>，然后返回<code>entry.getValue()</code>。因此<code>getEntry()</code>是算法的核心。 算法思想是首先通过<code>hash()</code>函数得到对应<code>bucket</code>的下标，然后依次遍历冲突链表，通过<code>key.equals(k)</code>方法来判断是否是要找的那个<code>entry</code>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; HashMap 查找\n&#x2F;&#x2F;getEntry()方法\nfinal Entry&lt;K,V&gt; getEntry(Object key) &#123;\n\t......\n\tint hash &#x3D; (key ** null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e &#x3D; table[hash&amp;(table.length-1)];&#x2F;&#x2F;得到冲突链表\n         e !&#x3D; null; e &#x3D; e.next) &#123;&#x2F;&#x2F;依次遍历冲突链表中的每个entry\n        Object k;\n        &#x2F;&#x2F;依据equals()方法判断是否相等\n        if (e.hash ** hash &amp;&amp;\n            ((k &#x3D; e.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return e;\n    &#125;\n    return null;\n&#125;</code></pre>\n\n<p>​    <code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>getEntry()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>，插入方式为<strong>头插法</strong>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        resize(2 * table.length);&#x2F;&#x2F;自动扩容，并重新哈希\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        bucketIndex &#x3D; hash &amp; (table.length-1);&#x2F;&#x2F;hash%table.length\n    &#125;\n    &#x2F;&#x2F;在冲突链表头部插入新的entry\n    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];\n    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n&#125;</code></pre>\n\n\n\n<h3 id=\"b-HashMap-JDK8\"><a href=\"#b-HashMap-JDK8\" class=\"headerlink\" title=\"b. HashMap-JDK8+\"></a>b. HashMap-JDK8+</h3><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以<strong>其由 <strong>数组+链表+红黑树</strong> 组成</strong>。</p>\n<p>根据 Java7 HashMap 的介绍，我们知道，<strong>查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</strong></p>\n<p>为了降低这部分的开销，在 Java8 中，<strong>当链表中的元素达到了 8 个时，会将链表转换为</strong>红黑树<strong>，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</strong></p>\n<p>来一张图简单示意一下吧：</p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/java-collection-hashmap8.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<p>简单分析一下插入操作的过程:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\n&#x2F;&#x2F; 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n&#x2F;&#x2F; 第五个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    \n    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab &#x3D; table) ** null || (n &#x3D; tab.length) ** 0)\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) ** null)\n        tab[i] &#x3D; newNode(hash, key, value, null);\n\n    else &#123;&#x2F;&#x2F; 数组该位置有数据\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点\n        if (p.hash ** hash &amp;&amp;\n            ((k &#x3D; p.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            e &#x3D; p;\n        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e &#x3D; p.next) ** null) &#123;\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个\n                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(** 或 equals)\n                if (e.hash ** hash &amp;&amp;\n                    ((k &#x3D; e.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node\n                    break;\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;\n        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值\n        if (e !&#x3D; null) &#123;\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue ** null)\n                e.value &#x3D; value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;</code></pre>\n\n<p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p>\n<hr>\n<h3 id=\"c-TreeMap\"><a href=\"#c-TreeMap\" class=\"headerlink\" title=\"c. TreeMap\"></a>c. TreeMap</h3><p>基于红黑树实现。</p>\n<p>TreeMap底层通过红黑树(Red-Black tree)实现，也就意味着<code>containsKey()</code>, <code>get()</code>, <code>put()</code>, <code>remove()</code>都有着<code>log(n)</code>的时间复杂度。</p>\n<p>出于性能原因，<em>TreeMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>TreeMap</em>包装成(wrapped)同步的:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">SortedMap m &#x3D; Collections.synchronizedSortedMap(new TreeMap(...));</code></pre>\n\n\n\n\n\n\n\n\n\n<h3 id=\"d-HashTable\"><a href=\"#d-HashTable\" class=\"headerlink\" title=\"d. HashTable\"></a>d. HashTable</h3><p>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>\n<h3 id=\"e-LinkedHashMap\"><a href=\"#e-LinkedHashMap\" class=\"headerlink\" title=\"e. LinkedHashMap\"></a>e. LinkedHashMap</h3><p><strong>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</strong></p>\n<p><em>LinkedHashMap</em>实现了<em>Map</em>接口，即允许放入<code>key</code>为<code>null</code>的元素，也允许插入<code>value</code>为<code>null</code>的元素。从名字上可以看出该容器是<em>linked list</em>和<em>HashMap</em>的混合体，也就是说它同时满足<em>HashMap</em>和<em>linked list</em>的某些特性。</p>\n<p><strong>可将LinkedHashMap看作采用linked list增强的HashMap。</strong></p>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/LinkedHashMap_base.png\" alt=\"LinkedHashMap_base.png\" style=\"zoom:67%;\" />\n\n\n\n<p>​    事实上<em>LinkedHashMap</em>是<em>HashMap</em>的直接子类，二者唯一的区别是<strong>LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。</strong>上图给出了<em>LinkedHashMap</em>的结构图，主体部分跟<em>HashMap</em>完全一样，多了<code>header</code>指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是<code>entry</code>的插入顺序。</p>\n<p>​    除了可以保迭代历顺序，这种结构还有一个好处 : <strong>迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可</strong>，也就是说<em>LinkedHashMap</em>的迭代时间就只跟<code>entry</code>的个数相关，而跟<code>table</code>的大小无关。</p>\n<p>​    出于性能原因，<em>LinkedHashMap</em>是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将<em>LinkedHashMap</em>包装成(wrapped)同步的:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Map m &#x3D; Collections.synchronizedMap(new LinkedHashMap(...));</code></pre>\n\n<p>与HashMap不同的是,对插入和删除操作来说:</p>\n<ol>\n<li>从<code>table</code>的角度看，新的<code>entry</code>需要插入(或删除)到对应的<code>bucket</code>里，当有哈希冲突时，采用头插法将新的<code>entry</code>插入(或删除)到冲突链表的头部。</li>\n<li>从<code>header</code>的角度看，新的<code>entry</code>需要插入(或删除)到双向链表的尾部。</li>\n</ol>\n<p><code>put(K key, V value)</code>方法是将指定的<code>key, value</code>对添加到<code>map</code>里。该方法首先会对<code>map</code>做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于<code>get()</code>方法；如果没有找到，则会通过<code>addEntry(int hash, K key, V value, int bucketIndex)</code>方法插入新的<code>entry</code>。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; LinkedHashMap.addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        resize(2 * table.length);&#x2F;&#x2F; 自动扩容，并重新哈希\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        bucketIndex &#x3D; hash &amp; (table.length-1);&#x2F;&#x2F; hash%table.length\n    &#125;\n    &#x2F;&#x2F; 1.在冲突链表头部插入新的entry\n    HashMap.Entry&lt;K,V&gt; old &#x3D; table[bucketIndex];\n    Entry&lt;K,V&gt; e &#x3D; new Entry&lt;&gt;(hash, key, value, old);\n    table[bucketIndex] &#x3D; e;\n    &#x2F;&#x2F; 2.在双向链表的尾部插入新的entry\n    e.addBefore(header);\n    size++;\n&#125;</code></pre>\n\n\n\n\n\n<h1 id=\"I-x2F-O\"><a href=\"#I-x2F-O\" class=\"headerlink\" title=\"I&#x2F;O\"></a>I&#x2F;O</h1><h2 id=\"a-本地IO\"><a href=\"#a-本地IO\" class=\"headerlink\" title=\"a. 本地IO\"></a>a. 本地IO</h2><h3 id=\"1-IO理解分类-从传输方式上\"><a href=\"#1-IO理解分类-从传输方式上\" class=\"headerlink\" title=\"1. IO理解分类 - 从传输方式上\"></a>1. IO理解分类 - 从传输方式上</h3><p>从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:</p>\n<ul>\n<li>字节流</li>\n<li>字符流</li>\n</ul>\n<p><code>字节</code>是个计算机看的，<code>字符</code>才是给人看的</p>\n<h3 id=\"2-字节流和字符流的区别\"><a href=\"#2-字节流和字符流的区别\" class=\"headerlink\" title=\"2. 字节流和字符流的区别\"></a>2. 字节流和字符流的区别</h3><ul>\n<li>字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)</li>\n<li>字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。</li>\n</ul>\n<img src=\"Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/image-20220311172058164.png\" alt=\"image-20220311172058164\" style=\"zoom:50%;\" />\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n *  流的体系结构\n *  抽象基类             节点流                缓存流\n *  InputStream         FileInputStream     BufferedInputStream\n *  OutputStream        FileOutputStream    BufferedOutputSteam\n *  Reader              FileReader          BufferedReader\n *  Writer              FileWriter          BufferedWriter\n * *&#x2F;</code></pre>\n\n<h3 id=\"3-FileReader\"><a href=\"#3-FileReader\" class=\"headerlink\" title=\"3. FileReader\"></a>3. FileReader</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 测试 FileReader\n&#x2F;&#x2F; 为了保证资源一定可以被关闭,使用try-catch-finally来关闭资源\npublic static void testFileReader() &#123;\n    FileReader fr &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F; 1. 实例化File类对象\n        File file &#x3D; new File(&quot;Interview\\\\hello.txt&quot;); &#x2F;&#x2F; 路径相较于当前工程\n        &#x2F;&#x2F; 2. 提供具体的流\n        fr &#x3D; new FileReader(file);\n        &#x2F;&#x2F; 3. 数据的读入过程\n        &#x2F;&#x2F; RETURN The character read, or -1 if the end of the stream has been reached\n        &#x2F;&#x2F; 返回一个读入的字符,如果到达文件末尾返回-1\n        int data;\n        while ((data &#x3D; fr.read()) !&#x3D; -1) &#123;\n            System.out.print((char) data);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            &#x2F;&#x2F; 4. 关闭流操作\n            &#x2F;&#x2F; JVM 虽然有垃圾回收机制,但对于物理连接无能为力,比如: 数据库连接、输入输出流、Socket\n            if (fr !&#x3D; null) fr.close();\n            &#x2F;&#x2F; 因为 fr可能在前面由于打开失败而为null,不能直接close\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void testFileReader1() &#123;\n    FileReader fr &#x3D; null;\n    try &#123;\n        File file &#x3D; new File(&quot;Interview&#x2F;&#x2F;hello.txt&quot;);\n        fr &#x3D; new FileReader(file);\n        char[] cBuf &#x3D; new char[5];\n        &#x2F;&#x2F; RETURN   The number of characters read,\n        &#x2F;&#x2F;          or -1 if the end of the stream has been reached\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            &#x2F;&#x2F;错误写法1\n            &#x2F;&#x2F;System.out.println(Arrays.toString(cBuf));&#x2F;&#x2F;\n            &#x2F;&#x2F;错误写法2\n            &#x2F;&#x2F;for (int i &#x3D; 0; i &lt; cBuf.length; i++) &#123;\n            &#x2F;&#x2F;   System.out.print(cBuf[i]);\n            &#x2F;&#x2F;&#125;\n            &#x2F;&#x2F; 正确1\n            for (int i &#x3D; 0; i &lt; len; i++) &#123;\n                System.out.print(cBuf[i]);\n            &#125;\n            &#x2F;&#x2F; 正确2\n            String s &#x3D; new String(cBuf, 0, len);\n            System.out.print(s);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"4-FileWriter\"><a href=\"#4-FileWriter\" class=\"headerlink\" title=\"4. FileWriter\"></a>4. FileWriter</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\t&#x2F;&#x2F; 从内存中写出数据到磁盘的文件里。\n\t&#x2F;*\n     *  输出操作 对应File可以不存在,会自动创建,不会爆异常\n     *          如果存在,可以根据第二个参数确定是否追加,默认不追加,进行覆盖\n     *          FileWriter fw &#x3D; new FileWriter(file,false&#x2F;true);\n     * *&#x2F;\npublic static void TestFileWriter() throws IOException &#123;\n\n    FileWriter fw &#x3D; null;\n    try &#123;\n        File file &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;helloWriter.txt&quot;);\n        System.out.println(file.getAbsolutePath());\n        &#x2F;&#x2F; file文件本身没有写出的能力,\n        fw &#x3D; new FileWriter(file, false);\n        fw.write(&quot;Fuck F4N!&quot;);\n        fw.write(&quot;2022-3-11&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        if (fw !&#x3D; null) fw.close();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"5-复制操作\"><a href=\"#5-复制操作\" class=\"headerlink\" title=\"5. 复制操作\"></a>5. 复制操作</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 对文件的读写,做一个复制操作\npublic static void TestFileReaderWriter() throws IOException &#123;\n    FileReader fr &#x3D; null;\n    FileWriter fw &#x3D; null;\n    try &#123;\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;helloWriter.txt&quot;);\n\n\n        fr &#x3D; new FileReader(srcFile);\n        fw &#x3D; new FileWriter(destFile,true);\n        char[] cBuf &#x3D; new char[5];\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            fw.write(cBuf, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fw !&#x3D; null) fw.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"6-FileInputOutputStream处理图片\"><a href=\"#6-FileInputOutputStream处理图片\" class=\"headerlink\" title=\"6. FileInputOutputStream处理图片\"></a>6. FileInputOutputStream处理图片</h3><p>处理图片、视频等需要用字节流，字节流处理字符可能出现乱码问题，尤其是中文。但<strong>实际上，如果只进行复制操作，而在程序中不进行加工，就没什么影响。</strong></p>\n<p>文本文件：.txt .java .c .cpp …</p>\n<p>非文本文件: .jpg .mp3 .doc .ppt …</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> &#x2F;&#x2F; 使用字节流处理图片\npublic static void ImgTestFileInputOutputStream   () throws IOException &#123;\n    FileInputStream fr &#x3D; null;\n    FileOutputStream fw &#x3D; null;\n    try &#123;\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;copyimg.jpg&quot;);\n\n        fr &#x3D; new FileInputStream(srcFile);\n        fw &#x3D; new FileOutputStream(destFile);\n        byte[] cBuf &#x3D; new byte[5];\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            fw.write(cBuf, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fw !&#x3D; null) fw.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"7-缓冲流\"><a href=\"#7-缓冲流\" class=\"headerlink\" title=\"7. 缓冲流\"></a>7. 缓冲流</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">BufferedInputStream\nBufferedOutputSteam\nBufferedReader\nBufferedWriter</code></pre>\n\n<p><strong>缓冲流使用要先套接到已有的”流”之上</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">BufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;)));</code></pre>\n\n<p>如果使用<code>BufferedReader</code>和<code>BufferedWriter</code>,可以使用String进行读取。</p>\n<p>开发会优先使用缓冲流， 因为<strong>缓冲流内部提供了缓冲区</strong> ，速度会快很多。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void TestBufferStream() throws IOException &#123;\n    &#x2F;*非文本文件的复制*&#x2F;\n    BufferedInputStream bis &#x3D; null;\n    BufferedOutputStream bos &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F; 造文件\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;CopyIMG.jpg&quot;);\n        &#x2F;&#x2F; 造节点流\n        FileInputStream fis &#x3D; new FileInputStream(srcFile);\n        FileOutputStream fos &#x3D; new FileOutputStream(destFile);\n        &#x2F;&#x2F; 造缓冲流\n        bis &#x3D; new BufferedInputStream(fis);\n        bos &#x3D; new BufferedOutputStream(fos);\n        &#x2F;&#x2F; 简写\n        &#x2F;&#x2F; bis &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg&quot; +\n        &#x2F;&#x2F;                    &quot;.jpg&quot;)));\n        &#x2F;&#x2F; bos &#x3D; new BufferedOutputStream(new FileOutputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;CopyIMG&quot; +\n        &#x2F;&#x2F;                    &quot;.jpg&quot;)));\n\n        byte[] buffer &#x3D; new byte[10];\n        int len;\n        while ((len &#x3D; bis.read(buffer)) !&#x3D; -1) &#123;\n            bos.write(buffer, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 资源关闭\n        &#x2F;&#x2F; 先关外层的流,再关内层的流\n        bis.close();\n        bos.close();\n        &#x2F;&#x2F; 其实,关闭外层流时,会自动关闭内层流,也就是说下面的内层的流可以省略\n        &#x2F;&#x2F; fis.close();\n        &#x2F;&#x2F; fos.close();\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"8-统计一个文件中字符出现次数\"><a href=\"#8-统计一个文件中字符出现次数\" class=\"headerlink\" title=\"8. 统计一个文件中字符出现次数\"></a>8. 统计一个文件中字符出现次数</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 统计 comment.txt中每个字符出现的次数\npublic static void wordCount() throws IOException &#123;\n    BufferedReader br &#x3D; new BufferedReader(new FileReader(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;comment.txt&quot;)));\n    BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;commentCount.txt&quot;)));\n    HashMap&lt;Character, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n    int ch;\n    while ((ch &#x3D; br.read()) !&#x3D; -1) &#123;\n        char c &#x3D; (char) ch;\n        hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);\n    &#125;\n    br.close();\n    for (Map.Entry&lt;Character, Integer&gt; en : hashMap.entrySet()) &#123;\n        char c &#x3D; en.getKey();\n        switch (c)&#123;\n            case &#39; &#39;:\n                bw.write(&quot;空格 &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\t&#39;:\n                bw.write(&quot;tab &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\r&#39;:\n                bw.write(&quot;回车 &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\n&#39;:\n                bw.write(&quot;换行 &#x3D; &quot;+en.getValue());\n                break;\n            default:\n                bw.write(c+&quot; &#x3D; &quot;+en.getValue());\n                break;\n        &#125;\n        bw.newLine();\n    &#125;\n    bw.close();\n&#125;</code></pre>\n\n<h3 id=\"9-转换流\"><a href=\"#9-转换流\" class=\"headerlink\" title=\"9. 转换流\"></a>9. 转换流</h3><p><strong>转换流提供了 字节流 到 字符流 的转换。</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&#x2F;*\n *  转换流:\n *  InputStreamReader ： 将一个字节的输入流 转换为 字符 的输入流\n *  OutputStreamWriter ：将一个字符的输出流 转换为 字节 的输出流\n *  实现了 字节流 到 字符流之间的转换。\n *\n *  从 字节 --&gt; 字符 是一种解码\n *  从 字符 --&gt; 字节 是一种编码\n *\n *  这个过程存在字符集的设置问题\n * *&#x2F;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) throws IOException &#123;\n    &#x2F;* 实现字节流到输入流的转换 *&#x2F;\n    FileInputStream fis &#x3D; new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;comment.txt&quot;);\n    FileOutputStream fos &#x3D; new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;commentGBK.txt&quot;);\n    &#x2F;&#x2F; 参数二指明字符集,根据读取的文件字符集来确定\n    InputStreamReader isr &#x3D; new InputStreamReader(fis, &quot;UTF-8&quot;);\n    OutputStreamWriter osw &#x3D; new OutputStreamWriter(fos, &quot;GBK&quot;);\n    char[] cbuf &#x3D; new char[20];\n    int len;\n    while ((len &#x3D; isr.read(cbuf)) !   &#x3D; -1) &#123;\n        String s &#x3D; new String(cbuf, 0, len);\n        System.out.print(s);\n        osw.write(s);\n    &#125;\n    isr.close();\n    osw.close();\n&#125;</code></pre>\n\n<h3 id=\"10-标准的输入输出流\"><a href=\"#10-标准的输入输出流\" class=\"headerlink\" title=\"10. 标准的输入输出流\"></a>10. 标准的输入输出流</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;*\n *  标准的输入流\n *  System.in: 标准的输入流,默认从键盘输入\n *  System.out: 标准的输出流,默认从控制台输出\n *\n *  System类的setIn(InputStream is) &#x2F; setOut(PrintStream ps)方式重新指定输入输出的流\n* *&#x2F;</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 实现一个输入转为大写的程序\n&#x2F;&#x2F; 1. 用Scanner实现\n&#x2F;&#x2F; 2. 用System.in实现\n&#x2F;&#x2F;    System.in --&gt; 转换流 --&gt; BufferedReader 的 readLine()\n\nInputStreamReader isr &#x3D; new InputStreamReader(System.in);\nBufferedReader br &#x3D; new BufferedReader(isr);\nwhile (true)&#123;\n    String s &#x3D; br.readLine();\n    if (&quot;e&quot;.equalsIgnoreCase(s) || &quot;exit&quot;.equalsIgnoreCase(s) )&#123;\n        System.out.println(&quot;EXIT.&quot;);\n        break;\n    &#125;\n    System.out.println(s.toUpperCase());\n&#125;\nbr.close();</code></pre>\n\n\n\n<h3 id=\"11-打印流\"><a href=\"#11-打印流\" class=\"headerlink\" title=\"11. 打印流\"></a>11. 打印流</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 打印流\n&#x2F;&#x2F; PrintStream PrintWriter\n&#x2F;&#x2F; 它们提供了一系列的 print println方法\n&#x2F;&#x2F; 可以使用System.setOut()设置答应的目标,默认为显示器\nFileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\nPrintStream stream &#x3D; new PrintStream(fos);\n&#x2F;&#x2F; 把输入目的地改为文件,而不是显示器\nif (stream !&#x3D; null) System.setOut(stream);\nSystem.out.println();</code></pre>\n\n<h3 id=\"12-数据流\"><a href=\"#12-数据流\" class=\"headerlink\" title=\"12. 数据流\"></a>12. 数据流</h3><p>主要是为了 <strong>为了方便操作Java语言中的基本类型和 String</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F;        DataInputStream 套接到 InputStream\n&#x2F;&#x2F;        DataOutputStream 套接到 OutputStream\nDataOutputStream dos &#x3D; new DataOutputStream(new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\ndos.writeUTF(&quot;中国&quot;);\n&#x2F;&#x2F; 刷新操作 flush-冲洗\ndos.flush();\ndos.writeInt(23);\ndos.flush();\ndos.writeBoolean(true);\ndos.close();\n\nDataInputStream dis &#x3D; new DataInputStream(new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\nString country &#x3D; dis.readUTF();\nint age &#x3D; dis.readInt();\nboolean b &#x3D; dis.readBoolean();\nSystem.out.println(country+&quot; &quot;+age+&quot; &quot;+b);\ndis.close();</code></pre>\n\n<h3 id=\"13-对象流\"><a href=\"#13-对象流\" class=\"headerlink\" title=\"13. 对象流:\"></a>13. 对象流:</h3><p><code>ObjectInputStream</code>和<code>ObjectOutputStream</code></p>\n<ul>\n<li>用以存储和读取 对象类型 和 基本类型 的处理流</li>\n<li>通过 <code>序列化</code> 与 <code>反序列化</code> 来进行对对象数据的 保存、传输、读取。</li>\n<li><code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 static和transient 修饰的成员变量</li>\n<li>对象序列化 : 将内存中的Java对象转换为平台无关的二进制流 这样就可以将对象进行与平台无关的 传输和保存</li>\n<li>实现了Serializable接口的对象 可以转化为 字节数据</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; Object 类型的写入\nObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;Object.dat&quot;));\noos.writeObject(new String(&quot;我爱北京&quot;));\noos.flush();\noos.close();\n\n&#x2F;&#x2F; Object 读入\nObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;Object.dat&quot;));\nString str &#x3D;(String) ois.readObject();\nSystem.out.println(str);\nois.close();</code></pre>\n\n<p>自定义对象实现 <code>Serializable接口</code> 来进行序列化和反序列化,需要提供一个<code>serialVersionUID</code>来进行一个标识,确保可以还原和区分。与此同时，<strong>必须保证自定义的类的属性字段也都可以序列化</strong>，基础类型默认可以序列化。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">class Person implements Serializable &#123;\n    &#x2F;&#x2F; 序列版本号\n   \n    private static final long serialVersionUID &#x3D; 46516164984L;\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n            &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n            &quot;, age&#x3D;&quot; + age +\n            &#39;&#125;&#39;;\n    &#125;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;</code></pre>\n\n<p><code>serialVersionUID</code>使用来表示类的不同版本间的兼容性，如果没有显示定义，JVM会自动生成一个，但这样可能会在修改类时产生问题，导致序列化失败。  </p>\n<h3 id=\"14-随机存取文件流\"><a href=\"#14-随机存取文件流\" class=\"headerlink\" title=\"14. 随机存取文件流\"></a>14. 随机存取文件流</h3><p><code>RandomAccessFile</code> 直接继承 Object , 随机存取文件流的特殊指出在于 <strong>既可以作为输入流,也可以作为输出流</strong>。</p>\n<p>如果文件已经存在,写时会从头进行覆盖。</p>\n<ul>\n<li>可以使用<code>seek()</code>函数进行指针的移动。</li>\n<li>要实现插入需要先将后面的数据向后移动再插入。</li>\n</ul>\n<p>如果文件不存在，则会自动创建。</p>\n<h3 id=\"基本知识点汇总\"><a href=\"#基本知识点汇总\" class=\"headerlink\" title=\"基本知识点汇总\"></a>基本知识点汇总</h3><ol>\n<li><p>流的三种分类方式</p>\n<ul>\n<li>流向: 输入流、输出流</li>\n<li>数据单位：字节流、字符流</li>\n<li>流的角色：节点流、处理流</li>\n</ul>\n</li>\n<li><p>写出4个IO流中的抽象基类,4个文件流,4个缓冲流</p>\n<p>抽象基类:</p>\n<ul>\n<li>InputStream</li>\n<li>OutputStream</li>\n<li>Reader</li>\n<li>Writer</li>\n</ul>\n<p>文件流:</p>\n<ul>\n<li>FileReader</li>\n<li>FileWriter</li>\n<li>FileInputStream</li>\n<li>FileOutputStream</li>\n</ul>\n<p>缓冲流:</p>\n<ul>\n<li>BufferedReader</li>\n<li>BufferedWriter</li>\n<li>BufferedInputStream</li>\n<li>BufferedOutputStream</li>\n</ul>\n<p>转换流:<code>InputSteamReader</code> <code>OutputStreamWriter</code></p>\n</li>\n<li><p>字符流和字节流分别的使用情景</p>\n<p>字节流: 主要用来处理非文本文件</p>\n<p>字符流: 主要用来处理文本文件</p>\n</li>\n</ol>\n<h2 id=\"b-BIO-NIO-AIO-异同\"><a href=\"#b-BIO-NIO-AIO-异同\" class=\"headerlink\" title=\"b. BIO NIO AIO 异同\"></a>b. BIO NIO AIO 异同</h2><p>BIO: <code>同步阻塞型</code>。 服务器为客户端一个连接一个线程，数据未准备好时阻塞。</p>\n<ul>\n<li>适用于连接数目少，并固定的架构，这种方式对服务器资源要求比较高，低并发的情况下。JDK1.4之前的唯一选择</li>\n</ul>\n<p>NIO: <code>同步非阻塞型</code>。由一个中央选择器进行IO请求的接收，并<code>轮询访问</code>是否有已经准备好的IO请求，有就会去处理。</p>\n<ul>\n<li>适用于连接数目较多，但单个连接比较短的情况，比如聊天服务器、弹幕系统、服务器通讯等.JDK1.4开始支持</li>\n</ul>\n<p>AIO: <code>异步非阻塞</code>。客户端IO请求先由操作系统(OS)进行处理,数据处理好后<code>通知服务器</code>处理程序来进行处理。</p>\n<ul>\n<li>适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持</li>\n</ul>\n<p>在文中我们一再说明JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO，这个从JAVA AIO框架的部分类设计上就可以看出来。</p>\n<table>\n<thead>\n<tr>\n<th>BIO</th>\n<th>NIO</th>\n<th>AIO</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>Socket</code></td>\n<td><code>SocketChannel</code></td>\n<td><code>AsynchronousSocketChannel</code></td>\n</tr>\n<tr>\n<td><code>ServerSocket</code></td>\n<td><code>ServerSocketChannel</code></td>\n<td><code>AsynchornousServerSocketChannel</code></td>\n</tr>\n</tbody></table>\n<h2 id=\"c-Unix-IO-类型\"><a href=\"#c-Unix-IO-类型\" class=\"headerlink\" title=\"c. Unix IO 类型\"></a>c. Unix IO 类型</h2><p>一个输入操作通常包括两个阶段:</p>\n<ul>\n<li>等待数据准备好</li>\n<li>从内核向进程复制数据</li>\n</ul>\n<p>​    对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p>\n<p>Unix 下有五种 I&#x2F;O 模型:</p>\n<ul>\n<li>阻塞式 I&#x2F;O</li>\n<li>非阻塞式 I&#x2F;O</li>\n<li>I&#x2F;O 复用(select 和 poll)</li>\n<li>信号驱动式 I&#x2F;O(SIGIO)</li>\n<li>异步 I&#x2F;O(AIO)</li>\n</ul>\n<h3 id=\"1-阻塞式IO\"><a href=\"#1-阻塞式IO\" class=\"headerlink\" title=\"1. 阻塞式IO\"></a>1. 阻塞式IO</h3><p><strong>应用进程被阻塞</strong>，直到数据复制到应用进程缓冲区中才返回。</p>\n<p>应该注意到，在阻塞的过程中，其它程序还可以执行，因此<strong>阻塞不意味着整个操作系统都被阻塞</strong>。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的<strong>执行效率会比较高。</strong></p>\n<h3 id=\"2-非阻塞式-I-x2F-O\"><a href=\"#2-非阻塞式-I-x2F-O\" class=\"headerlink\" title=\"2. 非阻塞式 I&#x2F;O\"></a>2. 非阻塞式 I&#x2F;O</h3><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是<strong>需要不断的执行系统调用来获知 I&#x2F;O 是否完成</strong>，这种方式称为<code>轮询(polling)</code>。</p>\n<p>由于 CPU 要处理更多的系统调用，因此这种模型是比较<strong>低效</strong>的。</p>\n<h3 id=\"3-I-x2F-O-复用\"><a href=\"#3-I-x2F-O-复用\" class=\"headerlink\" title=\"3. I&#x2F;O 复用\"></a>3. I&#x2F;O 复用</h3><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。</p>\n<p>它可以让<strong>单个进程具有处理多个 I&#x2F;O 事件的能力</strong>。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。</p>\n<p>如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。</p>\n<h3 id=\"4-信号驱动-I-x2F-O\"><a href=\"#4-信号驱动-I-x2F-O\" class=\"headerlink\" title=\"4. 信号驱动 I&#x2F;O\"></a>4. 信号驱动 I&#x2F;O</h3><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说<strong>等待数据阶段应用进程是非阻塞的</strong>。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p>\n<p><strong>相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高</strong>。</p>\n<h3 id=\"5-异步-I-x2F-O\"><a href=\"#5-异步-I-x2F-O\" class=\"headerlink\" title=\"5. 异步 I&#x2F;O\"></a>5. 异步 I&#x2F;O</h3><p>进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p>\n<p>异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。</p>\n<h2 id=\"e-BIO\"><a href=\"#e-BIO\" class=\"headerlink\" title=\"e. BIO\"></a>e. BIO</h2><p>BIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，<strong>应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；</strong>另一方面，<strong>操作系统收到请求后，也会等待数据完成</strong>，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。</p>\n<ul>\n<li><code>阻塞IO</code> 和 <code>非阻塞IO</code></li>\n</ul>\n<p>​    这两个概念是<code>程序级别</code>的。主要描述的是<strong>程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题</strong>: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)</p>\n<ul>\n<li><code>同步IO</code> 和 <code>非同步IO</code></li>\n</ul>\n<p>​    这两个概念是<code>操作系统级别</code>的。主要描述的是<strong>操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题</strong>: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。</p>\n<h3 id=\"1-传统BIO\"><a href=\"#1-传统BIO\" class=\"headerlink\" title=\"1. 传统BIO\"></a>1. 传统BIO</h3><p>以前大多数网络通信方式都是阻塞模式的，即:</p>\n<ul>\n<li>客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。</li>\n<li>服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。</li>\n</ul>\n<h3 id=\"2-传统的BIO的问题\"><a href=\"#2-传统的BIO的问题\" class=\"headerlink\" title=\"2. 传统的BIO的问题\"></a>2. 传统的BIO的问题</h3><ul>\n<li>同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。</li>\n<li>由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。</li>\n</ul>\n<h3 id=\"3-多线程方式-伪异步方式\"><a href=\"#3-多线程方式-伪异步方式\" class=\"headerlink\" title=\"3. 多线程方式 - 伪异步方式\"></a>3. 多线程方式 - 伪异步方式</h3><p>上面说的情况是服务器只有一个线程的情况，那么读者会直接提出我们可以使用多线程技术来解决这个问题:</p>\n<ul>\n<li>当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。</li>\n<li>客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式&#x2F;观察模式(等其他设计模式)通知主线程。</li>\n</ul>\n<p>但是使用线程来解决这个问题实际上是有<strong>局限性</strong>的:</p>\n<ul>\n<li>虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，<strong>实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来</strong>(下文的示例代码和debug过程我们可以明确看到这一点)</li>\n<li><strong>在linux系统中，可以创建的线程是有限的。</strong>我们可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。</li>\n<li>创建一个线程是有较大的资源消耗的。</li>\n<li>如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。</li>\n</ul>\n<p><strong>BIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。</strong></p>\n<p>即: 异步IO模式 就是为了解决这样的并发性存在的。</p>\n<h2 id=\"f-NIO\"><a href=\"#f-NIO\" class=\"headerlink\" title=\"f. NIO\"></a>f. NIO</h2><p>通俗理解: NIO 是可以做到用一个线程来处理多个请求的操作。假如有1000个请求，可以根据实际情况，分配20~80个线程来进行处理，不需要像阻塞式IO非要分配1000个线程。</p>\n<img src=\"/post/Java-IO-%E9%9B%86%E5%90%88%E7%B1%BB/image-20220315154500329.png\" class=\"\" title=\"image-20220315154500329\">\n\n<p>新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，<strong>提供了高速的、面向块的 I&#x2F;O。</strong></p>\n<p>I&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>\n<ul>\n<li><p>面向流的 I&#x2F;O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。</p>\n</li>\n<li><p>面向块的 I&#x2F;O <strong>一次处理一个数据块</strong>，按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。</p>\n</li>\n</ul>\n<p>I&#x2F;O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>\n<p>NIO 与普通 I&#x2F;O 的区别主要有以下两点:</p>\n<ul>\n<li><strong>NIO 是非阻塞的</strong></li>\n<li><strong>NIO 面向块，I&#x2F;O 面向流</strong></li>\n</ul>\n<h3 id=\"1-通道与缓冲区\"><a href=\"#1-通道与缓冲区\" class=\"headerlink\" title=\"1. 通道与缓冲区\"></a>1. 通道与缓冲区</h3><p>通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。</p>\n<p>通道与流的不同之处在于，<strong>流只能在一个方向上移动</strong>(一个流必须是 InputStream 或者 OutputStream 的子类)，而<strong>通道是双向的，可以用于读、写或者同时用于读写。</strong></p>\n<p>通道包括以下类型:</p>\n<ul>\n<li><strong>FileChannel: 从文件中读写数据；</strong></li>\n<li>DatagramChannel: 通过 UDP 读写网络中数据；</li>\n<li>SocketChannel: 通过 TCP 读写网络中数据；</li>\n<li>ServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>\n</ul>\n<hr>\n<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>\n<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。</p>\n<p>缓冲区包括以下类型:</p>\n<ul>\n<li>ByteBuffer</li>\n<li>CharBuffer</li>\n<li>ShortBuffer</li>\n<li>IntBuffer</li>\n<li>LongBuffer</li>\n<li>FloatBuffer</li>\n<li>DoubleBuffer</li>\n</ul>\n<hr>\n<p>使用 NIO 快速复制文件的实例:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static final String FILE_PATH &#x3D; &quot;Interview&#x2F;&#x2F;NIO&#x2F;&#x2F;&quot;;\npublic static void main(String[] args) throws IOException &#123;\n    &#x2F;*输入字节流*&#x2F;\n    FileInputStream fin &#x3D; new FileInputStream(FILE_PATH + &quot;hello.txt&quot;);\n    &#x2F;*输入通道*&#x2F;\n    FileChannel fcin &#x3D; fin.getChannel();\n    &#x2F;*输出管道*&#x2F;\n    FileOutputStream fout &#x3D; new FileOutputStream(FILE_PATH + &quot;out.txt&quot;);\n    &#x2F;*输出字节流*&#x2F;\n    FileChannel fcout &#x3D; fout.getChannel();\n    &#x2F;* 为缓冲区分配 1024 个字节 *&#x2F;\n    ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(1024);\n    while (true) &#123;\n        int read &#x3D; fcin.read(buffer);\n        if (read ** -1) break;\n        &#x2F;*切换读写*&#x2F;\n        buffer.flip();\n        &#x2F;* 把缓冲区的内容写入输出文件中 *&#x2F;\n        fcout.write(buffer);\n        &#x2F;* 清空缓冲区 *&#x2F;\n        buffer.clear();\n    &#125;\n    fcout.close();\n    fcin.close();\n&#125;</code></pre>\n\n\n\n<h3 id=\"2-Selector-选择器\"><a href=\"#2-Selector-选择器\" class=\"headerlink\" title=\"2. Selector(选择器)\"></a>2. Selector(选择器)</h3><p>有Selector选择器来在收到访问后,轮询的查找是否已经有准备好的IO请求可以进行返回处理,如果有,则去单独阻塞的处理请求。</p>\n<h3 id=\"3-NIO-IO多路复用详解\"><a href=\"#3-NIO-IO多路复用详解\" class=\"headerlink\" title=\"3. NIO - IO多路复用详解\"></a>3. NIO - IO多路复用详解</h3><p>目前流程的多路复用IO实现主要包括四种: <code>select</code>、<code>poll</code>、<code>epoll</code>、<code>kqueue</code>。下表是他们的一些重要特性的比较:</p>\n<table>\n<thead>\n<tr>\n<th>IO模型</th>\n<th align=\"left\">相对性能</th>\n<th>关键思路</th>\n<th>操作系统</th>\n<th>JAVA支持情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>select</td>\n<td align=\"left\">较高</td>\n<td>Reactor</td>\n<td>windows&#x2F;Linux</td>\n<td>支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型</td>\n</tr>\n<tr>\n<td>poll</td>\n<td align=\"left\">较高</td>\n<td>Reactor</td>\n<td>Linux</td>\n<td>Linux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式</td>\n</tr>\n<tr>\n<td>epoll</td>\n<td align=\"left\">高</td>\n<td>Reactor&#x2F;Proactor</td>\n<td>Linux</td>\n<td>Linux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO</td>\n</tr>\n<tr>\n<td>kqueue</td>\n<td align=\"left\">高</td>\n<td>Proactor</td>\n<td>Linux</td>\n<td>目前JAVA的版本不支持</td>\n</tr>\n</tbody></table>\n<p>多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。</p>\n<h2 id=\"g-AIO\"><a href=\"#g-AIO\" class=\"headerlink\" title=\"g. AIO\"></a>g. AIO</h2><p><code>异步非阻塞</code>。客户端IO请求先由操作系统(OS)进行处理,数据处理好后<code>通知服务器</code>处理程序来进行处理。</p>\n<p>当进行读写操作时，只需要直接调用API的read和write方法即可，这两种方法均是异步的。</p>\n<ul>\n<li>适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持</li>\n</ul>\n","text":"集合类容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。 Collectiona. SetSet:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素 用于存储...","link":"","photos":[],"count_time":{"symbolsCount":"35k","symbolsTime":"32 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"IO","slug":"IO","count":1,"path":"api/tags/IO.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%9B%86%E5%90%88%E7%B1%BB\"><span class=\"toc-text\">集合类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Collection\"><span class=\"toc-text\">Collection</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-Set\"><span class=\"toc-text\">a. Set</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-HashSet\"><span class=\"toc-text\">1. HashSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-TreeSet\"><span class=\"toc-text\">2. TreeSet</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-LinkedHashSet\"><span class=\"toc-text\">3. LinkedHashSet</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-List\"><span class=\"toc-text\">b. List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-ArrayList\"><span class=\"toc-text\">1. ArrayList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">自动扩容机制</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-LinkedList\"><span class=\"toc-text\">2. LinkedList</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-Vector\"><span class=\"toc-text\">3. Vector</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-Stack-%E5%92%8C-Queue\"><span class=\"toc-text\">4. Stack 和 Queue</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-Deque\"><span class=\"toc-text\">5. Deque</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-Queue\"><span class=\"toc-text\">c. Queue</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#PriorityQueue\"><span class=\"toc-text\">PriorityQueue</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Map\"><span class=\"toc-text\">Map</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#a-HashMap-JDK7\"><span class=\"toc-text\">a. HashMap-JDK7</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#b-HashMap-JDK8\"><span class=\"toc-text\">b. HashMap-JDK8+</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#c-TreeMap\"><span class=\"toc-text\">c. TreeMap</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#d-HashTable\"><span class=\"toc-text\">d. HashTable</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#e-LinkedHashMap\"><span class=\"toc-text\">e. LinkedHashMap</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#I-x2F-O\"><span class=\"toc-text\">I&#x2F;O</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E6%9C%AC%E5%9C%B0IO\"><span class=\"toc-text\">a. 本地IO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-IO%E7%90%86%E8%A7%A3%E5%88%86%E7%B1%BB-%E4%BB%8E%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F%E4%B8%8A\"><span class=\"toc-text\">1. IO理解分类 - 从传输方式上</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">2. 字节流和字符流的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-FileReader\"><span class=\"toc-text\">3. FileReader</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-FileWriter\"><span class=\"toc-text\">4. FileWriter</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">5. 复制操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-FileInputOutputStream%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87\"><span class=\"toc-text\">6. FileInputOutputStream处理图片</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E7%BC%93%E5%86%B2%E6%B5%81\"><span class=\"toc-text\">7. 缓冲流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-%E7%BB%9F%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%B8%AD%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0\"><span class=\"toc-text\">8. 统计一个文件中字符出现次数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-%E8%BD%AC%E6%8D%A2%E6%B5%81\"><span class=\"toc-text\">9. 转换流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10-%E6%A0%87%E5%87%86%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81\"><span class=\"toc-text\">10. 标准的输入输出流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11-%E6%89%93%E5%8D%B0%E6%B5%81\"><span class=\"toc-text\">11. 打印流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12-%E6%95%B0%E6%8D%AE%E6%B5%81\"><span class=\"toc-text\">12. 数据流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13-%E5%AF%B9%E8%B1%A1%E6%B5%81\"><span class=\"toc-text\">13. 对象流:</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81\"><span class=\"toc-text\">14. 随机存取文件流</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB\"><span class=\"toc-text\">基本知识点汇总</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-BIO-NIO-AIO-%E5%BC%82%E5%90%8C\"><span class=\"toc-text\">b. BIO NIO AIO 异同</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-Unix-IO-%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">c. Unix IO 类型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%98%BB%E5%A1%9E%E5%BC%8FIO\"><span class=\"toc-text\">1. 阻塞式IO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8F-I-x2F-O\"><span class=\"toc-text\">2. 非阻塞式 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-I-x2F-O-%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">3. I&#x2F;O 复用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8-I-x2F-O\"><span class=\"toc-text\">4. 信号驱动 I&#x2F;O</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E5%BC%82%E6%AD%A5-I-x2F-O\"><span class=\"toc-text\">5. 异步 I&#x2F;O</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#e-BIO\"><span class=\"toc-text\">e. BIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BC%A0%E7%BB%9FBIO\"><span class=\"toc-text\">1. 传统BIO</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%BC%A0%E7%BB%9F%E7%9A%84BIO%E7%9A%84%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">2. 传统的BIO的问题</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F-%E4%BC%AA%E5%BC%82%E6%AD%A5%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">3. 多线程方式 - 伪异步方式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#f-NIO\"><span class=\"toc-text\">f. NIO</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E9%80%9A%E9%81%93%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">1. 通道与缓冲区</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-Selector-%E9%80%89%E6%8B%A9%E5%99%A8\"><span class=\"toc-text\">2. Selector(选择器)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-NIO-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3\"><span class=\"toc-text\">3. NIO - IO多路复用详解</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#g-AIO\"><span class=\"toc-text\">g. AIO</span></a></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Linux基础","uid":"144f0b4d9b9f80ea377106e9c6a54a45","slug":"Linux基础","date":"2022-04-08T03:19:19.000Z","updated":"2022-04-08T03:25:19.742Z","comments":true,"path":"api/articles/Linux基础.json","keywords":null,"cover":[],"text":" Linux简介​ Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到 Minix 和 Unix 思想的启发，是一个基于 POSIX 的多用户、多任务、支持...","link":"","photos":[],"count_time":{"symbolsCount":"42k","symbolsTime":"38 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Linux","slug":"Linux","count":2,"path":"api/tags/Linux.json"},{"name":"Linux命令","slug":"Linux命令","count":1,"path":"api/tags/Linux命令.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{"title":"Git基础","uid":"7972c32d39f314ccb6f804289f8a291c","slug":"Git基础","date":"2022-04-07T13:36:21.000Z","updated":"2022-04-07T13:43:22.527Z","comments":true,"path":"api/articles/Git基础.json","keywords":null,"cover":[],"text":"分布式版本控制系统 简单理论四个工作区域： 工作目录 暂存区（Index\\Stage） 仓库区（Repository） 远程仓库（Remote） 基本配置$ git config -l 查看基础配置 本地存放位置 Git\\etc\\gitconfig中 $ git config -...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":7,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Git","slug":"Git","count":1,"path":"api/tags/Git.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}}}