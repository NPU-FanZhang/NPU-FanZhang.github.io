{"title":"Reids","uid":"d1660779e842dc0a9949e0b888a18409","slug":"Redis","date":"2022-04-07T05:26:46.000Z","updated":"2022-04-07T12:48:55.482Z","comments":true,"path":"api/articles/Redis.json","keywords":null,"cover":[],"content":"<h1 id=\"1-NoSQL\"><a href=\"#1-NoSQL\" class=\"headerlink\" title=\"1. NoSQL\"></a>1. NoSQL</h1><p><strong>NoSQL（ NoSQL &#x3D; Not Only SQL ）</strong>，意即不仅仅是 SQL，泛指非关系型的数据库。</p>\n<p>NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。</p>\n<ul>\n<li>不遵循 SQL 标准。</li>\n<li>不支持 ACID。</li>\n<li>远超于 SQL 的性能。</li>\n</ul>\n<p><strong>适用于的场景</strong></p>\n<ul>\n<li>对数据高并发的读写；</li>\n<li>海量数据的读写；</li>\n<li>对数据高可扩展性的。</li>\n</ul>\n<p><strong>不适用的场景</strong></p>\n<ul>\n<li>需要事务支持；</li>\n<li>基于 sql 的结构化查询存储，处理复杂的关系，需要即席查询。</li>\n</ul>\n<p>常见的 NoSQL 数据库</p>\n<ul>\n<li>Redis</li>\n<li>MongoDB</li>\n</ul>\n<h1 id=\"2-Redis-简介\"><a href=\"#2-Redis-简介\" class=\"headerlink\" title=\"2. Redis 简介\"></a>2. Redis 简介</h1><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 <strong>key-value 数据库</strong>。</p>\n<p>Redis 与其他 key - value 缓存产品有以下三个特点：</p>\n<ul>\n<li><strong>Redis支持数据的持久化</strong>，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>\n<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li>\n<li><strong>Redis支持数据的备份，即master-slave模式的数据备份。</strong></li>\n</ul>\n<p><code>Redis 优势</code></p>\n<ul>\n<li>性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。</li>\n<li>丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li>\n<li>原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li>\n<li>丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。</li>\n</ul>\n<h1 id=\"3-数据类型及操作\"><a href=\"#3-数据类型及操作\" class=\"headerlink\" title=\"3. 数据类型及操作\"></a>3. 数据类型及操作</h1><p>Redis 的<strong>基本类型有五个: String、List、Set、Hash、Zset</strong></p>\n<p>Redis <strong>新数据类型: Bitmaps、HyperLogLog、Geospatial</strong></p>\n<p><strong>原子性</strong></p>\n<p>所谓 <strong>原子</strong> 操作是指不会被线程调度机制打断的操作；</p>\n<p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p>\n<ul>\n<li>在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</li>\n<li>在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</li>\n</ul>\n<p>Redis 单命令的原子性主要得益于 <strong>Redis 的单线程。</strong></p>\n<p><code>Key操作</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">keys * \t    # 查看当前库的所有key\nexist key \t# 判断某个key是否存在\ndel key\t    # 删除指定key\nunlink key\t# 根据value 值进行非阻塞删除 真正的删除会在后面进行异步删除\ntype key\t# 判断key类型\nexpire key [10]\t# 为给定的 key 设置过期时间\nttl key\t\t# 查看还有多少秒过期，-1表示永不过期，-2表示已过期\nselect\t\t# 命令切换数据库\ndbsize\t\t# 查看当前数据库的 key 的数量\nflushdb \t# 清空当前库\nflushall\t# 通杀全部库</code></pre>\n\n\n\n\n\n<h2 id=\"a-字符串-String\"><a href=\"#a-字符串-String\" class=\"headerlink\" title=\"a. 字符串 String\"></a>a. 字符串 String</h2><p><strong>String 类型是二进制安全的。</strong>意味着 Redis的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。</p>\n<p>String 类型是 Redis 最基本的数据类型，<strong>一个 Redis 中字符串 value 最多可以是 512M。</strong></p>\n<p><code>常用命令:</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">set &lt;key&gt;&lt;value&gt;\t\t# 添加键值对\nget &lt;key&gt;\t\t\t    # 查询对应键值\nappend &lt;key&gt;&lt;value&gt;\t\t # 将给定的 &lt;value&gt; 追加到原值的末尾\nstrlen &lt;key&gt;\t\t\t# 获得值的长度\nsetnx &lt;key&gt;&lt;value&gt;\t\t # 只有在 key 不存在时，设置 key 的值\nincr &lt;key&gt;\t\t\t\t# 将 key 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（具有原子性）\ndecr &lt;key&gt;\t\t\t\t# 将 key 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1\nincrby&#x2F;decrby &lt;key&gt;&lt;步长&gt; \t\t\t  # 将 key 中储存的数字值增减。自定义步长\nmset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  \t\t# 同时设置一个或多个 key-value 对\nmget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...\t\t    \t# 同时获取一个或多个 value\nmsetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;... \t # 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在\ngetrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;\t\t # 获得值的范围\nsetrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;\t\t\t# 用 &lt;value&gt; 覆写 &lt;key&gt; 所储存的字符串值\nsetex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;\t\t\t# 设置键值的同时，设置过期时间，单位秒。\ngetset &lt;key&gt;&lt;value&gt;\t\t # 以新换旧，设置了新值同时获得旧值。</code></pre>\n\n<p><code>String内部的数据结构</code></p>\n<p><strong>内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配,不能超过512M;</strong></p>\n<h2 id=\"b-列表-List\"><a href=\"#b-列表-List\" class=\"headerlink\" title=\"b. 列表 List\"></a>b. 列表 List</h2><p><strong>单键 - 多值 数据结构</strong></p>\n<p><em>Redis</em> 列表是简单的字符串列表，按照插入顺序排序。<strong>你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</strong></p>\n<p><strong>它的底层实际是个双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p>\n<img src=\"Redis/image-20211022121129201.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<p><code>常用命令</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">lpush&#x2F;rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....\t# 从左边&#x2F;右边插入一个或多个值。\n #eg:  输入 : lpush k1 v1 v2 v3\n #      &gt; lrange k1 0 -1\n #     输出 ：v3 v2 v1 \n #     输入 : rpush k1 v1 v2 v3\n #      &gt; rrange k1 0 -1\n #     输出：v1 v2 v3\nlpop&#x2F;rpop &lt;key&gt;\t\t\t\t\t# 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。\nrpoplpush &lt;key1&gt;&lt;key2&gt;\t\t\t # 从 &lt;key1&gt; 列表右边吐出一个值，插到 &lt;key2&gt; 列表左边。\nlrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;\t\t # 按照索引下标获得元素（从左到右）\nlrange mylist 0 -1 0\t\t\t # 左边第一个，-1右边第一个，（0 -1表示获取所有）\nlindex &lt;key&gt;&lt;index&gt;\t\t\t\t # 按照索引下标获得元素（从左到右）\nllen &lt;key&gt;\t\t\t\t\t\t# 获得列表长度\nlinsert &lt;key&gt; before&#x2F;after &lt;value&gt;&lt;newvalue&gt;\t# 在 &lt;value&gt; 的前面&#x2F;后面插入 &lt;newvalue&gt; 插入值\nlrem &lt;key&gt;&lt;n&gt;&lt;value&gt;\t\t\t # 从左边删除 n 个 value（从左到右）\nlset&lt;key&gt;&lt;index&gt;&lt;value&gt;\t\t\t # 将列表 key 下标为 index 的值替换成 value</code></pre>\n\n<p><code>List内部数据结构</code></p>\n<p><em>List</em> 的数据结构为快速链表 quickList。</p>\n<p>首先<strong>在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。</strong></p>\n<p>它将所有的元素紧挨着一起存储，分配的是一块连续的内存。</p>\n<p><strong>当数据量比较多的时候才会改成 quicklist。</strong></p>\n<p>因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。</p>\n<p><strong>Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。</strong>这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>\n<img src=\"Redis/image-20211022122514593.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<h2 id=\"c-集合-Set\"><a href=\"#c-集合-Set\" class=\"headerlink\" title=\"c. 集合 Set\"></a>c. 集合 Set</h2><p>   Set 对外提供的功能与 List 类似列表的功能，特殊之处在于 <strong>Set 是可以 <strong>自动排重</strong> 的</strong>，当需要存储一个列表数据，又<strong>不希望出现重复数据</strong>时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>\n<p>   <strong>Redis 的 Set 是 String 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的复杂度都是 O(1)。</strong></p>\n<p>一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的时间不变。</p>\n<p><code>常用命令</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... \t# 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略\nsmembers &lt;key&gt;\t\t\t\t# 取出该集合的所有值。\nsismember &lt;key&gt;&lt;value&gt;\t\t # 判断集合 &lt;key&gt; 是否为含有该 &lt;value&gt; 值，有返回 1，没有返回 0\nscard&lt;key&gt;\t\t\t\t\t# 返回该集合的元素个数。\nsrem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....\t# 删除集合中的某个元素\nspop &lt;key&gt;\t\t\t\t\t# 随机从该集合中吐出一个值\nsrandmember &lt;key&gt;&lt;n&gt;\t\t # 随机从该集合中取出 n 个值，不会从集合中删除\nsmove &lt;source&gt;&lt;destination&gt;value\t# 把集合中一个值从一个集合移动到另一个集合\nsinter &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的交集元素\nsunion &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的并集元素\nsdiff &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的差集元素（key1 中的，不包含 key2 中的）</code></pre>\n\n<p><code>Set的内部数据结构</code></p>\n<p><strong>Set 数据结构是字典，字典是用哈希表实现的。</strong></p>\n<h2 id=\"d-哈希-Hash\"><a href=\"#d-哈希-Hash\" class=\"headerlink\" title=\"d. 哈希 Hash\"></a>d. 哈希 Hash</h2><p>Redis hash 是一个键值对集合。</p>\n<p>Redis hash 是一个 String 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p>\n<p>注意 <strong>Redis的Hash类型和String类型的区别。</strong></p>\n<img src=\"Redis/Redis-Hash.png\" alt=\"Redis-Hash\" style=\"zoom:67%;\" />\n\n<p><code>常用命令:</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">hset &lt;key&gt;&lt;field&gt;&lt;value&gt;\t\t# 给 &lt;key&gt; 集合中的 &lt;field&gt; 键赋值 &lt;value&gt;\nhget &lt;key1&gt;&lt;field&gt;\t\t\t    # 从 &lt;key1&gt; 集合 &lt;field&gt; 取出 value\nhmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...  # 批量设置 hash 的值\nhexists &lt;key1&gt;&lt;field&gt;\t\t\t# 查看哈希表 key 中，给定域 field 是否存在\nhkeys &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 field\nhvals &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 value\nhincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;\t # 为哈希表 key 中的域 field 的值加上增量 1 -1\nhsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;\t\t # 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在</code></pre>\n\n<p><code>Hash数据结构:</code></p>\n<p><strong>Hash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。</strong></p>\n<p>当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。</p>\n<h2 id=\"e-有序集合-Zset\"><a href=\"#e-有序集合-Zset\" class=\"headerlink\" title=\"e. 有序集合 Zset\"></a>e. 有序集合 Zset</h2><p>Redis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。</p>\n<p>不同之处是 <strong>zset有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。</strong>集合的成员是唯一的，但是评分可以是重复的。</p>\n<p>因为元素是有序的，所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p>\n<p>访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。</p>\n<p><code>常用命令:</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">zadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…\t\t# 将一个或多个 member 元素及其 score 值加入到有序集 key 当中\nzrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES] \t\t    # 返回有序集 key 中，下标在 &lt;start&gt;&lt;stop&gt; 之间的元素\n# 当带 WITHSCORES，可以让分数一起和值返回到结果集\nzrangebyscore key min max [withscores] [limit offset count]\t \t# 返回有序集 key 中，所有 score 值介于 min 和 max 之间（包括等于 min 或 max ）的成员。有序集成员按 score 值递增（从小到大）次序排列。\nzrevrangebyscore key max min [withscores] [limit offset count]   # 同上，改为从大到小排列\nzincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;\t\t\t# 为元素的 score 加上增量\nzrem &lt;key&gt;&lt;value&gt;\t\t\t\t\t   # 删除该集合下，指定值的元素\nzcount &lt;key&gt;&lt;min&gt;&lt;max&gt;\t\t\t\t    # 统计该集合，分数区间内的元素个数\nzrank &lt;key&gt;&lt;value&gt;\t\t\t\t\t   # 返回该值在集合中的排名，从 0 开始。</code></pre>\n\n<p><code>Zset内部结构:</code></p>\n<p>SortedSet（zset）是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。</p>\n<p>zset 底层使用了两个数据结构</p>\n<ul>\n<li>hash，<strong>hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值</strong></li>\n<li><strong>跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表</strong></li>\n</ul>\n<h2 id=\"f-Bitmaps\"><a href=\"#f-Bitmaps\" class=\"headerlink\" title=\"f. Bitmaps\"></a>f. Bitmaps</h2><p>Redis 提供了 Bitmaps 这个<code>数据类型</code> 来实现位操作。</p>\n<ol>\n<li>Bitmaps 本身不是一个数据类型,实际上是一个01字符串,但是它可以对这个字符串进行位操作。</li>\n<li>Bitmaps 单独提供了一套指令,所以在Redis中使用Bitmaps和使用字符串方式不同, 可以把Bitmaps想象成一个以位为单位的数组,每个单位只能存储01,下标在Bitmaps中成为 <code>偏移量</code>。</li>\n</ol>\n<img src=\"Redis/image-20220322111507259.png\" alt=\"image-20220322111507259\" style=\"zoom:67%;\" />\n\n<p><code>常用命令</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">setbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;\t\t# 给一个指定key的值得第offset位 赋值为value。\ngetbit &lt;key&gt; &lt;offset&gt;\t\t\t    # 返回一个指定key的二进制信息\nbitcount &lt;key&gt; &lt;start&gt; &lt;offset&gt;\t\t# 返回一个指定key中位的值为1的个数(是以byte为单位不是bit)\nbitop &lt;operation&gt; &lt;destkey&gt; key1 key2  \t# 对key1 和key2 执行 operation 并将结果保存到 destkey</code></pre>\n\n<p><code>主要用途</code></p>\n<p>​    主要用来存储大数据量但数据简单的操作,比如统计活跃用户量。</p>\n<h2 id=\"g-HyperLogLog\"><a href=\"#g-HyperLogLog\" class=\"headerlink\" title=\"g. HyperLogLog\"></a>g. HyperLogLog</h2><p>HyperLogLog是Redis的高级数据结构，它在做基数统计的时候非常有用，每个HyperLogLog的键可以计算接近 $2^{64}$ 不同元素的基数，而大小只需要12KB。</p>\n<p>HyperLogLog可以用很少的内存来存储集合的唯一元素。（每个HyperLogLog只有12K加上key本身的几个字节）</p>\n<p>HyperLogLog的结果并不精准，错误率大概在0.81%。</p>\n<p><code>常用操作</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">pfadd &lt;key&gt; &lt;element&gt;[element]  # 添加指定元素到Hyperloglog中\npfcount &lt;key&gt;\t\t\t\t  # 统计key中包含的元素的个数 \t\npfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey] \t# 将两个或多个元素集合合并</code></pre>\n\n\n\n<p><code>主要用途</code></p>\n<p>​    主要用来计算大量数据的基数。</p>\n<h2 id=\"h-Geospatial\"><a href=\"#h-Geospatial\" class=\"headerlink\" title=\"h. Geospatial\"></a>h. Geospatial</h2><p>​    Geo类型 是Geographic地理信息类型的缩写,该元素就是二维坐标,是地图上的经纬度。 Redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p>\n<p><code>常用命令</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">geoadd key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]\n# geoadd china:city 121.49 31.23 shanghai 添加一个位置信息\ngeopos key member [member ...]\t\t\n# geopos china:city shanghai  获取一个城市的信息\ngeodist key member1 member2 [m|km|ft|mi] # 获取两个位置之间的距离 [m|km|ft|mi] 来确定单位\ngeoradius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] # 获取一个经纬度范围内的位置信息</code></pre>\n\n\n\n\n\n\n\n<h1 id=\"4-Redis-配置文件\"><a href=\"#4-Redis-配置文件\" class=\"headerlink\" title=\"4. Redis 配置文件\"></a>4. Redis 配置文件</h1><p>本机安装Redis时,文件的配置路径为 <code>/etc/redis.conf</code></p>\n<p>如果使用docker由镜像生成redis容器,默认是没有配置文件的,需要自己在宿主机进行创建,然后进行配置文件挂载 <code>/docker/redis/conf/redis.conf:/etc/redis/redis.conf \\</code>。</p>\n<p>在配置文件中可以设置：</p>\n<ol>\n<li><p><code>Units 单位</code>，配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit。大小写不敏感。</p>\n</li>\n<li><p><code>INCLUDES 包含</code>，多实例的情况可以把公用的配置文件提取出来。</p>\n</li>\n<li><p><code>NETWORK 网络相关配置</code>。</p>\n<ul>\n<li><p>bind 默认情况 <code>bind=127.0.0.1</code> 只能接受本机的访问请求。不写的情况下，无限制接受任何 ip 地址的访问。<strong>生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，<em>所以需要将其注释掉</em>。</strong></p>\n</li>\n<li><p>protected-mode <strong>如果开启了protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis 只允许接受本机的响应。</strong></p>\n</li>\n<li><p>port 端口号，默认 6379。</p>\n</li>\n</ul>\n</li>\n<li><p><code>GENERAL 通用。</code></p>\n<ul>\n<li><p><strong>daemonize 是否为后台进程，设置为 yes。</strong></p>\n</li>\n<li><p>pidfile  存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件。</p>\n</li>\n<li><p>loglevel 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice。</p>\n</li>\n<li><p>logfile 日志文件名称。</p>\n</li>\n<li><p><strong>database 设定库的数量 默认16，默认数据库为 0，可以使用 <code>SELECT &lt;dbid&gt;</code> 命令在连接上指定数据库 id。</strong></p>\n</li>\n</ul>\n</li>\n<li><p><code>SECURITY 安全。</code></p>\n<p>访问密码的查看、设置和取消。</p>\n<p>在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。</p>\n<p>永久设置，需要在配置文件中进行设置。</p>\n</li>\n<li><p><code>LIMITS  限制。</code></p>\n<ul>\n<li><p>maxclients设置 redis 同时可以与多少个客户端进行连接。默认情况下为 10000 个客户端。</p>\n<p>如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 max number of clients reached 以作回应。</p>\n</li>\n<li><p>maxmemory 建议<strong>必须设置</strong>，否则，将内存占满，造成服务器宕机。</p>\n<p>设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。</p>\n<p>如果 redis 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等。</p>\n</li>\n<li><p>maxmemory-policy</p>\n</li>\n<li><p>volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键（最近最少使用）</p>\n</li>\n<li><p>allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h1 id=\"5-Redis的发布与订阅\"><a href=\"#5-Redis的发布与订阅\" class=\"headerlink\" title=\"5. Redis的发布与订阅\"></a>5. Redis的发布与订阅</h1><p>Redis 发布订阅（ pub&#x2F;sub ）是一种消息通信模式：发送者（ pub ）发送消息，订阅者（ sub ）接收消息。</p>\n<p>Redis 客户端可以订阅任意数量的频道。</p>\n<ol>\n<li>客户端可以订阅频道</li>\n</ol>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-22%2014.18.02.png\" alt=\"img\" style=\"zoom: 33%;\" />\n\n<ol>\n<li>当给这个频道发布消息后，消息就会发送给订阅的客户端</li>\n</ol>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-22%2014.21.40.png\" alt=\"img\" style=\"zoom: 33%;\" />\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">subscribe channel \t\t # 订阅频道\npublish channel hello \t # 频道发送信息</code></pre>\n\n<h1 id=\"6-SpringBoot整合Redis\"><a href=\"#6-SpringBoot整合Redis\" class=\"headerlink\" title=\"6. SpringBoot整合Redis\"></a>6. SpringBoot整合Redis</h1><p>a. 添加pom.xml 依赖</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;!-- redis --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- spring2.X集成redis所需common-pool2--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n\n<p>b. 配置Redis</p>\n<pre class=\"line-numbers language-properties\" data-language=\"properties\"><code class=\"language-properties\">#Redis服务器地址\nspring.redis.host&#x3D; ip\n#Redis服务器连接端口\nspring.redis.port&#x3D;6379\n#Redis数据库索引（默认为0）\nspring.redis.database&#x3D; 0\n#连接超时时间（毫秒）\nspring.redis.timeout&#x3D;1800000\n#连接池最大连接数（使用负值表示没有限制）\nspring.redis.lettuce.pool.max-active&#x3D;20\n#最大阻塞等待时间(负数表示没限制)\nspring.redis.lettuce.pool.max-wait&#x3D;-1\n#连接池中的最大空闲连接\nspring.redis.lettuce.pool.max-idle&#x3D;5\n#连接池中的最小空闲连接\nspring.redis.lettuce.pool.min-idle&#x3D;0</code></pre>\n\n<p>c. Redis 配置类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@EnableCaching\n@Configuration\npublic class RedisConfig extends CachingConfigurerSupport &#123;\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;\n        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();\n        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om &#x3D; new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n\t\t\t\t&#x2F;&#x2F; key序列化方式\n        template.setKeySerializer(redisSerializer);\n\t\t\t\t&#x2F;&#x2F; value序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n\t\t\t\t&#x2F;&#x2F; value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    &#125;\n\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;\n        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n\t\t\t\t&#x2F;&#x2F; 解决查询缓存转换异常的问题\n        ObjectMapper om &#x3D; new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\t\t\t\t&#x2F;&#x2F; 配置序列化（解决乱码的问题）,过期时间600秒\n        RedisCacheConfiguration config &#x3D; \n          RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(600))\n      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager &#x3D; RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    &#125;\n&#125;</code></pre>\n\n\n\n<h1 id=\"7-Redis事务\"><a href=\"#7-Redis事务\" class=\"headerlink\" title=\"7. Redis事务\"></a>7. Redis事务</h1><p><strong>Redis 事务是一个单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>\n<p><strong>Redis 事务的主要作用就是串联多个命令防止别的命令插队。</strong></p>\n<p><strong><code>事务三特性</code></strong></p>\n<ul>\n<li><p>单独的隔离操作</p>\n<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>\n</li>\n<li><p>没有隔离级别的概念</p>\n<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>\n</li>\n<li><p>不保证原子性</p>\n<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</p>\n</li>\n</ul>\n<h2 id=\"a-Multi、Exec、Discard\"><a href=\"#a-Multi、Exec、Discard\" class=\"headerlink\" title=\"a. Multi、Exec、Discard\"></a>a. <em>Multi</em>、<em>Exec</em>、<em>Discard</em></h2><p><strong>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。</strong></p>\n<p>组队的过程中可以通过 Discard 来放弃组队。</p>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-11-02%2010.47.24.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">127.0.0.1:6379&gt; multi\t\t\t\t# 开启事务\nOK\n127.0.0.1:6379(TX)&gt; set key1 val1\t # 进入队列\t\nQUEUED\n127.0.0.1:6379(TX)&gt; set key2 val2\t # 进入队列\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\t\t\t# 开始执行\n1) OK\n2) OK\n# 开始执行之前 使用discard命令可以中断排队</code></pre>\n\n<p>组队中有命令错误，队列中<code>所有命令都不会执行</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379(TX)&gt; set a1 b1\nQUEUED\n127.0.0.1:6379(TX)&gt; set b\n(error) ERR wrong number of arguments for &#39;set&#39; command\n127.0.0.1:6379(TX)&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.</code></pre>\n\n<p>组队中不报错，执行时报错,<code>只有报错的命令会被取消。</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379(TX)&gt; set vas sdad\nQUEUED\n127.0.0.1:6379(TX)&gt; incr vas\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n1) OK\n2) (error) ERR value is not an integer or out of range</code></pre>\n\n\n\n<h2 id=\"b-事务冲突\"><a href=\"#b-事务冲突\" class=\"headerlink\" title=\"b. 事务冲突\"></a>b. 事务冲突</h2><p>多个事务对同一数据进行操作时可能出现冲突。</p>\n<h3 id=\"1-悲观锁\"><a href=\"#1-悲观锁\" class=\"headerlink\" title=\"1. 悲观锁\"></a>1. 悲观锁</h3><p>悲观锁（Pessimistic Lock），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 block 直到成功拿到锁。（效率低）</p>\n<p><strong>一个事务执行时，其他对同一数据进行操作的事务都不能执行。</strong></p>\n<h3 id=\"2-乐观锁\"><a href=\"#2-乐观锁\" class=\"headerlink\" title=\"2. 乐观锁\"></a>2. 乐观锁</h3><p>乐观锁（Optimistic Lock），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是<strong>在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。</strong></p>\n<p><strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。</p>\n<p>Redis 就是利用这种 check-and-set 机制实现事务的。</p>\n<h3 id=\"3-Watch、unwatch\"><a href=\"#3-Watch、unwatch\" class=\"headerlink\" title=\"3. Watch、unwatch\"></a>3. <em>Watch、unwatch</em></h3><p><strong>在执行 multi 之前，先执行 watch key1 [key2]，可以监视一个（或多个 ）key 。如果在事务执行之前这个 key 被其他命令所改动，那么事务将被打断。</strong></p>\n<p>取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或 DISCARD 命令先被执行，那么就不需要再执行 UNWATCH 。</p>\n<h1 id=\"8-持久化\"><a href=\"#8-持久化\" class=\"headerlink\" title=\"8. 持久化\"></a>8. 持久化</h1><p>将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</p>\n<h2 id=\"a-RDB-Redis-DataBase\"><a href=\"#a-RDB-Redis-DataBase\" class=\"headerlink\" title=\"a. RDB(Redis DataBase)\"></a>a. RDB(Redis DataBase)</h2><p>在指定的 <code>时间间隔内</code> 将内存汇总的<code>数据集快照</code>写入磁盘。 即 Snapshot 快照，恢复时是将快照文件直接读到内存里。</p>\n<p><code>备份过程</code></p>\n<p>Redis 会单独<strong>创建一个子进程（fork）来进行持久化</strong>。</p>\n<p>先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 dump.rdb。</p>\n<p><strong>整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。</strong></p>\n<p><strong>RDB 的缺点是最后一次持久化后的数据可能丢失</strong>。</p>\n<p><strong><code>Fork子进程</code></strong></p>\n<ul>\n<li>作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程</li>\n<li>在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 <code>写时复制技术</code></li>\n<li><strong>一般情况父进程和子进程会共用同一段物理内存</strong>，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li>\n</ul>\n<p><code>和RDB有关的配置</code></p>\n<ul>\n<li><p>临时文件名设置。  在 redis.conf 中配置文件名称，默认为 dump.rdb。</p>\n</li>\n<li><p>临时文件保存位置。  rdb 文件的保存路径可以修改。默认为 Redis 启动时命令行所在的目录下。</p>\n</li>\n<li><p><code>stop-writes-on-bgsave-error</code>   即当 redis 无法写入磁盘，关闭 redis 的写入操作。</p>\n</li>\n<li><p><code>rdbcompression</code>    持久化的文件是否进行压缩存储。</p>\n</li>\n<li><p><code>rdbchecksum</code>   完整性的检查，即数据是否完整性、准确性。</p>\n</li>\n<li><p>save   表示达到什么操作数时进行备份。</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">save 60 10000  # 表示 如果60s内 超过 10000个keys改变过,那么触发持久化</code></pre></li>\n</ul>\n<p><code>优点</code></p>\n<ul>\n<li>适合大规模的数据恢复；</li>\n<li>对数据完整性和一致性要求不高更适合使用；</li>\n<li>节省磁盘空间；</li>\n<li>恢复速度快。</li>\n</ul>\n<p><code>缺点</code></p>\n<ul>\n<li>Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；</li>\n<li>虽然 Redis 在 fork 时使用了**<code>写时拷贝技术</code>**，但是如果数据庞大时还是比较消耗性能；</li>\n<li>在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。</li>\n</ul>\n<p><code>RBD的备份过程</code></p>\n<p>​    只需要将 要备份的rdb文件拷贝到备份文件的默认目录下,启动redis即可自动将rdb文件恢复。</p>\n<h2 id=\"b-AOF-Append-Of-File\"><a href=\"#b-AOF-Append-Of-File\" class=\"headerlink\" title=\"b. AOF(Append Of File)\"></a>b. AOF(Append Of File)</h2><p><strong>以日志的形式来记录每个写操作（增量保存），将 <em>Redis</em> 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，<em>Redis</em> 启动之初会读取该文件重新构建数据</strong>。</p>\n<p>如果 <em>Redis</em> 重启就会根据日志文件（如果AOF文件和RDB文件都存在，优先恢复AOF）的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>\n<p>AOF默认不开启。在配置文件中设置 <code>appendonly yes</code> 打开</p>\n<p><strong>执行流程</strong></p>\n<ul>\n<li>客户端的请求写命令会被 <em>append</em> 追加到 <em>AOF</em> 缓冲区内；</li>\n<li><em>AOF</em> 缓冲区根据 <em>AOF</em> 持久化策略 <code>[always,everysec,no]</code> 将操作 <em>sync</em> 同步到磁盘的 <em>AOF</em> 文件中；</li>\n<li><em>AOF</em> 文件大小超过重写策略或手动重写时，会对 <em>AOF</em> 文件 <em>Rewrite</em> 重写，压缩 <em>AOF</em> 文件容量；</li>\n<li><strong><em>Redis</em> 服务重启时，会重新 <em>load</em> 加载 <em>AOF</em> 文件中的写操作达到数据恢复的目的。</strong></li>\n</ul>\n<p><em>AOF</em> 和 <em>RDB</em> 同时开启时，系统默认读取 <em>AOF</em> 的数据（数据不会存在丢失）</p>\n<p><strong>和AOF有关的配置</strong></p>\n<ul>\n<li><code>appendfsync always</code>  时钟同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。</li>\n<li><code>appendfsync everysec</code>  每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。</li>\n<li><code>appendfsync no Redis</code> 不主动进行同步，把同步时机交给操作系统。</li>\n<li><em>Rewrite</em> 压缩当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 <code>bgrewriteaof</code>。</li>\n</ul>\n<p><strong>AOF 修复</strong></p>\n<p>当AOF文件出错时,可以使用 <code>redis-check-aof--fix [文件名]</code> 命令对AOF文件进行修复。</p>\n<p><strong>AOF优势</strong></p>\n<ul>\n<li>备份机制更稳健，丢失数据概率更低；</li>\n<li>可<br>读的日志文本，通过操作 AOF 稳健，可以处理误操作。</li>\n</ul>\n<p><strong>AOF缺点</strong></p>\n<ul>\n<li>比起 RDB 占用更多的磁盘空间；</li>\n<li>恢复备份速度要慢；</li>\n<li>每次读写都同步的话，有一定的性能压力；</li>\n<li>存在个别 Bug，造成不能恢复。</li>\n</ul>\n<h2 id=\"c-AOF和RDB的选择\"><a href=\"#c-AOF和RDB的选择\" class=\"headerlink\" title=\"c. AOF和RDB的选择\"></a>c. AOF和RDB的选择</h2><p>官方推荐两个都启用。</p>\n<p>如果对数据不敏感，可以选单独用 RDB。</p>\n<p>不建议单独用 AOF，因为可能会出现 Bug。</p>\n<p>如果只是做纯内存缓存，可以都不用。</p>\n<h1 id=\"9-Redis-主从复制\"><a href=\"#9-Redis-主从复制\" class=\"headerlink\" title=\"9. Redis 主从复制\"></a>9. Redis 主从复制</h1><p>主机数据更新后根据配置和策略， 自动同步到备机的 master&#x2F;slaver 机制，<strong>Master 以写为主，Slaver 以读为主。</strong></p>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-30%2014.12.36.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p><strong>主从复制的优势</strong></p>\n<ol>\n<li>读写分离，性能扩展</li>\n<li>容灾快速恢复</li>\n<li>一主多从！</li>\n</ol>\n<h2 id=\"a-模拟一主两从复制\"><a href=\"#a-模拟一主两从复制\" class=\"headerlink\" title=\"a. 模拟一主两从复制\"></a>a. 模拟一主两从复制</h2><p>我自己通过Docker模拟实现。</p>\n<ol>\n<li><p>为每个redis容器创建自己的<code>redis.conf</code>文件</p>\n<ul>\n<li><p>先创建一个公用的<code>redis.conf</code></p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># daemonize yes\ndir &#x2F;data\nlogfile &#x2F;data&#x2F;redis.log\nprotected-mode no\n#注释掉，可以远程访问\n#bind 127.0.0.1\n#开启AOF\nappendonly no</code></pre>\n</li>\n<li><p>然后分别创建 <code>redis6370.conf</code> <code>redis6371.conf</code> <code>redis6372.conf</code>,写入对应的配置信息。</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">include &#x2F;redis-cluster&#x2F;redis.conf\npidfile &#x2F;var&#x2F;run&#x2F;redis_6370.pid\nport 6370\ndbfilename dump6370.rdb</code></pre></li>\n</ul>\n</li>\n<li><p>启动三个<em>Redis</em>容器，加载对应的conf文件</p>\n<ul>\n<li><pre><code class=\"sh\">docker run -itd -p 6370:6379 -v /home/redis/redis.conf:/redis-cluster/redis6370.conf -v /home/redis/data/:/data --name redis6370 -e &quot;TZ=Asia/Shanghai&quot; redis  /redis-cluster/redis6370.conf\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n- &#96;&#96;&#96;sh\n  docker run -itd -p 6371:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6371.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data --name redis6371 -e &quot;TZ&#x3D;Asia&#x2F;Shanghai&quot; redis  &#x2F;redis-cluster&#x2F;redis6371.conf</code></pre>\n</code></pre>\n</li>\n<li><p>&#96;&#96;&#96;sh<br>docker run -itd -p 6372:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6372.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data –name redis6372 -e “TZ&#x3D;Asia&#x2F;Shanghai” redis  &#x2F;redis-cluster&#x2F;redis6372.conf</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n3. 随便进入一个redis进程,查看主从信息,发现三个都是主节点\n\n   &#96;&#96;&#96;sh\n   127.0.0.1:6379&gt; info replication\n   # Replication\n   role:master\t\t\t# 主机\n   connected_slaves:0\t # 没有slave节点\n   master_failover_state:no-failover\n   master_replid:1215d3dd30318947c9fbb130adb781e5e250bac5\n   master_replid2:0000000000000000000000000000000000000000\n   master_repl_offset:0\n   second_repl_offset:-1\n   repl_backlog_active:0\n   repl_backlog_size:1048576\n   repl_backlog_first_byte_offset:0\n   repl_backlog_histlen:0</code></pre></li>\n</ul>\n</li>\n<li><p>配置主从关系</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">slaveof [IP] [Port] # 将当前redis服务 作为从机备份到 [ip]:[port]</code></pre>\n\n<p>由于此处使用的是docker,所以得先查看主机的docker的IP地址</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">docker inspect [容器名 redis6370]\n&quot;Networks&quot;: &#123;\n    &quot;bridge&quot;: &#123;\n        &quot;IPAMConfig&quot;: null,\n        &quot;Links&quot;: null,\n        &quot;Aliases&quot;: null,\n        &quot;NetworkID&quot;: &quot;a4b86cbe5c82a4651588bb950df3cd42cd8391bffba939ac5fc43858d1f2be37&quot;,\n        &quot;EndpointID&quot;: &quot;052a96ffb53bdf74a7322adfceba70248f17394a9697951e6d78f21f5bf0b72f&quot;,\n        &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n        &quot;IPAddress&quot;: &quot;172.17.0.8&quot;,\n        &quot;IPPrefixLen&quot;: 16,\n        &quot;IPv6Gateway&quot;: &quot;&quot;,\n        &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n        &quot;GlobalIPv6PrefixLen&quot;: 0,\n        &quot;MacAddress&quot;: &quot;02:42:ac:11:00:08&quot;,\n        &quot;DriverOpts&quot;: null\n    &#125;\n&#125;</code></pre>\n</li>\n<li><p>查看 主机6370 和 从机6371&#x2F;2 对应的信息</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 6371 和 6372 作为 6370的从机\n# 6370\n127.0.0.1:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2   # 得到两个从服务器\nslave0:ip&#x3D;172.17.0.10,port&#x3D;6379,state&#x3D;online,offset&#x3D;602,lag&#x3D;1\nslave1:ip&#x3D;172.17.0.9,port&#x3D;6379,state&#x3D;online,offset&#x3D;602,lag&#x3D;1\nmaster_failover_state:no-failover\nmaster_replid:46570ab087353ccfb3b0314f18f2f2a3cfa6a31f\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:602\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:602</code></pre>\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 6371&#x2F;2\n127.0.0.1:6379&gt; info replication\n# Replication\nrole:slave\t\t# 角色为从机\nmaster_host:172.17.0.8\t# 主机为6370\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:3\nmaster_sync_in_progress:0\nslave_read_repl_offset:1050\nslave_repl_offset:1050\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:46570ab087353ccfb3b0314f18f2f2a3cfa6a31f\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:1050\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:547\nrepl_backlog_histlen:504</code></pre></li>\n</ol>\n<p>在从机上写数据会报错</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 6371\n127.0.0.1:6379&gt; set k1 a\n(error) READONLY You can&#39;t write against a read only replica.</code></pre>\n\n\n\n<h2 id=\"b-主从复制原理\"><a href=\"#b-主从复制原理\" class=\"headerlink\" title=\"b. 主从复制原理\"></a>b. 主从复制原理</h2><ul>\n<li><em>slave</em> 启动成功连接到 <em>master</em> 后会发送一个 <em>sync</em> 命令（同步命令）。</li>\n<li><em>master</em> 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，<em>master</em> 将传送整个数据文件（<em>rdb</em>）到 <em>slave</em>，以完成一次完全同步。</li>\n<li>当主服务进行写操作后，和从服务器进行数据同步。</li>\n<li>全量复制：而 <em>slave</em> 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>\n<li>增量复制：<em>master</em> 继续将新的所有收集到的修改命令依次传给 <em>slave</em>，完成同步。</li>\n<li>只要是重新连接 <em>master</em>，一次完全同步（全量复制）将被自动执行。</li>\n</ul>\n<h2 id=\"c-主从复制常用方式\"><a href=\"#c-主从复制常用方式\" class=\"headerlink\" title=\"c. 主从复制常用方式\"></a>c. 主从复制常用方式</h2><h3 id=\"1-一主两仆\"><a href=\"#1-一主两仆\" class=\"headerlink\" title=\"1. 一主两仆\"></a>1. 一主两仆</h3><p>主机为6370 从机 6371和6372;两个从机平等的作为一个主机的从机。</p>\n<p><strong>从机挂掉</strong></p>\n<p><strong>当从机6371挂掉,重启后,6371不再作为6370的主机,而是作为新的master</strong></p>\n<p><strong>当再次把6380作为6379的从机加入后，从机 会把数据从头到尾复制。</strong></p>\n<p><strong>主机挂掉</strong> </p>\n<p><strong>6371和6372仍然是6370的从机，不会做任何事；</strong><br><strong>当6370重启后，既然是主服务器。</strong></p>\n<h3 id=\"2-薪火相传\"><a href=\"#2-薪火相传\" class=\"headerlink\" title=\"2. 薪火相传\"></a>2. 薪火相传</h3><img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-30%2016.38.15.png\" alt=\"img\" style=\"zoom: 50%;\" />\n\n<p><strong>上一个 <em>slave</em> 可以是下一个 <em>slave</em> 的 <em>master</em></strong>，<strong><em>slave</em> 同样可以接收其他 <em>slave</em>的连接和同步请求</strong>，那么该 <em>slave</em> 作为了链条中下一个的 <em>master</em>，<strong>可以有效减轻 <em>master</em> 的写压力，去中心化降低风险。</strong></p>\n<p>中途变更转向：会清除之前的数据，重新建立拷贝最新的。</p>\n<p><strong>当某个 <em>slave</em> 宕机，后面的 <em>slave</em> 都没法备份。</strong></p>\n<p>即当主机挂掉，从机还是从机，但是无法继续写数据。</p>\n<h3 id=\"3-反客为主\"><a href=\"#3-反客为主\" class=\"headerlink\" title=\"3. 反客为主\"></a>3. 反客为主</h3><p> 当一个 <em>master</em> 宕机后，后面的 <em>slave</em> 可以立刻升为 <em>master</em>，其后面的 <em>slave</em> 不用做任何修改。<strong>手动完成</strong>。</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">slaveof no one</code></pre>\n\n\n\n<h2 id=\"d-哨兵模式\"><a href=\"#d-哨兵模式\" class=\"headerlink\" title=\"d. 哨兵模式\"></a>d. 哨兵模式</h2><p>哨兵模式<strong>自动实现主从切换</strong>，而上面的反客为主需要手动完成。</p>\n<p>能够后台监控主机是否故障，如果故障了<strong>根据投票数自动将从库转换为主库。</strong></p>\n<p><strong>当主机宕机后,会在从机中选举新的主机</strong></p>\n<p><strong>选举规则</strong></p>\n<ul>\n<li><p>根据优先级别，<em>slave-priority&#x2F;replica-priority</em>，优先选择优先级靠前的。</p>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-30%2017.02.50.png\" alt=\"img\" style=\"zoom:50%;\" />\n</li>\n<li><p>根据偏移量，优先选择偏移量大的。</p>\n</li>\n<li><p>根据 <em>runid</em>，优先选择最小的服务。</p>\n</li>\n</ul>\n<p><strong>复制延时</strong></p>\n<p>由于所有的写操作都是先在 <em>master</em> 上操作，然后同步更新到 <em>slave</em> 上，所以从 <em>master</em> 同步到 <em>slave</em> 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，<em>slave</em> 机器数量的增加也会使这个问题更加严重。</p>\n<p><strong>设置哨兵模式的方法</strong></p>\n<ol>\n<li>创建 <em>sentinel.conf</em> 文件</li>\n</ol>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">&#x2F;opt&#x2F;etc&#x2F;sentinel.conf</code></pre>\n\n<ol start=\"2\">\n<li>配置哨兵</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">sentinel monitor mymaster 172.16.88.168 6379 1\n# mymaster：监控对象起的服务器名称\n# 1：至少有多少个哨兵同意迁移的数量。 </code></pre>\n\n<ol start=\"3\">\n<li>启动哨兵</li>\n</ol>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">redis-sentinel  &#x2F;opt&#x2F;etc&#x2F;sentinel.conf </code></pre>\n\n\n\n<h1 id=\"10-Redis-集群\"><a href=\"#10-Redis-集群\" class=\"headerlink\" title=\"10. Redis 集群\"></a>10. <em>Redis</em> 集群</h1><p><strong>集群需要解决的问题</strong></p>\n<p>容量不够，redis 如何进行扩容？</p>\n<p>并发写操作， redis 如何分摊？</p>\n<p>主从模式，薪火相传模式，主机宕机，导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。</p>\n<p><strong>解决方案</strong></p>\n<ul>\n<li><p>代理主机</p>\n<img src=\"Redis/src=http%253A%252F%252Fupload-images.jianshu.io%252Fupload_images%252F5918960-1759ff9c2a48b74f.jpg&refer=http%253A%252F%252Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto\" alt=\"img\" style=\"zoom: 33%;\" />\n</li>\n<li><p>无中心化集群配置</p>\n</li>\n</ul>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-30%2017.21.46.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<p><em>Redis</em> 集群实现了对 <em>Redis</em> 的水平扩容，即启动 <em>N</em> 个 <em>Redis</em> 节点，将整个数据库分布存储在这 <em>N</em> 个节点中，每个节点存储总数据的 <em>1&#x2F;N</em> 。</p>\n<p><em>Redis</em> 集群通过分区（<em>partition</em>）来提供一定程度的可用性（<em>availability</em>），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p>\n<h2 id=\"a-搭建Redis集群\"><a href=\"#a-搭建Redis集群\" class=\"headerlink\" title=\"a. 搭建Redis集群\"></a>a. 搭建Redis集群</h2><p>搭建一个由三对主从服务器组成的redis集群,共六个redis服务器。</p>\n<ol>\n<li><p>创建六个redis服务的conf文件</p>\n<p>六个服务的主从端口号为：6370-6380 6371-6381 6372-6382</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">[root@VM-4-9-centos redis-cluster]# ll\ntotal 32\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6370.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:38 redis6371.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:38 redis6372.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6380.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6381.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6382.conf\n-rw-r--r-- 1 root root 142 Mar 23 19:27 redis.conf</code></pre>\n\n<p>配置文件内容为:</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">include &#x2F;redis-cluster&#x2F;redis.conf\npidfile &#x2F;var&#x2F;run&#x2F;redis_6370.pid\nport 6370\ndbfilename dump6370.rdb\ncluster-enabled yes\ncluster-config-file node6370.conf\ncluster-node-timeout 15000</code></pre>\n</li>\n<li><p>启动六个redis服务器</p>\n<p>启动命令为:</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 此处以6380为例,其他以此类推\ndocker run -itd -p 6380:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6380.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data --name redis6380 -e &quot;TZ&#x3D;Asia&#x2F;Shanghai&quot; redis  &#x2F;redis-cluster&#x2F;redis6380.conf</code></pre>\n\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">[root@VM-4-9-centos redis-cluster]# docker ps\nCONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                                                  NAMES\nc0ddd1a17009   redis         &quot;docker-entrypoint.s…&quot;   4 seconds ago    Up 4 seconds    0.0.0.0:6380-&gt;6379&#x2F;tcp, :::6380-&gt;6379&#x2F;tcp              redis6380\n677f6d098415   redis         &quot;docker-entrypoint.s…&quot;   29 seconds ago   Up 28 seconds   0.0.0.0:6381-&gt;6379&#x2F;tcp, :::6381-&gt;6379&#x2F;tcp              redis6381\ncf71e9f7f3cf   redis         &quot;docker-entrypoint.s…&quot;   2 minutes ago    Up 2 minutes    0.0.0.0:6382-&gt;6379&#x2F;tcp, :::6382-&gt;6379&#x2F;tcp              redis6382\n7657bb60a3ec   redis         &quot;docker-entrypoint.s…&quot;   2 minutes ago    Up 2 minutes    0.0.0.0:6372-&gt;6379&#x2F;tcp, :::6372-&gt;6379&#x2F;tcp              redis6372\ne48e4d898b90   redis         &quot;docker-entrypoint.s…&quot;   3 minutes ago    Up 3 minutes    0.0.0.0:6371-&gt;6379&#x2F;tcp, :::6371-&gt;6379&#x2F;tcp              redis6371\n79232aef9947   redis         &quot;docker-entrypoint.s…&quot;   4 minutes ago    Up 4 minutes    0.0.0.0:6370-&gt;6379&#x2F;tcp, :::6370-&gt;6379&#x2F;tcp              redis6370</code></pre>\n</li>\n<li><p>查看docker中,各个redis服务的IP地址,记录下来</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">docker inspect redis6370  \t# 172.17.0.8\ndocker inspect redis6371  \t# 172.17.0.9\ndocker inspect redis6372  \t# 172.17.0.10\ndocker inspect redis6380  \t# 172.17.0.12\ndocker inspect redis6381  \t# 172.17.0.7\ndocker inspect redis6382  \t# 172.17.0.11</code></pre>\n</li>\n<li><p>进入某一容器中,使用集群搭建命令</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\"># 执行\nredis-cli --cluster create --cluster-replicas 1 172.17.0.8:6370 172.17.0.9:6371 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391</code></pre></li>\n</ol>\n<p><strong>redis cluster 如何分配这六个节点?</strong></p>\n<p>一个集群至少要有三个主节点。</p>\n<p>选项 <code>--cluster-replicas 1</code>，表示希望为集群中的每个主节点创建一个从节点。</p>\n<p>分配原则 <strong>尽量保证每个主数据库运行在不同的 <em>IP</em> 地址，每个从库和主库不在一个 <em>IP</em> 地址上。</strong></p>\n<img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-31%2014.30.26.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n\n\n<p>*<em>什么是 <em>slots</em>？</em>*</p>\n<p>一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个。</p>\n<p>集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。</p>\n<p>集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：</p>\n<ul>\n<li>节点 A 负责处理 0 号至 5460 号插槽。</li>\n<li>节点 B 负责处理 5461 号至 10922 号插槽。</li>\n<li>节点 C 负责处理 10923 号至 16383 号插槽。</li>\n</ul>\n<p><strong>如何在集群中录入值</strong>？</p>\n<p>在 redis-cli 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会报错，并告知应前往的 redis 实例地址和端口。</p>\n<p>redis-cli 客户端提供了 –c 参数实现自动重定向。</p>\n<p>例如 <code>redis-cli -c –p 6379</code> 登入后，再录入、查询键值对可以自动重定向。</p>\n<p><strong>如何查询集群中的值</strong>？</p>\n<p>每个主机只能查询自己范围内部的插槽。</p>\n<p><code>cluster keyslot &lt;key&gt;</code>：查询某个 key 的 slot。</p>\n<p><code>cluster countkeysinslot &lt;slot&gt;</code>：查询某个 slot 是否有值。</p>\n<p><code>CLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;</code>：返回 count 个 slot 槽中的键。</p>\n<p><strong>故障恢复</strong></p>\n<p>如果主节点下线？从节点能否自动升为主节点？注意：15 秒超时。</p>\n<ul>\n<li>当 6379 挂掉后，6389 成为新的主机。</li>\n</ul>\n<p>主节点恢复后，主从关系会如何？<strong>主节点回来变成从机。</strong></p>\n<ul>\n<li>当 6379 重启后，6379 成为 6389 的从机。</li>\n</ul>\n<p>如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续?</p>\n<ul>\n<li>如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage&#x3D;yes，那么 ，整个集群都挂掉。</li>\n<li>如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage&#x3D;no，那么，该插槽数据全都不能使用，也无法存储。</li>\n</ul>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">redis.conf&#96; 中的参数 &#96;cluster-require-full-coverage</code></pre>\n\n\n\n<h2 id=\"b-集群优点\"><a href=\"#b-集群优点\" class=\"headerlink\" title=\"b. 集群优点\"></a>b. 集群优点</h2><ul>\n<li>实现扩容；</li>\n<li>分摊压力；</li>\n<li>无中心配置相对简单。</li>\n</ul>\n<h2 id=\"c-集群缺点\"><a href=\"#c-集群缺点\" class=\"headerlink\" title=\"c. 集群缺点\"></a>c. 集群缺点</h2><ul>\n<li><strong>多键操作是不被支持的；</strong></li>\n<li>多键的 Redis 事务是不被支持的。lua 脚本不被支持；</li>\n<li>由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大</li>\n</ul>\n<h1 id=\"11-Redis-应用问题\"><a href=\"#11-Redis-应用问题\" class=\"headerlink\" title=\"11. Redis 应用问题\"></a>11. <em>Redis</em> 应用问题</h1><h2 id=\"a-缓存穿透\"><a href=\"#a-缓存穿透\" class=\"headerlink\" title=\"a. 缓存穿透\"></a>a. 缓存穿透</h2><img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-31%2015.02.58.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p><strong>现象</strong></p>\n<p><strong>key 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。</strong></p>\n<p>比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。</p>\n<p>造成：</p>\n<ol>\n<li>应用服务器压力变大。</li>\n<li>redis 命中率下降 –&gt; 一直查询数据库 。</li>\n</ol>\n<p><strong>如何解决</strong></p>\n<ul>\n<li><p><strong>对空值缓存</strong></p>\n<p>如果一个查询返回的数据为空（不管是数据是否不存在），仍然<strong>把这个空结果（null）进行缓存</strong>，设置空结果的过期时间会很短，最长不超过五分钟。</p>\n</li>\n<li><p><strong>设置可访问的名单（白名单）：</strong></p>\n<p>使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，<strong>如果访问 id 不在 bitmaps 里面，进行拦截，则不允许访问。</strong></p>\n</li>\n<li><p><strong>采用布隆过滤器</strong></p>\n<p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。</p>\n<p><strong>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</strong></p>\n<p>将所有可能存在的数据哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。</p>\n</li>\n<li><p><strong>进行实时监控</strong></p>\n<p>当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p>\n</li>\n</ul>\n<h2 id=\"b-缓存击穿\"><a href=\"#b-缓存击穿\" class=\"headerlink\" title=\"b.  缓存击穿\"></a>b.  缓存击穿</h2><img src=\"Redis/%E6%88%AA%E5%B1%8F2021-10-31%2015.18.09.png\" alt=\"img\" style=\"zoom:50%;\" />\n\n<p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>\n<ol>\n<li>数据库访问压力瞬间增大。</li>\n<li><strong>redis 中没有出现大量 key 过期，redis 正常运行。</strong></li>\n<li><strong>某个经常访问的 key 过期</strong>，突然有大量访问这个数据</li>\n</ol>\n<p><strong>如何解决</strong></p>\n<ul>\n<li><p><strong>预先设置热门数据</strong></p>\n<p>在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面,<strong>加大这些热门数据 key 的时长。</strong></p>\n</li>\n<li><p>实时调整</p>\n<p>现场监控哪些数据热门，实时调整 key 的过期时长。</p>\n</li>\n<li><p>使用锁</p>\n<p>效率会降低</p>\n</li>\n</ul>\n<h2 id=\"c-缓存雪崩\"><a href=\"#c-缓存雪崩\" class=\"headerlink\" title=\"c. 缓存雪崩\"></a>c. 缓存雪崩</h2><img src=\"Redis/image-20220324152930208.png\" alt=\"image-20220324152930208\" style=\"zoom: 67%;\" />\n\n<p>key 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。</p>\n<p>缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。</p>\n<ol>\n<li>数据库压力变大。</li>\n<li><strong>即极少的时间段，查询大量 key 的集中过期情况。</strong></li>\n</ol>\n<p><strong>如何解决</strong></p>\n<ul>\n<li><p><strong>构建</strong>多级缓存架构****</p>\n<p>nginx 缓存 + redis 缓存 + 其他缓存（ehcache等）</p>\n</li>\n<li><p><strong>使用锁或队列：</strong></p>\n<p>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。</p>\n</li>\n<li><p><strong>设置过期标志更新缓存：</strong></p>\n<p>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。</p>\n</li>\n<li><p><strong>将缓存失效时间分散开：</strong></p>\n<p>比如我们可以<strong>在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低</strong>，就很难引发集体失效的事件。</p>\n</li>\n</ul>\n<h1 id=\"12-分布式锁\"><a href=\"#12-分布式锁\" class=\"headerlink\" title=\"12. 分布式锁\"></a>12. 分布式锁</h1><p>​    随着计算机系统规模的发展,分布式系统越来越多的被应用到商业中。由于分布式系统分布在不同的机器上，将使原有的单机情况下的并发控制锁策略失效，单冲的Java API 并没有提供分布式锁的能力，为了解决这个问题，就<strong>需要一种垮JVM的互斥机制来控制共享资源的访问。</strong></p>\n<p><strong>主流的分布式锁解决方案</strong></p>\n<ol>\n<li>基于数据库实现分布式锁</li>\n<li>基于缓存实现分布式锁，性能最高</li>\n<li>基于Zookeeper，可靠性最高</li>\n</ol>\n<h2 id=\"a-基于Redis的分布式锁实现\"><a href=\"#a-基于Redis的分布式锁实现\" class=\"headerlink\" title=\"a. 基于Redis的分布式锁实现\"></a>a. 基于<em>Redis</em>的分布式锁实现</h2><h3 id=\"1-setnx\"><a href=\"#1-setnx\" class=\"headerlink\" title=\"1. setnx\"></a>1. <em>setnx</em></h3><p>redis中可以使用 <code>setnx</code> 来设置一个带锁的键值对,加锁期间其他的人无法进行修改。</p>\n<p>为了防止一直加锁,可以使用<code>expire</code>设置过期时间。<code>del</code>来删除锁</p>\n<p>为了防止设置过期时间的时候就出现异常,导致设置失败,可以在set的同时进行加锁,并同时设置过期时间。</p>\n<pre class=\"line-numbers language-sh\" data-language=\"sh\"><code class=\"language-sh\">127.0.0.1:6379&gt; setnx user k1  # 设置带锁的user\n(integer) 1\n127.0.0.1:6379&gt; setnx user k2  # 锁没释放,无法再次设置\t\n(integer) 0\n127.0.0.1:6379&gt; setnx user k3\n(integer) 0\n127.0.0.1:6379&gt; del user\t   # 删除锁\t\n(integer) 1\n127.0.0.1:6379&gt; setnx user k3   # 就可以再次设置\t\n(integer) 1\n127.0.0.1:6379&gt; expire user 10\t# 可以设置过期时间\n(integer) 1\n127.0.0.1:6379&gt; ttl user\n(integer) 7\n127.0.0.1:6379&gt; ttl user\n(integer) 6\n127.0.0.1:6379&gt; ttl user\n(integer) 1\n127.0.0.1:6379&gt; ttl user \t# 过期\n(integer) -2\n# 为了防止设置过期时间的时候就出现异常,导致设置失败,可以在set的同时进行加锁,并设置过期时间\n127.0.0.1:6379&gt; set k2 v2 nx ex 12\nOK\n127.0.0.1:6379&gt; get k2\n&quot;v2&quot;\n127.0.0.1:6379&gt; ttl k2\n(integer) 6\n127.0.0.1:6379&gt; ttl k2\n(integer) 4\n127.0.0.1:6379&gt; ttl k2\n(integer) 3</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","text":"1. NoSQLNoSQL（ NoSQL &#x3D; Not Only SQL ），意即不仅仅是 SQL，泛指非关系型的数据库。 NoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。 不遵循 SQL 标准。 不支持 A...","link":"","photos":[],"count_time":{"symbolsCount":"29k","symbolsTime":"27 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":10,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"Redis","slug":"Redis","count":2,"path":"api/tags/Redis.json"},{"name":"分布式缓存","slug":"分布式缓存","count":1,"path":"api/tags/分布式缓存.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-NoSQL\"><span class=\"toc-text\">1. NoSQL</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#2-Redis-%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">2. Redis 简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3. 数据类型及操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E5%AD%97%E7%AC%A6%E4%B8%B2-String\"><span class=\"toc-text\">a. 字符串 String</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E5%88%97%E8%A1%A8-List\"><span class=\"toc-text\">b. 列表 List</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E9%9B%86%E5%90%88-Set\"><span class=\"toc-text\">c. 集合 Set</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#d-%E5%93%88%E5%B8%8C-Hash\"><span class=\"toc-text\">d. 哈希 Hash</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#e-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88-Zset\"><span class=\"toc-text\">e. 有序集合 Zset</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#f-Bitmaps\"><span class=\"toc-text\">f. Bitmaps</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#g-HyperLogLog\"><span class=\"toc-text\">g. HyperLogLog</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#h-Geospatial\"><span class=\"toc-text\">h. Geospatial</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#4-Redis-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">4. Redis 配置文件</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#5-Redis%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E8%AE%A2%E9%98%85\"><span class=\"toc-text\">5. Redis的发布与订阅</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#6-SpringBoot%E6%95%B4%E5%90%88Redis\"><span class=\"toc-text\">6. SpringBoot整合Redis</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#7-Redis%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">7. Redis事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-Multi%E3%80%81Exec%E3%80%81Discard\"><span class=\"toc-text\">a. Multi、Exec、Discard</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">b. 事务冲突</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%82%B2%E8%A7%82%E9%94%81\"><span class=\"toc-text\">1. 悲观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">2. 乐观锁</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-Watch%E3%80%81unwatch\"><span class=\"toc-text\">3. Watch、unwatch</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#8-%E6%8C%81%E4%B9%85%E5%8C%96\"><span class=\"toc-text\">8. 持久化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-RDB-Redis-DataBase\"><span class=\"toc-text\">a. RDB(Redis DataBase)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-AOF-Append-Of-File\"><span class=\"toc-text\">b. AOF(Append Of File)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-AOF%E5%92%8CRDB%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">c. AOF和RDB的选择</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#9-Redis-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">9. Redis 主从复制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">a. 模拟一主两从复制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">b. 主从复制原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">c. 主从复制常用方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%86\"><span class=\"toc-text\">1. 一主两仆</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%96%AA%E7%81%AB%E7%9B%B8%E4%BC%A0\"><span class=\"toc-text\">2. 薪火相传</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8F%8D%E5%AE%A2%E4%B8%BA%E4%B8%BB\"><span class=\"toc-text\">3. 反客为主</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#d-%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">d. 哨兵模式</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#10-Redis-%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">10. Redis 集群</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4\"><span class=\"toc-text\">a. 搭建Redis集群</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E9%9B%86%E7%BE%A4%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">b. 集群优点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E9%9B%86%E7%BE%A4%E7%BC%BA%E7%82%B9\"><span class=\"toc-text\">c. 集群缺点</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11-Redis-%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">11. Redis 应用问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F\"><span class=\"toc-text\">a. 缓存穿透</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#b-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF\"><span class=\"toc-text\">b.  缓存击穿</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#c-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9\"><span class=\"toc-text\">c. 缓存雪崩</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#12-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">12. 分布式锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#a-%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">a. 基于Redis的分布式锁实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-setnx\"><span class=\"toc-text\">1. setnx</span></a></li></ol></li></ol></li></ol>","author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}},"mapped":true,"prev_post":{"title":"Mysql","uid":"7f77c660cadf02b64dd36120e903f5f0","slug":"Mysql","date":"2022-04-07T06:17:50.000Z","updated":"2022-04-07T12:49:22.858Z","comments":true,"path":"api/articles/Mysql.json","keywords":null,"cover":[],"text":"1. 概述MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。 一条SQL语句的执行流程如下: 建立连接。先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。 在完成经典的 ...","link":"","photos":[],"count_time":{"symbolsCount":"8.8k","symbolsTime":"8 mins."},"categories":[{"name":"互联网八股","slug":"互联网八股","count":10,"path":"api/categories/互联网八股.json"}],"tags":[{"name":"数据库","slug":"数据库","count":1,"path":"api/tags/数据库.json"},{"name":"Mysql","slug":"Mysql","count":1,"path":"api/tags/Mysql.json"}],"author":{"name":"张 凡","slug":"张-凡","avatar":"/svg/coke.png","link":"/","description":"少年与爱永不老去 <br/>即使披荆斩棘,丢失怒马鲜衣。","socials":{"github":"https://github.com/Zhang-F4N","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/36174882"},"leetcode":{"icon":"/svg/leetcode.svg","link":"https://leetcode-cn.com/u/zhong-an-zu-zhi-hu-z/"}}}}},"next_post":{}}