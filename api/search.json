[{"id":"4d0cd99506fa5ed9a6631a984ab7b868","title":"Mysql 面试题","content":"Mysql 面试题1. B树和B+树的区别?相同点:\n\n都是多路平衡查找树\n一个节点中都有多个元素,且有序\n\n不同点:\n\nB+树所有关键码都存放在叶节点中;B树关键字集合分布在整颗树中；\nB+树叶节点包含了全部关键码及指向相应数据记录存放地址的指针，且叶节点本身按关键码从小到大顺序连接。\n\n2. InnoDB中B+树有什么特点?\nInnoDB中的B+树叶节点之间是由双向指针连接\nInnoDB中的B+树的叶节点都是一个Page\n\n3. 什么是InnoDB中的page?\n一页默认大小 16384B &#x3D; 16KB\nInnoDB的读取、创建、读入都是以页Page为单位的\n\n页的结构可以理解为:\nclass Page&#123;\n    Page prev; &#x2F;&#x2F; 前一页指针\n    Page next; &#x2F;&#x2F; 下一页指针\n    PageDirectory; &#x2F;&#x2F; 存放数据的目录\n    List&lt;UserRecord&gt; Data; &#x2F;&#x2F; 用户数据项\n    &#x2F;&#x2F; 其他数据项\n&#125;\n\n\n\n目的: 如果每次读取都按照一条一条数据取出,那么每次都会产生一次磁盘IO,时间开销太大,但如果按照Page方式取出,则可以一次取出大量数据,减少磁盘IO次数\n4. InnoDB中的Page是如何产生的?Mysql中的Page都保存在磁盘中,所以对Page的访问很慢,应该尽可能减少访问次数\n每次插入,删除数据都会在一页内进行操作包括维护页目录和用户数据区。\n\n\n\n\n5. 什么是聚簇索引和非聚簇索引?聚集索引：是以主键创建的索引，在叶子节点存储的是表中的数据\n非聚集索引：就是以非主键创建的索引(也叫做二级索引)，在叶子节点存储的是主键和索引列，需要回表查询\n\n聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个\n\n聚集索引中表记录的排列顺序和索引的排列顺序一致；所以查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。缺点：新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页重新排序。\n\n非聚集索引中表记录的排列顺序和索引的排列顺序不一致。\n\n聚集索引是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储不连续。\n\n聚集索引每张表只能有一个，非聚集索引可以有多个。\n\n\n各自优势:\n\n查询聚簇索引可以直接获取数据,非聚簇索引需要回表\n聚簇索引适合用在排序上,非聚簇索引要回表则不合适\n\n各自劣势:\n\n聚簇索引维护非常昂贵\n\n主键如果不是连续自增例如UUID,可能会让索引很慢,甚至比\n\n主键空间较大的话,辅助索引会非常大,因为辅助索引要保存主键值\n\n\n6. InnoDB是如何支持范围查找走索引的?对于范围查找,InnoDB会先通过索引查找搜索范围的边界值,然后再在叶子结点上通过链表进行顺序查找。\n7. 什么是联合索引?对应的B+树时如何生成的?联合索引结构上的叶子节点包含了多个索引列。\ncreate index idx_name on t1(a,b,c); -- 在表t1的a,b,c字段上创建联合索引\n\n在创建对应的索引树时，按照优先级 第一个字段 &gt; 第二个字段 &gt; 第三个字段 … 以此类推来创建索引。\n叶子结点保存的是主键值，然后再回表在聚簇索引中查找对应的数据。\n在联合索引匹配过程中，首先会将联合索引中的第一个索引条件和节点中的第一个索引列进行匹配。如果匹配成功，那么接着匹配第二个索引条件和第二个索引列。依次类推，直到所有的索引条件都完成匹配。\n8. 什么是最左前缀原则?为什么要遵循最左前缀原则才能利用索引?​    当b+树的索引是联合索引的数据结构，⽐如(name,age,sex)的时候，b+树是按照从左到右的顺序来建⽴搜索树的，⽐如当(张三,20,F)这样的数据来检索的时候，b+树会优先⽐较name来确定下⼀步的所搜⽅向，如果name相同再依次⽐较age和sex，最后得到检索的数据；\n​    但当(20,F)这样的没有name的数据来的时候，b+树就不知道下⼀步该查哪个节点，因为建⽴搜索树的时候name就是第一个比较因子,必须要先根据name来搜索才知道下一步去哪里查询。⽐如当(张三,F)这样的数据来检索时，b+树可以⽤name来指定搜索⽅向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，在匹配性别是F的数据了，这便是最左前缀原则。如果给的查询条件中，无左侧字段，只有右边的字段，而只看右边的字段的话在索引中的分布是无序的，所以无法走索引。\n9. Mysql中字符串和数字的类型转换问题字符串转数字 -&gt; 统统转换为数字 0   ‘123’ &#x3D;&#x3D; 0 为真\n数字转字符串 -&gt; 转换为数字对应的字符串  123 &#x3D;&#x3D; ‘123’为真\n10. 什么是索引条件的下推?11. 什么是覆盖索引?查询的字段包括在了索引之中,则不需要回表,这种查询情况叫做覆盖索引.\nselect b from t1; \t\t\t -- 在b字段上创建了索引,查询完成不需要回表\nselect b from t1 where b &#x3D; 1; -- 在b字段上创建了索引,查询完成不需要回表\n\n\n\n12. 有哪些情况会导致索引失效?\n范围查找可能会导致索引失效，因为在非聚簇索引上的范围查找后的结果还需要回表，可能导致时间大于全扫描，所以可能失效。所以范围越小越容易走索引，引擎会根据综合情况决定是否走索引.\n\norder by 可能会导致失效。 \n-- t1表上 b字段存在索引\nselect * from t1 order by b; -- 不会走索引,虽然走索引不用排序,但是需要多次回表\nselect b from t1 order by b; -- 走索引,因为查询的字段都是索引字段\n\n条件语句中 存在类型转换,会导致索引失效\n\n类型转换可能导致索引顺序错误 例如 字符’12’ &lt; 数字1，转换后 ‘1’ 转换为0\n硬走索引会需要对索引上的每个值进行类型转换,开销巨大\n\n\n\n13. Mysql有哪些存储引擎?MySQL给用户提供了这么多存储引擎，包括处理事务安全表的引擎和出来了非事物安全表的引擎。主要的有以下三种:\n\nInnoDB ：MySql 5.6 版本默认的存储引擎。InnoDB 是一个事务安全的存储引擎，它具备提交、回滚以及崩溃恢复的功能以保护用户数据。InnoDB 的行级别锁定以及 Oracle 风格的一致性无锁读提升了它的多用户并发数以及性能。InnoDB 将用户数据存储在聚集索引中以减少基于主键的普通查询所带来的 I&#x2F;O 开销。为了保证数据的完整性，InnoDB 还支持外键约束。\n\nMyISAM ：MyISAM既不支持事务、也不支持外键、其优势是访问速度快，但是表级别的锁定限制了它在读写负载方面的性能，因此它经常应用于只读或者以读为主的数据场景。\n\nMemory：在内存中存储所有数据，应用于对非关键数据由快速查找的场景。Memory类型的表访问数据非常快，因为它的数据是存放在内存中的，并且默认使用HASH索引，但是一旦服务关闭，表中的数据就会丢失\n\n\n14. InnoDB 和 MyISAM 的主要区别?\nInnoDB支持事务 MyISAM不支持事务(但每个操作都是原子的)\nInnoDB支持外键 MyISAM不支持外键\nInnoDB中包含外键的表转为MyISAM的表会失败。\n\n\nInnoDB是聚簇索引 MyISAM是非聚簇索引\n聚簇索引的文件放在主键索引的叶子结点上,因此InnoDB必须有主键。但辅助索引会需要回表\nMyISAM是非聚簇索引,数据文件是分离的,索引文件保存数据文件的指针。\n\n\nInnoDB最小锁粒度是行锁，MyISAM最小锁粒度为表锁\nMyISAM用变量保存了表的具体行数 select count(*) from table;会直接拿出变量值,InnoDB需要全表扫描\n\n15. Mysql 中Varchar(M)最多能存储多少数据?对于varchar(m)类型的列最多可以定义为65535个字节。其中m代表该类型最多存储最多的字符量,但实际存储并不能放这么多。\nMysql对一条记录占用的最大存储空间有限制,出了BLOG和TEXT类型之外,其他的占用字节长度不得超过65535字节。\n16. 事务的基本特性？ACID：原子性、一致性、隔离性、持久性。\n原子性：一个事务中的操作要么全部成功,要么全部失败。\n一致性：数据库总是从一个一致性状态转换到另外一个一致性状态。\n隔离性：一个事务的修改在最终提交前，对其他事务不可见。\n持久性：一旦事务提交，所做的修改就会永久保存在数据库中（落盘）。\n17. 事务并发会引发什么问题？脏读: 读取到另外一个事务未提交的数据的现象就叫脏读。\n不可重复读: 事务B读取了两次数据,在两次读取过程中事务A修改了数据,导致事务B两次读取出来的数据不一致。在同一事务中，前后两次读取的数据不一致现象就称为不可重复读。\n幻读：事务B前后读取同一个范围的数据，在事务两次读取过程中A增加了数据，导致事务B后一次读取到前一次查询没有看到的行。幻读和不可重复读有些类似，但幻读强调的是集合的增减，而不是单个数据的更新。\n18. Mysql有哪些索引?常见的索引可以分为四类: 主键索引、唯一索引、普通索引、前缀索引。\n主键索引：建立在主键上的索引,一张表只能由一个主键索引,不允许有空值。\n唯一索引：建立在UNIQUE字段上的索引被称为唯一索引,一张表可以有多个唯一索引,索引允许列值为空,多个空值不会发生冲突。\n普通索引：建立在普通字段上的索引被称为评估索引。\n前缀索引：建立在字符类型字段的前几个字符建立的索引，而不是整个字段上建索引，减少索引占用空间，提高查询效率。\n19. 如何提高insert性能?\n多个inset合并为一条\n减少了日志量,减少了解析开销\n\n\n修改参数 bulk_insert_buffer_size 调大批量插入缓存\n设置 innodb_flush_log_at_trx_commit = 0\n0 代表log buffer中的数据以每秒一次的频率写入log file中,同时会进行文件系统到磁盘的同步操作,但每个事务commit不会触发任何log buffer到log file的刷新\n1 代表每次事务提交的时候将log buffer中的数据写入到log file,同时触发磁盘同步\n2 代表事务提交会触发log buffer 到 log file 的刷新,并不触发同步,此外,每秒会有一次文件系统到磁盘的同步操作\n\n\n手动设置事务\n默认autocommit每插入一条数据会进行一次commit;为了减少创建事务的消耗,可以手动设置事务,一般设置1000条提交一次。\n\n\n\n20. 介绍一下数据库中的锁？按照锁粒度可以分为：行锁，表锁，页锁，记录锁，间隙锁，临建锁\n按照锁的属性分类：共享锁、排它锁\n按照锁的状态分类：意向共享锁、意向排它锁\n\n共享锁&#x2F;读锁（Share Lock）\n\n共享锁又称读锁,简称S锁,当一个事务为数据加上读锁之后,其他事务只能对该数据加读锁,不能再加写锁。主要是为了支持并发读取。\n\n\n排它锁&#x2F;写锁(Exclusive Lock)\n\n排它锁又称为写锁,简称X锁,当一个事务未数据加上写锁时,这个数据便不能再被添加任何锁,只能等写锁释放再添加其他的锁。\n\n\n表锁\n\n表锁是指锁住的表为整个表,下个事务访问该表时只能等前一个事务释放后在进行操作。\n特点：粒度大 加锁简单 容易冲突\n\n\n行锁\n\n行锁是指锁住的是表的某一行或多行记录,其他事务访问一张表时,只有被锁住的记录不能访问,其他的记录可以正常访问\n特点: 粒度小 加锁麻烦 不容易冲突 并发度高\nInnoDB默认行锁\n\n\n记录锁(Record Lock)\n\n记录锁属于行锁的一种,只不过只能锁住某一条记录\n精准条件命中,并且锁住的条件字段唯一\n加了记录锁之后的数据可以避免在查询的时候被修改的重复读问题,也避免了读未提交的脏读问题\n\n\n页锁(Page Lock)\n\n页锁是Mysql提供的锁粒度介于行级锁和表级锁之间的一种锁，一次锁定相邻的一部分数据。\n特点: 开销和加锁时间介于行锁和表锁之间,可能出现死锁,并发度一般\n\n\n间隙锁(Gap Lock)\n\n属于行锁的一种,间隙锁是在事务加锁后的某一个区间,比如锁住的记录中ID属于(a,b]的一个区间的记录。\n比如数据ID 1,3,7 形成区间 (-n , 1] (1,3] (3,7] (7,+n] 几个区间,锁住的正是这些区间,防止幻读问题\n\n\n临建锁(Next-Key Lock)\n\n属于行锁的一种，并且是InnoDB默认的行锁算法，是行锁和间隙锁的结合,临建锁会锁住查询出来的记录,同时会把查询出来的间隙锁住\n特点: 避免了范围查询时出现脏读,幻读,重复读问题,临建锁之后,范围区间内的数据不允许被插入和修改\n\n\n\n意向锁是一种状态,告知其他事务是否有其他事务锁住了这个数据,并不是实际的锁,为了提高加锁效率\n\n意向共享锁,当一个事务视图对整个表加共享锁之前,需要先获取这个意向共享锁\n\n意向排它锁,当一个事务视图对整个表加排他锁之前,需要先获取这个意向排他锁\n\n\n21. 介绍一下Mysql中的死锁死锁是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待且都无法推进下去的情况。\n如何查看死锁\n\n使用 show engine innodb status 查看最近一次的死锁\n使用 InnoDB Lock Monitor 打开锁监控, 每15s输出一次日志,查看死锁，完毕后记得关闭。\n\n解决死锁的两种常见策略\n\n通过 innodblockwait_timeout来设置超时时间,一直等待到超时而结束\n发起死锁检测,发现死锁后,主动回滚死锁中某一事务,让其他事务继续进行\n\n22. Mysql中主从同步中实现的读写分离原理基于主从复制的读写分离，是我们在单机环境下，数据库的性能到瓶颈了，可以通过读写分离，提高后台服务。存储这一块的增删改查的并发的处理能力，主库专门负责写操作，从库专门负责读操作，主库的数据更改通过主从复制同步到从库\n\n\n主从同步的核心就是其中的 bin log,其中主从复制的过程如下:\n\n在每个事务更新数据完成之前，master在bin log记录这些改变。写入bin log完成后，master通知存储引擎提交事务。\n主节点在 bin log 有变动时, 启动dump process,将变动内容发送给从节点。\n从节点I&#x2F;O线程接收 binlog内容,并将其写入自己的 relay log中。\n从节点启动 sql thread 从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I&#x2F;O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。\n\n由于mysql默认的复制方式是异步的，主库把日志发送给从库后就不关心从库处理情况，可能会导致主库挂了，从库处理失败，这时候从库升级为主库后，日志丢失的问题，为解决这个问题，产生两个概念：\n\n全同步方式\n主库写入binlog后强制同步到从库,所有从库同步完成后才返回客户端,很显然这种方式性能会产生严重影响\n\n半同步方式\n和全同步不同的是,半同步方式在从库写入成功后返回ACK给主库,主库至少接收到一个ACK的确认就认为写操作完成.\n\n\n23. Mysql如何实现分库分表?分库分表分为两类:垂直拆分和水平拆分\n\n垂直拆分主要关注于业务,对吞吐量并没有效果\n水平拆分主要关注于数据本身的特点(如按照userID将同一表中数据分到不同的表中)\n\n我们主要分析的是水平拆分,水平拆分避免不了需要选定一个或几个拆分字段,如时间,id等\n\nhash(userID)拆分\n逻辑拆分(例如按月存储,按年存储等等)\n\n缺点是:\n\n每次查询都需要带上拆分字段\n\n数据统计会很麻烦\n\n\n24. 索引的设计原则\n出现在where子句中的列才有建立索引的价值\n基数比较小的列没有创建索引的必要,比如性别\n特别长的字段,可以只使用前缀来作为索引,减小索引长度和空间大小\n不要过度索引,索引维护是有代价的\n定义有外键的数据列一定要建索引\n频繁更新的字段不适合建索引\n尽量扩展索引而不是新建索引,比如已有a的索引,要添加(a,b)的索引,只需要在原来基础上新建\n对于超长的数据类型比如 text、image、bit 不适合创建索引\n\n25. Mysql执行计划怎么看?使用EXPLAIN关键字来查看执行计划\n+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+-------+\n| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |\n+----+-------------+-------+------------+------+---------------+-----+---------+-----+------+----------+-------+\n- id\t查询标识符。在所有组中，id值越大，优先级越高，越先执行，id如果相同，可以认为是一组，从上往下顺序执行；\n- select_type \t表示查询语句中,每个select语句的类型,包括 simple primary subquery等等\n- table\t该语句查询的表\n- partitions\t该参数用于记录使用的分区信息，NULL表示该表不是分区表\n- type\t连接类型，见后面&quot;执行计划连接类型type&quot;. 索引查询的类型（ALL、index、range、ref、eq_ref、const(system)、NULL）\n- possible_keys\t在该查询中，MySQL可能使用的索引，如果此列是NULL，则没有相关的索引\n- key\tMySQL实际使用的索引。在大多数情况下，key中的值都在possible_key里面\n- key_len\t该列指MySQL决定使用的索引长度。该值体现了在使用复合索引的时候，使用了复合索引的前面哪几个列\n- ref\t列显示哪些列或者常量与key中的索引进行比较,即就是命中的索引名\n- rows\t按照当前执行计划,会读取的行数\n- filtered\t被条件过滤的行数百分比。最大值为100，表示没有行过滤，值从100减小表示过滤增加。 越高越好\n- Extra\t执行计划的额外信息\n\n\n\n26. 事务的隔离级别事务的隔离级别有4个,分别是:\n\n读未提交,read uncommit,可能会读到其他事务未提交的数据,也叫作 脏读\n\n读已提交,read commit,只能读到已经提交的数据,但是可能两次读取结果不一致,叫做 不可重复读 oracle的默认级别\n\n可重复读,repeatable read,这是mysql的默认隔离级别,就是每次读取结果一致,但会导致 幻读 \n\n串行化 serializable, 一般不会使用,会给每一行数据加锁 ,会导致大量的超时和锁竞争问题\n\n\n27. 什么是MVCC?MVCC即多版本并发控制，MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问\nMVCC在MySQL InnoDB中的实现主要是为了提高数据库的并发性能，用更好的方式去处理读-写冲突，做到&#x3D;&#x3D;即使有读写冲突时，也能做到不加锁，非阻塞并发读&#x3D;&#x3D;。\nMVCC保证数据读已提交和可重复读的流程如下:\n\nInnoDB在每行数据都增加三个隐藏字段，一个唯一行号，一个记录创建的版本号，一个记录回滚的版本号。\n\n&#x3D;&#x3D;在每开启一个事务时，会生成一个事务的版本号&#x3D;&#x3D;，被操作的数据会生成一条新的数据行（临时），但是在提交前对其他事务是不可见的，对于数据的更新（包括增删改）操作成功，会将这个版本号更新到数据的行中，事务提交成功，将新的版本号更新到此数据行中，这样保证了每个事务操作的数据，都是互不影响的，也不存在锁的问题。\n\nRead View : 创建一个新事务时，复制一份当前系统中的活跃事务列表。意思是，当前不应该被本事务看到的其他事务id列表。\n例如当前系统中的事务包括 3 4 5 [6 7 8] 9 几个事务其中6,7,8是活动的事务, 3,4,5是已提交的事务,9是未执行的事务 \n这个数组就是一个Read View\n\n当有一个事务要执行时,会查询该事务的Read View,如果自己的事务id在活动事务之前,那么就说明自己访问的数据之前的事务都已经提交,可以访问;如果自己的事务id在活动事务之后,则需要获取上一个版本重新对比,等待之前必要的事务完成才能访问\n\n\n对于Read View快照的生成时机，也非常关键，正是因为生成时机的不同，造成了RC，RR两种隔离级别的不同可见性；\n\n在innodb中(默认repeatable read级别)，事务在begin&#x2F;start transaction之后的第一条select读操作后，会创建一个快照(Read View)，将当前系统中活跃的其他事务记录记录起来\n在innodb中(read committed级别)，事务中每条select语句都会创建一个快照(Read View)\n\n28. ACID分别靠什么保证?\nA原子性: 由undo log保证,它记录了需要回滚的日志信息,用来撤销已经执行的sql\n\nC一致性: 一致性是业务级别的特性,由其他三个特性共同保证。\n\nI隔离性: 由MVCC来保证\n\nD持久性: 由内存和redo log来保证,mysql修改数据的同时在内存和redo log记录这次记录,宕机是从redo log中恢复数据。并且在空闲时间，会根据redo log来进行数据落盘\ninnoDB 的redo log写盘时,事务进入prepare状态,如果prepare成功,binlog写盘,在继续将事务持久化到binlog,持久化成功后,事务进入commit状态,完成事务,后续在系统空闲时落盘\n\n29. Mysql的日志系统Mysql的日志有六种:\n重写日志（redo log）、回滚日志（undo log）、二进制日志（bin log）、\n错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log）\n前三个日志比较重要\n\nundo log 记录的是修改之前的数据,undo log主要用来回滚到某一个版本，是一种逻辑日志。还可以提供多版本并发控制下的读取（MVCC）。undo log 有两个作用：提供回滚和多版本并发控制下的读(MVCC)，也即非锁定读\n在数据修改的时候，不仅记录了redo，还记录了相对应的 undo，如果因为某些原因导致事务失败或回滚了，可以借助该 undo 进行回滚。\n\nredo log 物理格式的日志，记录的是物理数据页面的修改信息（在某个数据页上做了什么修改）和大多数关系型数据库一样，InnoDB 记录了对数据文件的物理更改，并保证总是日志先行，也就是所谓的 WAL，即在持久化数据文件前，保证之前的 redo 日志已经写到磁盘。由于 redo log 是顺序整块写入，所以性能要更好。\n\nbin log 二进制日志（BINLOG日志）记录了所有DDL（数据库定义语言）语句和DML（数据操纵语言）语句，但是不包括查询语句，此日志对于灾难时的数据恢复有非常重要的作用，MySQL的主从复制，就是通过该日志实现的。\nbinlog 是 没有 MySQL sever 层维护的一种二进制日志，与 innodb 引擎中的 redo&#x2F;undo log 是完全不同的日志。其主要是用来记录对 MySQL 数据更新或潜在发生更新的 SQL 语句\n\n\n30. 如何处理 脏读、不可重复读、幻读问题？各个隔离级别会导致的问题：\n读未提交–&gt;脏读\n读已提交–&gt;不可重复读\n可重复读–&gt;幻读\n解决策略一  加锁\n\n脏读: 写加排它锁,读加共享锁。 当某个事务写的时候，其他事务不能读，就不会读到脏数据\n\n不可重复读： 读数据时加读锁，写数据时加写锁。 保证读的过程中没有更新操作，写的过程中没有读操作\n\n幻读: 加间隙锁+行锁\n\n\n解决策略二 事务隔离\n\n脏读: 设置读已提交隔离级别\n\n不可重复读： 可重复读级别\n\n幻读: 串行\n\n\n","slug":"Mysql 面试题","date":"2022-08-10T03:19:19.000Z","categories_index":"互联网八股,面试题","tags_index":"Mysql,面试题","author_index":"张 凡"},{"id":"c975c593c9f6a4e28b749c03dfbcdd4c","title":"TCP/IP面试题","content":"TCP&#x2F;IP面试题1. 什么是网络分层?OSI和TCP&#x2F;IP模型分别是如何分层的?网络为什么要分层？因为，是个复杂的程序都要分层。\n\n\nOSI网络模型包括7层:\n物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层\n\nTCP&#x2F;IP模型将实际应用中较为紧密的几层合并在了一起,\n\n将 物理层和数据链路层合并为网络接口层\n将 会话层表示层应用层合并为应用层\n\n网络接口层-&gt; 网络层(IP&#x2F;ICMP&#x2F;IGMP&#x2F;ARP&#x2F;RARP)-&gt;传输层(TCP&#x2F;UDP)-&gt;应用层\n\n\n\n2. UCP协议报文结构UDP是一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据包的方法。提供面向事务的简单不可靠信息传送服务。\n\n\nUDP协议的特点:\n\nUDP提供了无连接通信，且不对传送数据包进行可靠性保证，适合于一次传输少量数据，UDP传输的可靠性由应用层负责。\nUDP是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并。\n常用的UDP端口号有：53（DNS）、69（TFTP）、161（SNMP）\n使用UDP协议包括：TFTP、SNMP、NFS、DNS、BOOTP。\n\n3. TCP协议报文TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，该协议称为传输控制协议（TCP，Transmission Control Protocol）\n\n\nTCP协议的主要特点:\n\n面向连接；\n可靠通信方式；\n基于流的方式；\n在网络状况不佳的时候尽量降低系统由于重传带来的带宽开销；\n通信连接维护是面向通信的两个端点的，而不考虑中间网段和节点。\n\n为了满足可靠,高效的传输,TCP协议提供以下的策略:\n\n数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；\n到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；\n超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有收到相应的确认，重发分片；\n滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；\n失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层；\n重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；\n数据校验：TCP将保持它首部和数据的检验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到分片的检验和有差错，TCP将丢弃这个分片，并不确认收到此报文段导致对端超时并重发。\n\n4. IP协议报文IP协议，Internet Protocol ，互联网协议，IP协议位于网络层，主要目的是使得网络间能互联通信\nIP是TCP&#x2F;IP协议族中的核心协议，所有TCP、UDP、ICMP和IGMP数据都是通过IP数据报传输。\n\n\n- 版本号：指IP协议所使用的版本。4个位。版本号为0100，4，即IPv4，版本号为6，即IPv6\n- IP首部长度：表示IP包头长度，该字段用4位表示。最常见的报头长度是0101即20位，当IP报头长度不是4字节整数倍时，就需要对填充域填充\n- 区分服务:现在一般用于支持QoS中差分服务模型，实现网络流量优化\n- 总长度：指IPv4数据报的总长度。数据报的最大长度为：2*16-1&#x3D;65535字节，当IP数据报超过最大传输单元MTU后，会被分片处理\n- 标识符：网络中转发的IP报文的长度可以不同，但如果报文长度超过了数据链路所支持的最大长度，则报文就需要分割成若干个小的片段才能在链路上传输。将报文分割成多个片段的过程叫做分片主机将数据报分片后，在发送前，会给每一个分片数据报一个ID值，放在16位的标识符字段中。\n- 标志位：标志字段在IP报头中占3位，\n\t- 第1位作为保留，置0;\n\t- 第2位，分段，有两个不同的取值：该位置0，表示可以分段;该位置1，表示不能分段;\n\t- 第3位，更多分段，同样有两个取值：该位置0，表示这是数据流中的最后一个分段，该位置1，表示数据流未完，后续还有\n- 偏移量：各个IP分片数据报在发送到目的主机时可能是无序的，所以就需要“偏移量”字段来指明“该分片在原数据报中的位置顺序”\n\n\n\n\n\n\n\n5. HTTP1.0&#x2F;1.1协议报","slug":"TCP-IP面试题","date":"2022-08-10T03:00:16.000Z","categories_index":"互联网八股,面试题","tags_index":"计算机网络,TCP/IP,HTTP","author_index":"张 凡"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-08-09T11:23:04.463Z","categories_index":"","tags_index":"","author_index":"张 凡"},{"id":"739ea830e013671a7c881bb81994b122","title":"疑难杂症","content":"a. 编译器相关问题1. Pycharm 使用 Matplotlib 绘制动图，在PyCharm中显示绘制的动图问题.[解决办法]：在设置中将在PyCharm内部显示取消掉。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nb. Windows 有关设置1. 修改Windows11默认的文件夹图标这个UP主提供了解决方案,https://www.bilibili.com/video/BV1eK4y1C7J6?spm_id_from=333.999.0.0\n修改注册表路径 计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Icons没有就新建,设置值 ,只要有下面的 2 3 就行了\n\n","slug":"疑难杂症","date":"2022-05-13T07:48:56.000Z","categories_index":"疑难杂症","tags_index":"Java,Mysql,编译器,IDEA,PyCharm,Spring,Windows","author_index":"张 凡"},{"id":"73914c70a525ea7d633ba7d52ba12831","title":"Java高频八股文","content":"一、Java基础1. 二分查找比较基础,注意边界问题和mid的计算 mid = (l + r) &gt;&gt;&gt; 1;\npublic class MyBinarySearch &#123;\n    &#x2F;*\n     *  搜索次数 log2(M) + 1 向上取整 即就是搜索树的树深\n     * *&#x2F;\n    public static void main(String[] args) &#123;\n        int[] arr &#x3D; &#123;1, 5, 8, 11, 19, 22, 31, 35, 40, 45, 48, 49, 50&#125;;\n        int tar &#x3D; 47;\n        int l &#x3D; 0, r &#x3D; arr.length - 1;\n        while (l &lt;&#x3D; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt;&gt; 1;\n            if (arr[mid] &#x3D;&#x3D; tar) &#123;\n                System.out.println(mid);\n                return;\n            &#125;\n            if (arr[mid] &lt; tar) &#123;\n                l &#x3D; mid + 1;\n            &#125; else &#123;\n                r &#x3D; mid - 1;\n            &#125;\n        &#125;\n        System.out.println(-1);\n    &#125;\n&#125;\n\n\n2. 排序算法a. 冒泡排序&#x2F;*\n* 冒泡排序: 稳定\n* 可优化的点:\n* 1. 每轮判断是否有序,如果有序了就不需要再进行冒泡\n* 2. 每轮冒泡记录最后一次交换的位置,该位置之后的肯定已经有序,下轮只需要排序到记录的位置\n* *&#x2F;\npublic static void bubbling(int[] arr) &#123;\n    int n &#x3D; arr.length - 1;\n    while (true) &#123;\n        &#x2F;&#x2F; 最后一次交换的位置\n        int last &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n; j++) &#123;\n            if (arr[j] &gt; arr[j + 1]) &#123;\n                &#x2F;&#x2F; 如果不发生交换,就说明不需要再进行后面的冒泡\n                int temp &#x3D; arr[j];\n                arr[j] &#x3D; arr[j + 1];\n                arr[j + 1] &#x3D; temp;\n                last &#x3D; j;\n            &#125;\n        &#125;\n        n &#x3D; last;\n        if (last &#x3D;&#x3D; 0) break;\n    &#125;\n&#125;\n\nb. 选择排序&#x2F;*\n* 选择排序\n* 不稳定、\n* *&#x2F;\npublic static void selection(int[] arr) &#123;\n    int n &#x3D; arr.length;\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        int mIdx &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; n - i; j++) &#123;\n            if (arr[mIdx] &lt; arr[j]) &#123;\n                mIdx &#x3D; j;\n            &#125;\n        &#125;\n        int temp &#x3D; arr[mIdx];\n        arr[mIdx] &#x3D; arr[n - i - 1];\n        arr[n - i - 1] &#x3D; temp;\n    &#125;\n&#125;\n\n\n\nc. 插入排序&#x2F;*\n* 插入排序 稳定\n* 性能略高于选择\n* 将数组分为已经由于和无序两部分,\n* 每次从无序选择一个元素,然后在有序部分找到合适插入位置\n* *&#x2F;\npublic static void insert(int[] arr) &#123;\n    int n &#x3D; arr.length;\n\n    for (int i &#x3D; 1; i &lt; n; i++) &#123;\n        int temp &#x3D; arr[i];\n        int j &#x3D; i - 1;\n\n        while (j &gt;&#x3D; 0) &#123;\n            if (arr[j] &gt;&#x3D; temp) &#123;\n                arr[j + 1] &#x3D; arr[j];\n            &#125; else break;\n            j--;\n        &#125;\n        arr[j + 1] &#x3D; temp;\n    &#125;\n&#125;\n\n希尔排序利用 选择和插入排序在数组有序的情况下时间复杂度较低的特性将数组分为不同的组(比如按下标的奇偶来分),\n代码略\nd. 快速排序快排有两种典型实现:\n\n单边快速排序 lomuto实现\n双边快速排序\n\n代码主体分为两部分:\n第一部分为递归调用划分\npublic static void quickSort(int[] arr, int l, int h) &#123;\n    if (l &gt;&#x3D; h) return;\n    int p &#x3D; partition2(arr, l, h);\n    quickSort(arr, l, p - 1);\n    quickSort(arr, p + 1, h);\n&#125;\n\n第二部分有两种实现\n单边循环快排实现:\n&#x2F;*lomuto实现 单边循环快排*&#x2F;\npublic static int partition(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[h];\n    int i &#x3D; l;\n    &#x2F;&#x2F; i j 都是从左边出发,往最后面进行搜索,i代表小于pv的数的边界,j寻找小于pv的数\n    &#x2F;&#x2F; j 一搜到就进行交换\n    for (int j &#x3D; l; j &lt; h; j++) &#123;\n        if (arr[j] &lt; pv) &#123;\n            int temp &#x3D; arr[j];\n            arr[j] &#x3D; arr[i];\n            arr[i] &#x3D; temp;\n            i++;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; pv和最后的i交换\n    int temp &#x3D; arr[i];\n    arr[i] &#x3D; arr[h];\n    arr[h] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;\n\n双边循环快排\n&#x2F;*双边循环快排*&#x2F;\npublic static int partition2(int[] arr, int l, int h) &#123;\n    int pv &#x3D; arr[l];\n    int i &#x3D; l, j &#x3D; h;\n    while (i &lt; j) &#123;\n        &#x2F;&#x2F; 必须先从后往前找\n        while (i &lt; j &amp;&amp; arr[j] &gt; pv) j--;&#x2F;&#x2F; 不能将j--写在while;里,会出现短路运算\n        &#x2F;&#x2F; 这里等于号要特别注意  刚开始 i指向的就是pv位置\n        while (i &lt; j &amp;&amp; arr[i] &lt;&#x3D; pv) i++;\n\n        int temp &#x3D; arr[i];\n        arr[i] &#x3D; arr[j];\n        arr[j] &#x3D; temp;\n    &#125;\n\n    int temp &#x3D; arr[l];\n    arr[l] &#x3D; arr[i];\n    arr[i] &#x3D; temp;\n    System.out.println(Arrays.toString(arr));\n    return i;\n&#125;\n\n\n\n\n\n3. 集合类a. ArrayList扩容机制:\n\n因为懒加载,无参初始化容量为0,第一次使用add添加会扩容为10\n如果使用addAll(arr),扩容至 max&#123;arr的大小,1.5倍&#125;\n空间不够时,会扩容1.5倍 size = size+(size&gt;&gt;1)\n\nIterator迭代器遍历修改问题:\n\nFail-Fast 一旦发现遍历过程中其他人修改,立即抛出异常。典型代表 ArrayList\nFail-Safe 遍历过程中发现有人修改,会促使遍历完成，比如在遍历过程中添加元素，添加的元素并不会在这次遍历访问到。(本质就是在遇到修改时,先拷贝一份用以遍历,再修改一份,遍历完成后拷贝给原来集合) 典型代表 CopyOnWriteArrayList\n\nb. LinkedList vs ArrayList\nLinkedList\n\n基于双向链表,无需连续内存\n随机访问慢\n头尾插入删除快\n需要额外内存保存节点信息\n\n\nArrayList\n\n基于数组实现,需要连续内存\n随机访问快\n尾部插入,删除的性能可以\n其他部分插入删除都需要移动数据,性能会降低\n可以利用CPU缓存,局部性原理\n\n\n\n多数情况下,ArrayList的性能都要高于LinkedList\nc. HashMap底层实现，1.7和1.8的不同\n\n1.7 数组+链表\n1.8 数组+（链表|红黑树）\n\n[注意] 在链表树化时,需要满足两个条件: 1. 数组长度要大于64  2.链表长度大于8(在hash足够随机的情况下,服从泊松分布,选择8时再树化的概率只有0.00000006)\n\n条件1 的原因是因为数组扩容时,可能会让链表缩短 \n红黑树用来避免DoS攻击,防止链表超长时性能下降,树化应该是偶然情况\n\n[退化为链表的情况]:\n\n扩容时拆分树,树元素个数 &lt;&#x3D; 6 时会退化为链表\nremove树节点时,若root||root.left||root.right||root.left.left 有一个为 null时,会退化为链表\n\n[二次哈希]\n在获得HashCode之后,还会进行hashCode = (hashCode ^ (hashCode&gt;&gt;&gt;16))%Cap,这样可以让分布更加均匀\n索引的计算\n索引如何计算\n先计算对象的 hashCode(),再调用HashMap的hash()进行二次哈希,最后 &amp;(capacity-1)得到索引\n\n有了HashCode为什么还要二次hash()?\n二次hash()是为了综合高位数据,让hash分布更加均匀\n\n数组容量为什么是2的n次幂?\n计算索引时,如果容量是2的n次幂,可以使用位与运算代替取模,效率更高\n扩容时,hash&amp;oldCap==0的元素留在原来的位置,其他的新位置=旧位置+oldCap\n\n\n其他问题\n0.75f的负载因子是权衡那俩个方面?\n\n权衡了map容量和搜索速度两方面\n\n\n多线程下会有什么问题?\n\n1.7 下会出现死链问题\n\n1.7 1.8 可能出现数据丢失问题,比如两个线程在添加元素的时刻进行了线程切换,就会丢失某个线程的结果。\n\n\n\n作为key的变量有什么条件？\n1)必须实现hashCode()函数和equals()函数\n2)必须是不可变的对象,不然可能会导致放入后因为修改而找不到\n\nString的hashCode()是如何设计的?\nhash的目标是尽可能的均匀，每一位字符根据下标i，实现 ch*31的i次幂,最后相加为整个字符串的hashCode。\n因为31有较好的散列特性，并且31在运算上可以进行位运算优化\n\n\n4. 枚举类型一个枚举类编译后的代码如下\n枚举类:\nenum Sex &#123;\n    MALE, FEMALE;\n&#125;\n\n编译后字节码对应的类:\nfinal class Sex extends Enum&lt;Sex&gt; &#123;\n    public static final Sex MALE;\n    public static final Sex FEMALE;\n\n    private Sex(String name, int ordinal) &#123;\n        super(name, ordinal);\n    &#125;\n    static &#123;\n        MALE &#x3D; new Sex(&quot;MALE&quot;, 0);\n        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 0);\n        $VALUES &#x3D; $values();\n    &#125;\n\n    private static final Sex[] $VALUES;\n\n    private static Sex[] $values() &#123;\n        return new Sex[]&#123;MALE, FEMALE&#125;;\n    &#125;\n\n    public static Sex valueOf(String value) &#123;\n        return Enum.valueOf(Sex.class, value);\n    &#125;\n&#125;\n\n\n\n\n5. 单例模式单例模式：一个类只能实现一个实例。\n5种实现方式\n饿汉式\n\n&#x2F;*\n * 1. 饿汉式\n * 唯一实例会提前创建,在类调用时就会创建\n * 可能会通过以下方法破坏单例\n * a. 通过反射,调用私有构造,可以在构造方法中预防\n * b. 实现了Serializable接口的类,通过反序列化破坏单例,实现readResolve()预防\n * c. unsafe破坏单例 无法预防\n * *&#x2F;\n&#x2F;&#x2F; 实现序列化接口可以通过反序列化\npublic static class Singleton1 implements Serializable &#123;\n\n    &#x2F;&#x2F; 私有构造\n    private Singleton1() &#123;\n        &#x2F;&#x2F; 预防反射破坏单例\n        if (INSTANCE !&#x3D; null) &#123;\n            throw new RuntimeException(&quot;单例对象不能重复创建&quot;);\n        &#125;\n        System.out.println(&quot;private Singleton&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 唯一实现\n    private static final Singleton1 INSTANCE &#x3D; new Singleton1();\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton1 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; 防止反序列化破坏单例\n\n    public Object readResolve() &#123;\n        return INSTANCE;\n    &#125;\n\n    &#x2F;&#x2F; ... 其他方法\n&#125;\n\n\n枚举饿汉式\n\n&#x2F;*\n* 2. 枚举饿汉式\n* a. 通过反射,无法进行破坏\n* b. 也无法通过反序列化破坏单例\n* c. unsafe破坏单例 无法预防\n* *&#x2F;\npublic enum Singleton2 &#123;\n    INSTANCE;\n    Singleton2() &#123;\n        System.out.println(&quot;private Singleton2&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 提供获取方法\n    public static Singleton2 getInstance() &#123;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;\n\n\n懒汉式\n\n&#x2F;*\n* 3. 懒汉式\n* 在第一次调用 getInstance 才会初始化\n* *&#x2F;\nclass Singleton3 &#123;\n    private static Singleton3 INSTANCE &#x3D; null;\n\n    private Singleton3() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n\n    &#x2F;&#x2F; 加上synchronized防止多线程同时进入 INSTANCE &#x3D; new Singleton3();\n    public static synchronized Singleton3 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            INSTANCE &#x3D; new Singleton3();\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;\n\n\nDCL懒汉式\n\n[注意] 加volatile来防止指令重排序问题\n&#x2F;*\n* 4. DCL懒汉式\n* 方法三 synchronized 加载静态方法上,相当于加在Singleton4.class上,每次调用这个类都会加锁\n* 多线程下效率过低,创建单例后其实可以避免每次加锁\n* *&#x2F;\nclass Singleton4 &#123;\n    &#x2F;*\n    * 双检查锁要加 volatile\n    * volatile解决共享变量的 可见性和有序性的问题\n    * JVM在将代码编译为字节码后,在执行时,可能会因为优化而改变指令的执行顺序(指令重排序)\n    * 在单线程情况可以正常执行,但是多线程就有可能出现问题\n    * *&#x2F;\n    private static volatile Singleton4 INSTANCE &#x3D; null;\n\n    private Singleton4() &#123;\n        System.out.println(&quot;private Singleton3&quot;);\n    &#125;\n    &#x2F;&#x2F; 双检查锁机制\n    public static Singleton4 getInstance() &#123;\n        if (INSTANCE &#x3D;&#x3D; null) &#123;\n            synchronized (Singleton4.class) &#123;\n                if (INSTANCE &#x3D;&#x3D; null) &#123;\n                    INSTANCE &#x3D; new Singleton4();\n                &#125;\n            &#125;\n        &#125;\n        return INSTANCE;\n    &#125;\n    &#x2F;&#x2F; ... 其他方法\n&#125;\n\n\n内部类懒汉式\n\n&#x2F;*\n* 5. 内部类懒汉式\n* 第一次调用getInstance才会触发内部类的加载链接初始化\n* *&#x2F;\nclass Singleton5 &#123;\n    private Singleton5() &#123;\n        System.out.println(&quot;private Singleton5&quot;);\n    &#125;\n\n    private static class Holder &#123;\n        static Singleton5 INSTANCE &#x3D; new Singleton5();\n    &#125;\n\n    public static Singleton5 getInstance() &#123;\n        return Holder.INSTANCE;\n    &#125;\n    &#x2F;&#x2F; .. 其他方法\n&#125;\n\n\n\n6. 易混知识点a. 重载和重写的区别重载 : 发生在同一个类中,方法名必须相同, 参数类型不同,个数不同,顺序不同\n[ 注意 ]返回值不同,访问修饰符不同不算重载\n重写 :  发生在父子类中, 方法名,参数列表必须相同,返回值范围小于等于父类,抛出异常的范围小于等于父类,访问修饰符范围大于等于父类,如果父类方法访问修饰符为private,则子类就不能重写该方法\nb. 接口和抽象类的区别\n抽象类 可以存在普通成员函数,而 接口 中只能存在 public abstract 方法\n抽象类 成员变量可以是各种类型,而 接口 中的成员变量只能是 public static final\n抽象类 只能继承一个, 接口 可以多实现\n\n概念上:\n\n抽象类: 是对类本质的抽象 is-a 的关系\n\n设计目的: 代码复用\n抽象类不允许被实例化出来\n\n\n接口: 是对类的行为的约束 like-a 的关系\n\n核心: 是定义行为\n\n\n\nc. List和Set的区别\nList：有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出 所有元素，在逐一遍历，还可以使用get(int index)获取指定下标的元素 \nSet：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元 素，在逐一遍历各个元素\n\n小知识点\nstatic变量的初始化会被JVM放入静态代码块中,静态代码块中的代码不用考虑多线程的并发问题,有JVM控制。\n\n二、并发篇本篇详细内容可以参考https://zhang-f4n.github.io/post/JUC,这里主要介绍面试考点\n并发三大特性: 原子性 可见性 有序性\n1. 线程状态操作系统5种状态\n2. 线程池核心参数public ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t&#x2F;&#x2F; 常驻线程数量 可以为0\n                          int maximumPoolSize,\t\t\t\t&#x2F;&#x2F; 最大线程数量\n                          long keepAliveTime,\t\t\t\t&#x2F;&#x2F; 线程存活时间\n                          TimeUnit unit,\t\t\t\t\t&#x2F;&#x2F; 存活时间单位\n                          BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 阻塞队列\n                          ThreadFactory threadFactory,\t\t  &#x2F;&#x2F; 线程工厂,用于创建线程,为线程提供名字\n                          RejectedExecutionHandler handler) &#123;&#125; &#x2F;&#x2F; 拒绝策略,当线程池爆满时的拒绝接收线程的策略\n    \n&#x2F;&#x2F; 线程池的使用\nExecutorService threadPool &#x3D; new ThreadPoolExecutor(\n    2,\n    5,\n    2L,\n    TimeUnit.SECONDS,\n    new ArrayBlockingQueue&lt;&gt;(3),\n    Executors.defaultThreadFactory(),\n    new ThreadPoolExecutor.AbortPolicy());\n&#x2F;&#x2F; 自定义线程池使用\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为5的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        threadPool.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool.shutdown();\n&#125;\n\nRejectedExecutionHandler 线程池的饱和拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:\n\nAbortPolicy: 直接抛出异常，默认策略；\nCallerRunsPolicy: 用调用者所在的线程来执行任务；\nDiscardOldestPolicy: 丢弃阻塞队列中靠最前的任务，并执行当前任务；\nDiscardPolicy: 直接丢弃任务；\n\n\n3. HashTable 和 ConcurrentHashMap\nHashTable 和 ConcurrentHashMap都是线程安全的Map集合,键值不能为空\nHashTable 并发度低,这个Hashtable公共一把锁,同一时刻,只能由一个线程操作它\nConcurrentHashMap\n1.8之前 使用 segment + 数组 + 链表的形式,每个Segment对应一把锁,多个线程访问不同的segment不会冲突\n1.8开始 将数组的每个头节点作为锁,如果多个线程访问的头结点不同,则不会冲突\n\n\n\n4. ThreadLocalThreadLocal 可以实现[资源对象]的线程隔离,让每个线程各用各的[资源对象],避免引发线程安全问题,同时实现了线程内的资源共享(不同方法都可以访问)\n「线程内资源共享 线程间资源隔离」\n其原理就是，每一个线程内都有ThreadLocalMap类型的成员变量，用来存储资源对象\n\n调用set方法时，以ThreadLocal自己作为key，资源对象作为value，放入当前线程的ThreadLocalMap集合中\n调用get方法，以ThreadLocal自己作为key，到当前线程中查找相关联的资源值\n调用remove方法，就是以ThreadLocal自己作为key，移除当前线程相关的资源值\n\n\n为什么ThreadLocalMap中的key要设计为弱引用?\nThread可能长时间运行,如果key不再使用,需要在内存不足时去释放占用的内存\n但GC仅仅是让key的内存释放,后续还要根据key是否为null来进一步释放值的内存,释放的时机有\n获取key时发现 null key\nset key时,会使用启发式扫描, 清理临近的null key,启发次数与元素个数,是否发现null key\nremove时(推荐) ,一般ThreadLocal作为静态变量,GC无法回收\n\n\n\n\n\n5. 小知识点a. 对比 sleep(long) 和 wait(long)\n sleep(long) 和 wait(long)的效果都是让当前线程暂时放弃CPU的使用权,进入阻塞状态\n\n方法归属不同:\nsleep是 Thread 的静态方法\nwait 是 Object 的成员方法,每个对象都有\n\n\n醒来时机不同\n都会在等待相应的毫秒数后醒来,都可以被打断(interrupt)唤醒\nwait还可以被notify唤醒,wait()如果不唤醒就会一直等待下去\n\n\n锁特性不同\nwait方法必须先获取wait对象锁,sleep无此限制\nwait方法执行后会释放对象锁,允许其他线程获得该对象锁\nsleep如果在synchronized代码块中执行,并不会释放对象锁\n\n\n\npublic class MyWaitSleep &#123;\n    static final Object LOCK &#x3D; new Object();\n    public static void main(String[] args) throws InterruptedException &#123;\n&#x2F;&#x2F;        illegalWait();\n        waiting();\n    &#125;\n    private static void illegalWait() throws InterruptedException &#123;\n&#x2F;&#x2F;        LOCK.wait(); 报错 须配合 对象锁\n        synchronized (LOCK) &#123; &#x2F;&#x2F; wait 锁必须配合 对象锁 使用,不然会报错\n            LOCK.wait();\n        &#125;\n    &#125;\n    private static void waiting() throws InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(() -&gt; &#123;\n            synchronized (LOCK)&#123;\n                try &#123;\n                    System.out.println(&quot;t1 -- &gt; waiting&quot;);\n                    Thread.sleep(5000L);&#x2F;&#x2F; 不会释放LOCK锁\n                    LOCK.wait(5000L); &#x2F;&#x2F; 会释放LOCK锁\n                &#125;catch (InterruptedException e)&#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;t1&quot;);\n        t1.start();\n&#x2F;&#x2F;        t1.interrupt();&#x2F;&#x2F; 可以用来强制唤醒\n        Thread.sleep(100);\n        synchronized (LOCK)&#123;&#x2F;&#x2F; 如果t1 内使用 sleep,那么就得等待\n            System.out.println(&quot;main&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n\nb. 对比 lock 和 synchronized\n\n语法层面\nsynchronized 是关键字,用c++实现的\nLock是接口,由jdk提供\nsynchronized 退出同步代码块会自动释放,Lock需要调用unlock释放\n\n\n功能层面\n都是悲观锁,都具备互斥,同步,锁重入功能\nLock 提供了许多 synchronized 不具备的功能,例如获取等待状态,公平锁,可打断,可超时,多条件变量\nLock有很多不同的实现,ReentrantLock,ReentrantReadWriteLock\n\n\n性能层面\n没有竞争是,synchronized有许多优化,比如偏向锁,轻量级锁,性能不赖\n竞争激烈时,Lock的实现通常会提供更好的性能\n\n\n\nc. volatile 能否保证线程安全\n线程安全要考虑三个方面: 可见性、有序性、原子性\n\n可见性：一个线程对共享变量修改，另外一个线程能看到最新结果\n有序性：一个线程内代码按编写的顺序执行\n原子性：一个线程内多行代码以一个整体执行，并不能保证原子性\n\nvolatile 能够保证共享变量的可见性与有序性,并不能保证原子性。\nd. java 中的悲观锁和乐观锁\n悲观锁的代表是 synchronized和Lock锁\n\n核心思想[线程只要占有了锁,才能操作共享变量,每次只有一个线程占锁成功,获取锁失败的线程,都得等待]\n线程从运行到阻塞,再从阻塞到唤醒,涉及线程上下文切换,如果频繁发生,影响性能\n实际上,线程获取synchronized和lock锁时,如果锁已经被占用,会重试,减少阻塞机会\n\n乐观锁代表是AtomicInteger,使用cas来保证原子性\n\n核心思想是[无须加锁,不断重试,但是只有一个线程能成功修改,直到重试成功]\n需要多核支持,且线程数不能超过核数\n线程一直运行,不需要阻塞,因此不涉及上下文切换\n\ncas-&gt;CompareAndSet,比较后赋值,在最后的赋值前对比拿到的值是否和进入时拿到的值一致,不一致就false,一致才赋值\n在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。\n三、虚拟机1. Java 虚拟机内存结构\n\n\n\na. 这些内存区域中,哪些会产生内存溢出?\n不会产生内存溢出的区域:程序计数器\n会出现内存溢出的区域分为两类:\n\n出现OutOfMemoryError\n堆内存耗尽    - 对象太多,但又不能回收会报错\n方法区内存耗尽 - 加载的类越来越多,很多框架会在运行期间动态产生新的类\n虚拟机栈累计   - 每个线程最多1M内存,线程越来越多,但又未销毁时会出现溢出\n\n\n出现StackOverFlowError\n虚拟机栈内部 - 方法调用次数过多(比如递归)\n\n\n\nb. 方法区、永久代、元空间之间的关系\n\n方法区: 方法区是JVM规范中的一种定义,是一块存储元数据,方法字节码,即时编译器需要的信息的内存\n永久代: 是HotSpot虚拟机对JVM的实现(1.8之前)\n元空间: 是HotSpot虚拟机对JVM的实现,使用本地内存保存这些信息(1.8之后)\n\nc. Java虚拟机内存参数\n[ 注意 ]这里指的是堆内存\n\n-Xmx 10240M  虚拟机最大内存\n\n-Xms 10240M  虚拟机最小内存\n\n-Xmn 5120M   虚拟机新生代内存大小\n\n-XX:MaxNewSize 新生代最大大小\n\n-XX:NewSize    常用的新生代大小\n\n-XX:SurvivorRatio=4  伊甸园区和幸存者者内存比例\n\n-XX:NewRatio=2  老年代和新生代内存的比例\n\n\n\n\n\n\n2. 垃圾回收\n标记清除\n\n从 GC Root 出发,能访问到的都标记,标记的都不清除\n\n会产生内存碎片\n\n\n\n标记整理 - 常用于老年代\n\n和标记清除一样,但会在最后进行内存移动整理,避免产生内存碎片\n但是移动过程耗时\n\n\n标记复制 - 常用于新生代,因为新生代对象存活少\n\n多开辟一半内存,在整理过程中,不清理的部分整体复制到另外一部分,不用考虑是否需要清理等问题(提高了整理效率)\n但是内存利用率低了\n\n\n\na. 谈谈GC和分代回收算法\nGC特点:\n\nGC的目的在于实现对于无用对象内存的自动释放,减少内存碎片,加快内存分配速度\nGC回收的区域是堆内存,不包括虚拟机栈,栈内存在方法调用结束会自动释放内存\n判断无用对象,使用的是 可达性分析算法 ,用 三色标记法 来标记存活对象,回收未标记对象\nGC的具体实现被称为 垃圾回收器 ,如 并行垃圾回收器 、 CMS 、G1\nGC大部分采用了 分代回收思想,理论依据是根据大部分对象朝生夕灭,用完立刻回收,另有少部分对象长时间存活,每次很难回收,根据这两类对象的特性将回收区域分为 新生代 和 老年代 ,不用区域使用不同的回收策略\nGC依据回收的规模,可以分为 Minor GC,Mixed GC,Full GC\n\n分代回收:\n\n伊甸园 eden: 初始的对象都分配在这里,与幸存者区合称新生代\n幸存者区 survivor: 当伊甸园内存不足,回收后的幸存对象到这里,分为 from 和 to ,采用 标记复制算法\n老年代 old: 当幸存者对象熬过几次回收(最多15次),晋升到老年代(幸存区内存不足或大对象会导致提前晋升)\n\n\n\nGC规模:\n\nminorGC 发生在新生代,时间短\nMixedGC 新生代+老年代部分区域回收,G1收集器特有\nFullGC 新生代+老年代完整垃圾回收,时间长,应尽量避免\n\nb.三色标记和并发漏标问题\n用三种颜色记录对象的标记状态:\n\n黑色 - 已经完成标记\n灰色 - 正在标记中\n白色 - 还未标记处理\n\n标记的过程,就像广度优先搜索一样,在初始时都是白色,在逐次的标记时,慢慢实现对所有的对象标记,最后剩下的白色对象全部进行清理。\n漏标问题的产生：\n\n多线程之前：由于线程和GC工作是不会并行的，所以不会产生漏标问题。\n多线程情况下： 由于线程和GC可能并行工作，可能会出现在GC标记过程中，引用关系发生变化的情况，导致对象漏标\n在GC运行时，白色对象被引用的黑色节点，由于黑色节点已经处理过，导致其没有被标记而清理\n\n\n\n\n\n漏标的解决方案 - 原理是记录发生变化的对象:\n\n增量更新 increment Update \n只要赋值发生变化,被赋值的对象就被记录,然后会重新扫描这些赋值的对象\n\n原始快照 Snapshot At The Beginning SATB\n\n新加的对象会被记录\n被删除引用关系对象也被记录\n\n\n\nc. Parallel GC\n\neden 内存不足时发生Minor GC,标记复制STW\nold 内存不足时发生Full GC ,标记整理STW\n吞吐量高,但是会STW,在STW时采用多线程回收垃圾,所以叫Parallel GC\n\nd. CMS - ConcurrentMarkSweep GC\n\nold并发标记,重新标记时会STW,并发清除\nFailback Full GC,失败时会触发Full GC\n注重响应时间\n\ne. G1 GC\n\n兼顾响应时间和吞吐量\n划分多个区域,每个区域都当做 eden、survivor、old、humongous\n新生代回收: eden内存不足 标记复制 STW\n并发标记(old 占比达到45%以上): old并发标记,不会暂停,但是漏标时,重新标记会需要STW\n混合收集: 并发标记完成,开始混合收集,参与复制的有eden、survivor、old、其中old会根据 暂停时间目标,选择部分回收价值高的区域,复制时会STW\nFailback Full GC\n\n\n\n\n\n3. 内存溢出问题a. 误用线程池导致内存溢出,怎么解决?\n\n使用newFixedThreadPool()导致\n\n此函数有等待队列,在线程池满时,再来新的任务,会加到任务等待队列(没有设置上限)后,过多会导致堆内存溢出。\n\n解决方案： 不使用官方工具类的线程池，或者自己对任务队列进行限制\nExecutorService executorService &#x3D; Executors.newFixedThreadPool(2);\nwhile (true) &#123;\n    executorService.submit(() -&gt; &#123;\n        try &#123;\n            TimeUnit.SECONDS.sleep(30);\n        &#125; catch (InterruptedException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n    &#125;);\n&#125;\n\n使用 newCachedThreadPool()导致\n\n此线程池中有急救线程,上限很大,可能在使用过程中过多的创建线程导致线程池溢出。\n\n解决方法： 不使用官方工具类的线程池，或者自己对救急线程数目上限进行限制\n\n\nb. 查询数据量太大,导致内存溢出,怎么解决?\n生产环境中，比如在编写findAll方法时,对象数据过大,会导致内存溢出\n解决方案: 在查询时进行限制,如添加limit,保证在内存允许范围内\nc. 动态生成类,导致内存溢出,怎么解决?\n比如在执行自己写的脚本时,如果自己写的类加载器等没有结束时,类就不能释放,如果不断生成类,就会导致MetaSpace(元空间&#x2F;方法区)溢出\n解决方案:将类加载器不要设置为static等,缩短生命周期,让它可以被GC回收\n4. 类加载过程、双亲委派机制类加载过程分为三个阶段:\n\n加载\n将类的字节码载入方法区,创建类.class对象\n如果类的父类没有加载,先加载父类\n加载是懒执行(用到时才会触发类加载)\n\n\n链接\n验证 - 验证类是否符合Class规范,合法性,安全性检查\n准备 - 为static变量分配空间,设置默认值 (并不会进行构造初始化,final会赋值)\n解析 - 将常量池的符号引用解析为直接引用\n\n\n初始化\n执行静态代码块 与 非final静态变量的赋值\n初始化为懒执行\n\n\n\n[ 注意 ] \n\nfinal static 修饰的基本类型的调用,不会触发类的加载\nfinal static 修饰的引用类型的调用,会触发类的加载\n\n双亲委派机制:\n指优先委派上级类加载器进行加载,如果上级类加载器\n\n能找到这个类,由上级加载,加载后的类也对下级类加载器可见\n找不着这个类,则下级类加载器才有资格执行加载 下级加载的类对上级不可见\n\n\n\n\n\n\n能不能自己写个类叫 java.lang.System?\n不能。\n\n假设自己的类加载器使用双亲委派，那么就会先由Bootstrap加载系统的java.lang.System,导致自己的加载失败\n如果自己的类加载器不使用双亲委派,那么自己的类加载器加载假冒的java.lang.System时,需要先加载 java.lang.Object,而未使用双亲委派,会找不到而失败\n实际上, 自己定义的类加载器加载以java.开头的包时,就会报安全异常,jdk9之后更是编译也无法通过\n\n&#x2F;&#x2F; 这是ClassLoader中一段检查的代码\nif (!checkName(name))\n    throw new NoClassDefFoundError(&quot;IllegalName: &quot; + name);\n\n&#x2F;&#x2F; Note:  Checking logic in java.lang.invoke.MemberName.checkForTypeAlias\n&#x2F;&#x2F; relies on the fact that spoofing is impossible if a class has a name\n&#x2F;&#x2F; of the form &quot;java.*&quot;\nif ((name !&#x3D; null) &amp;&amp; name.startsWith(&quot;java.&quot;)\n    &amp;&amp; this !&#x3D; getBuiltinPlatformClassLoader()) &#123;\n    throw new SecurityException\n        (&quot;Prohibited package name: &quot; +\n         name.substring(0, name.lastIndexOf(&#39;.&#39;)));\n&#125;\n\n5. 引用类型和finalize关键字引用类型分为哪几类?\n\n强引用\n普通变量赋值即为强引用,如 A a = new A();\n通过GC ROOT引用链,如果强引用不到该对象,该对象才会被回收\n\n\n软引用(SoftReference)\n例如: SoftReference a = new SoftReference(new A());\n如果仅有软引用该对象,首次垃圾回收不会回收该对象,如果内存依然不足,再次回收才会回收软引用对象\n软引用只是需要配合引用队列来释放\n典型的例子是反射对象\n\n\n弱引用(WeakReference)\n例如:WeakReference a = new WeakReference(new A());\n如果仅有弱引用引用该对象,只要发生垃圾回收,就会释放该对象\n弱引用需要配和引用队列来释放\n典型例子就是 ThreadLocalMap 中的 Entry对象\n\n\n虚引用(PhantomReference)\n例如: PhantomReference a = new PhantomReference(new A());\n必须配合引用队列一起使用,当虚引用引用的对象被回收,会将虚引用对象入队,由Reference Handler线程释放其关联的外部资源\n典型例子就是 Cleaner 释放 DirectByteBuffer 占用的直接内存\n\n\n\n\n\n[ 注意 ] 前面所说的弱引用,虚引用,配合引用队列使用,都是为了找到哪些Java对象被回收,从而进行他对他们关联的资源进一步的清理,为了简化API难度,从 java9 开始引入 Cleaner 对象\n谈谈对finalize的理解?\nfinalize() 是Object中的一个方法, 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。java9之后已经被标注为 @Deprecated\n\nfinalize方法调用次序并不固定\n创建了Finalizer线程(守护线程)来实现回收\nfinalize方法中出现异常并不会中断\n垃圾回收并不会立刻执行finalize方法,会先加入一个unfinalized队列,然后按序执行finalize方法,然后再进行垃圾回收\n\n当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Java高频八股文","date":"2022-05-05T13:42:50.000Z","categories_index":"互联网八股","tags_index":"Java,集合类,JVM","author_index":"张 凡"},{"id":"b57cd9d792371efee42384e9cc2f9aee","title":"B站网友的奇妙发言","content":"手冲是我和牛子的相互欺骗。\n鬼火一响，爹妈白养。\n弯道快才是快，谁直线不会加油？\n弯道快才逝快，谁吃席不会夹菜？\n我系一个保安 保卫一方平安\n爱吃小熊饼干 上班只为下班\n喜欢业主小丹\n小时候是喜欢成绩好的女生，大一点开始喜欢漂亮的女生，然后是文静的女生，然后是丰满的女性，然后是青葱系的女生，然后是勤恳的女性，到最后我也不知道何为喜欢了，只觉得水陆草木之花，可爱者甚繁。\n\n\n","slug":"B站网友的奇妙发言","date":"2022-05-05T06:46:30.000Z","categories_index":"奇妙发言","tags_index":"搞笑,语录,歇后语","author_index":"张 凡"},{"id":"c9f2b21b690f4db6367244e90c766293","title":"NIO","content":"1. NIO基础NIO - Non-blocking IO 或 New IO\na. NIO的三大核心-Channel、Buffer、Selector1. Channel 与 BufferJava NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。\n通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。简而言之，通道负责传输，缓冲区负责存储\n常见的Channel有以下四种\n\nFileChannel    主要用于文件传输\nDatagramChannel   \nSocketChannel\nServerSocketChannel\n\n其中FileChannel主要用于文件传输，其余三种用于网络通信\nBuffer有以下几种，其中使用较多的是ByteBuffer\n\nByteBuffer  常用\nMappedByteBuffer\nDirectByteBuffer\nHeapByteBuffer\n\n\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\nCharBuffer\n\n2. Selector在使用Selector之前，服务器处理socket连接还有以下两种方法\na. 服务器使用多线程技术\n为每个连接分别开辟一个线程，分别去处理对应的socke连接\n\n\n这种方法存在以下几个问题\n\n内存占用高\n每个线程都需要占用一定的内存，当连接较多时，会开辟大量线程，导致占用大量内存\n\n\n线程上下文切换成本高\n只适合连接数少的场景\n连接数过多，会导致创建很多线程，从而出现问题\n\n\n\nb. 服务器使用线程池技术\n使用线程池，让线程池中的线程去处理连接\n\n\n这种方法存在以下几个问题\n\n阻塞模式下，线程仅能处理一个连接\n线程池中的线程获取任务（task）后，只有当其执行完任务之后（断开连接后），才会去获取并执行下一个任务\n若socke连接一直未断开，则其对应的线程无法处理其他socke连接\n\n\n仅适合短连接场景\n短连接即建立连接发送请求并响应后就立即断开，使得线程池中的线程可以快速处理其他连接\n\n\n\nc.服务器使用selector技术\nselector 的作用就是配合一个线程来管理多个 channel（fileChannel因为是阻塞式的，所以无法使用selector），获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，当一个channel中没有执行任务时，可以去执行其他channel中的任务。适合连接数多，但流量较少的场景\n若事件未就绪，调用 selector 的 select() 方法会阻塞线程，直到 channel 发生了就绪事件。这些事件就绪后，select 方法就会返回这些事件交给 thread 来处理。\n\n\nb. ByteBuffer1. 使用方式\n向 buffer 写入数据，例如调用 channel.read(buffer)\n\n调用 flip() 切换至读模式\n\nflip会使得buffer中的limit变为position，position变为0\n\n\n从 buffer 读取数据，例如调用 buffer.get()\n\n调用 clear() 或者compact()切换至\n写模式\n\n调用clear()方法时position&#x3D;0，limit变为capacity\n调用compact()方法时，会将缓冲区中的未读数据压缩到缓冲区前面\n\n\n重复以上步骤\n\n\n使用ByteBuffer读取文件中的内容\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F; FileChannel\n    &#x2F;&#x2F; 1. 使用输入输出流来获取 2. RandomAccessFile\n    try &#123;\n        &#x2F;&#x2F; 获取通道\n        FileChannel channel &#x3D; new FileInputStream(&quot;data.txt&quot;).getChannel();\n        &#x2F;&#x2F; 准备缓冲区\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(10);\n        &#x2F;&#x2F; 从channel 读取数据,向buffer写入\n        &#x2F;&#x2F; return : The number of bytes read, possibly zero, or -1 if the channel has reached\n        &#x2F;&#x2F; end-of-stream\n        int len &#x3D; channel.read(buffer);\n        &#x2F;&#x2F; 每次读缓冲区大小的数据,循环读,知道文件读完\n        while (len !&#x3D; -1)&#123;\n            &#x2F;&#x2F; 打印验证\n            buffer.flip(); &#x2F;&#x2F; 切换至读模式\n            while (buffer.hasRemaining()) &#123;\n                byte b &#x3D; buffer.get();&#x2F;&#x2F; 无参代表一次读一个字节\n                System.out.print((char) b);\n            &#125;\n            buffer.clear();&#x2F;&#x2F; 切换为写模式 不加会死循环,一直循环读前是个字节\n            len &#x3D; channel.read(buffer);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;\n\n2. ByteBuffer 结构a. 核心属性&#x2F;&#x2F; Invariants: mark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity\nprivate int mark &#x3D; -1;\nprivate int position &#x3D; 0;\nprivate int limit;\nprivate int capacity;\n\n\ncapacity：缓冲区的容量。通过构造函数赋予，一旦设置，无法更改\nlimit：缓冲区的界限。位于limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量\nposition：下一个读写位置的索引（类似PC）。缓冲区的位置不能为负，并且不能大于limit\nmark：记录当前position的值。position被改变后，可以通过调用reset() 方法恢复到mark的位置。\n\n以上四个属性必须满足以下要求\n\nmark &lt;&#x3D; position &lt;&#x3D; limit &lt;&#x3D; capacity\n\nb. 核心方法put()方法\n\nput()方法可以将一个数据放入到缓冲区中。\n进行该操作后，postition的值会+1，指向下一个可以放入的位置。capacity &#x3D; limit ，为缓冲区容量的值。\n\n\n\n\n\nflip()方法\n\nflip()方法会切换对缓冲区的操作模式，由写-&gt;读 &#x2F; 读-&gt;写\n进行该操作后\n如果是写模式-&gt;读模式，position &#x3D; 0 ， limit 指向最后一个元素的下一个位置，capacity不变\n如果是读-&gt;写，则恢复为put()方法中的值\n\n\n\n\n\n\n\nget()方法\n\nget()方法会读取缓冲区中的一个值\n进行该操作后，position会+1，如果超过了limit则会抛出异常\n注意：get(i)方法不会改变position的值\n\n\n\n\n\nrewind()方法\n\n该方法只能在读模式下使用\nrewind()方法后，会恢复position、limit和capacity的值，变为进行get()前的值\n\n\n\nclean()方法\n\nclean()方法会将缓冲区中的各个属性恢复为最初的状态，position &#x3D; 0, capacity &#x3D; limit\n此时缓冲区的数据依然存在，处于“被遗忘”状态，下次进行写操作时会覆盖这些数据\n\n\n\n\n\nmark()和reset()方法\n\nmark()方法会将postion的值保存到mark属性中\nreset()方法会将position的值改为mark中保存的值\n\ncompact()方法\n此方法为ByteBuffer的方法，而不是Buffer的方法\n\ncompact会把未读完的数据向前压缩，然后切换到写模式\n数据前移后，原位置的值并未清零，写时会覆盖之前的值\n\n\n\n\n\nclear() VS compact()\nclear只是对position、limit、mark进行重置，而compact在对position进行设置，以及limit、mark进行重置的同时，还涉及到数据在内存中拷贝（会调用arraycopy）。所以compact比clear更耗性能。但compact能保存你未读取的数据，将新数据追加到为读取的数据之后；而clear则不行，若你调用了clear，则未读取的数据就无法再读取到了\n所以需要根据情况来判断使用哪种方法进行模式切换\n3. 字符串和 ByteBuffer 之间的转换&#x2F;&#x2F; 字符串和 ByteBuffer 之间的转换\npublic static void testByteBufferString() &#123;\n    &#x2F;&#x2F; 字符串转为 byteBuffer\n    &#x2F;&#x2F; 1. String 的 getBytes方法\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    buffer.put(&quot;hello&quot;.getBytes());\n    &#x2F;&#x2F; 2. StandardCharsets.UTF_8.encode 方法\n    ByteBuffer buffer2 &#x3D; StandardCharsets.UTF_8.encode(&quot;输出Hell&quot;);\n    &#x2F;&#x2F; 3. ByteBuffer.wrap\n    ByteBuffer buffer3 &#x3D; ByteBuffer.wrap(&quot;hello&quot;.getBytes());\n\n    &#x2F;&#x2F; byteBuffer转为字符串\n    String string &#x3D; StandardCharsets.UTF_8.decode(buffer2).toString();\n    &#x2F;&#x2F; buffer2的pos指针已经在第一个位置,可以直接转换\n    System.out.println(string);\n    buffer.flip();\n    String string2 &#x3D; StandardCharsets.UTF_8.decode(buffer).toString();\n    &#x2F;&#x2F; buffer1的pos指针不在第一个位置,要先转换模式\n    System.out.println(string2);\n&#125;\n\n\n\n4. 粘包半包处理现象\n网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\nHello,world\\n\nI’m Nyima\\n\nHow are you?\\n\n\n变成了下面的两个 byteBuffer (粘包，半包)\n\nHello,world\\nI’m Nyima\\nHo\nw are you?\\n\n\n出现原因\n\n粘包:发送方在发送数据时，并不是一条一条地发送数据，而是将数据整合在一起，当数据达到一定的数量后再一起发送。这就会导致多条信息被放在一个缓冲区中被一起发送出去\n\n半包:接收方的缓冲区的大小是有限的，当接收方的缓冲区满了以后，就需要将信息截断，等缓冲区空了以后再继续放入数据。这就会发生一段完整的数据最后被截断的现象\n\n\n解决办法\n\n通过get(index)方法遍历ByteBuffer，遇到分隔符时进行处理。\n注意\n：get(index)不会改变position的值\n\n记录该段数据长度，以便于申请对应大小的缓冲区\n将缓冲区的数据通过get()方法写入到target中\n\n\n调用compact方法切换模式，因为缓冲区中可能还有未读的数据\n\n\npublic static void testByteBufferExam() &#123;\n    &#x2F;*\n\t\t网络上有多条数据发送给服务端，数据之间使用 \\n 进行分隔\n\t\t但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为\n\t\tHello,world\\n\n\t\tI’m Nyima\\n\n\t\tHow are you?\\n\n\t\t变成了下面的两个 byteBuffer (粘包，半包)\n\t\tHello,world\\nI’m Nyima\\nHo\n\t\tw are you?\\n\n    *&#x2F;\n    &#x2F;&#x2F; 接收到被分割的信息\n    ByteBuffer source &#x3D; ByteBuffer.allocate(32);\n    source.put(&quot;Hello,world\\nI’m Nyima\\nHo&quot;.getBytes());\n    &#x2F;&#x2F; 进行分割\n    split(source);\n    source.put(&quot;w are you?\\n&quot;.getBytes());\n    split(source);\n&#125;\n\npublic static void split(ByteBuffer source) &#123;\n    &#x2F;&#x2F; 切换读模式\n    source.flip();\n    for (int i &#x3D; 0; i &lt; source.limit(); i++) &#123;\n        &#x2F;&#x2F; 找到一个换行符则有一条消息\n        if (source.get(i) &#x3D;&#x3D; &#39;\\n&#39;) &#123;\n            &#x2F;&#x2F; 把消息存入新的ByteBuffer\n            int len &#x3D; i + 1 - source.position(); &#x2F;&#x2F; 计算两个 \\n 之间内容的长度\n            ByteBuffer tar &#x3D; ByteBuffer.allocate(len);\n            for (int j &#x3D; 0; j &lt; len; j++) &#123;\n                tar.put(source.get());\n            &#125;\n            tar.flip(); &#x2F;&#x2F; 切换模式,让指针指向起始\n             System.out.print(StandardCharsets.UTF_8.decode(tar).toString());\n            tar.flip();\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 没读完,前推\n    source.compact();\n&#125;\n\n+--------+-------------------- all ------------------------+----------------+\nposition: [12], limit: [12]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 65 6c 6c 6f 2c 77 6f 72 6c 64 0a             |Hello,world.    |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [10], limit: [10]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 49 27 6d 20 4e 79 69 6d 61 0a                   |I&#39;m Nyima.      |\n+--------+-------------------------------------------------+----------------+\n+--------+-------------------- all ------------------------+----------------+\nposition: [13], limit: [13]\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 6f 77 20 61 72 65 20 79 6f 75 3f 0a          |How are you?.   |\n+--------+-------------------------------------------------+----------------+\n\n\n\nc. 文件编程1. FileChannelFileChannel只能工作在阻塞模式下，所以无法搭配Selector\na. 获取不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法\n\n通过 FileInputStream 获取的 channel 只能读\n通过 FileOutputStream 获取的 channel 只能写\n通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定\n\nb. 读取通过 FileInputStream 获取channel，通过read方法将数据写入到ByteBuffer中\nread方法的返回值表示读到了多少字节，若读到了文件末尾则返回-1\nint readBytes &#x3D; channel.read(buffer);\n\n可根据返回值判断是否读取完毕\nwhile(channel.read(buffer) &gt; 0) &#123;\n    &#x2F;&#x2F; 进行对应操作\n    ...\n&#125;\n\n\n\nc. 写入因为channel也是有大小的，所以 write 方法并不能保证一次将 buffer 中的内容全部写入 channel。必须需要按照以下规则进行写入\n&#x2F;&#x2F; 通过hasRemaining()方法查看缓冲区中是否还有数据未写入到通道中\nwhile(buffer.hasRemaining()) &#123;\n\tchannel.write(buffer);\n&#125;\n\n\n\nd. 关闭通道需要close，一般情况通过try-with-resource进行关闭，最好使用以下方法获取strea以及channel，避免某些原因使得资源未被关闭\npublic class TestChannel &#123;\n    public static void main(String[] args) throws IOException &#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 执行对应操作\n            ...\n        &#125;\n    &#125;\n&#125;\n\n\n\ne.位置 positionchannel也拥有一个保存读取数据位置的属性，即position\nlong pos &#x3D; channel.position();\n\n可以通过position(int pos)设置channel中position的值\nlong newPos &#x3D; ...;\nchannel.position(newPos);\n\n设置当前位置时，如果设置为文件的末尾\n\n这时读取会返回 -1\n这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）\n\nf. 强制写入操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘，而是等到缓存满了以后将所有数据一次性的写入磁盘。可以调用 force(true) 方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘\n2. 两个Channel传输数据transferTo方法\n使用transferTo方法可以快速、高效地将一个channel中的数据传输到另一个channel中，但一次只能传输2G的内容\ntransferTo底层使用了零拷贝技术\npublic class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            &#x2F;&#x2F; 参数：inputChannel的起始位置，传输数据的大小，目的channel\n            &#x2F;&#x2F; 返回值为传输的数据的字节数\n            &#x2F;&#x2F; transferTo一次只能传输2G的数据\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n当传输的文件大于2G时，需要使用以下方法进行多次传输\npublic class TestChannel &#123;\n    public static void main(String[] args)&#123;\n        try (FileInputStream fis &#x3D; new FileInputStream(&quot;stu.txt&quot;);\n             FileOutputStream fos &#x3D; new FileOutputStream(&quot;student.txt&quot;);\n             FileChannel inputChannel &#x3D; fis.getChannel();\n             FileChannel outputChannel &#x3D; fos.getChannel()) &#123;\n            long size &#x3D; inputChannel.size();\n            long capacity &#x3D; inputChannel.size();\n            &#x2F;&#x2F; 分多次传输\n            while (capacity &gt; 0) &#123;\n                &#x2F;&#x2F; transferTo返回值为传输了的字节数\n                capacity -&#x3D; inputChannel.transferTo(size-capacity, capacity, outputChannel);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n3. Path\nPath 用来表示文件路径\nPaths 是工具类，用来获取 Path 实例\n\nPath source &#x3D; Paths.get(&quot;1.txt&quot;); &#x2F;&#x2F; 相对路径 不带盘符 使用 user.dir 环境变量来定位 1.txt\n\nPath source &#x3D; Paths.get(&quot;d:\\\\1.txt&quot;); &#x2F;&#x2F; 绝对路径 代表了  d:\\1.txt 反斜杠需要转义\n\nPath source &#x3D; Paths.get(&quot;d:&#x2F;1.txt&quot;); &#x2F;&#x2F; 绝对路径 同样代表了  d:\\1.txt\n\nPath projects &#x3D; Paths.get(&quot;d:\\\\data&quot;, &quot;projects&quot;); &#x2F;&#x2F; 代表了  d:\\data\\projects\n\n\n. 代表了当前路径\n.. 代表了上一级路径\n\n例如目录结构如下\nd:\n|- data\n\t|- projects\n\t\t|- a\n\t\t|- bCopy\n\n代码\nPath path &#x3D; Paths.get(&quot;d:\\\\data\\\\projects\\\\a\\\\..\\\\b&quot;);\nSystem.out.println(path);\nSystem.out.println(path.normalize()); &#x2F;&#x2F; 正常化路径 会去除 . 以及 ..\n\n输出结果为\nd:\\data\\projects\\a\\..\\b\nd:\\data\\projects\\b\n\n4. Filesa. 查找检查文件是否存在\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nSystem.out.println(Files.exists(path));\n\nb. 创建创建一级目录\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.createDirectory(path);\n\n\n如果目录已存在，会抛异常 FileAlreadyExistsException\n不能一次创建多级目录，否则会抛异常 NoSuchFileException\n\n创建多级目录用\nPath path &#x3D; Paths.get(&quot;helloword&#x2F;d1&#x2F;d2&quot;);\nFiles.createDirectories(path);\n\nc. 拷贝及移动拷贝文件\nPath source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.copy(source, target);\n\n\n如果文件已存在，会抛异常 FileAlreadyExistsException\n\n如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制\nFiles.copy(source, target, StandardCopyOption.REPLACE_EXISTING);\n\n移动文件\nPath source &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;data.txt&quot;);\n\nFiles.move(source, target, StandardCopyOption.ATOMIC_MOVE);\n\n\nStandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性\n\nd. 删除删除文件\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;target.txt&quot;);\nFiles.delete(target);\n\n\n如果文件不存在，会抛异常 NoSuchFileException\n\n删除目录\nPath target &#x3D; Paths.get(&quot;helloword&#x2F;d1&quot;);\nFiles.delete(target);\n\n\n如果目录还有内容，会抛异常 DirectoryNotEmptyException\n只能删除空目录\n\ne. 遍历目录可以使用Files工具类中的walkFileTree(Path, FileVisitor)方法，其中需要传入两个参数\n\nPath：文件起始路径\n\nFileVisitor：文件访问器，\n使用访问者模式\n\n接口的实现类SimpleFileVisitor有四个方法\npreVisitDirectory：访问目录前的操作\nvisitFile：访问文件的操作\nvisitFileFailed：访问文件失败时的操作\npostVisitDirectory：访问目录后的操作\n\n\n\n\n\npublic static void testFilesWalkFileTree() throws IOException &#123;\n    final AtomicInteger dirCnt &#x3D; new AtomicInteger();\n    final AtomicInteger fileCnt &#x3D; new AtomicInteger();\n    Files.walkFileTree(Paths.get(&quot;C:\\\\Users\\\\Lenovo\\\\.jdks\\\\corretto-1.8.0_302&quot;), new SimpleFileVisitor&lt;Path&gt;() &#123;\n        @Override\n        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&gt;&quot; + dir);\n            dirCnt.incrementAndGet();\n            return super.preVisitDirectory(dir, attrs);\n        &#125;\n        @Override\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123;\n            System.out.println(file);\n            fileCnt.incrementAndGet();\n            return super.visitFile(file, attrs);\n        &#125;\n    &#125;);\n    System.out.println(&quot;dir count &quot; + dirCnt);\n    System.out.println(&quot;file count &quot; + fileCnt);\n&#125;\n\n...\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\index.html\n&#x3D;&#x3D;&#x3D;&gt;C:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\CustomAutoCloseableSample.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\Unzip.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\sample\\try-with-resources\\src\\ZipCat.java\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\src.zip\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\THIRD_PARTY_README\nC:\\Users\\Lenovo\\.jdks\\corretto-1.8.0_302\\version.txt\ndir count 166\nfile count 701\n\n\n\n2. 网络编程a. 阻塞模式\n阻塞模式下，相关方法都会导致线程暂停\nServerSocketChannel.accept 会在没有连接建立时让线程暂停\nSocketChannel.read 会在通道中没有数据可读时让线程暂停\n阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置\n\n\n单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持\n但多线程下，有新的问题，体现在以下方面\n32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低\n可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接\n\n\n\n服务器端代码\n&#x2F;&#x2F; 使用NIO来理解阻塞模式\npublic static void testBlocking() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建服务器\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n    &#x2F;&#x2F; 2. 绑定监听端口\n    ssc.bind(new InetSocketAddress(8080));\n\n    &#x2F;&#x2F; 3. 建立客户端连接,可能有多个连接\n    List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 保存连接集合\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    while (true) &#123;\n        &#x2F;&#x2F; 4. SocketChannel用来与客户端通信\n        System.out.println(&quot;connecting..&quot;);\n        SocketChannel sc &#x3D; ssc.accept();\n        System.out.println(&quot;connected..&quot; + sc.toString());\n        channels.add(sc);\n        &#x2F;&#x2F; 5.接收客户端发送的数据\n        for (SocketChannel channel : channels) &#123;\n            System.out.println(&quot;Before read&quot;);\n            channel.read(buffer); &#x2F;&#x2F; 阻塞方法,如果没有数据可读会一直等待\n            buffer.flip();&#x2F;&#x2F; 切换读模式\n            System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n            buffer.clear();\n            System.out.println(&quot;After read&quot;);\n        &#125;\n    &#125;\n&#125;\n\n客户端代码\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        System.out.println(&quot;waiting&quot;);\n    &#125;\n&#125;\n\n运行结果\n\n客户端-服务器建立连接前：服务器端因accept阻塞\n\n\n\n\n客户端-服务器建立连接后，客户端发送消息前：服务器端因通道为空被阻塞\n\n\n客户端发送数据后，服务器处理通道中的数据。再次进入循环时，再次被accept阻塞\n\n\n\n\n之前的客户端再次发送消息，服务器端因为被accept阻塞，无法处理之前客户端发送到通道中的信息\n\n\nb. 非阻塞模式\n可以通过ServerSocketChannel的configureBlocking(false)方法将获得连接设置为非阻塞的。此时若没有连接，accept会返回null\n可以通过SocketChannel的configureBlocking(false)方法将从通道中读取数据设置为非阻塞的。若此时通道中没有数据可读，read会返回-1\n\n服务器代码\n&#x2F;&#x2F; 理解非阻塞模式\npublic static void testNonBlocking() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建服务器\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n\n    &#x2F;&#x2F; 2. 绑定监听端口\n    ssc.bind(new InetSocketAddress(8080));\n    ssc.configureBlocking(false);\n\n    &#x2F;&#x2F; 3. 建立客户端连接,可能有多个连接\n    List&lt;SocketChannel&gt; channels &#x3D; new ArrayList&lt;&gt;(); &#x2F;&#x2F; 保存连接集合\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    while (true) &#123;\n        &#x2F;&#x2F; 4. SocketChannel用来与客户端通信\n        &#x2F;&#x2F;System.out.println(&quot;connecting..&quot;);\n        SocketChannel sc &#x3D; ssc.accept(); &#x2F;&#x2F; 如果非阻塞,返回的是null\n        if (sc !&#x3D; null) &#123;\n            System.out.println(&quot;connected..&quot; + sc.toString());\n            sc.configureBlocking(false); &#x2F;&#x2F; 将SocketChannel设置为非阻塞\n            channels.add(sc);\n        &#125;\n        &#x2F;&#x2F; 5.接收客户端发送的数据\n        for (SocketChannel channel : channels) &#123;\n            &#x2F;&#x2F;System.out.println(&quot;Before read&quot;);\n            int read &#x3D; channel.read(buffer); &#x2F;&#x2F; 阻塞方法,如果没有数据可读会一直等待\n            if (read &gt; 0) &#123;\n                buffer.flip();&#x2F;&#x2F; 切换读模式\n                System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n                buffer.clear();\n                System.out.println(&quot;After read&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n客户端\n&#x2F;&#x2F; 客户端不变\npublic class Client &#123;\n    public static void main(String[] args) throws IOException &#123;\n        SocketChannel sc &#x3D; SocketChannel.open();\n        sc.connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        System.out.println(&quot;waiting&quot;);\n    &#125;\n&#125;\n\n因为设置为了非阻塞，会一直执行while(true)中的代码，CPU一直处于忙碌状态，会使得性能变低，所以实际情况中不使用这种方法处理请求\n\n\n\n\nc. Selector模式1. 多路复用单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用\n\n多路复用仅针对网络 IO，普通文件 IO 无法利用多路复用\n如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证\n有可连接事件时才去连接\n有可读事件才去读取\n有可写事件才去写入\n限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件\n\n\n\n\n\n要使用Selector实现多路复用，服务端代码如下改进\n&#x2F;&#x2F; Selector进行网络编程\npublic static void testSelector() throws IOException &#123;\n    &#x2F;&#x2F; 1. 创建Selector,管理多个Channel\n    Selector selector &#x3D; Selector.open();\n    ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n    ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n    ssc.configureBlocking(false);\n    &#x2F;&#x2F; 2. 建立selector和 channel之间的联系 (注册)\n    &#x2F;&#x2F; 将 channel注册到 选择器, 当有事件发生时,会返回一个selectionKey来告知是哪个channel发生的事件\n    SelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n    &#x2F;&#x2F; 声明只关注 accept 事件\n    sscKey.interestOps(SelectionKey.OP_ACCEPT);\n    System.out.println(&quot;sscKey -&gt; &quot;+sscKey);\n\n    ssc.bind(new InetSocketAddress(8080));\n    while (true) &#123;\n        &#x2F;&#x2F; 3. 如何知道有没有发生事件\n        &#x2F;&#x2F; 选择器进行选择,如果没有 事件发生,则进行阻塞;有事件发生,程序继续向下运行\n        selector.select();\n\n        &#x2F;&#x2F; 4. 处理事件\n        &#x2F;&#x2F; selectedKeys包含了所有发生的事件\n        Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n        while (it.hasNext()) &#123;\n            SelectionKey key &#x3D; it.next();\n            System.out.println(&quot;key -&gt; &quot;+key);\n            &#x2F;&#x2F; 如果获取事件后不处理,会重复加入事件列表,不断循环\n            ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n            SocketChannel sc &#x3D; channel.accept();\n            System.out.println(&quot;sc -&gt; &quot;+sc);\n        &#125;\n    &#125;\n&#125;\n\n步骤解析:\n\n获得选择器Selector\nSelector selector &#x3D; Selector.open();\n\n将通道设置为非阻塞模式，并注册到选择器中，并设置感兴趣的事件\n\nchannel 必须工作在非阻塞模式\nFileChannel 没有非阻塞模式，因此不能配合 selector 一起使用\n绑定的事件类型可以有\nconnect - 客户端连接成功时触发\naccept - 服务器端成功接受连接时触发\nread - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况\nwrite - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况\n\n\n\nServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\nssc.configureBlocking(false);\n&#x2F;&#x2F; 2. 建立selector和 channel之间的联系 (注册)\n&#x2F;&#x2F; 将 channel注册到 选择器, 当有事件发生时,会返回一个selectionKey来告知是哪个channel发生的事件\nSelectionKey sscKey &#x3D; ssc.register(selector, 0, null);\n&#x2F;&#x2F; 声明只关注 accept 事件\nsscKey.interestOps(SelectionKey.OP_ACCEPT);\nSystem.out.println(&quot;sscKey -&gt; &quot;+sscKey);\n\n通过Selector监听事件，并获得就绪的通道个数，若没有通道就绪，线程会被阻塞\n\n阻塞直到绑定事件发生\n\nint id &#x3D; selector.select();\n\n\n阻塞直到绑定事件发生，或是超时（时间单位为 ms）\n\nint id &#x3D; selector.select(long timeout);\n\n\n不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件\n\nint id &#x3D; selector.selectNow();\n\n获取就绪事件并得到对应的通道，然后进行处理\n&#x2F;&#x2F; 4. 处理事件\n&#x2F;&#x2F; selectedKeys包含了所有发生的事件\nIterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\nwhile (it.hasNext()) &#123;\n    SelectionKey key &#x3D; it.next();\n    System.out.println(&quot;key -&gt; &quot;+key);\n    &#x2F;&#x2F; 如果获取事件后不处理,会重复加入事件列表,不断循环\n    ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n    SocketChannel sc &#x3D; channel.accept();\n    System.out.println(&quot;sc -&gt; &quot;+sc);\n&#125;\n\n事件发生后能否不处理\n事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发\n\n\n2. Read事件\n在Accept事件中，若有客户端与服务器端建立了连接，需要将其对应的SocketChannel设置为非阻塞，并注册到选择其中\n添加Read事件，触发后进行读取操作\n\n &#x2F;&#x2F; 4. 处理事件\n&#x2F;&#x2F; selectedKeys包含了所有发生的事件\nIterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\nwhile (it.hasNext()) &#123;\n    SelectionKey key &#x3D; it.next();\n    &#x2F;&#x2F; 如果这里不删除,下次进入响应事件后,还会访问,但实际上他的事件已经在上次处理结束\n    it.remove();\n    System.out.println(&quot;key -&gt; &quot; + key);\n    &#x2F;&#x2F; key就代表一个事件,可以获得事件是那个channel触发的\n    &#x2F;&#x2F; 可以区分这些事件进行处理\n    if (key.isAcceptable()) &#123;\n        ServerSocketChannel channel &#x3D; (ServerSocketChannel) key.channel();&#x2F;&#x2F; 获取触发事件的channel\n        SocketChannel sc &#x3D; channel.accept();\n        System.out.println(&quot;sc-&gt; &quot;+sc);\n        sc.configureBlocking(false);\n        SelectionKey scKey &#x3D; sc.register(selector, 0, null);\n        scKey.interestOps(SelectionKey.OP_READ);\n\n    &#125; else if (key.isReadable()) &#123;\n        SocketChannel channel &#x3D; (SocketChannel) key.channel();\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n        channel.read(buffer);\n        buffer.flip();\n        System.out.println(StandardCharsets.UTF_8.decode(buffer).toString());\n    &#125;\n&#125;\n\n删除事件\n当处理完一个事件后，一定要调用迭代器的remove方法移除对应事件，否则会出现错误。\n\n当调用了 server.register(selector, SelectionKey.OP_ACCEPT)后，Selector中维护了一个集合，用于存放SelectionKey以及其对应的通道\n\n当选择器中的通道对应的事件发生后，selecionKey会被放到另一个集合中，但是selecionKey不会自动移除，所以需要我们在处理完一个事件后，通过迭代器手动移除其中的selecionKey。否则会导致已被处理过的事件再次被处理，就会引发错误\n\n\n3. 客户端关闭异常当客户端与服务器之间的连接断开时，会给服务器端发送一个读事件，对异常断开和正常断开需要加以不同的方式进行处理\n\n\n\n正常断开时，服务器端的channel.read(buffer)方法的返回值为-1，所以当结束到返回值为-1时，需要调用key的cancel方法取消此事件，并在取消后移除该事件\nint read &#x3D; channel.read(buffer);\n&#x2F;&#x2F; 断开连接时，客户端会向服务器发送一个写事件，此时read的返回值为-1\nif(read &#x3D;&#x3D; -1) &#123;\n    &#x2F;&#x2F; 取消该事件的处理\n\tkey.cancel();\n    channel.close();\n&#125; else &#123;\n    ...\n&#125;\n&#x2F;&#x2F; 取消或者处理，都需要移除key\niterator.remove();\n\n异常断开\n\n异常断开时，会抛出IOException异常， 在try-catch的catch块中捕获异常并调用key的cancel方法即可\n\n\n\n4. 消息边界的处理当客户端发送中文时:\nsc.write(Charset.defaultCharset().encode(&quot;这他妈是八岁?三岁和他妈一样高,五岁就&quot;))\n\n服务器端由于缓冲区大小,可能会导致一个汉字编码被切割的情况\n这是因为UTF-8字符集下，1个汉字占用3个字节，此时缓冲区可能一次读时间无法处理完通道中的所有数据，所以一共会触发两次读事件。这就导致 你好 的 好 字被拆分为了前半部分和后半部分发送，解码时就会出现问题\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n这他妈是八�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��?三岁和他�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��一样高,五�\nkey -&gt; sun.nio.ch.SelectionKeyImpl@65b3120a\n��就\n\n传输的文本可能有以下三种情况\n\n文本大于缓冲区大小\n此时需要将缓冲区进行扩容\n\n\n发生半包现象\n发生粘包现象\n\n\n\n解决思路大致有以下三种\n\n固定消息长度，数据包大小一样，服务器按预定长度读取，当发送的数据较少时，需要将数据进行填充，直到长度与消息规定长度一致。缺点是浪费带宽\n另一种思路是按分隔符拆分，缺点是效率低，需要一个一个字符地去匹配分隔符\nTLV 格式，即 Type 类型、Length 长度、Value 数据（也就是在消息开头用一些空间存放后面数据的长度），如HTTP请求头中的Content-Type与Content-Length。类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量\nHttp 1.1 是 TLV 格式\nHttp 2.0 是 LTV 格式\n\n\n\n附件与扩容\nChannel的register方法还有第三个参数：附件，可以向其中放入一个Object类型的对象，该对象会与登记的Channel以及其对应的SelectionKey绑定，可以从SelectionKey获取到对应通道的附件\npublic final SelectionKey register(Selector sel, int ops, Object att)\n\n可通过SelectionKey的attachment()方法获得附件\nByteBuffer buffer &#x3D; (ByteBuffer) key.attachment();\n\n我们需要在Accept事件发生后，将通道注册到Selector中时，对每个通道添加一个ByteBuffer附件，让每个通道发生读事件时都使用自己的通道，避免与其他通道发生冲突而导致问题\n&#x2F;&#x2F; 设置为非阻塞模式，同时将连接的通道也注册到选择其中，同时设置附件\nsocketChannel.configureBlocking(false);\nByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n&#x2F;&#x2F; 添加通道对应的Buffer附件\nsocketChannel.register(selector, SelectionKey.OP_READ, buffer);\n\n当Channel中的数据大于缓冲区时，需要对缓冲区进行扩容操作。此代码中的扩容的判定方法：Channel调用compact方法后，的position与limit相等，说明缓冲区中的数据并未被读取（容量太小），此时创建新的缓冲区，其大小扩大为两倍。同时还要将旧缓冲区中的数据拷贝到新的缓冲区中，同时调用SelectionKey的attach方法将新的缓冲区作为新的附件放入SelectionKey中\n&#x2F;&#x2F; 如果缓冲区太小，就进行扩容\nif (buffer.position() &#x3D;&#x3D; buffer.limit()) &#123;\n    ByteBuffer newBuffer &#x3D; ByteBuffer.allocate(buffer.capacity()*2);\n    &#x2F;&#x2F; 将旧buffer中的内容放入新的buffer中\n    ewBuffer.put(buffer);\n    &#x2F;&#x2F; 将新buffer作为附件放到key中\n    key.attach(newBuffer);\n&#125;\n\n\n\n\n\nByteBuffer的大小分配\n\n每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer\nByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer\n分配思路可以参考\n一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能\n参考实现 http://tutorials.jenkov.com/java-performance/resizable-array.html\n\n\n另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗\n\n\n\n5. Write事件服务器通过Buffer向通道中写入数据时，可能因为通道容量小于Buffer中的数据大小，导致无法一次性将Buffer中的数据全部写入到Channel中，这时便需要分多次写入，具体步骤如下\n\n执行一次写操作，向将buffer中的内容写入到SocketChannel中，然后判断Buffer中是否还有数据\n若Buffer中还有数据，则需要将SockerChannel注册到Seletor中，并关注写事件，同时将未写完的Buffer作为附件一起放入到SelectionKey中\n\nint write &#x3D; sc.write(buffer);\nif (buffer.hasRemaining()) &#123;\n    &#x2F;&#x2F; 一次写不完,关注可写事件\n    sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n    sckey.attach(buffer);\n&#125;\n\n\n添加写事件的相关操作key.isWritable()，对Buffer再次进行写操作\n每次写后需要判断Buffer中是否还有数据（是否写完）。若写完，需要移除SelecionKey中的Buffer附件，避免其占用过多内存，同时还需移除对写事件的关注\n\n\n\nif (selectionKey.isWritable()) &#123;\n    ByteBuffer attachment &#x3D; (ByteBuffer) selectionKey.attachment();\n    SocketChannel sc &#x3D; (SocketChannel) selectionKey.channel();\n    int write &#x3D; sc.write(attachment);\n    System.out.println(write);\n    &#x2F;&#x2F; 清理一下buffer\n    if (!attachment.hasRemaining()) &#123;\n        selectionKey.attach(null); &#x2F;&#x2F; 清理buffer\n        &#x2F;&#x2F; 不再关注可写事件\n        selectionKey.interestOps(selectionKey.interestOps() - SelectionKey.OP_WRITE);\n    &#125;\n&#125;\n\n整体的代码如下\npublic class WriteServe &#123;\n    public static void main(String[] args) throws IOException &#123;\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector selector &#x3D; Selector.open();\n        ssc.register(selector, SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n        while (true) &#123;\n            selector.select();\n            Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n            while (it.hasNext()) &#123;\n                SelectionKey selectionKey &#x3D; it.next();\n                it.remove();\n                if (selectionKey.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n\n                    SelectionKey sckey &#x3D; sc.register(selector, 0, null);\n                    System.out.println(sckey);\n                    sckey.interestOps(SelectionKey.OP_READ);\n                    &#x2F;&#x2F; 向客户端发送大量数据\n                    StringBuilder sb &#x3D; new StringBuilder();\n                    for (int i &#x3D; 0; i &lt; 30000000; i++) &#123;\n                        sb.append(&quot;a&quot;);\n                    &#125;\n                    ByteBuffer buffer &#x3D; Charset.defaultCharset().encode(sb.toString());\n                    int write &#x3D; sc.write(buffer);\n                    System.out.println(write);\n                    if (buffer.hasRemaining()) &#123;\n                        &#x2F;&#x2F; 一次写不完,关注可写事件\n                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);\n                        sckey.attach(buffer);\n                    &#125;\n                &#125; else if (selectionKey.isWritable()) &#123;\n                    ByteBuffer attachment &#x3D; (ByteBuffer) selectionKey.attachment();\n                    SocketChannel sc &#x3D; (SocketChannel) selectionKey.channel();\n                    int write &#x3D; sc.write(attachment);\n                    System.out.println(write);\n                    &#x2F;&#x2F; 清理一下buffer\n                    if (!attachment.hasRemaining()) &#123;\n                        selectionKey.attach(null); &#x2F;&#x2F; 清理buffer\n                        &#x2F;&#x2F; 不再关注可写事件\n                        selectionKey.interestOps(selectionKey.interestOps() - SelectionKey.OP_WRITE);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n3. 多线程优化为了充分利用多核CPU，可以分两组选择器\n\n单线程配一个选择器（Boss），专门处理 accept 事件\n创建 cpu 核心数的线程（Worker），每个线程配一个选择器，轮流处理 read 事件\n\n实现思路\n\n创建一个负责处理Accept事件的Boss线程，与多个负责处理Read事件的Worker线程\n\nBoss线程执行的操作\n\n接受并处理Accepet事件，当Accept事件发生后，调用Worker的register(SocketChannel socket)方法，让Worker去处理Read事件，其中需要根据标识robin去判断将任务分配给哪个Worker\n&#x2F;&#x2F; 创建固定数量的Worker\nWorker[] workers &#x3D; new Worker[4];\n&#x2F;&#x2F; 用于负载均衡的原子整数\nAtomicInteger robin &#x3D; new AtomicInteger(0);\n&#x2F;&#x2F; 负载均衡，轮询分配Worker\nworkers[robin.getAndIncrement()% workers.length].register(socket);\n\nregister(SocketChannel socket)方法会通过同步队列完成Boss线程与Worker线程之间的通信，让SocketChannel的注册任务被Worker线程执行。添加任务后需要调用selector.wakeup()来唤醒被阻塞的Selector\npublic void register(final SocketChannel socket) throws IOException &#123;\n    &#x2F;&#x2F; 只启动一次\n    if (!started) &#123;\n       &#x2F;&#x2F; 初始化操作\n    &#125;\n    &#x2F;&#x2F; 向同步队列中添加SocketChannel的注册事件\n    &#x2F;&#x2F; 在Worker线程中执行注册事件\n    queue.add(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                socket.register(selector, SelectionKey.OP_READ);\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;);\n    &#x2F;&#x2F; 唤醒被阻塞的Selector\n    &#x2F;&#x2F; select类似LockSupport中的park，wakeup的原理类似LockSupport中的unpark\n    selector.wakeup();\n&#125;\n\n\nWorker线程执行的操作\n\n从同步队列中获取注册任务，并处理Read事件\n\n\n\npublic class testMultiThreadServer &#123;\n    public static void main(String[] args) throws IOException &#123;\n        Thread.currentThread().setName(&quot;BOSS&quot;);\n        ServerSocketChannel ssc &#x3D; ServerSocketChannel.open();\n        ssc.configureBlocking(false);\n        Selector boss &#x3D; Selector.open();\n        SelectionKey bossKey &#x3D; ssc.register(boss, 0, null);\n        bossKey.interestOps(SelectionKey.OP_ACCEPT);\n        ssc.bind(new InetSocketAddress(8080));\n        &#x2F;&#x2F;  创建固定数量的Worker\n        Worker[] workers &#x3D; new Worker[2];\n        for (int i &#x3D; 0; i &lt; 2; i++) &#123;\n            workers[i] &#x3D; new Worker(&quot;Worker-&quot; + i);\n        &#125;\n        AtomicInteger idx &#x3D; new AtomicInteger();\n        while (true) &#123;\n            boss.select();\n            Iterator&lt;SelectionKey&gt; it &#x3D; boss.selectedKeys().iterator();\n            while (it.hasNext()) &#123;\n                SelectionKey key &#x3D; it.next();\n                it.remove();\n                if (key.isAcceptable()) &#123;\n                    SocketChannel sc &#x3D; ssc.accept();\n                    sc.configureBlocking(false);\n                    System.out.println(&quot;sc --&gt; &quot; + sc);\n                    workers[idx.getAndIncrement() % workers.length].register(sc);\n                    &#x2F;&#x2F; 因为是内部类,所以可以直接访问属性\n&#x2F;&#x2F;                    sc.register(worker.selector, SelectionKey.OP_READ, null);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    static class Worker implements Runnable &#123;\n        private Thread thread;\n        private Selector selector;\n        private String name;\n        private volatile boolean flag &#x3D; false;\n        private ConcurrentLinkedQueue&lt;Runnable&gt; queue &#x3D; new ConcurrentLinkedQueue&lt;&gt;();\n        public Worker(String name) &#123;\n            this.name &#x3D; name;\n        &#125;\n\n        &#x2F;&#x2F; 初始化线程和Selector\n        public void register(SocketChannel sc) throws IOException &#123;\n            if (!flag) &#123;\n                selector &#x3D; Selector.open();\n                thread &#x3D; new Thread(this, name);\n                thread.start();\n                flag &#x3D; true;\n            &#125;\n\n            queue.add(() -&gt; &#123;\n                try &#123;\n                    sc.register(selector, SelectionKey.OP_READ, null);\n                &#125; catch (ClosedChannelException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;);\n            selector.wakeup();\n        &#125;\n        @Override\n        public void run() &#123;\n            while (true) &#123;\n                try &#123;\n                    selector.select();\n                    Runnable task &#x3D; queue.poll();\n                    if (task !&#x3D; null) task.run();\n                    Iterator&lt;SelectionKey&gt; it &#x3D; selector.selectedKeys().iterator();\n                    while (it.hasNext()) &#123;\n                        SelectionKey key &#x3D; it.next();\n                        it.remove();\n                        if (key.isReadable()) &#123;\n                            System.out.println(&quot;Read...&quot;);\n                            ByteBuffer buffer &#x3D; ByteBuffer.allocate(16);\n                            SocketChannel channel &#x3D; (SocketChannel) key.channel();\n                            channel.read(buffer);\n                            buffer.flip();\n                            System.out.println(Charset.defaultCharset().decode(buffer).toString());\n                            buffer.clear();\n                        &#125;\n                    &#125;\n                &#125; catch (IOException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n4. NIO vs BIOa. Stream vs Channel\nstream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）\nstream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用\n二者均为全双工，即读写可以同时进行\n虽然Stream是单向流动的，但是它也是全双工的\n\n\n\nb. IO模型五种IO模型\n\n同步阻塞\n同步非阻塞\n同步多路复用\n异步非阻塞(异步没有阻塞的情况)\n\n同步和异步:\n\n同步：线程自己去获取结果（一个线程）\n例如：线程调用一个方法后，需要等待方法返回结果\n\n\n异步：线程自己不去获取结果，而是由其它线程返回结果（至少两个线程）\n例如：线程A调用一个方法后，继续向下运行，运行结果由线程B返回\n\n\n\n当调用一次 channel.read 或 stream.read 后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：\n\n等待数据阶段\n复制数据阶段\n\n1.阻塞IO\n\n\n用户线程进行read操作时，需要等待操作系统执行实际的read操作，此期间用户线程是被阻塞的，无法执行其他操作\n\n2.非阻塞IO\n\n\n用户线程\n在一个循环中一直调用read方法，若内核空间中还没有数据可读，立即返回\n\n只是在等待阶段非阻塞\n\n\n用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果\n\n\n3.多路复用\n\nJava中通过Selector实现多路复用\n\n当没有事件是，调用select方法会被阻塞住\n一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用\n\n多路复用与阻塞IO的区别\n\n阻塞IO模式下，若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后，才能去处理read事件\n多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行\n\n4.异步IO\n\n\n线程1调用方法后理解返回，不会被阻塞也不需要立即获取结果\n当方法的运行结果出来以后，由线程2将结果返回给线程1\n\nc.零拷贝零拷贝指的是数据无需拷贝到 JVM 内存中，同时具有以下三个优点\n\n更少的用户态与内核态的切换\n不利用 cpu 计算，减少 cpu 缓存伪共享\n零拷贝适合小文件传输\n\n1. 传统 IO 问题传统的 IO 将一个文件通过 socket 写出\nFile f &#x3D; new File(&quot;helloword&#x2F;data.txt&quot;);\nRandomAccessFile file &#x3D; new RandomAccessFile(file, &quot;r&quot;);\n\nbyte[] buf &#x3D; new byte[(int)f.length()];\nfile.read(buf);\n\nSocket socket &#x3D; ...;\nsocket.getOutputStream().write(buf);\n\n内部工作流如下\n\n\n\nJava 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 Java 程序的用户态切换至内核态，去调用操作系统（Kernel）的读能力，将数据读入内核缓冲区。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 CPU。\nDMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO\n\n从内核态切换回用户态，将数据从内核缓冲区读入用户缓冲区（即 byte[] buf），这期间 CPU 会参与拷贝，无法利用 DMA\n\n调用 write 方法，这时将数据从用户缓冲区（byte[] buf）写入 socket 缓冲区，CPU 会参与拷贝\n\n接下来要向网卡写数据，这项能力 Java 又不具备，因此又得从用户态切换至内核态，调用操作系统的写能力，使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 CPU\n\n\n可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的\n\n用户态与内核态的切换发生了 3 次，这个操作比较重量级\n数据拷贝了共 4 次\n\n2. NIO 优化通过 DirectByteBuf\n\nByteBuffer.allocate(10)\n\n底层对应 HeapByteBuffer，使用的还是 Java 内存\n\n\nByteBuffer.\nallocateDirect\n(10)\n\n底层对应DirectByteBuffer，使用的是操作系统内存\n\n\n\n\n\n大部分步骤与优化前相同，唯有一点：Java 可以使用 DirectByteBuffer 将堆外内存映射到 JVM 内存中来直接访问使用\n\n这块内存不受 JVM 垃圾回收的影响，因此内存地址固定，有助于 IO 读写\nJava 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步\nDirectByteBuffer 对象被垃圾回收，将虚引用加入引用队列\n当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存\nDirectByteBuffer 的释放底层调用的是 Unsafe 的 freeMemory 方法\n\n\n通过专门线程访问引用队列，根据虚引用释放堆外内存\n\n\n减少了一次数据拷贝，用户态与内核态的切换次数没有减少\n\n3. 进一步优化1以下两种方式都是零拷贝，即无需将数据拷贝到用户缓冲区中（JVM内存中）\n底层采用了 linux 2.1 后提供的 sendFile 方法，Java 中对应着两个 channel 调用 transferTo&#x2F;transferFrom 方法拷贝数据\n\n\n\nJava 调用 transferTo 方法后，要从 Java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 CPU\n数据从内核缓冲区传输到 socket 缓冲区，CPU 会参与拷贝\n最后使用 DMA 将 socket 缓冲区的数据写入网卡，不会使用 CPU\n\n这种方法下\n\n只发生了1次用户态与内核态的切换\n数据拷贝了 3 次\n\n4. 进一步优化2linux 2.4 对上述方法再次进行了优化\n\n\n\nJava 调用 transferTo 方法后，要从 Java 程序的用户态切换至内核态，使用 DMA将数据读入内核缓冲区，不会使用 CPU\n只会将一些 offset 和 length 信息拷入 socket 缓冲区，几乎无消耗\n使用 DMA 将 内核缓冲区的数据写入网卡，不会使用 CPU\n\n整个过程仅只发生了1次用户态与内核态的切换，数据拷贝了 2 次\n5. AIOAIO 用来解决数据复制阶段的阻塞问题\n\n同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置\n异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果\n\n异步模型需要底层操作系统（Kernel）提供支持\n\nWindows 系统通过 IOCP 实现了真正的异步 IO\nLinux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势\n\n","slug":"NIO","date":"2022-04-18T05:11:37.000Z","categories_index":"互联网八股","tags_index":"Java,NIO","author_index":"张 凡"},{"id":"46d3e14db35995d713fed042cf2dff6b","title":"Netty","content":"视频教程参考 黑马程序员Netty全套教程\n博客参考了 Nyima\n1. Netty 概述Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.\nNetty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端\n注意：netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO\n优势:\n如果使用传统NIO，其工作量大，bug 多\n\n需要自己构建协议\n解决 TCP 传输问题，如粘包、半包\n因为bug的存在，epoll 空轮询导致 CPU 100%\n\nNetty 对 API 进行增强，使之更易用，如\n\nFastThreadLocal &#x3D;&gt; ThreadLocal\nByteBuf &#x3D;&gt; ByteBuffer\n\n2. 入门案例服务器端代码\npublic class HelloServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 1、启动器，负责装配netty组件，启动服务器\n        new ServerBootstrap()\n                &#x2F;&#x2F; 2、创建 NioEventLoopGroup，可以简单理解为 线程池 + Selector\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 3、选择服务器的 ServerSocketChannel 实现\n                .channel(NioServerSocketChannel.class)\n                &#x2F;&#x2F; 4、child 负责处理读写，该方法决定了 child 执行哪些操作\n            \t&#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n            \t&#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(NioSocketChannel nioSocketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 5、SocketChannel的处理器，使用StringDecoder解码，ByteBuf&#x3D;&gt;String\n                        nioSocketChannel.pipeline().addLast(new StringDecoder());\n                        &#x2F;&#x2F; 6、SocketChannel的业务处理，使用上一个处理器的处理结果\n                        nioSocketChannel.pipeline().addLast(new SimpleChannelInboundHandler&lt;String&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;\n                                System.out.println(s);\n                            &#125;\n                        &#125;);\n                    &#125;\n                    &#x2F;&#x2F; 7、ServerSocketChannel绑定8080端口\n                &#125;).bind(8080);\n    &#125;\n&#125;\n\n客户端代码\npublic class HelloClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        new Bootstrap()\n                .group(new NioEventLoopGroup())\n                &#x2F;&#x2F; 选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现\n                .channel(NioSocketChannel.class)\n                &#x2F;&#x2F; ChannelInitializer 处理器（仅执行一次）\n                &#x2F;&#x2F; 它的作用是待客户端SocketChannel建立连接后，执行initChannel以便添加更多的处理器\n                .handler(new ChannelInitializer&lt;Channel&gt;() &#123;\n                    @Override\n                    protected void initChannel(Channel channel) throws Exception &#123;\n                        &#x2F;&#x2F; 消息会经过通道 handler 处理，这里是将 String &#x3D;&gt; ByteBuf 编码发出\n                        channel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 指定要连接的服务器和端口\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                &#x2F;&#x2F; Netty 中很多方法都是异步的，如 connect\n                &#x2F;&#x2F; 这时需要使用 sync 方法等待 connect 建立连接完毕\n                .sync()\n                &#x2F;&#x2F; 获取 channel 对象，它即为通道抽象，可以进行数据读写操作\n                .channel()\n                &#x2F;&#x2F; 写入消息并清空缓冲区\n                .writeAndFlush(&quot;hello world&quot;);\n    &#125;\n&#125;\n\n执行流程:\n左：客户端 右：服务器端\n\n\n组件解释\n\nchannel 可以理解为数据的通道\nmsg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 中的各个 handler 加工，会变成其它类型对象，最后输出又变成 ByteBuf\nhandler 可以理解为数据的处理工序\n工序有多道，合在一起就是 pipeline（传递途径），pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）\npipeline 中有多个 handler，处理时会依次调用其中的 handler\n\n\nhandler 分 Inbound 和 Outbound 两类\nInbound 入站\nOutbound 出站\n\n\n\n\neventLoop 可以理解为处理数据的工人\neventLoop 可以管理多个 channel 的 io 操作，并且一旦 eventLoop 负责了某个 channel，就会将其与channel进行绑定，以后该 channel 中的 io 操作都由该 eventLoop 负责\neventLoop 既可以执行 io 操作，也可以进行任务处理，每个 eventLoop 有自己的任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务\neventLoop 按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每个 handler 指定不同的 eventLoop\n\n\n\n3. Netty 组件a. EventLoop事件循环对象 EventLoop\nEventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件\n它的继承关系如下\n\n继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法\n继承自 netty 自己的 OrderedEventExecutor\n提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop\n提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup\n\n\n\n事件循环组 EventLoopGroup\nEventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）\n\n继承自 netty 自己的 EventExecutorGroup\n实现了 Iterable 接口提供遍历 EventLoop 的能力\n另有 next 方法获取集合中下一个 EventLoop\n\n\n\n1. EventLoop处理普通与定时任务public class TestEventLoop &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程\n        EventLoopGroup group &#x3D; new NioEventLoopGroup(2);\n        &#x2F;&#x2F; 通过next方法可以获得下一个 EventLoop\n        System.out.println(group.next());\n        System.out.println(group.next());\n\n        &#x2F;&#x2F; 通过EventLoop执行普通任务\n        group.next().execute(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello&quot;);\n        &#125;);\n\n        &#x2F;&#x2F; 通过EventLoop执行定时任务\n        group.next().scheduleAtFixedRate(()-&gt;&#123;\n            System.out.println(Thread.currentThread().getName() + &quot; hello2&quot;);\n        &#125;, 0, 1, TimeUnit.SECONDS);\n        \n        &#x2F;&#x2F; 优雅地关闭\n        group.shutdownGracefully();\n    &#125;\n&#125;\n\n输出结果如下:\nio.netty.channel.nio.NioEventLoop@7bb11784\nio.netty.channel.nio.NioEventLoop@33a10788\nnioEventLoopGroup-2-1 hello \t&#x2F;&#x2F; 普通任务\nnioEventLoopGroup-2-2 hello2\t&#x2F;&#x2F; 每隔一秒打印一次\nnioEventLoopGroup-2-2 hello2\nnioEventLoopGroup-2-2 hello2\n\n关闭 EventLoopGroup\n优雅关闭 shutdownGracefully 方法。该方法会首先切换 EventLoopGroup 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的\n2. EventLoop处理IO任务服务器端\npublic class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n\n客户端\npublic class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        Channel channel &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080))\n                .sync()\n                .channel();\n        System.out.println(channel);\n        &#x2F;&#x2F; 此处打断点调试，调用 channel.writeAndFlush(...);\n        System.in.read();\n    &#125;\n&#125;\n\n多个EventLoopGroup分工\npublic class MyServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n            \t&#x2F;&#x2F; 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n\t\t\t\t...\n    &#125;\n&#125;\n\n多个客户端分别发送 hello 结果\nnioEventLoopGroup-3-1 hello1\nnioEventLoopGroup-3-2 hello2\nnioEventLoopGroup-3-1 hello3\nnioEventLoopGroup-3-2 hello4\nnioEventLoopGroup-3-2 hello4 \n\n可以看出，一个EventLoop可以负责多个Channel，且EventLoop一旦与Channel绑定，则一直负责处理该Channel中的事件\n\n3. 增加自定义EventLoopGroup当有的任务需要较长的时间处理时，可以使用非NioEventLoopGroup，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理\npublic class MyServer &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 增加自定义的非NioEventLoopGroup\n        EventLoopGroup group &#x3D; new DefaultEventLoopGroup();\n        \n        new ServerBootstrap()\n                .group(new NioEventLoopGroup(1), new NioEventLoopGroup(2))\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理\n                        socketChannel.pipeline().addLast(&quot;nioHandler&quot;,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                                &#x2F;&#x2F; 调用下一个handler\n                                ctx.fireChannelRead(msg);\n                            &#125;\n                        &#125;)\n                        &#x2F;&#x2F; 该handler绑定自定义的Group\n                        .addLast(group, &quot;myHandler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                ByteBuf buf &#x3D; (ByteBuf) msg;\n                                System.out.println(Thread.currentThread().getName() + &quot; &quot; + buf.toString(StandardCharsets.UTF_8));\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n\n启动四个客户端发送数据\nnioEventLoopGroup-4-1 hello1\ndefaultEventLoopGroup-2-1 hello1\nnioEventLoopGroup-4-2 hello2\ndefaultEventLoopGroup-2-2 hello2\nnioEventLoopGroup-4-1 hello3\ndefaultEventLoopGroup-2-3 hello3\nnioEventLoopGroup-4-2 hello4\ndefaultEventLoopGroup-2-4 hello4\n\n可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理\n\n\n4. 切换的实现不同的EventLoopGroup切换的实现原理如下\n由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务\nstatic void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;\n    final Object m &#x3D; next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);\n    &#x2F;&#x2F; 获得下一个EventLoop, excutor 即为 EventLoopGroup\n    EventExecutor executor &#x3D; next.executor();\n    \n    &#x2F;&#x2F; 如果下一个EventLoop 在当前的 EventLoopGroup中\n    if (executor.inEventLoop()) &#123;\n        &#x2F;&#x2F; 使用当前 EventLoopGroup 中的 EventLoop 来处理任务\n        next.invokeChannelRead(m);\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行\n        executor.execute(new Runnable() &#123;\n            public void run() &#123;\n                next.invokeChannelRead(m);\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n如果两个 handler 绑定的是同一个EventLoopGroup，那么就直接调用\n否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用\n\nb. ChannelChannel 的常用方法\n\nclose() 可以用来关闭Channel\ncloseFuture() 用来处理 Channel 的关闭\nsync 方法作用是同步等待 Channel 关闭\n而 addListener 方法是异步等待 Channel 关闭\n\n\npipeline() 方法用于添加处理器\nwrite() 方法将数据写入\n因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送\n只有当缓冲满了或者调用了flush()方法后，才会将数据通过 Channel 发送出去\n\n\nwriteAndFlush() 方法将数据写入并立即发送（刷出）\n\n1. ChannelFuture连接问题拆分客户端代码\npublic class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n            \t&#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n        &#x2F;&#x2F; 该方法用于等待连接真正建立\n        channelFuture.sync();\n        \n        &#x2F;&#x2F; 获取客户端-服务器之间的Channel对象\n        Channel channel &#x3D; channelFuture.channel();\n        channel.writeAndFlush(&quot;hello world&quot;);\n        System.in.read();\n    &#125;\n&#125;\n\n如果我们去掉channelFuture.sync()方法，会服务器无法收到hello world\n这是因为建立连接(connect)的过程是异步非阻塞的，若不通过sync()方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() 拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel，也就没法将信息正确的传输给服务器端\n所以需要通过channelFuture.sync()方法，阻塞主线程，同步处理结果，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程都是主线程\n下面还有一种方法，用于异步获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）\naddListener方法\n通过这种方法可以在NIO线程中获取 Channel 并发送数据，而不是在主线程中执行这些操作\npublic class MyClient &#123;\n    public static void main(String[] args) throws IOException, InterruptedException &#123;\n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                &#x2F;&#x2F; 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程\n                &#x2F;&#x2F; NIO线程：NioEventLoop 中的线程\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        \n\t\t&#x2F;&#x2F; 当connect方法执行完毕后，也就是连接真正建立后\n        &#x2F;&#x2F; 会在NIO线程中调用operationComplete方法\n        channelFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n                Channel channel &#x3D; channelFuture.channel();\n                channel.writeAndFlush(&quot;hello world&quot;);\n            &#125;\n        &#125;);\n        System.in.read();\n    &#125;\n&#125;\n\n2.处理关闭public class ReadClient &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoopGroup，使用完毕后关闭\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        \n        ChannelFuture channelFuture &#x3D; new Bootstrap()\n                .group(group)\n                .channel(NioSocketChannel.class)\n                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        socketChannel.pipeline().addLast(new StringEncoder());\n                    &#125;\n                &#125;)\n                .connect(new InetSocketAddress(&quot;localhost&quot;, 8080));\n        channelFuture.sync();\n\n        Channel channel &#x3D; channelFuture.channel();\n        Scanner scanner &#x3D; new Scanner(System.in);\n\n        &#x2F;&#x2F; 创建一个线程用于输入并向服务器发送\n        new Thread(()-&gt;&#123;\n            while (true) &#123;\n                String msg &#x3D; scanner.next();\n                if (&quot;q&quot;.equals(msg)) &#123;\n                    &#x2F;&#x2F; 关闭操作是异步的，在NIO线程中执行\n                    channel.close();\n                    break;\n                &#125;\n                channel.writeAndFlush(msg);\n            &#125;\n        &#125;, &quot;inputThread&quot;).start();\n\n        &#x2F;&#x2F; 获得closeFuture对象\n        ChannelFuture closeFuture &#x3D; channel.closeFuture();\n        System.out.println(&quot;waiting close...&quot;);\n        \n        &#x2F;&#x2F; 同步等待NIO线程执行完close操作\n        closeFuture.sync();\n        \n        &#x2F;&#x2F; 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        \n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;\n\n关闭channel\n当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个异步方法。真正的关闭操作并不是在调用该方法的线程中执行的，而是在NIO线程中执行真正的关闭操作\n如果我们想在channel真正关闭以后，执行一些额外的操作，可以选择以下两种方法来实现\n\n通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用sync()方法阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作\n&#x2F;&#x2F; 获得closeFuture对象\nChannelFuture closeFuture &#x3D; channel.closeFuture();\n\n&#x2F;&#x2F; 同步等待NIO线程执行完close操作\ncloseFuture.sync();\n\n调用closeFuture.addListener方法，添加close的后续操作\ncloseFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;\n        &#x2F;&#x2F; 等待channel关闭后才执行的操作\n        System.out.println(&quot;关闭之后执行一些额外操作...&quot;);\n        &#x2F;&#x2F; 关闭EventLoopGroup\n        group.shutdownGracefully();\n    &#125;\n&#125;);\n\nc. Future &amp; Promise1.概念netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口\nnetty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展\n\njdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果\nnetty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束\nnetty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器\n\n\n\n\n功能&#x2F;名称\njdk Future\nnetty Future\nPromise\n\n\n\ncancel\n取消任务\n-\n-\n\n\nisCanceled\n任务是否取消\n-\n-\n\n\nisDone\n任务是否完成，不能区分成功失败\n-\n-\n\n\nget\n获取任务结果，阻塞等待\n-\n-\n\n\ngetNow\n-\n获取任务结果，非阻塞，还未产生结果时返回 null\n-\n\n\nawait\n-\n等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断\n-\n\n\nsync\n-\n等待任务结束，如果任务失败，抛出异常\n-\n\n\nisSuccess\n-\n判断任务是否成功\n-\n\n\ncause\n-\n获取失败信息，非阻塞，如果没有失败，返回null\n-\n\n\naddLinstener\n-\n添加回调，异步接收结果\n-\n\n\nsetSuccess\n-\n-\n设置成功结果\n\n\nsetFailure\n-\n-\n设置失败结果\n\n\n2. JDK Futurepublic class JdkFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        ThreadFactory factory &#x3D; new ThreadFactory() &#123;\n            @Override\n            public Thread newThread(Runnable r) &#123;\n                return new Thread(r, &quot;JdkFuture&quot;);\n            &#125;\n        &#125;;\n        &#x2F;&#x2F; 创建线程池\n        ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10,10, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(10), factory);\n\n        &#x2F;&#x2F; 获得Future对象\n        Future&lt;Integer&gt; future &#x3D; executor.submit(new Callable&lt;Integer&gt;() &#123;\n\n            @Override\n            public Integer call() throws Exception &#123;\n                TimeUnit.SECONDS.sleep(1);\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 通过阻塞的方式，获得运行结果\n        System.out.println(future.get());\n    &#125;\n&#125;\n\n3.Netty Futurepublic class NettyFuture &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n\n        &#x2F;&#x2F; 获得 EventLoop 对象\n        EventLoop eventLoop &#x3D; group.next();\n        Future&lt;Integer&gt; future &#x3D; eventLoop.submit(new Callable&lt;Integer&gt;() &#123;\n            @Override\n            public Integer call() throws Exception &#123;\n                return 50;\n            &#125;\n        &#125;);\n\n        &#x2F;&#x2F; 主线程中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n        System.out.println(&quot;getNow &quot; + future.getNow());\n        System.out.println(&quot;get &quot; + future.get());\n\n        &#x2F;&#x2F; NIO线程中异步获取结果\n        future.addListener(new GenericFutureListener&lt;Future&lt;? super Integer&gt;&gt;() &#123;\n            @Override\n            public void operationComplete(Future&lt;? super Integer&gt; future) throws Exception &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 获取结果&quot;);\n                System.out.println(&quot;getNow &quot; + future.getNow());\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n运行结果\nmain 获取结果\ngetNow null\nget 50\nnioEventLoopGroup-2-1 获取结果\ngetNow 50\n\nNetty中的Future对象，可以通过EventLoop的sumbit()方法得到\n\n可以通过Future对象的get方法，阻塞地获取返回结果\n也可以通过getNow方法，获取结果，若还没有结果，则返回null，该方法是非阻塞的\n还可以通过future.addListener方法，在Callable方法执行的线程中，异步获取返回结果\n\n4.Netty PromisePromise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果\npublic class NettyPromise &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建EventLoop\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        EventLoop eventLoop &#x3D; group.next();\n\n        &#x2F;&#x2F; 创建Promise对象，用于存放结果\n        DefaultPromise&lt;Integer&gt; promise &#x3D; new DefaultPromise&lt;&gt;(eventLoop);\n\n        new Thread(()-&gt;&#123;\n            try &#123;\n                TimeUnit.SECONDS.sleep(1);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 自定义线程向Promise中存放结果\n            promise.setSuccess(50);\n        &#125;).start();\n\n        &#x2F;&#x2F; 主线程从Promise中获取结果\n        System.out.println(Thread.currentThread().getName() + &quot; &quot; + promise.get());\n    &#125;\n&#125;\n\n\n\nd. Handler &amp; Pipline1. Pipelinepublic class PipeLineServer &#123;\n    public static void main(String[] args) &#123;\n        new ServerBootstrap()\n                .group(new NioEventLoopGroup())\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;\n                        &#x2F;&#x2F; 在socketChannel的pipeline中添加handler\n                        &#x2F;&#x2F; pipeline中handler是带有head与tail节点的双向链表，的实际结构为\n    \t\t\t\t \t&#x2F;&#x2F; head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail\n                        &#x2F;&#x2F; Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法\n                        &#x2F;&#x2F; 入站时，handler是从head向后调用的\n                        socketChannel.pipeline().addLast(&quot;handler1&quot; ,new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 1&quot;);\n                                &#x2F;&#x2F; 父类该方法内部会调用fireChannelRead\n                                &#x2F;&#x2F; 将数据传递给下一个handler\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler2&quot;, new ChannelInboundHandlerAdapter() &#123;\n                            @Override\n                            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Inbound handler 2&quot;);\n                                &#x2F;&#x2F; 执行write操作，使得Outbound的方法能够得到调用\n          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(&quot;Server...&quot;.getBytes(StandardCharsets.UTF_8)));\n                                super.channelRead(ctx, msg);\n                            &#125;\n                        &#125;);\n                        &#x2F;&#x2F; Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法\n                        &#x2F;&#x2F; 出站时，handler的调用是从tail向前调用的\n                        socketChannel.pipeline().addLast(&quot;handler3&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 1&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                        socketChannel.pipeline().addLast(&quot;handler4&quot; ,new ChannelOutboundHandlerAdapter()&#123;\n                            @Override\n                            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                                System.out.println(Thread.currentThread().getName() + &quot; Outbound handler 2&quot;);\n                                super.write(ctx, msg, promise);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n\n运行结果如下\nnioEventLoopGroup-2-2 Inbound handler 1\nnioEventLoopGroup-2-2 Inbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 2\nnioEventLoopGroup-2-2 Outbound handler 1\n\n通过channel.pipeline().addLast(name, handler)添加handler时，记得给handler取名字。这样可以调用pipeline的addAfter、addBefore等方法更灵活地向pipeline中添加handler\nhandler需要放入通道的pipeline中，才能根据放入顺序来使用handler\n\npipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler\n要通过ctx.fireChannelRead(msg)等方法，将当前handler的处理结果传递给下一个handler\n\n\n当有入站（Inbound）操作时，会从head开始向后调用handler，直到handler不是处理Inbound操作为止\n当有出站（Outbound）操作时，会从tail开始向前调用handler，直到handler不是处理Outbound操作为止\n\n具体结构如下\n\n\n调用顺序如下\n\n\n2. OutboundHandlera. socketChannel.writeAndFlush()当handler中调用该方法进行写操作时，会触发Outbound操作，此时是从tail向前寻找OutboundHandler\n\n\nb. ctx.writeAndFlush()当handler中调用该方法进行写操作时，会触发Outbound操作，此时是从当前handler向前寻找OutboundHandler\n\n\n3. EmbeddedChannelEmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可\npublic class TestEmbeddedChannel &#123;\n    public static void main(String[] args) &#123;\n        ChannelInboundHandlerAdapter h1 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;1&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelInboundHandlerAdapter h2 &#x3D; new ChannelInboundHandlerAdapter() &#123;\n            @Override\n            public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n                System.out.println(&quot;2&quot;);\n                super.channelRead(ctx, msg);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h3 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;3&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        ChannelOutboundHandlerAdapter h4 &#x3D; new ChannelOutboundHandlerAdapter() &#123;\n            @Override\n            public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;\n                System.out.println(&quot;4&quot;);\n                super.write(ctx, msg, promise);\n            &#125;\n        &#125;;\n\n        &#x2F;&#x2F; 用于测试Handler的Channel\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(h1, h2, h3, h4);\n        \n        &#x2F;&#x2F; 执行Inbound操作 \n        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n        &#x2F;&#x2F; 执行Outbound操作\n        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(&quot;hello&quot;.getBytes(StandardCharsets.UTF_8)));\n    &#125;\n&#125;\n\n\n\ne. ByteBuf1.创建public class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        StringBuilder sb &#x3D; new StringBuilder();\n        for(int i &#x3D; 0; i &lt; 20; i++) &#123;\n            sb.append(&quot;a&quot;);\n        &#125;\n        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n        &#x2F;&#x2F; 查看写入结果\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;\n\n运行结果\nread index:0 write index:0 capacity:16\n\nread index:0 write index:20 capacity:64\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|\n|00000010| 61 61 61 61                                     |aaaa            |\n+--------+-------------------------------------------------+----------------+\n\nByteBuf通过ByteBufAllocator选择allocator并调用对应的buffer()方法来创建的，默认使用直接内存作为ByteBuf，容量为256个字节，可以指定初始容量的大小\n当ByteBuf的容量无法容纳所有数据时，ByteBuf会进行扩容操作\n如果在handler中创建ByteBuf，建议使用ChannelHandlerContext ctx.alloc().buffer()来创建\n2.直接内存与堆内存通过该方法创建的ByteBuf，使用的是基于直接内存的ByteBuf\nByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16); \n\n可以使用下面的代码来创建池化基于堆的 ByteBuf\nByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16); \n\n也可以使用下面的代码来创建池化基于直接内存的 ByteBuf\nByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16); \n\n\n直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用\n直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放\n\n验证\npublic class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.heapBuffer(16);\n        System.out.println(buffer.getClass());\n\n        buffer &#x3D; ByteBufAllocator.DEFAULT.directBuffer(16);\n        System.out.println(buffer.getClass());\n    &#125;\n&#125;\n&#x2F;&#x2F; 使用池化的直接内存\nclass io.netty.buffer.PooledUnsafeDirectByteBuf\n    \n&#x2F;&#x2F; 使用池化的堆内存    \nclass io.netty.buffer.PooledUnsafeHeapByteBuf\n    \n&#x2F;&#x2F; 使用池化的直接内存    \nclass io.netty.buffer.PooledUnsafeDirectByteBuf \n\n3.池化与非池化池化的最大意义在于可以重用 ByteBuf，优点有\n\n没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力\n有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率\n高并发时，池化功能更节约内存，减少内存溢出的可能\n\n池化功能是否开启，可以通过下面的系统环境变量来设置\n-Dio.netty.allocator.type&#x3D;&#123;unpooled|pooled&#125; \n\n\n4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现\n4.1 之前，池化功能还不成熟，默认是非池化实现\n\n4.组成ByteBuf主要有以下几个组成部分\n\n最大容量与当前容量\n\n在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE\n当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若超出最大容量，会抛出java.lang.IndexOutOfBoundsException异常\n\n\n读写操作不同于ByteBuffer只用position进行控制，\nByteBuf分别由读指针和写指针两个指针控制\n。进行读写操作时，无需进行模式的切换\n\n读指针前的部分被称为废弃部分，是已经读过的内容\n读指针与写指针之间的空间称为可读部分\n写指针与当前容量之间的空间称为可写部分\n\n\n\n\n\n5.写入常用方法如下\n\n\n\n方法签名\n含义\n备注\n\n\n\nwriteBoolean(boolean value)\n写入 boolean 值\n用一字节 01|00 代表 true|false\n\n\nwriteByte(int value)\n写入 byte 值\n\n\n\nwriteShort(int value)\n写入 short 值\n\n\n\nwriteInt(int value)\n写入 int 值\nBig Endian（大端写入），即 0x250，写入后 00 00 02 50\n\n\nwriteIntLE(int value)\n写入 int 值\nLittle Endian（小端写入），即 0x250，写入后 50 02 00 00\n\n\nwriteLong(long value)\n写入 long 值\n\n\n\nwriteChar(int value)\n写入 char 值\n\n\n\nwriteFloat(float value)\n写入 float 值\n\n\n\nwriteDouble(double value)\n写入 double 值\n\n\n\nwriteBytes(ByteBuf src)\n写入 netty 的 ByteBuf\n\n\n\nwriteBytes(byte[] src)\n写入 byte[]\n\n\n\nwriteBytes(ByteBuffer src)\n写入 nio 的 ByteBuffer\n\n\n\nint writeCharSequence(CharSequence sequence, Charset charset)\n写入字符串\nCharSequence为字符串类的父类，第二个参数为对应的字符集\n\n\n注意\n\n这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据\n网络传输中，默认习惯是 Big Endian，使用 writeInt(int value)\n\n使用方法\npublic class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeInt(5);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeIntLE(6);\n        ByteBufUtil.log(buffer);\n\n        buffer.writeLong(7);\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125;\n\n运行结果\nread index:0 write index:0 capacity:16\n\nread index:0 write index:4 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05                         |........        |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:12 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |\n+--------+-------------------------------------------------+----------------+\n\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置\n6.扩容当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作\nbuffer.writeLong(7);\nByteBufUtil.log(buffer); \n&#x2F;&#x2F; 扩容前\nread index:0 write index:12 capacity:16\n...\n\n&#x2F;&#x2F; 扩容后\nread index:0 write index:20 capacity:20\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|\n|00000010| 00 00 00 07                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n7.扩容规则\n如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容\n\n例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节\n\n\n如果写入后数据大小超过 512 字节，则选择下一个 2\nn\n\n例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）\n\n\n扩容不能超过 maxCapacity，否则会抛出java.lang.IndexOutOfBoundsException异常\n\n\nException in thread &quot;main&quot; java.lang.IndexOutOfBoundsException: writerIndex(20) + minWritableBytes(8) exceeds maxCapacity(20): PooledUnsafeDirectByteBuf(ridx: 0, widx: 20, cap: 20&#x2F;20)\n...\n\n8.读取读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针\n如果需要重复读取，需要调用buffer.markReaderIndex()对读指针进行标记，并通过buffer.resetReaderIndex()将读指针恢复到mark标记的位置\npublic class ByteBufStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4&#125;);\n        buffer.writeInt(5);\n\n        &#x2F;&#x2F; 读取4个字节\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        System.out.println(buffer.readByte());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 通过mark与reset实现重复读取\n        buffer.markReaderIndex();\n        System.out.println(buffer.readInt());\n        ByteBufUtil.log(buffer);\n\n        &#x2F;&#x2F; 恢复到mark标记处\n        buffer.resetReaderIndex();\n        ByteBufUtil.log(buffer);\n    &#125;\n&#125; \n1\n2\n3\n4\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+\n5\nread index:8 write index:8 capacity:16\n\nread index:4 write index:8 capacity:16\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 00 00 05                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n还有以 get 开头的一系列方法，这些方法不会改变读指针的位置\n9.释放由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。\n\nUnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可\nUnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存\nPooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存\n\nNetty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口\n\n每个 ByteBuf 对象的初始计数为 1\n调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收\n调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收\n当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用\n\n10.释放规则因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）\n基本规则是，谁是最后使用者，谁负责 release\n\n起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）\n\n入站 ByteBuf 处理原则\n\n对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release\n将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release\n如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release\n注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release\n假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）\n\n\n出站 ByteBuf 处理原则\n\n出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release\n\n\n异常处理原则\n\n有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true\nwhile (!buffer.release()) &#123;&#125; \n\n\n\n当ByteBuf被传到了pipeline的head与tail时，ByteBuf会被其中的方法彻底释放，但前提是ByteBuf被传递到了head与tail中\nTailConext中释放ByteBuf的源码\nprotected void onUnhandledInboundMessage(Object msg) &#123;\n    try &#123;\n        logger.debug(&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;, msg);\n    &#125; finally &#123;\n        &#x2F;&#x2F; 具体的释放方法\n        ReferenceCountUtil.release(msg);\n    &#125;\n&#125;\n\n判断传过来的是否为ByteBuf，是的话才需要释放\npublic static boolean release(Object msg) &#123;\n\treturn msg instanceof ReferenceCounted ? ((ReferenceCounted)msg).release() : false;\n&#125;\n\n11.切片ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针\n得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用\n修改原ByteBuf中的值，也会影响切片后得到的ByteBuf\n\n\npublic class TestSlice &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建ByteBuf\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer(16, 20);\n\n        &#x2F;&#x2F; 向buffer中写入数据\n        buffer.writeBytes(new byte[]&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10&#125;);\n\n        &#x2F;&#x2F; 将buffer分成两部分\n        ByteBuf slice1 &#x3D; buffer.slice(0, 5);\n        ByteBuf slice2 &#x3D; buffer.slice(5, 5);\n\n        &#x2F;&#x2F; 需要让分片的buffer引用计数加一\n        &#x2F;&#x2F; 避免原Buffer释放导致分片buffer无法使用\n        slice1.retain();\n        slice2.retain();\n        \n        ByteBufUtil.log(slice1);\n        ByteBufUtil.log(slice2);\n\n        &#x2F;&#x2F; 更改原始buffer中的值\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        buffer.setByte(0,5);\n\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        ByteBufUtil.log(slice1);\n    &#125;\n&#125;\n\n运行结果\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 01 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 06 07 08 09 0a                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;修改原buffer中的值&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;打印slice1&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\nread index:0 write index:5 capacity:5\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 05 02 03 04 05                                  |.....           |\n+--------+-------------------------------------------------+----------------+\n\n12.优势\n池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能\n读写指针分离，不需要像 ByteBuffer 一样切换读写模式\n可以自动扩容\n支持链式调用，使用更流畅\n很多地方体现零拷贝，例如\nslice、duplicate、CompositeByteBuf\n\n\n\n4. 黏包半包a.黏包与半包现象服务器代码\npublic class StudyServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    void start() &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup(1);\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) &#123;\n                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接建立时会执行该方法\n                            log.debug(&quot;connected &#123;&#125;&quot;, ctx.channel());\n                            super.channelActive(ctx);\n                        &#125;\n\n                        @Override\n                        public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;\n                            &#x2F;&#x2F; 连接断开时会执行该方法\n                            log.debug(&quot;disconnect &#123;&#125;&quot;, ctx.channel());\n                            super.channelInactive(ctx);\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; serverBootstrap.bind(8080);\n            log.debug(&quot;&#123;&#125; binding...&quot;, channelFuture.channel());\n            channelFuture.sync();\n            log.debug(&quot;&#123;&#125; bound...&quot;, channelFuture.channel());\n            &#x2F;&#x2F; 关闭channel\n            channelFuture.channel().closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;server error&quot;, e);\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n            log.debug(&quot;stopped&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        new StudyServer().start();\n    &#125;\n&#125;\n\n1. 粘包现象客户端代码\npublic class StudyClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(worker);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    log.debug(&quot;connected...&quot;);\n                    ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            log.debug(&quot;sending...&quot;);\n                            &#x2F;&#x2F; 每次发送16个字节的数据，共发送10次\n                            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                                ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n                                ctx.writeAndFlush(buffer);\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            ChannelFuture channelFuture &#x3D; bootstrap.connect(&quot;127.0.0.1&quot;, 8080).sync();\n            channelFuture.channel().closeFuture().sync();\n\n        &#125; catch (InterruptedException e) &#123;\n            log.error(&quot;client error&quot;, e);\n        &#125; finally &#123;\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n服务器接收结果\n7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:53797] READ: 160B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象\n2. 半包现象将客户端-服务器之间的channel容量进行调整\n服务器代码\n&#x2F;&#x2F; 调整channel的容量\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10);\n\n注意\nserverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍\n服务器接收结果\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 36B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n|00000020| 00 01 02 03                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|\n|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 40B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|\n|00000020| 04 05 06 07 08 09 0a 0b                         |........        |\n+--------+-------------------------------------------------+----------------+\n\n5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:49679] READ: 4B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 0c 0d 0e 0f                                     |....            |\n+--------+-------------------------------------------------+----------------+\n\n可见客户端每次发送的数据，因channel容量不足，无法将发送的数据一次性接收，便产生了半包现象\nb. 现象分析1. 粘包\n现象\n发送 abc def，接收 abcdef\n\n\n原因\n应用层\n接收方 ByteBuf 设置太大（Netty 默认 1024）\n\n\n传输层-网络层\n滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包\nNagle 算法：会造成粘包\n\n\n\n\n\n2. 半包\n现象\n发送 abcdef，接收 abc def\n\n\n原因\n应用层\n接收方 ByteBuf 小于实际发送数据量\n\n\n传输层-网络层\n滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包\n\n\n数据链路层\nMSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包\n\n\n\n\n\n3. 本质发生粘包与半包现象的本质是因为 TCP 是流式协议，消息无边界\nc. 解决方案1. 短链接客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以短链接无法解决半包现象\n客户端代码改进\n修改channelActive方法\npublic void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n    log.debug(&quot;sending...&quot;);\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(16);\n    buffer.writeBytes(new byte[]&#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15&#125;);\n    ctx.writeAndFlush(buffer);\n    &#x2F;&#x2F; 使用短链接，每次发送完毕后就断开连接\n    ctx.channel().close();\n&#125; \n\n将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F; 发送10次\n    for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n        send();\n    &#125;\n&#125;\n\n运行结果\n6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] ACTIVE\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65024] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65024] INACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] ACTIVE\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65057] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|\n+--------+-------------------------------------------------+----------------+\n\n6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:&#x2F;127.0.0.1:8080 ! R:&#x2F;127.0.0.1:65057] INACTIVE\n\n...\n\n客户端先于服务器建立连接，此时控制台打印ACTIVE，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印INACTIVE，可见未出现粘包现象\n2. 定长解码器客户端于服务器约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度。若发送数据长度不足则需要补齐至该长度\n服务器接收数据时，将接收到的数据按照约定的最大长度进行拆分，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。服务端需要用到FixedLengthFrameDecoder对数据进行定长解码，具体使用方法如下\nch.pipeline().addLast(new FixedLengthFrameDecoder(16)); \n\n客户端代码\n客户端发送数据的代码如下\n&#x2F;&#x2F; 约定最大长度为16\nfinal int maxLength &#x3D; 16;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\n&#x2F;&#x2F; 向服务器发送10个报文\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 定长byte数组，未使用部分会以0进行填充\n    byte[] bytes &#x3D; new byte[maxLength];\n    &#x2F;&#x2F; 生成长度为0~15的数据\n    for (int j &#x3D; 0; j &lt; (int)(Math.random()*(maxLength-1)); j++) &#123;\n        bytes[j] &#x3D; (byte) c;\n    &#125;\n    buffer.writeBytes(bytes);\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;\n\n服务器代码\n使用FixedLengthFrameDecoder对粘包数据进行拆分，该handler需要添加在LoggingHandler之前，保证数据被打印时已被拆分\n&#x2F;&#x2F; 通过定长解码器对粘包数据进行拆分\nch.pipeline().addLast(new FixedLengthFrameDecoder(16));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n\n运行结果\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|\n+--------+-------------------------------------------------+----------------+\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|\n+--------+-------------------------------------------------+----------------+\n\n\n8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:52954] READ: 16B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|\n+--------+-------------------------------------------------+----------------+\n\n...\n\n3. 行解码器行解码器的是通过分隔符对数据进行拆分来解决粘包半包问题的\n可以通过LineBasedFrameDecoder(int maxLength)来拆分以换行符(\\n)为分隔符的数据，也可以通过DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)来指定通过什么分隔符来拆分数据（可以传入多个分隔符）\n两种解码器都需要传入数据的最大长度，若超出最大长度，会抛出TooLongFrameException异常\n以换行符 \\n 为分隔符\n客户端代码\n&#x2F;&#x2F; 约定最大长度为 64\nfinal int maxLength &#x3D; 64;\n&#x2F;&#x2F; 被发送的数据\nchar c &#x3D; &#39;a&#39;;\nfor (int i &#x3D; 0; i &lt; 10; i++) &#123;\n    ByteBuf buffer &#x3D; ctx.alloc().buffer(maxLength);\n    &#x2F;&#x2F; 生成长度为0~62的数据\n    Random random &#x3D; new Random();\n    StringBuilder sb &#x3D; new StringBuilder();\n    for (int j &#x3D; 0; j &lt; (int)(random.nextInt(maxLength-2)); j++) &#123;\n        sb.append(c);\n    &#125;\n    &#x2F;&#x2F; 数据以 \\n 结尾\n    sb.append(&quot;\\n&quot;);\n    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n    c++;\n    &#x2F;&#x2F; 将数据发送给服务器\n    ctx.writeAndFlush(buffer);\n&#125;\n\n服务器代码\n&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\n 为分隔符\n&#x2F;&#x2F; 需要指定最大长度\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n\n运行结果\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 10B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |\n+--------+-------------------------------------------------+----------------+\n\n4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:58282] READ: 2B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 63 63                                           |cc              |\n+--------+-------------------------------------------------+----------------+\n\n...\n\n以自定义分隔符 \\c 为分隔符\n客户端代码\n...\n    \n&#x2F;&#x2F; 数据以 \\c 结尾\nsb.append(&quot;\\\\c&quot;);\nbuffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n\n...\n\n服务器代码\n&#x2F;&#x2F; 将分隔符放入ByteBuf中\nByteBuf bufSet &#x3D; ch.alloc().buffer().writeBytes(&quot;\\\\c&quot;.getBytes(StandardCharsets.UTF_8));\n&#x2F;&#x2F; 通过行解码器对粘包数据进行拆分，以 \\c 为分隔符\nch.pipeline().addLast(new DelimiterBasedFrameDecoder(64, ch.alloc().buffer().writeBytes(bufSet)));\nch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n\n运行结果\n8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 14B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |\n+--------+-------------------------------------------------+----------------+\n\n\n8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:&#x2F;127.0.0.1:8080 - R:&#x2F;127.0.0.1:65159] READ: 3B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 62 62 62                                        |bbb             |\n+--------+-------------------------------------------------+----------------+\n\n...\n\n4. 长度字段解码器在传送数据时可以在数据中添加一个用于表示有用数据长度的字段，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的\nLengthFieldBasedFrameDecoder解码器可以提供更为丰富的拆分方法，其构造方法有五个参数\npublic LengthFieldBasedFrameDecoder(\n    int maxFrameLength,\n    int lengthFieldOffset, int lengthFieldLength,\n    int lengthAdjustment, int initialBytesToStrip)\n\n参数解析\n\nmaxFrameLength 数据最大长度\n表示数据的最大长度（包括附加信息、长度标识等内容）\n\n\nlengthFieldOffset 数据长度标识的起始偏移量\n用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息\n\n\nlengthFieldLength 数据长度标识所占字节数（用于指明有用数据的长度）\n数据中用于表示有用数据长度的标识所占的字节数\n\n\nlengthAdjustment 长度表示与有用数据的偏移量\n用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息\n\n\ninitialBytesToStrip 数据读取起点\n读取起点，不读取 0 ~ initialBytesToStrip 之间的数据\n\n\n\n参数图解\n\n\nlengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0 (&#x3D; do not strip header)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)\n+--------+----------------+      +--------+----------------+\n| Length | Actual Content |-----&gt;| Length | Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | 0x000C | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +--------+----------------+\n\n从0开始即为长度标识，长度标识长度为2个字节\n0x000C 即为后面 HELLO, WORLD的长度\n\nlengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 2 (&#x3D; the length of the Length field)\n  \nBEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)\n+--------+----------------+      +----------------+\n| Length | Actual Content |-----&gt;| Actual Content |\n| 0x000C | &quot;HELLO, WORLD&quot; |      | &quot;HELLO, WORLD&quot; |\n+--------+----------------+      +----------------+\n\n从0开始即为长度标识，长度标识长度为2个字节，读取时从第二个字节开始读取（此处即跳过长度标识）\n因为跳过了用于表示长度的2个字节，所以此处直接读取HELLO, WORLD\n\nlengthFieldOffset   &#x3D; 2 (&#x3D; the length of Header 1)\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 0\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n| Header 1 |  Length  | Actual Content |-----&gt;| Header 1 |  Length  | Actual Content |\n|  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |      |  0xCAFE  | 0x00000C | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+\n\n长度标识前面还有2个字节的其他内容（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)\nHeader1中有附加信息，读取长度标识时需要跳过这些附加信息来获取长度\n\nlengthFieldOffset   &#x3D; 0\nlengthFieldLength   &#x3D; 3\nlengthAdjustment    &#x3D; 2 (&#x3D; the length of Header 1)\ninitialBytesToStrip &#x3D; 0\n  \nBEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)\n+----------+----------+----------------+      +----------+----------+----------------+\n|  Length  | Header 1 | Actual Content |-----&gt;|  Length  | Header 1 | Actual Content |\n| 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |      | 0x00000C |  0xCAFE  | &quot;HELLO, WORLD&quot; |\n+----------+----------+----------------+      +----------+----------+----------------+\n\n从0开始即为长度标识，长度标识长度为3个字节，长度标识之后还有2个字节的其他内容（0xCAFE）\n长度标识(0x00000C)表示的是**从其后lengthAdjustment（2个字节）开始的数据的长度，即HELLO, WORLD**，不包括0xCAFE\n\nlengthFieldOffset   &#x3D; 1 (&#x3D; the length of HDR1)\nlengthFieldLength   &#x3D; 2\nlengthAdjustment    &#x3D; 1 (&#x3D; the length of HDR2)\ninitialBytesToStrip &#x3D; 3 (&#x3D; the length of HDR1 + LEN)\n  \nBEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)\n+------+--------+------+----------------+      +------+----------------+\n| HDR1 | Length | HDR2 | Actual Content |-----&gt;| HDR2 | Actual Content |\n| 0xCA | 0x000C | 0xFE | &quot;HELLO, WORLD&quot; |      | 0xFE | &quot;HELLO, WORLD&quot; |\n+------+--------+------+----------------+      +------+----------------+ \n\n长度标识前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取，即读取 0xFE HELLO, WORLD\n\n使用\n通过 EmbeddedChannel 对 handler 进行测试\npublic class EncoderStudy &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 模拟服务器\n        &#x2F;&#x2F; 使用EmbeddedChannel测试handler\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel(\n                &#x2F;&#x2F; 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）\n                new LengthFieldBasedFrameDecoder(1024, 1, 4, 1, 0),\n                new LoggingHandler(LogLevel.DEBUG)\n        );\n\n        &#x2F;&#x2F; 模拟客户端，写入数据\n        ByteBuf buffer &#x3D; ByteBufAllocator.DEFAULT.buffer();\n        send(buffer, &quot;Hello&quot;);\n        channel.writeInbound(buffer);\n        send(buffer, &quot;World&quot;);\n        channel.writeInbound(buffer);\n    &#125;\n\n    private static void send(ByteBuf buf, String msg) &#123;\n        &#x2F;&#x2F; 得到数据的长度\n        int length &#x3D; msg.length();\n        byte[] bytes &#x3D; msg.getBytes(StandardCharsets.UTF_8);\n        &#x2F;&#x2F; 将数据信息写入buf\n        &#x2F;&#x2F; 写入长度标识前的其他信息\n        buf.writeByte(0xCA);\n        &#x2F;&#x2F; 写入数据长度标识\n        buf.writeInt(length);\n        &#x2F;&#x2F; 写入长度标识后的其他信息\n        buf.writeByte(0xFE);\n        &#x2F;&#x2F; 写入具体的数据\n        buf.writeBytes(bytes);\n    &#125;\n&#125;\n\n运行结果\n146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |\n+--------+-------------------------------------------------+----------------+\n\n146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |\n+--------+-------------------------------------------------+----------------+\n\n\n\n\n\n5. 协议设计与解析a. 协议的作用TCP&#x2F;IP 中消息传输基于流的方式，没有边界\n协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则\nb. Redis协议如果我们要向Redis服务器发送一条set name Nyima的指令，需要遵守如下协议\n&#x2F;&#x2F; 该指令一共有3部分，每条指令之后都要添加回车与换行符\n*3\\r\\n\n&#x2F;&#x2F; 第一个指令的长度是3\n$3\\r\\n\n&#x2F;&#x2F; 第一个指令是set指令\nset\\r\\n\n&#x2F;&#x2F; 下面的指令以此类推\n$4\\r\\n\nname\\r\\n\n$5\\r\\n\nNyima\\r\\n\n\n客户端代码如下\npublic class RedisClient &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D;  new NioEventLoopGroup();\n        try &#123;\n            ChannelFuture channelFuture &#x3D; new Bootstrap()\n                    .group(group)\n                    .channel(NioSocketChannel.class)\n                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                        @Override\n                        protected void initChannel(SocketChannel ch) &#123;\n                            &#x2F;&#x2F; 打印日志\n                            ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                            ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;\n                                @Override\n                                public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                                    &#x2F;&#x2F; 回车与换行符\n                                    final byte[] LINE &#x3D; &#123;&#39;\\r&#39;,&#39;\\n&#39;&#125;;\n                                    &#x2F;&#x2F; 获得ByteBuf\n                                    ByteBuf buffer &#x3D; ctx.alloc().buffer();\n                                    &#x2F;&#x2F; 连接建立后，向Redis中发送一条指令，注意添加回车与换行\n                                    &#x2F;&#x2F; set name Nyima\n                                    buffer.writeBytes(&quot;*3&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$3&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;set&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$4&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;name&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;$5&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    buffer.writeBytes(&quot;Nyima&quot;.getBytes());\n                                    buffer.writeBytes(LINE);\n                                    ctx.writeAndFlush(buffer);\n                                &#125;\n\n                            &#125;);\n                        &#125;\n                    &#125;)\n                    .connect(new InetSocketAddress(&quot;localhost&quot;, 6379));\n            channelFuture.sync();\n            &#x2F;&#x2F; 关闭channel\n            channelFuture.channel().close().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 关闭group\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n控制台打印结果\n1600 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x28c994f1, L:&#x2F;127.0.0.1:60792 - R:localhost&#x2F;127.0.0.1:6379] WRITE: 34B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|\n|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 4e 79 69 6d 61 |.name..$5..Nyima|\n|00000020| 0d 0a                                           |..              |\n+--------+-------------------------------------------------+----------------+\n\nRedis中查询执行结果\n\nc. HTTP协议HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用HttpServerCodec作为服务器端的解码器与编码器，来处理HTTP请求\n&#x2F;&#x2F; HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder\n&#x2F;&#x2F; Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器\npublic final class HttpServerCodec extends CombinedChannelDuplexHandler&lt;HttpRequestDecoder, HttpResponseEncoder&gt;\n        implements HttpServerUpgradeHandler.SourceCodec\n\n服务器代码\npublic class HttpServer &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        new ServerBootstrap()\n                .group(group)\n                .channel(NioServerSocketChannel.class)\n                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                    @Override\n                    protected void initChannel(SocketChannel ch) &#123;\n                        ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n                        &#x2F;&#x2F; 作为服务器，使用 HttpServerCodec 作为编码器与解码器\n                        ch.pipeline().addLast(new HttpServerCodec());\n                        &#x2F;&#x2F; 服务器只处理HTTPRequest\n                        ch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;() &#123;\n                            @Override\n                            protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) &#123;\n                                &#x2F;&#x2F; 获得请求uri\n                                log.debug(msg.uri());\n\n                                &#x2F;&#x2F; 获得完整响应，设置版本号与状态码\n                                DefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n                                &#x2F;&#x2F; 设置响应内容\n                                byte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);\n                                &#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容\n                                response.headers().setInt(CONTENT_LENGTH, bytes.length);\n                                &#x2F;&#x2F; 设置响应体\n                                response.content().writeBytes(bytes);\n\n                                &#x2F;&#x2F; 写回响应\n                                ctx.writeAndFlush(response);\n                            &#125;\n                        &#125;);\n                    &#125;\n                &#125;)\n                .bind(8080);\n    &#125;\n&#125;\n\n服务器负责处理请求并响应浏览器。所以只需要处理HTTP请求即可\n&#x2F;&#x2F; 服务器只处理HTTPRequest\nch.pipeline().addLast(new SimpleChannelInboundHandler&lt;HttpRequest&gt;()\n\n获得请求后，需要返回响应给浏览器。需要创建响应对象DefaultFullHttpResponse，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得CONTENT_LENGTH而一直空转，需要添加CONTENT_LENGTH字段，表明响应体中数据的具体长度\n&#x2F;&#x2F; 获得完整响应，设置版本号与状态码\nDefaultFullHttpResponse response &#x3D; new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);\n&#x2F;&#x2F; 设置响应内容\nbyte[] bytes &#x3D; &quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;.getBytes(StandardCharsets.UTF_8);\n&#x2F;&#x2F; 设置响应体长度，避免浏览器一直接收响应内容\nresponse.headers().setInt(CONTENT_LENGTH, bytes.length);\n&#x2F;&#x2F; 设置响应体\nresponse.content().writeBytes(bytes);\n\n运行结果\n浏览器\n\n控制台\n&#x2F;&#x2F; 请求内容\n1714 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] READ: 688B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 47 45 54 20 2f 66 61 76 69 63 6f 6e 2e 69 63 6f |GET &#x2F;favicon.ico|\n|00000010| 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a | HTTP&#x2F;1.1..Host:|\n|00000020| 20 6c 6f 63 61 6c 68 6f 73 74 3a 38 30 38 30 0d | localhost:8080.|\n|00000030| 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 6b 65 65 |.Connection: kee|\n|00000040| 70 2d 61 6c 69 76 65 0d 0a 50 72 61 67 6d 61 3a |p-alive..Pragma:|\n....\n\n&#x2F;&#x2F; 响应内容\n1716 [nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x72630ef7, L:&#x2F;0:0:0:0:0:0:0:1:8080 - R:&#x2F;0:0:0:0:0:0:0:1:55503] WRITE: 61B\n         +-------------------------------------------------+\n         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |\n+--------+-------------------------------------------------+----------------+\n|00000000| 48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d |HTTP&#x2F;1.1 200 OK.|\n|00000010| 0a 43 6f 6e 74 65 6e 74 2d 4c 65 6e 67 74 68 3a |.Content-Length:|\n|00000020| 20 32 32 0d 0a 0d 0a 3c 68 31 3e 48 65 6c 6c 6f | 22....&lt;h1&gt;Hello|\n|00000030| 2c 20 57 6f 72 6c 64 21 3c 2f 68 31 3e          |, World!&lt;&#x2F;h1&gt;   |\n+--------+-------------------------------------------------+----------------+\n\nd. 自定义协议1.组成要素\n魔数：用来在第一时间判定接收的数据是否为无效数据包\n版本号：可以支持协议的升级\n序列化算法：消息正文到底采用哪种序列化反序列化方式\n如：json、protobuf、hessian、jdk\n\n\n指令类型：是登录、注册、单聊、群聊… 跟业务相关\n请求序号：为了双工通信，提供异步能力\n正文长度\n消息正文\n\n2. 编码器与解码器public class MessageCodec extends ByteToMessageCodec&lt;Message&gt; &#123;\n\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception &#123;\n        &#x2F;&#x2F; 设置魔数 4个字节\n        out.writeBytes(new byte[]&#123;&#39;N&#39;,&#39;Y&#39;,&#39;I&#39;,&#39;M&#39;&#125;);\n        &#x2F;&#x2F; 设置版本号 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置序列化方式 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置指令类型 1个字节\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 设置请求序号 4个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据\n        out.writeByte(0xff);\n\n        &#x2F;&#x2F; 获得序列化后的msg\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; 获取魔数\n        int magic &#x3D; in.readInt();\n        &#x2F;&#x2F; 获取版本号\n        byte version &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得序列化方式\n        byte seqType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得指令类型\n        byte messageType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得请求序号\n        int sequenceId &#x3D; in.readInt();\n        &#x2F;&#x2F; 移除补齐字节\n        in.readByte();\n        &#x2F;&#x2F; 获得正文长度\n        int length &#x3D; in.readInt();\n        &#x2F;&#x2F; 获得正文\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n\t\t&#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n        \n        &#x2F;&#x2F; 打印获得的信息正文\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(magic);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(version);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(seqType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(messageType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(sequenceId);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(length);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(message);\n    &#125;\n&#125;\n\n\n编码器与解码器方法源于父类ByteToMessageCodec，通过该类可以自定义编码器与解码器，泛型类型为被编码与被解码的类。此处使用了自定义类Message，代表消息\npublic class MessageCodec extends ByteToMessageCodec&lt;Message&gt; \n\n编码器负责将附加信息与正文信息写入到ByteBuf中，其中附加信息总字节数最好为2n，不足需要补齐。正文内容如果为对象，需要通过序列化将其放入到ByteBuf中\n\n解码器负责将ByteBuf中的信息取出，并放入List中，该List用于将信息传递给下一个handler\n\n\n编写测试类\npublic class TestCodec &#123;\n    static final org.slf4j.Logger log &#x3D; LoggerFactory.getLogger(StudyServer.class);\n    public static void main(String[] args) throws Exception &#123;\n        EmbeddedChannel channel &#x3D; new EmbeddedChannel();\n        &#x2F;&#x2F; 添加解码器，避免粘包半包问题\n        channel.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0));\n        channel.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));\n        channel.pipeline().addLast(new MessageCodec());\n        LoginRequestMessage user &#x3D; new LoginRequestMessage(&quot;Nyima&quot;, &quot;123&quot;);\n\n        &#x2F;&#x2F; 测试编码与解码\n        ByteBuf byteBuf &#x3D; ByteBufAllocator.DEFAULT.buffer();\n        new MessageCodec().encode(null, user, byteBuf);\n        channel.writeInbound(byteBuf);\n    &#125;\n&#125;\n\n\n测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题\n通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码\n\n运行结果\n\n\n\n\n\n\n3. @Sharable注解为了提高handler的复用率，可以将handler创建为handler对象，然后在不同的channel中使用该handler对象进行处理操作\nLoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n&#x2F;&#x2F; 不同的channel中使用同一个handler对象，提高复用率\nchannel1.pipeline().addLast(loggingHandler);\nchannel2.pipeline().addLast(loggingHandler); \n\n但是并不是所有的handler都能通过这种方法来提高复用率的，例如LengthFieldBasedFrameDecoder。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题\n\nchannel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播\n此时channel2中也收到了一个半包，因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包。LengthFieldBasedFrameDecoder让该数据包继续向下传播，最终引发错误\n\n为了提高handler的复用率，同时又避免出现一些并发问题，Netty中原生的handler中用@Sharable注解来标明，该handler能否在多个channel中共享。\n只有带有该注解，才能通过对象的方式被共享，否则无法被共享\n4. 自定义编解码器能否使用@Sharable注解这需要根据自定义的handler的处理逻辑进行分析\n我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的\n但是实际情况我们并不能添加该注解，会抛出异常信息ChannelHandler cn.nyimac.study.day8.protocol.MessageCodec is not allowed to be shared\n\n因为MessageCodec继承自ByteToMessageCodec，ByteToMessageCodec类的注解如下\n\n\n这就意味着ByteToMessageCodec不能被多个channel所共享的\n\n原因：因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过。所以传过来的ByteBuf可能并不是完整的数据，如果共享则会出现问题\n\n\n\n如果想要共享，需要怎么办呢？\n继承MessageToMessageDecoder即可。该类的目标是：将已经被处理的完整数据再次被处理。传过来的Message如果是被处理过的完整数据，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似\n@ChannelHandler.Sharable\npublic class MessageSharableCodec extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out) throws Exception &#123;\n        ...\n    &#125;\n\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out) throws Exception &#123;\n\t\t...\n    &#125;\n&#125;\n\n\n\n\n\n6. 源码分析a、启动流程Netty启动流程可以简化成如下代码\n&#x2F;&#x2F; netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector\nSelector selector &#x3D; Selector.open(); \n\n&#x2F;&#x2F; 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config\nNioServerSocketChannel attachment &#x3D; new NioServerSocketChannel();\n\n&#x2F;&#x2F; 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel\nServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open(); \nserverSocketChannel.configureBlocking(false);\n\n&#x2F;&#x2F; 启动 nio boss 线程执行接下来的操作\n\n&#x2F;&#x2F;注册（仅关联 selector 和 NioServerSocketChannel），未关注事件\nSelectionKey selectionKey &#x3D; serverSocketChannel.register(selector, 0, attachment);\n\n&#x2F;&#x2F; head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor\n\n&#x2F;&#x2F; 绑定端口\nserverSocketChannel.bind(new InetSocketAddress(8080));\n\n&#x2F;&#x2F; 触发 channel active 事件，在 head 中关注 op_accept 事件\nselectionKey.interestOps(SelectionKey.OP_ACCEPT);\n\n\n获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器\n创建NioServerSocketChannel，该Channel作为附件添加到ServerSocketChannel中\n创建ServerSocketChannel，将其设置为非阻塞模式，并注册到Selector中，此时未关注事件，但是添加了附件NioServerSocketChannel\n绑定端口\n通过interestOps设置感兴趣的事件\n\n1. bind选择器Selector的创建是在NioEventloopGroup中完成的。NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由bind方法完成的\n所以服务器启动的入口便是io.netty.bootstrap.ServerBootstrap.bind\npublic ChannelFuture bind(SocketAddress localAddress) &#123;\n\tvalidate();\n\treturn doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));\n&#125; \n\n2. doBind真正完成初始化、注册以及绑定的方法是io.netty.bootstrap.AbstractBootstrap.doBind\ndobind方法在主线程中执行\nprivate ChannelFuture doBind(final SocketAddress localAddress) &#123;\n    &#x2F;&#x2F; 负责NioServerSocketChannel和ServerSocketChannel的创建\n    &#x2F;&#x2F; ServerSocketChannel的注册工作\n    &#x2F;&#x2F; init由main线程完成，regisetr由NIO线程完成\n    final ChannelFuture regFuture &#x3D; initAndRegister();\n    final Channel channel &#x3D; regFuture.channel();\n    if (regFuture.cause() !&#x3D; null) &#123;\n        return regFuture;\n    &#125;\n\n    &#x2F;&#x2F; 因为register操作是异步的\n    &#x2F;&#x2F; 所以要判断主线程执行到这里时，register操作是否已经执行完毕\n    if (regFuture.isDone()) &#123;\n        &#x2F;&#x2F; At this point we know that the registration was complete and successful.\n        ChannelPromise promise &#x3D; channel.newPromise();\n        \n        &#x2F;&#x2F; 执行doBind0绑定操作\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    &#125; else &#123;\n        &#x2F;&#x2F; Registration future is almost always fulfilled already, but just in case it&#39;s not.\n        &#x2F;&#x2F; 如果register操作还没执行完，就会到这个分支中来\n        final PendingRegistrationPromise promise &#x3D; new PendingRegistrationPromise(channel);\n        \n        &#x2F;&#x2F; 添加监听器，NIO线程异步进行doBind0操作\n        regFuture.addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                Throwable cause &#x3D; future.cause();\n                if (cause !&#x3D; null) &#123;\n                    &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                    &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.\n                    promise.setFailure(cause);\n                &#125; else &#123;\n                    &#x2F;&#x2F; Registration was successful, so set the correct executor to use.\n                    &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586\n                    promise.registered();\n\n                    doBind0(regFuture, channel, localAddress, promise);\n                &#125;\n            &#125;\n        &#125;);\n        return promise;\n    &#125;\n&#125;\n\n\ndoBind()中有两个重要方法initAndRegister()和doBind0(regFuture, channel, localAddress, promise)\ninitAndRegister主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作\ndoBind0则负责连接的创建工作\n\n3. initAndRegisterd代码\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel &#x3D; null;\n    try &#123;\n        channel &#x3D; channelFactory.newChannel();\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        if (channel !&#x3D; null) &#123;\n            &#x2F;&#x2F; channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))\n            channel.unsafe().closeForcibly();\n            &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);\n        &#125;\n        &#x2F;&#x2F; as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor\n        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);\n    &#125;\n\n    ChannelFuture regFuture &#x3D; config().group().register(channel);\n    if (regFuture.cause() !&#x3D; null) &#123;\n        if (channel.isRegistered()) &#123;\n            channel.close();\n        &#125; else &#123;\n            channel.unsafe().closeForcibly();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F; If we are here and the promise is not failed, it&#39;s one of the following cases:\n    &#x2F;&#x2F; 1) If we attempted registration from the event loop, the registration has been completed at this point.\n    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now because the channel has been registered.\n    &#x2F;&#x2F; 2) If we attempted registration from the other thread, the registration request has been successfully\n    &#x2F;&#x2F;    added to the event loop&#39;s task queue for later execution.\n    &#x2F;&#x2F;    i.e. It&#39;s safe to attempt bind() or connect() now:\n    &#x2F;&#x2F;         because bind() or connect() will be executed *after* the scheduled registration task is executed\n    &#x2F;&#x2F;         because register(), bind(), and connect() are all bound to the same thread.\n\n    return regFuture;\n&#125;\n\n4. initChannel channel &#x3D; null;\ntry &#123;\n    &#x2F;&#x2F; 通过反射初始化NioServerSocketChannel\n    channel &#x3D; channelFactory.newChannel();\n    init(channel);\n&#125;\n\nnewChannel方法\n@Override\npublic T newChannel() &#123;\n    try &#123;\n        &#x2F;&#x2F; 通过反射调用NioServerSocketChannel的构造方法\n        &#x2F;&#x2F; 创建NioServerSocketChannel对象\n        return constructor.newInstance();\n    &#125; catch (Throwable t) &#123;\n        throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);\n    &#125;\n&#125;\n\nNioServerSocketChannel构造方法\npublic NioServerSocketChannel() &#123;\n    &#x2F;&#x2F; 创建了ServerSocketChannel实例\n    this(newSocket(DEFAULT_SELECTOR_PROVIDER));\n&#125;\n\nnewSocket方法\nprivate static ServerSocketChannel newSocket(SelectorProvider provider) &#123;\n    try &#123;\n        &#x2F;&#x2F; ServerSocketChannel.open方法：\n        &#x2F;&#x2F; SelectorProvider.provider().openServerSocketChannel()\n\t    &#x2F;&#x2F; 所以此处相当于ServerSocketChannel.open()\n        &#x2F;&#x2F; 创建了ServerSocketChannel实例\n    \treturn provider.openServerSocketChannel();\n\t&#125; catch (IOException e) &#123;\n  \t  throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);\n\t&#125;\n&#125;\n\ninit方法\n@Override\nvoid init(Channel channel) &#123;\n   \t...\n\t\t\n    &#x2F;&#x2F; NioSocketChannl的Pipeline    \n    ChannelPipeline p &#x3D; channel.pipeline();\n\t\t\n    ...\n\n    &#x2F;&#x2F; 向Pipeline中添加了一个handler，该handler等待被调用\n    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;\n        @Override\n        &#x2F;&#x2F; register之后才调用该方法\n        public void initChannel(final Channel ch) &#123;\n            final ChannelPipeline pipeline &#x3D; ch.pipeline();\n            \n            &#x2F;&#x2F; 创建handler并加入到pipeline中\n            ChannelHandler handler &#x3D; config.handler();\n            if (handler !&#x3D; null) &#123;\n                pipeline.addLast(handler);\n            &#125;\n\n            ch.eventLoop().execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 添加新的handler，在发生Accept事件后建立连接\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n&#125; \n\ninit主要完成了以下三个操作\n\n创建NioServerSocketChannel\n\n通过NioServerSocketChannel的构造器，创建了ServerSocketChannel\n\n由initChannel方法向NioServerSocketChannel中添加了两个handler，\n添加操作在register之后被执行\n\n一个handler负责设置配置\n一个handler负责发生Accepet事件后建立连接\n\n\n\n5. Registerinit执行完毕后，便执行ChannelFuture regFuture = config().group().register(channel)操作\n该方法最终调用的是promise.channel().unsafe().register(this, promise)方法\npromise.channel().unsafe().register(this, promise)\n@Override\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    ...\n\n    &#x2F;&#x2F; 获取EventLoop\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n   \t&#x2F;&#x2F; 此处完成了由 主线程 到 NIO线程 的切换\n    &#x2F;&#x2F; eventLoop.inEventLoop()用于判断当前线程是否为NIO线程\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 向NIO线程中添加任务\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 该方法中会执行doRegister\n                    &#x2F;&#x2F; 执行真正的注册操作\n                    register0(promise);\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n           ...\n        &#125;\n    &#125;\n&#125; \n\nregister0方法\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n       \t...\n            \n        &#x2F;&#x2F; 执行真正的注册操作\n        doRegister();\n        neverRegistered &#x3D; false;\n        registered &#x3D; true;\n\n        &#x2F;&#x2F; Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n        &#x2F;&#x2F; user may already fire events through the pipeline in the ChannelFutureListener.\n        \n        &#x2F;&#x2F; 调用init中的initChannel方法\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        ...\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n&#125; \n\ndoRegister方法\n@Override\nprotected void doRegister() throws Exception &#123;\n    boolean selected &#x3D; false;\n    for (;;) &#123;\n        try &#123;\n            &#x2F;&#x2F; javaChannel()即为ServerSocketChannel\n            &#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector\n            &#x2F;&#x2F; this为NIOServerSocketChannel，作为附件\n            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        &#125; catch (CancelledKeyException e) &#123;\n            ...\n           \n        &#125;\n    &#125;\n&#125; \n\n回调initChannel\n@Override\npublic void initChannel(final Channel ch) &#123;\n    final ChannelPipeline pipeline &#x3D; ch.pipeline();\n    ChannelHandler handler &#x3D; config.handler();\n    if (handler !&#x3D; null) &#123;\n        pipeline.addLast(handler);\n    &#125;\n\n    &#x2F;&#x2F; 添加新任务，任务负责添加handler\n    &#x2F;&#x2F; 该handler负责发生Accepet事件后建立连接\n    ch.eventLoop().execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            pipeline.addLast(new ServerBootstrapAcceptor(\n                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n        &#125;\n    &#125;);\n&#125; \n\nRegister主要完成了以下三个操作\n\n完成了主线程到NIO的线程切换\n\n通过eventLoop.inEventLoop()进行线程判断，判断当前线程是否为NIO线程\n切换的方式为让eventLoop执行register的操作\nregister的操作在NIO线程中完成\n\n\n调用doRegister方法\n&#x2F;&#x2F; javaChannel()即为ServerSocketChannel\n&#x2F;&#x2F; eventLoop().unwrappedSelector()获取eventLoop中的Selector\n&#x2F;&#x2F; this为NIOServerSocketChannel，作为附件\nselectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this); \n\n\n将ServerSocketChannel注册到EventLoop的Selector中\n此时还未关注事件\n添加NioServerSocketChannel附件\n\n\n通过invokeHandlerAddedIfNeeded调用init中的initChannel方法\n\ninitChannel方法主要创建了\n两个handler\n\n一个handler负责设置配置\n一个handler负责发生Accept事件后建立连接\n\n\n\n\n\n6. doBind0绑定端口\n在doRegister和invokeHandlerAddedIfNeeded操作中的完成后，会调用safeSetSuccess(promise)方法，向Promise中设置执行成功的结果。此时doBind方法中由initAndRegister返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作\n&#x2F;&#x2F; initAndRegister为异步方法，会返回ChannelFuture对象\nfinal ChannelFuture regFuture &#x3D; initAndRegister();\nregFuture.addListener(new ChannelFutureListener() &#123;\n    @Override\n    public void operationComplete(ChannelFuture future) throws Exception &#123;\n        Throwable cause &#x3D; future.cause();\n        if (cause !&#x3D; null) &#123;\n            &#x2F;&#x2F; Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n            &#x2F;&#x2F; IllegalStateException once we try to access the EventLoop of the Channel.\n            promise.setFailure(cause);\n        &#125; else &#123;\n            &#x2F;&#x2F; Registration was successful, so set the correct executor to use.\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2586\n            promise.registered();\n            &#x2F;&#x2F; 如果没有异常，则执行绑定操作\n            doBind0(regFuture, channel, localAddress, promise);\n        &#125;\n    &#125;\n&#125;); \n\ndoBind0最底层调用的是ServerSocketChannel的bind方法\nNioServerSocketChannel.doBind方法\n通过该方法，绑定了对应的端口\n@SuppressJava6Requirement(reason &#x3D; &quot;Usage guarded by java version check&quot;)\n@Override\nprotected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        &#x2F;&#x2F; 调用ServerSocketChannel的bind方法，绑定端口\n        javaChannel().bind(localAddress, config.getBacklog());\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125; \n\n\n\n关注事件\n在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件\nif (!wasActive &amp;&amp; isActive()) &#123;\n    invokeLater(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            pipeline.fireChannelActive();\n        &#125;\n    &#125;);\n&#125; \n\n最终在AbstractNioChannel.doBeginRead方法中，会添加ServerSocketChannel添加Accept事件\n@Override\nprotected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n    readPending &#x3D; true;\n    final int interestOps &#x3D; selectionKey.interestOps();\n    &#x2F;&#x2F; 如果ServerSocketChannel没有关注Accept事件\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 则让其关注Accepet事件\n        &#x2F;&#x2F; readInterestOp 取值是 16\n        &#x2F;&#x2F; 在 NioServerSocketChannel 创建时初始化\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125; \n\n注意：此处设置interestOps时使用的方法，避免覆盖关注的其他事件\n\n首先获取Channel所有感兴趣的事件\nfinal int interestOps &#x3D; selectionKey.interestOps(); \n\n然后再设置其感兴趣的事件\nselectionKey.interestOps(interestOps | readInterestOp); \n\n各个事件对应的值\n\n7.总结通过上述步骤，完成了\n\nNioServerSocketChannel与ServerSocketChannel的创建\nServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件\n绑定了对应的端口\n关注了Accept事件\n\nb、NioEventLoop剖析1. 组成NioEventLoop的重要组成部分有三个\n\nSelector\npublic final class NioEventLoop extends SingleThreadEventLoop &#123;\n    \n    ...\n        \n    &#x2F;&#x2F; selector中的selectedKeys是基于数组的\n    &#x2F;&#x2F; unwrappedSelector中的selectedKeys是基于HashSet的    \n    private Selector selector;\n    private Selector unwrappedSelector;\n    private SelectedSelectionKeySet selectedKeys;\n    \n    ...\n&#125; \n\nThread与TaskQueue\npublic abstract class SingleThreadEventExecutor extends AbstractScheduledEventExecutor implements OrderedEventExecutor &#123;\n    &#x2F;&#x2F; 任务队列\n    private final Queue&lt;Runnable&gt; taskQueue;\n\n    &#x2F;&#x2F; 线程\n    private volatile Thread thread;\n&#125; \n\nSelector的创建\nSelector是在NioEventLoop的构造方法中被创建的\nNioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;\n    \n        ...\n           \n        &#x2F;&#x2F; 初始化selector，初始化过程在openSelector中\n        final SelectorTuple selectorTuple &#x3D; openSelector();\n        this.selector &#x3D; selectorTuple.selector;\n        this.unwrappedSelector &#x3D; selectorTuple.unwrappedSelector;\n&#125;\n\n\nprivate SelectorTuple openSelector() &#123;\n    final Selector unwrappedSelector;\n    try &#123;\n        &#x2F;&#x2F; 此处等同于 Selector.open()方法\n        &#x2F;&#x2F; 创建了unwrappedSelector对象\n        unwrappedSelector &#x3D; provider.openSelector();\n    &#125; catch (IOException e) &#123;\n        throw new ChannelException(&quot;failed to open a new selector&quot;, e);\n    &#125;\n&#125; \n\nNioEventLoop的构造方法中，调用了openSelector()方法， 该方法会返回一个\nSelectorTuple对象，该方法是创建Selector的核心方法。openSelector()方法内部调用了\nunwrappedSelector &#x3D; provider.openSelector(); \n\n获得了Selector对象unwrappedSelector\n后面会通过反射，修改unwrappedSelector中SelectedKeys的实现，然后通过SelectedSelectionKeySetSelector方法获得selector。最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector\nprivate static final class SelectorTuple &#123;\n    final Selector unwrappedSelector;\n    final Selector selector;\n\n    SelectorTuple(Selector unwrappedSelector) &#123;\n        this.unwrappedSelector &#x3D; unwrappedSelector;\n        this.selector &#x3D; unwrappedSelector;\n    &#125;\n\n    &#x2F;**\n    * 一般调用的是这个构造方法\n    *&#x2F;\n    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;\n        this.unwrappedSelector &#x3D; unwrappedSelector;\n        this.selector &#x3D; selector;\n    &#125;\n&#125; \n\n再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector\n两个Selector\nNioEventLoop中有selector和unwrappedSelector两个Selector，它们的区别主要在于SelectedKeys的数据结构\n\nselector中的SelectedKeys是基于数组的\nunwrappedSelector中的是基于HashSet的\n\n这样做的主要目的是，数组的遍历效率要高于HashSet\nprivate SelectorTuple openSelector() &#123;\n    final Selector unwrappedSelector;\n    try &#123;\n        unwrappedSelector &#x3D; provider.openSelector();\n    &#125; catch (IOException e) &#123;\n        throw new ChannelException(&quot;failed to open a new selector&quot;, e);\n    &#125;\n\n    ...\n    \n    &#x2F;&#x2F; 获得基于数组的selectedKeySet实现\n    final SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();\n\n\n    Object maybeException &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;\n        @Override\n        public Object run() &#123;\n            try &#123;\n                &#x2F;&#x2F; 通过反射拿到unwrappedSelector中的selectedKeys属性\n                Field selectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);\n                Field publicSelectedKeysField &#x3D; selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);\n\n                ...\n\t\n                &#x2F;&#x2F; 暴力反射，修改私有属性\n                Throwable cause &#x3D; ReflectionUtil.trySetAccessible(selectedKeysField, true);\n                if (cause !&#x3D; null) &#123;\n                    return cause;\n                &#125;\n                cause &#x3D; ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);\n                if (cause !&#x3D; null) &#123;\n                    return cause;\n                &#125;\n\n                &#x2F;&#x2F; 替换为基于数组的selectedKeys实现\n                selectedKeysField.set(unwrappedSelector, selectedKeySet);\n                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);\n                return null;\n            &#125; catch (NoSuchFieldException e) &#123;\n                return e;\n            &#125; catch (IllegalAccessException e) &#123;\n                return e;\n            &#125;\n        &#125;\n    &#125;);\n\n    selectedKeys &#x3D; selectedKeySet;\n    \n    &#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector\n    return new SelectorTuple(unwrappedSelector,\n                             new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));\n&#125; \n\n获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下\n\n获得基于数组的selectedKeySet实现\n&#x2F;&#x2F; 获得基于数组的selectedKeySet实现\nfinal SelectedSelectionKeySet selectedKeySet &#x3D; new SelectedSelectionKeySet();\n\nSelectedSelectionKeySet() &#123;\n\tkeys &#x3D; new SelectionKey[1024];\n&#125; \n\n通过反射拿到unwrappedSelector中的SelectedKeySet并将其替换为selectedKeySet\n\n通过Selector的构造方法获得selector\nnew SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet) \n\n通过SelectorTuple的构造方法获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop\n&#x2F;&#x2F; 调用构造函数，创建unwrappedSelector与selector\nreturn new SelectorTuple(unwrappedSelector, new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)); \n\n2. NIO线程启动时机启动\nNioEventLoop中的线程，在首次执行任务时，才会被创建，且只会被创建一次\n测试代码\npublic class TestNioEventLoop &#123;\n    public static void main(String[] args) &#123;\n        EventLoop eventLoop &#x3D; new NioEventLoopGroup().next();\n        &#x2F;&#x2F; 使用NioEventLoop执行任务\n        eventLoop.execute(()-&gt;&#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;);\n    &#125;\n&#125;\n\n进入execute执行任务\n@Override\npublic void execute(Runnable task) &#123;\n    &#x2F;&#x2F; 检测传入的任务是否为空，为空会抛出NullPointerException\n    ObjectUtil.checkNotNull(task, &quot;task&quot;);\n    &#x2F;&#x2F; 执行任务\n    &#x2F;&#x2F; 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true\n    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));\n&#125; \n\n进入上述代码的execute方法\nprivate void execute(Runnable task, boolean immediate) &#123;\n    &#x2F;&#x2F; 判断当前线程是否为NIO线程\n    &#x2F;&#x2F; 判断方法为 return thread &#x3D;&#x3D; this.thread;\n    &#x2F;&#x2F; this.thread即为NIO线程，首次执行任务时，其为null\n    boolean inEventLoop &#x3D; inEventLoop();\n    \n    &#x2F;&#x2F; 向任务队列taskQueue中添加任务\n    addTask(task);\n    \n    &#x2F;&#x2F; 当前线程不是NIO线程，则进入if语句\n    if (!inEventLoop) &#123;\n        &#x2F;&#x2F; 启动NIO线程的核心方法\n        startThread();\n        \n        ...\n        \n    &#125;\n\t\n    &#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程\n    if (!addTaskWakesUp &amp;&amp; immediate) &#123;\n        wakeup(inEventLoop);\n    &#125;\n&#125; \n\n进入startThread方法\nprivate void startThread() &#123;\n    &#x2F;&#x2F; 查看NIO线程状态是否为未启动\n    &#x2F;&#x2F; 该if代码块只会执行一次\n    &#x2F;&#x2F; state一开始的值就是ST_NOT_STARTED\n    &#x2F;&#x2F; private volatile int state &#x3D; ST_NOT_STARTED;\n    if (state &#x3D;&#x3D; ST_NOT_STARTED) &#123;\n        &#x2F;&#x2F; 通过原子属性更新器将状态更新为启动（ST_STARTED）\n        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;\n            boolean success &#x3D; false;\n            try &#123;\n                &#x2F;&#x2F; 执行启动线程\n                doStartThread();\n                success &#x3D; true;\n            &#125; finally &#123;\n                if (!success) &#123;\n                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125; \n\n进入doStartThread，真正创建NIO线程并执行任务\nprivate void doStartThread() &#123;\n    assert thread &#x3D;&#x3D; null;\n    &#x2F;&#x2F; 创建NIO线程并执行任务\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            &#x2F;&#x2F; thread即为NIO线程\n            thread &#x3D; Thread.currentThread();\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success &#x3D; false;\n            updateLastExecutionTime();\n            try &#123;\n                &#x2F;&#x2F; 执行内部run方法\n                SingleThreadEventExecutor.this.run();\n                success &#x3D; true;\n            &#125; \n            \n            ...\n    &#125;);\n&#125; \n\n通过SingleThreadEventExecutor.this.run()执行传入的任务（task）\n该run方法是NioEvnetLoop的run方法\n@Override\nprotected void run() &#123;\n    int selectCnt &#x3D; 0;\n    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行\n    for (;;) &#123;\t\n      \t&#x2F;&#x2F; 执行各种任务\n   \t\ttry &#123;\n            int strategy;\n            try &#123;\n                strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());\n                switch (strategy) &#123;\n                case SelectStrategy.CONTINUE:\n                    continue;\n\n                case SelectStrategy.BUSY_WAIT:\n                    &#x2F;&#x2F; fall-through to SELECT since the busy-wait is not supported with NIO\n\n                case SelectStrategy.SELECT:\n                    long curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();\n                    if (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;\n                        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar\n                    &#125;\n                    nextWakeupNanos.set(curDeadlineNanos);\n                    try &#123;\n                        if (!hasTasks()) &#123;\n                            strategy &#x3D; select(curDeadlineNanos);\n                        &#125;\n                    &#125; finally &#123;\n                        &#x2F;&#x2F; This update is just to help block unnecessary selector wakeups\n                        &#x2F;&#x2F; so use of lazySet is ok (no race condition)\n                        nextWakeupNanos.lazySet(AWAKE);\n                    &#125;\n                    &#x2F;&#x2F; fall through\n                default:\n                &#125;\n       \t\t&#125;\n    \t&#125;\n\t&#125; \n\n\n\n唤醒\nNioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中\n@Override\nprotected void run() &#123;\n    int selectCnt &#x3D; 0;\n    &#x2F;&#x2F; 死循环，不断地从任务队列中获取各种任务来执行\n    for (;;) &#123;\n      \t&#x2F;&#x2F; 执行各种任务\n   \t\t...\n    &#125;\n&#125; \n\n中被执行，但该循环不会空转，执行到某些代码时，会被阻塞\nrun方法中有SELECT分支\ncase SelectStrategy.SELECT:\n\tlong curDeadlineNanos &#x3D; nextScheduledTaskDeadlineNanos();\n\tif (curDeadlineNanos &#x3D;&#x3D; -1L) &#123;\n        curDeadlineNanos &#x3D; NONE; &#x2F;&#x2F; nothing on the calendar\n    &#125;\n\tnextWakeupNanos.set(curDeadlineNanos);\n\ttry &#123;\n    \tif (!hasTasks()) &#123;\n            &#x2F;&#x2F; 执行select方法\n            strategy &#x3D; select(curDeadlineNanos);\n        &#125;\n    &#125;\n\t... \n\n会执行NioEvnetLoop的select方法，该方法内部会根据情况，执行selector的有参和无参的select方法\nprivate int select(long deadlineNanos) throws IOException &#123;\n    &#x2F;&#x2F; 如果没有指定阻塞事件，就调用select()\n    if (deadlineNanos &#x3D;&#x3D; NONE) &#123;\n        return selector.select();\n    &#125;\n    &#x2F;&#x2F; 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞\n    &#x2F;&#x2F; Timeout will only be 0 if deadline is within 5 microsecs\n    long timeoutMillis &#x3D; deadlineToDelayNanos(deadlineNanos + 995000L) &#x2F; 1000000L;\n    return timeoutMillis &lt;&#x3D; 0 ? selector.selectNow() : selector.select(timeoutMillis);\n&#125; \n\n但需要注意的是，**select方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**\n唤醒是通过execute最后的if代码块来完成的\n&#x2F;&#x2F; 有任务需要被执行时，唤醒阻塞的NIO线程\nif (!addTaskWakesUp &amp;&amp; immediate) &#123;\n    wakeup(inEventLoop);\n&#125; \n\nNioEventLoop.wakeup唤醒被selector.select方法阻塞的NIO线程\n@Override\nprotected void wakeup(boolean inEventLoop) &#123;\n    &#x2F;&#x2F; 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒\n    &#x2F;&#x2F; 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功\n    if (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) !&#x3D; AWAKE) &#123;\n        &#x2F;&#x2F; 唤醒被selector.select方法阻塞的NIO线程\n        selector.wakeup();\n    &#125;\n&#125; \n\n唤醒时需要进行两个判断\n\n判断提交任务的\n是否为NIO线程\n\n若是其他线程，才能唤醒NIO线程\n若是NIO线程自己，则不能唤醒\n\n\n通过AtomicLong保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程\n\n\nSELECT分支\nrun方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制\nint strategy &#x3D; selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());\nswitch (strategy) &#123;\n\t...\n&#125; \n\nstrategy的值由calculateStrategy方法确定\n@Override\npublic int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;\n    &#x2F;&#x2F; selectSupplier.get() 底层是 selector.selectNow();\n    return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;\n&#125; \n\n该方法会根据hasTaks变量判断任务队列中是否有任务\n\n若有任务，则通过selectSupplier获得strategy的值\n\nget方法会selectNow方法，顺便拿到IO事件\nprivate final IntSupplier selectNowSupplier &#x3D; new IntSupplier() &#123;\n    public int get() throws Exception &#123;\n        return NioEventLoop.this.selectNow();\n    &#125;\n&#125;;\n\nint selectNow() throws IOException &#123;\n    return this.selector.selectNow();\n&#125; \n\n\n若没有任务，就会进入SELECT分支\n\n\n也就说，当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过get方法调用selector.selectNow方法，顺便拿到IO事件\n3. Java NIO空轮询BUGJava NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题\n在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高\n@Override\nprotected void run() &#123;\n    ...\n    for(;;)&#123;\n        ...\n        &#x2F;&#x2F; 可能发生空轮询，无法阻塞NIO线程\n        strategy &#x3D; select(curDeadlineNanos);  \n        ...     \n    \n     \tif(...) &#123;\n\t\t\t...\n     \t&#125; else if (unexpectedSelectorWakeup(selectCnt) )&#123;\n            &#x2F;&#x2F; 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector\n            &#x2F;&#x2F; 并将selectCnt重置为0\n            selectCnt &#x3D; 0;\n        &#125;\n\t&#125;\n&#125; \n\nNetty中通过selectCnt变量来检测select方法是否发生空轮询BUG\n若发生空轮询BUG，那么selectCnt的值会增长是十分迅速。当selectCnt的值大于等于SELECTOR_AUTO_REBUILD_THRESHOLD（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理\nif (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;&#x3D; SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;\n    &#x2F;&#x2F; The selector returned prematurely many times in a row.\n    &#x2F;&#x2F; Rebuild the selector to work around the problem.\n    logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;,selectCnt, selector);\n    &#x2F;&#x2F; 重建selector，将原selector的配置信息传给新selector\n    &#x2F;&#x2F; 再用新selector覆盖旧selector\n    rebuildSelector();\n    return true;\n&#125; \n\n通过rebuildSelector方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0\n5. ioRatioNioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制\nNioEventLoop.run方法\n&#x2F;&#x2F; 处理IO事件时间比例，默认为50%\nfinal int ioRatio &#x3D; this.ioRatio;\n\n&#x2F;&#x2F; 如果IO事件时间比例设置为100%\nif (ioRatio &#x3D;&#x3D; 100) &#123;\n    try &#123;\n        &#x2F;&#x2F; 如果需要去处理IO事件\n        if (strategy &gt; 0) &#123;\n            &#x2F;&#x2F; 先处理IO事件\n            processSelectedKeys();\n        &#125;\n    &#125; finally &#123;\n        &#x2F;&#x2F; Ensure we always run tasks.\n        &#x2F;&#x2F; 剩下的时间都去处理普通任务和定时任务\n        ranTasks &#x3D; runAllTasks();\n    &#125;\n&#125; else if (strategy &gt; 0) &#123; &#x2F;&#x2F; 如果需要去处理IO事件\n    &#x2F;&#x2F; 记录处理IO事件前的时间\n    final long ioStartTime &#x3D; System.nanoTime();\n    try &#123;\n        &#x2F;&#x2F; 去处理IO事件\n        processSelectedKeys();\n    &#125; finally &#123;\n        &#x2F;&#x2F; Ensure we always run tasks.\n        &#x2F;&#x2F; ioTime为处理IO事件耗费的事件\n        final long ioTime &#x3D; System.nanoTime() - ioStartTime;\n        &#x2F;&#x2F; 计算出处理其他任务的事件\n        &#x2F;&#x2F; 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行\n        ranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio);\n    &#125;\n&#125; else &#123; &#x2F;&#x2F; 没有IO事件需要处理\n    &#x2F;&#x2F; This will run the minimum number of tasks\n    &#x2F;&#x2F; 直接处理普通和定时任务\n    ranTasks &#x3D; runAllTasks(0); \n&#125; \n\n通过ioRatio控制各个任务执行的过程如下\n\n判断ioRatio是否为100\n\n若是，判断是否需要处理IO事件（strategy&gt;0）\n\n若需要处理IO事件，则先处理IO事件\n\n\n若否（或IO事件已经处理完毕），接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完\n&#x2F;&#x2F; 没有指定执行任务的时间\nranTasks &#x3D; runAllTasks(); \n\n\n若ioRatio不为100\n\n先去处理IO事件，记录处理IO事件所花费的事件保存在ioTime中\n\n接下来去处理其他任务，根据ioTime与ioRatio计算执行其他任务可用的时间\n&#x2F;&#x2F; 比如ioTime为10s，ioRatio为50\n&#x2F;&#x2F; 那么通过 10*(100-50)&#x2F;50&#x3D;10 计算出其他任务可用的时间为 10s\n&#x2F;&#x2F; 处理IO事件占用的事件总比例为50%\nranTasks &#x3D; runAllTasks(ioTime * (100 - ioRatio) &#x2F; ioRatio); \n\n执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行\n\n\n\n若没有IO事件需要处理，则去执行最少数量的普通任务和定时任务\n&#x2F;&#x2F; 运行最少数量的任务\nranTasks &#x3D; runAllTasks(0); \n\n6. 处理事件IO事件是通过NioEventLoop.processSelectedKeys()方法处理的\nprivate void processSelectedKeys() &#123;\n    &#x2F;&#x2F; 如果selectedKeys是基于数组的\n    &#x2F;&#x2F; 一般情况下都走这个分支\n    if (selectedKeys !&#x3D; null) &#123;\n        &#x2F;&#x2F; 处理各种IO事件\n        processSelectedKeysOptimized();\n    &#125; else &#123;\n        processSelectedKeysPlain(selector.selectedKeys());\n    &#125;\n&#125; \n\nprocessSelectedKeysOptimized方法\nprivate void processSelectedKeysOptimized() &#123;\n    for (int i &#x3D; 0; i &lt; selectedKeys.size; ++i) &#123;\n        &#x2F;&#x2F; 拿到SelectionKeyec\n        final SelectionKey k &#x3D; selectedKeys.keys[i];\n        &#x2F;&#x2F; null out entry in the array to allow to have it GC&#39;ed once the Channel close\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n        selectedKeys.keys[i] &#x3D; null;\n\n        &#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel\n        final Object a &#x3D; k.attachment();\n\n        if (a instanceof AbstractNioChannel) &#123;\n            &#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel\n            processSelectedKey(k, (AbstractNioChannel) a);\n        &#125; else &#123;\n            @SuppressWarnings(&quot;unchecked&quot;)\n            NioTask&lt;SelectableChannel&gt; task &#x3D; (NioTask&lt;SelectableChannel&gt;) a;\n            processSelectedKey(k, task);\n        &#125;\n\n        if (needsToSelectAgain) &#123;\n            &#x2F;&#x2F; null out entries in the array to allow to have it GC&#39;ed once the Channel close\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2363\n            selectedKeys.reset(i + 1);\n\n            selectAgain();\n            i &#x3D; -1;\n        &#125;\n    &#125;\n&#125; \n\n该方法中通过fori的方法，遍历基于数组的SelectedKey，通过\nfinal SelectionKey k &#x3D; selectedKeys.keys[i]; \n\n获取到SelectionKey，然后获取其再Register时添加的附件NioServerSocketChannel\n&#x2F;&#x2F; 获取SelectionKey上的附件，即NioServerSocketChannel\nfinal Object a &#x3D; k.attachment(); \n\n如果附件继承自AbstractNioChannel，则会调用\n&#x2F;&#x2F; 处理事件，传入附件NioServerSocketChannel\nprocessSelectedKey(k, (AbstractNioChannel) a); \n\n去处理各个事件\n真正处理各种事件的方法processSelectedKey\n获取SelectionKey的事件，然后进行相应处理\nprivate void processSelectedKey(SelectionKey k, AbstractNioChannel ch) &#123;\n    final AbstractNioChannel.NioUnsafe unsafe &#x3D; ch.unsafe();\n    if (!k.isValid()) &#123;\n        final EventLoop eventLoop;\n        try &#123;\n            eventLoop &#x3D; ch.eventLoop();\n        &#125; catch (Throwable ignored) &#123;\n            &#x2F;&#x2F; If the channel implementation throws an exception because there is no event loop, we ignore this\n            &#x2F;&#x2F; because we are only trying to determine if ch is registered to this event loop and thus has authority\n            &#x2F;&#x2F; to close ch.\n            return;\n        &#125;\n        &#x2F;&#x2F; Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop\n        &#x2F;&#x2F; and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is\n        &#x2F;&#x2F; still healthy and should not be closed.\n        &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;5125\n        if (eventLoop &#x3D;&#x3D; this) &#123;\n            &#x2F;&#x2F; close the channel if the key is not valid anymore\n            unsafe.close(unsafe.voidPromise());\n        &#125;\n        return;\n    &#125;\n\n    try &#123;\n        int readyOps &#x3D; k.readyOps();\n        &#x2F;&#x2F; We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise\n        &#x2F;&#x2F; the NIO JDK channel implementation may throw a NotYetConnectedException.\n        if ((readyOps &amp; SelectionKey.OP_CONNECT) !&#x3D; 0) &#123;\n            &#x2F;&#x2F; remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;924\n            int ops &#x3D; k.interestOps();\n            ops &amp;&#x3D; ~SelectionKey.OP_CONNECT;\n            k.interestOps(ops);\n\n            unsafe.finishConnect();\n        &#125;\n\n        &#x2F;&#x2F; Process OP_WRITE first as we may be able to write some queued buffers and so free memory.\n        if ((readyOps &amp; SelectionKey.OP_WRITE) !&#x3D; 0) &#123;\n            &#x2F;&#x2F; Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write\n            ch.unsafe().forceFlush();\n        &#125;\n\n        &#x2F;&#x2F; Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead\n        &#x2F;&#x2F; to a spin loop\n        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n            unsafe.read();\n        &#125;\n    &#125; catch (CancelledKeyException ignored) &#123;\n        unsafe.close(unsafe.voidPromise());\n    &#125;\n&#125; \n\nc、Accept剖析1. NIO中处理Accept事件流程NIO中处理Accept事件主要有以下六步\n\nselector.select()阻塞线程，直到事件发生\n遍历selectionKeys\n获取一个key，判断事件类型是否为Accept\n\n\n\n创建SocketChannel，设置为非阻塞\n将SocketChannel注册到selector中\n关注selectionKeys的read事件\n\n代码如下\n&#x2F;&#x2F; 阻塞直到事件发生\nselector.select();\n\nIterator&lt;SelectionKey&gt; iter &#x3D; selector.selectionKeys().iterator();\nwhile (iter.hasNext()) &#123;    \n    &#x2F;&#x2F; 拿到一个事件\n    SelectionKey key &#x3D; iter.next();\n    \n    &#x2F;&#x2F; 如果是 accept 事件\n    if (key.isAcceptable()) &#123;\n        \n        &#x2F;&#x2F; 执行accept，获得SocketChannel\n        SocketChannel channel &#x3D; serverSocketChannel.accept();\n        channel.configureBlocking(false);\n        \n        &#x2F;&#x2F; 将SocketChannel注册到selector中，并关注read事件\n        channel.register(selector, SelectionKey.OP_READ);\n    &#125;\n    &#x2F;&#x2F; ...\n&#125; \n\n其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步\n2. SocketChannel的创建与注册发生Accept事件后，会执行NioEventLoop.run方法的如下if分支\nif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n\tunsafe.read();\n&#125; \n\nNioMessageUnsafe.read方法\npublic void read() &#123;\n\n    ...\n    \n    try &#123;\n        try &#123;\n            do &#123;\n\t\t\t\t&#x2F;&#x2F; doReadMessages中执行了accept获得了SocketChannel\n                &#x2F;&#x2F; 并创建NioSocketChannel作为消息放入readBuf\n                &#x2F;&#x2F; readBuf是一个ArrayList用来缓存消息\n                &#x2F;&#x2F; private final List&lt;Object&gt; readBuf &#x3D; new ArrayList&lt;Object&gt;();\n                int localRead &#x3D; doReadMessages(readBuf);\n                \n                ...\n                \n\t\t\t\t&#x2F;&#x2F; localRead值为1，就一条消息，即接收一个客户端连接\n                allocHandle.incMessagesRead(localRead);\n            &#125; while (allocHandle.continueReading());\n        &#125; catch (Throwable t) &#123;\n            exception &#x3D; t;\n        &#125;\n\n        int size &#x3D; readBuf.size();\n        for (int i &#x3D; 0; i &lt; size; i ++) &#123;\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发read事件，让pipeline上的handler处理\n            &#x2F;&#x2F; ServerBootstrapAcceptor.channelRead\n            pipeline.fireChannelRead(readBuf.get(i));\n        &#125;\n        \n        ...\n        \n    &#125; finally &#123;\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125; \n\nNioSocketChannel.doReadMessages方法\n该方法中处理accpet事件，获得SocketChannel，同时创建了NioSocketChannel，作为消息放在了readBuf中\n@Override\nprotected int doReadMessages(List&lt;Object&gt; buf) throws Exception &#123;\n    &#x2F;&#x2F; 处理accpet事件，获得SocketChannel\n    SocketChannel ch &#x3D; SocketUtils.accept(javaChannel());\n\n    try &#123;\n        if (ch !&#x3D; null) &#123;\n            &#x2F;&#x2F; 创建了NioSocketChannel，作为消息放在了readBuf中\n            buf.add(new NioSocketChannel(this, ch));\n            return 1;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n       ...\n    &#125;\n\n    return 0;\n&#125; \nServerBootstrapAcceptor.channelRead\npublic void channelRead(ChannelHandlerContext ctx, Object msg) &#123;\n    &#x2F;&#x2F; 这时的msg是NioSocketChannel\n    final Channel child &#x3D; (Channel) msg;\n\n    &#x2F;&#x2F; NioSocketChannel添加childHandler，即初始化器\n    child.pipeline().addLast(childHandler);\n\n    &#x2F;&#x2F; 设置选项\n    setChannelOptions(child, childOptions, logger);\n\n    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;\n        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());\n    &#125;\n\n    try &#123;\n        &#x2F;&#x2F; 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程\n        childGroup.register(child).addListener(new ChannelFutureListener() &#123;\n            @Override\n            public void operationComplete(ChannelFuture future) throws Exception &#123;\n                if (!future.isSuccess()) &#123;\n                    forceClose(child, future.cause());\n                &#125;\n            &#125;\n        &#125;);\n    &#125; catch (Throwable t) &#123;\n        forceClose(child, t);\n    &#125;\n&#125; \n\n通过AbstractUnsafe.register 方法，将SocketChannel注册到了Selector中，过程与启动流程中的Register过程类似\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    \n    ...\n\n    AbstractChannel.this.eventLoop &#x3D; eventLoop;\n\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            &#x2F;&#x2F; 这行代码完成的是nio boss -&gt; nio worker线程的切换\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    &#x2F;&#x2F; 真正的注册操作\n                    register0(promise);\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            ...\n        &#125;\n    &#125;\n&#125; \nAbstractChannel.AbstractUnsafe.register0\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n        \n        ...\n            \n        &#x2F;&#x2F; 该方法将SocketChannel注册到Selector中\n        doRegister();\n        \n        &#x2F;&#x2F; 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail\n        pipeline.invokeHandlerAddedIfNeeded();\n        &#x2F;&#x2F; 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail\n\n        safeSetSuccess(promise);\n        pipeline.fireChannelRegistered();\n        \n        if (isActive()) &#123;\n            if (firstRegistration) &#123;\n                &#x2F;&#x2F; 触发pipeline上active事件\n                pipeline.fireChannelActive();\n            &#125; else if (config().isAutoRead()) &#123;\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        closeForcibly();\n        closeFuture.setClosed();\n        safeSetFailure(promise, t);\n    &#125;\n&#125; \n\nAbstractNioChannel.doRegister将SocketChannel注册到Selector中\n@Override\nprotected void doRegister() throws Exception &#123;\n    boolean selected &#x3D; false;\n    for (;;) &#123;\n        try &#123;\n            &#x2F;&#x2F; 将Selector注册到Selector中\n            selectionKey &#x3D; javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        &#125; catch (CancelledKeyException e) &#123;\n            ...\n        &#125;\n    &#125;\n&#125; \nHeadContext.channelActive\npublic void channelActive(ChannelHandlerContext ctx) &#123;\n    ctx.fireChannelActive();\n\t&#x2F;&#x2F; 触发read(NioSocketChannel这里read只是为了触发channel的事件注册，还未涉及数据读取)\n    readIfIsAutoRead();\n&#125; \n\nAbstractNioChannel.doBeginRead，通过该方法，SocketChannel关注了read事件\nprotected void doBeginRead() throws Exception &#123;\n    &#x2F;&#x2F; Channel.read() or ChannelHandlerContext.read() was called\n    final SelectionKey selectionKey &#x3D; this.selectionKey;\n    if (!selectionKey.isValid()) &#123;\n        return;\n    &#125;\n\n    readPending &#x3D; true;\n\t&#x2F;&#x2F; 这时候 interestOps是0\n    final int interestOps &#x3D; selectionKey.interestOps();\n    if ((interestOps &amp; readInterestOp) &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 关注read事件\n        selectionKey.interestOps(interestOps | readInterestOp);\n    &#125;\n&#125; \n\nd、Read剖析read事件的处理也是在\nif ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) !&#x3D; 0 || readyOps &#x3D;&#x3D; 0) &#123;\n\tunsafe.read();\n&#125;\n\n分支中，通过unsafe.read()方法处理的，不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中\n@Override\npublic final void read() &#123;\n    &#x2F;&#x2F; 获得Channel的配置\n    final ChannelConfig config &#x3D; config();\n    if (shouldBreakReadReady(config)) &#123;\n        clearReadPending();\n        return;\n    &#125;\n    final ChannelPipeline pipeline &#x3D; pipeline();\n\t&#x2F;&#x2F; 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）\n\tfinal ByteBufAllocator allocator &#x3D; config.getAllocator();\n    &#x2F;&#x2F; 用来分配 byteBuf，确定单次读取大小\n    final RecvByteBufAllocator.Handle allocHandle &#x3D; recvBufAllocHandle();\n    allocHandle.reset(config);\n\n    ByteBuf byteBuf &#x3D; null;\n    boolean close &#x3D; false;\n    try &#123;\n        do &#123;\n            &#x2F;&#x2F; 创建ByteBuf\n            byteBuf &#x3D; allocHandle.allocate(allocator);\n            &#x2F;&#x2F; 读取内容，放入ByteBUf中\n            allocHandle.lastBytesRead(doReadBytes(byteBuf));\n            if (allocHandle.lastBytesRead() &lt;&#x3D; 0) &#123;\n                byteBuf.release();\n                byteBuf &#x3D; null;\n                close &#x3D; allocHandle.lastBytesRead() &lt; 0;\n                if (close) &#123;\n                    readPending &#x3D; false;\n                &#125;\n                break;\n            &#125;\n\n            allocHandle.incMessagesRead(1);\n            readPending &#x3D; false;\n            &#x2F;&#x2F; 触发read 事件，让pipeline上的handler处理\n            &#x2F;&#x2F; 这时是处理NioSocketChannel上的handler\n            pipeline.fireChannelRead(byteBuf);\n            byteBuf &#x3D; null;\n        &#125; \n        &#x2F;&#x2F; 是否要继续循环\n        while (allocHandle.continueReading());\n\n        allocHandle.readComplete();\n        &#x2F;&#x2F; 触发 read complete事件\n        pipeline.fireChannelReadComplete();\n\n        if (close) &#123;\n            closeOnRead(pipeline);\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        handleReadException(pipeline, byteBuf, t, close, allocHandle);\n    &#125; finally &#123;\n         &#x2F;&#x2F; Check if there is a readPending which was not processed yet.\n         &#x2F;&#x2F; This could be for two reasons:\n         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n         &#x2F;&#x2F; * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n         &#x2F;&#x2F;\n         &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;2254\n        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;\n            removeReadOp();\n        &#125;\n    &#125;\n&#125; \nDefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)\npublic boolean continueReading(UncheckedBooleanSupplier maybeMoreDataSupplier) &#123;\n    return \n           &#x2F;&#x2F; 一般为true\n           config.isAutoRead() &amp;&amp;\n           &#x2F;&#x2F; respectMaybeMoreData默认为true\n           &#x2F;&#x2F; maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true\n           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;\n           &#x2F;&#x2F; 小于最大次数，maxMessagePerRead默认16\n           totalMessages &lt; maxMessagePerRead &amp;&amp;\n           &#x2F;&#x2F; 实际读到了数据\n           totalBytesRead &gt; 0;\n&#125;\n","slug":"Netty","date":"2022-04-12T02:52:09.000Z","categories_index":"互联网八股","tags_index":"Netty","author_index":"张 凡"},{"id":"9bc6b9b8ef2259594a736fcc57388eb4","title":"聊天项目教程","content":"博文主要介绍后端的核心内容\n视频教训参考 黑马程序员Netty全套教程\n博客参考了 Nyima\n0. 总体思路前后端信息交互的推送技术有三类:\n\n短轮询\n\n一般是客户端定时发送普通Http请求给服务端\n会占用大量服务器资源\n数据响应不及时\n\n\n长轮询(Comet)\n\n\n\n基于Ajax长轮询技术(Long-polling)或者SSE(Server-Sent-Event)\n\n\n\n\n1. 环境搭建本项目的后端使用Maven构建，主要的依赖如下:\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;\n         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;\n    &lt;groupId&gt;org.example&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;com.netty.netty&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;maven-compiler-plugin&lt;&#x2F;artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;source&gt;8&lt;&#x2F;source&gt;\n                    &lt;target&gt;8&lt;&#x2F;target&gt;\n                &lt;&#x2F;configuration&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.netty&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;netty-all&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;4.1.51.Final&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.18.20&lt;&#x2F;version&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n        &lt;&#x2F;dependency&gt;\n&lt;!--        &lt;dependency&gt;--&gt;\n&lt;!--            &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;--&gt;\n&lt;!--            &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;--&gt;\n&lt;!--            &lt;version&gt;1.7.30&lt;&#x2F;version&gt;--&gt;\n&lt;!--            &lt;scope&gt;test&lt;&#x2F;scope&gt;--&gt;\n&lt;!--        &lt;&#x2F;dependency&gt;--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.google.code.gson&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;gson&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;2.8.5&lt;&#x2F;version&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n&lt;&#x2F;project&gt;\n\n\n\n2. 创建聊天传送的消息类这些都是聊天过程中发送的消息类，主要是为了规范消息的格式。\n\n\n所有的类都实现了Message类,它的主要内容如下:\n@Data\npublic abstract class Message implements Serializable &#123;\n\n    &#x2F;**\n     * 根据消息类型字节，获得对应的消息 class\n     * @param messageType 消息类型字节\n     * @return 消息 class\n     *&#x2F;\n    public static Class&lt;? extends Message&gt; getMessageClass(int messageType) &#123;\n        return messageClasses.get(messageType);\n    &#125;\n\n    private int sequenceId;\n\n    private int messageType;\n\n    public abstract int getMessageType();\n\n    public static final int LoginRequestMessage &#x3D; 0;\n    public static final int LoginResponseMessage &#x3D; 1;\n    public static final int ChatRequestMessage &#x3D; 2;\n    public static final int ChatResponseMessage &#x3D; 3;\n    public static final int GroupCreateRequestMessage &#x3D; 4;\n    public static final int GroupCreateResponseMessage &#x3D; 5;\n    public static final int GroupJoinRequestMessage &#x3D; 6;\n    public static final int GroupJoinResponseMessage &#x3D; 7;\n    public static final int GroupQuitRequestMessage &#x3D; 8;\n    public static final int GroupQuitResponseMessage &#x3D; 9;\n    public static final int GroupChatRequestMessage &#x3D; 10;\n    public static final int GroupChatResponseMessage &#x3D; 11;\n    public static final int GroupMembersRequestMessage &#x3D; 12;\n    public static final int GroupMembersResponseMessage &#x3D; 13;\n    public static final int PingMessage &#x3D; 14;\n    public static final int PongMessage &#x3D; 15;\n    &#x2F;**\n     * 请求类型 byte 值\n     *&#x2F;\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    &#x2F;**\n     * 响应类型 byte 值\n     *&#x2F;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    private static final Map&lt;Integer, Class&lt;? extends Message&gt;&gt; messageClasses &#x3D; new HashMap&lt;&gt;();\n\n    static &#123;\n        messageClasses.put(LoginRequestMessage, cn.message.LoginRequestMessage.class);\n        messageClasses.put(LoginResponseMessage, cn.message.LoginResponseMessage.class);\n        messageClasses.put(ChatRequestMessage, cn.message.ChatRequestMessage.class);\n        messageClasses.put(ChatResponseMessage, cn.message.ChatResponseMessage.class);\n        messageClasses.put(GroupCreateRequestMessage, cn.message.GroupCreateRequestMessage.class);\n        messageClasses.put(GroupCreateResponseMessage, cn.message.GroupCreateResponseMessage.class);\n        messageClasses.put(GroupJoinRequestMessage, cn.message.GroupJoinRequestMessage.class);\n        messageClasses.put(GroupJoinResponseMessage, cn.message.GroupJoinResponseMessage.class);\n        messageClasses.put(GroupQuitRequestMessage, cn.message.GroupQuitRequestMessage.class);\n        messageClasses.put(GroupQuitResponseMessage, cn.message.GroupQuitResponseMessage.class);\n        messageClasses.put(GroupChatRequestMessage, cn.message.GroupChatRequestMessage.class);\n        messageClasses.put(GroupChatResponseMessage, cn.message.GroupChatResponseMessage.class);\n        messageClasses.put(GroupMembersRequestMessage, cn.message.GroupMembersRequestMessage.class);\n        messageClasses.put(GroupMembersResponseMessage, cn.message.GroupMembersResponseMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n&#x2F;&#x2F;        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;\n\n\n\n3. 创建会话管理类会话Session相关类的作用是:\n\nSession 维护 channel 和 用户之间的关系。\nGroupSession维护聊天室和成员的关系信息\n\n\n\n他们都通过工厂模式实现,可以他们的接口定义如下:\nSession\n&#x2F;**\n * 会话管理接口\n *&#x2F;\npublic interface Session &#123;\n\n    &#x2F;**\n     * 绑定会话\n     * @param channel 哪个 channel 要绑定会话\n     * @param username 会话绑定用户\n     *&#x2F;\n    void bind(Channel channel, String username);\n\n    &#x2F;**\n     * 解绑会话\n     * @param channel 哪个 channel 要解绑会话\n     *&#x2F;\n    void unbind(Channel channel);\n\n    &#x2F;**\n     * 获取属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @return 属性值\n     *&#x2F;\n    Object getAttribute(Channel channel, String name);\n\n    &#x2F;**\n     * 设置属性\n     * @param channel 哪个 channel\n     * @param name 属性名\n     * @param value 属性值\n     *&#x2F;\n    void setAttribute(Channel channel, String name, Object value);\n\n    &#x2F;**\n     * 根据用户名获取 channel\n     * @param username 用户名\n     * @return channel\n     *&#x2F;\n    Channel getChannel(String username);\n&#125;\n\n\nGroupSession\npublic interface GroupSession &#123;\n    &#x2F;**\n     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null\n     * @param name 组名\n     * @param members 成员\n     * @return 成功时返回组对象, 失败返回 null\n     *&#x2F;\n    Group createGroup(String name, Set&lt;String&gt; members);\n    &#x2F;**\n     * 加入聊天组\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group joinMember(String name, String member);\n    &#x2F;**\n     * 移除组成员\n     * @param name 组名\n     * @param member 成员名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeMember(String name, String member);\n    &#x2F;**\n     * 移除聊天组\n     * @param name 组名\n     * @return 如果组不存在返回 null, 否则返回组对象\n     *&#x2F;\n    Group removeGroup(String name);\n    &#x2F;**\n     * 获取组成员\n     * @param name 组名\n     * @return 成员集合, 如果群不存在或没有成员会返回 empty set\n     *&#x2F;\n    Set&lt;String&gt; getMembers(String name);\n    &#x2F;**\n     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回\n     * @param name 组名\n     * @return 成员 channel 集合\n     *&#x2F;\n    List&lt;Channel&gt; getMembersChannel(String name);\n&#125;\n\n\n\n\n个人聊天建立的时候，会执行如下代码保存会话信息：\nSessionFactory.getSession().bind(ctx.channel(), username);\n\n聊天室建立的时候,会执行如下代码\nGroupSession groupSession &#x3D; GroupSessionFactory.getGroupSession();\nGroup group &#x3D; groupSession.createGroup(groupName, members);\nif (group &#x3D;&#x3D; null) &#123;\n    &#x2F;&#x2F; 发送拉群消息\n    List&lt;Channel&gt; channels &#x3D; groupSession.getMembersChannel(groupName);\n    &#x2F;&#x2F;---\n&#125;\n\n\n\n本地存储用户的信息,也可以通过数据库实现\n\n\n&#x2F;**\n * 用户管理接口\n *&#x2F;\npublic interface UserService &#123;\n\n    &#x2F;**\n     * 登录\n     * @param username 用户名\n     * @param password 密码\n     * @return 登录成功返回 true, 否则返回 false\n     *&#x2F;\n    boolean login(String username, String password);\n&#125;\n\nUserServiceMemoryImpl\npublic class UserServiceMemoryImpl implements UserService &#123;\n    private Map&lt;String, String&gt; allUserMap &#x3D; new ConcurrentHashMap&lt;&gt;();\n\n    &#123;\n        allUserMap.put(&quot;zhangsan&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;lisi&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;wangwu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;zhaoliu&quot;, &quot;123&quot;);\n        allUserMap.put(&quot;qianqi&quot;, &quot;123&quot;);\n    &#125;\n\n    @Override\n    public boolean login(String username, String password) &#123;\n        String pass &#x3D; allUserMap.get(username);\n        if (pass &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n        return pass.equals(password);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n4. 创建应用层传输的协议规定应用层报文的格式,他们是对消息进行编解码的。\n\n\nMessageCodecSharable来解决编解码问题\n@ChannelHandler.Sharable\n&#x2F;**\n * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的\n *&#x2F;\npublic class MessageCodecSharable extends MessageToMessageCodec&lt;ByteBuf, Message&gt; &#123;\n    @Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        ByteBuf out &#x3D; ctx.alloc().buffer();\n        &#x2F;&#x2F; 设置魔数 4个字节\n        out.writeBytes(new byte[]&#123;&#39;N&#39;, &#39;Y&#39;, &#39;I&#39;, &#39;M&#39;&#125;);\n        &#x2F;&#x2F; 设置版本号 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置序列化方式 1个字节\n        out.writeByte(1);\n        &#x2F;&#x2F; 设置指令类型 1个字节\n        out.writeByte(msg.getMessageType());\n        &#x2F;&#x2F; 设置请求序号 4个字节\n        out.writeInt(msg.getSequenceId());\n        &#x2F;&#x2F; 为了补齐为16个字节，填充1个字节的数据\n        out.writeByte(0xff);\n        &#x2F;&#x2F; 获得序列化后的msg\n        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n        oos.writeObject(msg);\n        byte[] bytes &#x3D; bos.toByteArray();\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n    @Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; 获取魔数\n        int magic &#x3D; in.readInt();\n        &#x2F;&#x2F; 获取版本号\n        byte version &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得序列化方式\n        byte seqType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得指令类型\n        byte messageType &#x3D; in.readByte();\n        &#x2F;&#x2F; 获得请求序号\n        int sequenceId &#x3D; in.readInt();\n        &#x2F;&#x2F; 移除补齐字节\n        in.readByte();\n        &#x2F;&#x2F; 获得正文长度\n        int length &#x3D; in.readInt();\n        &#x2F;&#x2F; 获得正文\n        byte[] bytes &#x3D; new byte[length];\n        in.readBytes(bytes, 0, length);\n        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n        Message message &#x3D; (Message) ois.readObject();\n        &#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n        &#x2F;&#x2F; 打印获得的信息正文\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;魔数&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(magic);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;版本号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(version);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;序列化方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(seqType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;指令类型&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(messageType);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;请求序号&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(sequenceId);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文长度&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(length);\n        System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;正文&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        System.out.println(message);\n    &#125;\n&#125;\n\nProcotolFrameDecoder解决黏包半包问题\npublic class ProcotolFrameDecoder extends LengthFieldBasedFrameDecoder &#123;\n    public ProcotolFrameDecoder() &#123;\n        this(1024, 12, 4, 0, 0);\n    &#125;\n    public ProcotolFrameDecoder(int maxFrameLength, int lengthFieldOffset, int lengthFieldLength, int lengthAdjustment, int initialBytesToStrip) &#123;\n        super(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);\n    &#125;\n&#125;\n\n\n\n5. 创建客户端代码\npublic class ChatClient &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatClient.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        CountDownLatch WAIT_FOR_LOGIN &#x3D; new CountDownLatch(1);\n        AtomicBoolean LOGIN &#x3D; new AtomicBoolean(false);\n        AtomicBoolean EXIT &#x3D; new AtomicBoolean(false);\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.group(group);\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    &#x2F;&#x2F; 心跳机制\n                    ch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\n                    ch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n                        @Override\n                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n                            IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n                            if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n                                &#x2F;&#x2F; 发送心跳包\n                                ctx.writeAndFlush(new PingMessage());\n                            &#125;\n                        &#125;\n                    &#125;);\n                    ch.pipeline().addLast(&quot;client handler&quot;, new ChannelInboundHandlerAdapter() &#123;\n                        &#x2F;&#x2F; 接收响应消息\n                        @Override\n                        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;\n&#x2F;&#x2F;                            log.debug(&quot;msg: &#123;&#125;&quot;, msg);\n                            if ((msg instanceof LoginResponseMessage)) &#123;\n                                LoginResponseMessage response &#x3D; (LoginResponseMessage) msg;\n                                if (response.isSuccess()) &#123;\n                                    &#x2F;&#x2F; 如果登录成功\n                                    LOGIN.set(true);\n                                &#125;\n                                &#x2F;&#x2F; 唤醒 system in 线程\n                                WAIT_FOR_LOGIN.countDown();\n                            &#125;\n                            System.out.println(msg);\n                        &#125;\n\n                        @Override\n                        public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;\n                            new Thread(() -&gt; &#123;\n                                System.out.println(&quot;请输入用户名:&quot;);\n                                Scanner scanner &#x3D; new Scanner(System.in);\n                                String username &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                System.out.println(&quot;请输入密码:&quot;);\n                                String password &#x3D; scanner.nextLine();\n                                if (EXIT.get()) &#123;\n                                    return;\n                                &#125;\n                                &#x2F;&#x2F; 构造消息对象\n                                LoginRequestMessage message &#x3D; new LoginRequestMessage(username, password);\n                                System.out.println(message);\n                                &#x2F;&#x2F; 发送消息\n                                ctx.writeAndFlush(message);\n                                System.out.println(&quot;等待后续操作...&quot;);\n                                try &#123;\n                                    WAIT_FOR_LOGIN.await();\n                                &#125; catch (InterruptedException e) &#123;\n                                    e.printStackTrace();\n                                &#125;\n                                &#x2F;&#x2F; 如果登录失败\n                                if (!LOGIN.get()) &#123;\n                                    ctx.channel().close();\n                                    return;\n                                &#125;\n                                while (true) &#123;\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    System.out.println(&quot;send [username] [content]&quot;);\n                                    System.out.println(&quot;gsend [group name] [content]&quot;);\n                                    System.out.println(&quot;gcreate [group name] [m1,m2,m3...]&quot;);\n                                    System.out.println(&quot;gmembers [group name]&quot;);\n                                    System.out.println(&quot;gjoin [group name]&quot;);\n                                    System.out.println(&quot;gquit [group name]&quot;);\n                                    System.out.println(&quot;quit&quot;);\n                                    System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n                                    String command &#x3D; null;\n                                    try &#123;\n                                        command &#x3D; scanner.nextLine();\n                                    &#125; catch (Exception e) &#123;\n                                        break;\n                                    &#125;\n                                    if (EXIT.get()) &#123;\n                                        return;\n                                    &#125;\n                                    String[] s &#x3D; command.split(&quot; &quot;);\n                                    switch (s[0]) &#123;\n                                        case &quot;send&quot;:\n                                            ctx.writeAndFlush(new ChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gsend&quot;:\n                                            ctx.writeAndFlush(new GroupChatRequestMessage(username, s[1], s[2]));\n                                            break;\n                                        case &quot;gcreate&quot;:\n                                            Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;(Arrays.asList(s[2].split(&quot;,&quot;)));\n                                            set.add(username); &#x2F;&#x2F; 加入自己\n                                            ctx.writeAndFlush(new GroupCreateRequestMessage(s[1], set));\n                                            break;\n                                        case &quot;gmembers&quot;:\n                                            ctx.writeAndFlush(new GroupMembersRequestMessage(s[1]));\n                                            break;\n                                        case &quot;gjoin&quot;:\n                                            ctx.writeAndFlush(new GroupJoinRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;gquit&quot;:\n                                            ctx.writeAndFlush(new GroupQuitRequestMessage(username, s[1]));\n                                            break;\n                                        case &quot;quit&quot;:\n                                            ctx.channel().close();\n                                            return;\n                                    &#125;\n                                &#125;\n                            &#125;, &quot;System in&quot;).start();\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(&quot;localhost&quot;, 8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n6. 创建服务器代码服务器端代码,逻辑很简单,但是重点对于各个Handler的封装,然后依次加入SocketChannel\nch.pipeline().addLast(new ProcotolFrameDecoder());\nch.pipeline().addLast(loggingHandler);\nch.pipeline().addLast(messageSharableCodec);\nch.pipeline().addLast(loginRequestMessageHandler);\nch.pipeline().addLast(chatRequestMessageHandler);\nch.pipeline().addLast(groupCreateRequestMessageHandler);\nch.pipeline().addLast(groupJoinRequestMessageHandler);\nch.pipeline().addLast(groupMembersRequestMessageHandler);\nch.pipeline().addLast(groupQuitRequestMessageHandler);\nch.pipeline().addLast(groupChatRequestMessageHandler);\nch.pipeline().addLast(quitHandler);\n\n每个Handler是对客户端发过来不同类型的消息进行处理,按照消息类型的不同,封装成不同的Handler,下面以一个loginRequestMessageHandler为例来介绍具体代码\n@ChannelHandler.Sharable &#x2F;&#x2F; 设置成Sharable 可以公用一个处理器\n&#x2F;&#x2F; 继承SimpleChannelInboundHandler,注意针对的数据类型LoginRequestMessage\npublic class LoginRequestMessageHandler extends SimpleChannelInboundHandler&lt;LoginRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, LoginRequestMessage msg) throws Exception &#123;\n        String username &#x3D; msg.getUsername();\n        String password &#x3D; msg.getPassword();\n        boolean login &#x3D; UserServiceFactory.getUserService().login(username,\n                password);\n        LoginResponseMessage message;\n        if (login) &#123;\n            SessionFactory.getSession().bind(ctx.channel(), username);\n            message &#x3D; new LoginResponseMessage(true, &quot;登陆成功&quot;);\n        &#125; else &#123;\n            message &#x3D; new LoginResponseMessage(false, &quot;登录失败&quot;);\n        &#125;\n        &#x2F;&#x2F; 消息传回客户端\n        ctx.writeAndFlush(message);\n    &#125;\n&#125;\n\n\n\n完整代码如下:\npublic class ChatServer &#123;\n    &#x2F;&#x2F;    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageCodecSharable messageSharableCodec &#x3D; new MessageCodecSharable();\n        LoginRequestMessageHandler loginRequestMessageHandler &#x3D; new LoginRequestMessageHandler();\n        ChatRequestMessageHandler chatRequestMessageHandler &#x3D; new ChatRequestMessageHandler();\n        GroupCreateRequestMessageHandler groupCreateRequestMessageHandler &#x3D; new GroupCreateRequestMessageHandler();\n        GroupJoinRequestMessageHandler groupJoinRequestMessageHandler &#x3D; new GroupJoinRequestMessageHandler();\n        GroupMembersRequestMessageHandler groupMembersRequestMessageHandler &#x3D; new GroupMembersRequestMessageHandler();\n        GroupQuitRequestMessageHandler groupQuitRequestMessageHandler &#x3D; new GroupQuitRequestMessageHandler();\n        GroupChatRequestMessageHandler groupChatRequestMessageHandler &#x3D; new GroupChatRequestMessageHandler();\n        QuitHandler quitHandler &#x3D; new QuitHandler();\n        try &#123;\n            ServerBootstrap bootstrap &#x3D; new ServerBootstrap();\n            bootstrap.group(boss, worker);\n            bootstrap.channel(NioServerSocketChannel.class);\n            bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    &#x2F;&#x2F; 判断是不是读写时间过长\n                    &#x2F;&#x2F; 5s内如果没有收到Channel的数据,会触发事件IdleStateEvent\n                    ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\n                    ch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n                        &#x2F;&#x2F; 用来处理特殊事件\n                        @Override\n                        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n                            IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n                            &#x2F;&#x2F; 如果触发了读空闲事件\n                            if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE)&#123;\n                                System.out.println(&quot;已经5s没有读到数据了&quot;);\n                            &#125;\n&#x2F;&#x2F;                            super.userEventTriggered(ctx, evt);\n                        &#125;\n                    &#125;);\n                    ch.pipeline().addLast(new ProcotolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(loginRequestMessageHandler);\n                    ch.pipeline().addLast(chatRequestMessageHandler);\n                    ch.pipeline().addLast(groupCreateRequestMessageHandler);\n                    ch.pipeline().addLast(groupJoinRequestMessageHandler);\n                    ch.pipeline().addLast(groupMembersRequestMessageHandler);\n                    ch.pipeline().addLast(groupQuitRequestMessageHandler);\n                    ch.pipeline().addLast(groupChatRequestMessageHandler);\n                    ch.pipeline().addLast(quitHandler);\n\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n7. 添加心跳机制a. 连接假死原因\n网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源\n公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，会白白地消耗资源\n应用程序线程阻塞，无法进行数据读写\n\n问题\n\n假死的连接占用的资源不能自动释放\n向假死的连接发送数据，得到的反馈是发送超时\n\nb. 解决方法可以添加IdleStateHandler对空闲时间进行检测，通过构造函数可以传入三个参数\n\nreaderIdleTimeSeconds 读空闲经过的秒数\nwriterIdleTimeSeconds 写空闲经过的秒数\nallIdleTimeSeconds 读和写空闲经过的秒数\n\n当指定时间内未发生读或写事件时，会触发特定事件\n\n\n\n读空闲会触发READER_IDLE\n写空闲会触发WRITE_IDLE\n读和写空闲会触发ALL_IDEL\n\n想要处理这些事件，需要自定义事件处理函数\n&#x2F;&#x2F; 判断是不是读写时间过长\n&#x2F;&#x2F; 5s内如果没有收到Channel的数据,会触发事件IdleStateEvent\nch.pipeline().addLast(new IdleStateHandler(5, 0, 0));\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    &#x2F;&#x2F; 用来处理特殊事件\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        &#x2F;&#x2F; 如果触发了读空闲事件\n        if (event.state() &#x3D;&#x3D; IdleState.READER_IDLE)&#123;\n            System.out.println(&quot;已经5s没有读到数据了&quot;);\n        &#125;\n  \t\t&#x2F;&#x2F;super.userEventTriggered(ctx, evt);\n    &#125;\n&#125;);\n\nc. 心跳机制为避免因非网络等原因引发的READ_IDLE事件，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，直接让服务器断开连接是不可取的\n为避免此类情况，需要在客户端向服务器发送心跳包，发送频率要小于服务器设置的IdleTimeSeconds，一般设置为其值的一半\n客户端代码\n&#x2F;&#x2F; 发送心跳包，让服务器知道客户端在线\n&#x2F;&#x2F; 3s未发生WRITER_IDLE，就像服务器发送心跳包\n&#x2F;&#x2F; 该值为服务器端设置的READER_IDLE触发时间的一半左右\nch.pipeline().addLast(new IdleStateHandler(0, 3, 0));\nch.pipeline().addLast(new ChannelDuplexHandler() &#123;\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;\n        IdleStateEvent event &#x3D; (IdleStateEvent) evt;\n        if (event.state() &#x3D;&#x3D; IdleState.WRITER_IDLE) &#123;\n            &#x2F;&#x2F; 发送心跳包\n            ctx.writeAndFlush(new PingMessage());\n        &#125;\n    &#125;\n&#125;);\n\n8. 序列化a. 定义序列化接口public interface Serializer &#123;\n    &#x2F;**\n     * 序列化\n     * @param object 被序列化的对象\n     * @param &lt;T&gt; 被序列化对象类型\n     * @return 序列化后的字节数组\n     *&#x2F;\n    &lt;T&gt; byte[] serialize(T object);\n\n    &#x2F;**\n     * 反序列化\n     * @param clazz 反序列化的目标类的Class对象\n     * @param bytes 被反序列化的字节数组\n     * @param &lt;T&gt; 反序列化目标类\n     * @return 反序列化后的对象\n     *&#x2F;\n    &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes);\n&#125;\n\nb. 枚举实现类public enum SerializerAlgorithm implements Serializer &#123;\n    &#x2F;&#x2F; Java的序列化和反序列化\n    Java &#123;\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            &#x2F;&#x2F; 序列化后的字节数组\n            byte[] bytes &#x3D; null;\n            try (ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n                 ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos)) &#123;\n                oos.writeObject(object);\n                bytes &#x3D; bos.toByteArray();\n            &#125; catch (IOException e) &#123;\n                e.printStackTrace();\n            &#125;\n            return bytes;\n        &#125;\n\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            T target &#x3D; null;\n            System.out.println(Arrays.toString(bytes));\n            try (ByteArrayInputStream bis &#x3D; new ByteArrayInputStream(bytes);\n                 ObjectInputStream ois &#x3D; new ObjectInputStream(bis)) &#123;\n                target &#x3D; (T) ois.readObject();\n            &#125; catch (IOException | ClassNotFoundException e) &#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 返回反序列化后的对象\n            return target;\n        &#125;\n    &#125;\n    \n     &#x2F;&#x2F; Json的序列化和反序列化\n    Json &#123;\n        @Override\n        public &lt;T&gt; byte[] serialize(T object) &#123;\n            String s &#x3D; new Gson().toJson(object);\n            System.out.println(s);\n            &#x2F;&#x2F; 指定字符集，获得字节数组\n            return s.getBytes(StandardCharsets.UTF_8);\n        &#125;\n\n        @Override\n        public &lt;T&gt; T deserialize(Class&lt;T&gt; clazz, byte[] bytes) &#123;\n            String s &#x3D; new String(bytes, StandardCharsets.UTF_8);\n            System.out.println(s);\n            &#x2F;&#x2F; 此处的clazz为具体类型的Class对象，而不是父类Message的\n            return new Gson().fromJson(s, clazz);\n        &#125;\n    &#125;\n&#125;\n\nc. 调用自定义的序列化算法MessageCodecSharable\n@Override\n    protected void encode(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList) throws Exception &#123;\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; 获得序列化后的msg\n        byte[] bytes &#x3D; Serializer.Algorithm.Java.serializer(msg);\n\n&#x2F;&#x2F;        ByteArrayOutputStream bos &#x3D; new ByteArrayOutputStream();\n&#x2F;&#x2F;        ObjectOutputStream oos &#x3D; new ObjectOutputStream(bos);\n&#x2F;&#x2F;        oos.writeObject(msg);\n&#x2F;&#x2F;        byte[] bytes &#x3D; bos.toByteArray();\n\n        &#x2F;&#x2F; 获得并设置正文长度 长度用4个字节标识\n        out.writeInt(bytes.length);\n        &#x2F;&#x2F; 设置消息正文\n        out.writeBytes(bytes);\n        outList.add(out);\n    &#125;\n\n@Override\n    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;\n        &#x2F;&#x2F; ...\n        Message message &#x3D; Serializer.Algorithm.Java.deserialize(Message.class, bytes);\n&#x2F;&#x2F;        byte[] bytes &#x3D; new byte[length];\n&#x2F;&#x2F;        in.readBytes(bytes, 0, length);\n&#x2F;&#x2F;        ObjectInputStream ois &#x3D; new ObjectInputStream(new ByteArrayInputStream(bytes));\n&#x2F;&#x2F;        Message message &#x3D; (Message) ois.readObject();\n        &#x2F;&#x2F; 将信息放入List中，传递给下一个handler\n        out.add(message);\n\n\n    &#125;\n\n\n\n9. 参数优化a. 连接超时优化CONNECT_TIMEOUT_MILLIS\n\n属于 SocketChannal 的参数\n用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常\n注意：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO\n\n使用\npublic class TestParam &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常\n        new Bootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n        \n        &#x2F;&#x2F; ServerSocketChannel 5s内未建立连接就抛出异常\n        new ServerBootstrap().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,5000);\n        &#x2F;&#x2F; SocketChannel 5s内未建立连接就抛出异常\n        new ServerBootstrap().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);\n    &#125;\n&#125;\n\n\n客户端通过 Bootstrap.option 函数来配置参数，配置参数作用于 SocketChannel\n服务器通过ServerBootstrap来配置参数，但是对于不同的 Channel 需要选择不同的方法\n通过 option 来配置 ServerSocketChannel 上的参数\n通过 childOption 来配置 SocketChannel 上的参数\n\n\n\n源码分析\n客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？\nAbstractNioChannel.AbstractNioUnsafe.connect方法中\npublic final void connect(\n                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;\n    \n    ...\n        \n    &#x2F;&#x2F; Schedule connect timeout.\n    &#x2F;&#x2F; 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置\n    int connectTimeoutMillis &#x3D; config().getConnectTimeoutMillis();\n    &#x2F;&#x2F; 如果超时时间大于0\n    if (connectTimeoutMillis &gt; 0) &#123;\n        &#x2F;&#x2F; 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行\n        &#x2F;&#x2F; schedule(Runnable command, long delay, TimeUnit unit)\n        connectTimeoutFuture &#x3D; eventLoop().schedule(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                &#x2F;&#x2F; 判断是否建立连接，Promise进行NIO线程与主线程之间的通信\n                &#x2F;&#x2F; 如果超时，则通过tryFailure方法将异常放入Promise中\n                &#x2F;&#x2F; 在主线程中抛出\n                ChannelPromise connectPromise &#x3D; AbstractNioChannel.this.connectPromise;\n                ConnectTimeoutException cause &#x3D; new ConnectTimeoutException(&quot;connection timed out: &quot; + remoteAddress);\n                if (connectPromise !&#x3D; null &amp;&amp; connectPromise.tryFailure(cause)) &#123;\n                    close(voidPromise());\n                &#125;\n            &#125;\n        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n    &#125;\n    \n   \t...\n        \n&#125;\n\n超时的判断主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的\n\nschedule 设置了一个定时任务，延迟connectTimeoutMillis秒后执行该方法\n如果指定时间内没有建立连接，则会执行其中的任务\n任务负责创建 ConnectTimeoutException 异常，并将异常通过 Pormise 传给主线程并抛出\n\n\n\nb.SO_BACKLOG该参数是 ServerSocketChannel 的参数\n1.次握手与连接队列第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入半连接队列中\n\n\n当完成三次握手以后，连接会被放入全连接队列中\n\n\n服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理\n\n\n在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 linux 2.2 之后，分别用下面两个参数来控制\n\n半连接队列 - sync queue\n大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 syncookies 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略\n\n\n全连接队列 - accept queue\n其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值\n如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client\n\n\n\n2. 作用在Netty中，SO_BACKLOG主要用于设置全连接队列的大小。当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于SO_BACKLOG设置的值是，便会抛出异常\n设置方式如下\n&#x2F;&#x2F; 设置全连接队列，大小为2\nnew ServerBootstrap().option(ChannelOption.SO_BACKLOG, 2);\n\n\n\n3. 默认值backlog参数在NioSocketChannel.doBind方法被使用\n@Override\nprotected void doBind(SocketAddress localAddress) throws Exception &#123;\n    if (PlatformDependent.javaVersion() &gt;&#x3D; 7) &#123;\n        javaChannel().bind(localAddress, config.getBacklog());\n    &#125; else &#123;\n        javaChannel().socket().bind(localAddress, config.getBacklog());\n    &#125;\n&#125;\n\n其中backlog被保存在了DefaultServerSocketChannelConfig配置类中\nprivate volatile int backlog &#x3D; NetUtil.SOMAXCONN;\n\n具体的赋值操作如下\nSOMAXCONN &#x3D; AccessController.doPrivileged(new PrivilegedAction&lt;Integer&gt;() &#123;\n    @Override\n    public Integer run() &#123;\n        &#x2F;&#x2F; Determine the default somaxconn (server socket backlog) value of the platform.\n        &#x2F;&#x2F; The known defaults:\n        &#x2F;&#x2F; - Windows NT Server 4.0+: 200\n        &#x2F;&#x2F; - Linux and Mac OS X: 128\n        int somaxconn &#x3D; PlatformDependent.isWindows() ? 200 : 128;\n        File file &#x3D; new File(&quot;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn&quot;);\n        BufferedReader in &#x3D; null;\n        try &#123;\n            &#x2F;&#x2F; file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the\n            &#x2F;&#x2F; try &#x2F; catch block.\n            &#x2F;&#x2F; See https:&#x2F;&#x2F;github.com&#x2F;netty&#x2F;netty&#x2F;issues&#x2F;4936\n            if (file.exists()) &#123;\n                in &#x3D; new BufferedReader(new FileReader(file));\n                &#x2F;&#x2F; 将somaxconn设置为Linux配置文件中设置的值\n                somaxconn &#x3D; Integer.parseInt(in.readLine());\n                if (logger.isDebugEnabled()) &#123;\n                    logger.debug(&quot;&#123;&#125;: &#123;&#125;&quot;, file, somaxconn);\n                &#125;\n            &#125; else &#123;\n                ...\n            &#125;\n            ...\n        &#125;  \n        &#x2F;&#x2F; 返回backlog的值\n        return somaxconn;\n    &#125;\n&#125;\n\n\nbacklog的值会根据操作系统的不同，来\n选择不同的默认值\n\nWindows 200\nLinux&#x2F;Mac OS 128\n\n\n如果配置文件/proc/sys/net/core/somaxconn存在，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的\n\n\nc. TCP_NODELAY\n属于 SocketChannal 参数\n因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就可能导致数据的发送存在一定的延时\n该参数默认为false，如果不希望的发送被延时，则需要将该值设置为true\n\nd. SO_SNDBUF &amp; SO_RCVBUF\nSO_SNDBUF 属于 SocketChannal 参数\nSO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）\n该参数用于指定接收方与发送方的滑动窗口大小\n\ne. ALLOCATOR\n属于 SocketChannal 参数\n用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存\n\n使用\n&#x2F;&#x2F; 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型\n&#x2F;&#x2F; 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型\nnew ServerBootstrap().childOption(ChannelOption.ALLOCATOR, new PooledByteBufAllocator());\n\n\n\nByteBufAllocator类型\n\n池化并使用直接内存\n&#x2F;&#x2F; true表示使用直接内存\nnew PooledByteBufAllocator(true);\n\n池化并使用堆内存\n&#x2F;&#x2F; false表示使用堆内存\nnew PooledByteBufAllocator(false);\n\n非池化并使用直接内存\n&#x2F;&#x2F; ture表示使用直接内存\nnew UnpooledByteBufAllocator(true);\n\n非池化并使用堆内存\n&#x2F;&#x2F; false表示使用堆内存\nnew UnpooledByteBufAllocator(false);\n\nf. RCVBUF_ALLOCATOR\n属于 SocketChannal 参数\n控制 Netty 接收缓冲区大小\n负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定\n\n10. 简易RPCa. 准备工作在聊天室代码的基础上进行一定的改进,Message中添加如下代码\npublic abstract class Message implements Serializable &#123;\n\n    ...\n\n    &#x2F;&#x2F; 添加RPC消息类型\n    public static final int RPC_MESSAGE_TYPE_REQUEST &#x3D; 101;\n    public static final int  RPC_MESSAGE_TYPE_RESPONSE &#x3D; 102;\n\n    static &#123;\n        &#x2F;&#x2F; 将消息类型放入消息类对象Map中\n        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);\n        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);\n    &#125;\n\n&#125;\n\n\n\nRPC请求消息\npublic class RpcRequestMessage extends Message &#123;\n    &#x2F;**\n     * 调用的接口全限定名，服务端根据它找到实现\n     *&#x2F;\n    private String interfaceName;\n    \n    &#x2F;**\n     * 调用接口中的方法名\n     *&#x2F;\n    private String methodName;\n    \n    &#x2F;**\n     * 方法返回类型\n     *&#x2F;\n    private Class&lt;?&gt; returnType;\n    \n    &#x2F;**\n     * 方法参数类型数组\n     *&#x2F;\n    private Class[] parameterTypes;\n    \n    &#x2F;**\n     * 方法参数值数组\n     *&#x2F;\n    private Object[] parameterValue;\n\n    public RpcRequestMessage(int sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue) &#123;\n        super.setSequenceId(sequenceId);\n        this.interfaceName &#x3D; interfaceName;\n        this.methodName &#x3D; methodName;\n        this.returnType &#x3D; returnType;\n        this.parameterTypes &#x3D; parameterTypes;\n        this.parameterValue &#x3D; parameterValue;\n    &#125;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_REQUEST;\n    &#125;\n    \n     public String getInterfaceName() &#123;\n        return interfaceName;\n    &#125;\n\n    public String getMethodName() &#123;\n        return methodName;\n    &#125;\n\n    public Class&lt;?&gt; getReturnType() &#123;\n        return returnType;\n    &#125;\n\n    public Class[] getParameterTypes() &#123;\n        return parameterTypes;\n    &#125;\n\n    public Object[] getParameterValue() &#123;\n        return parameterValue;\n    &#125;\n    \n    @Override\n    public String toString() &#123;\n        return &quot;RpcRequestMessage&#123;&quot; +\n                &quot;interfaceName&#x3D;&#39;&quot; + interfaceName + &#39;\\&#39;&#39; +\n                &quot;, methodName&#x3D;&#39;&quot; + methodName + &#39;\\&#39;&#39; +\n                &quot;, returnType&#x3D;&quot; + returnType +\n                &quot;, parameterTypes&#x3D;&quot; + Arrays.toString(parameterTypes) +\n                &quot;, parameterValue&#x3D;&quot; + Arrays.toString(parameterValue) +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n想要远程调用一个方法，必须知道以下五个信息\n\n方法所在的全限定类名\n方法名\n方法返回值类型\n方法参数类型\n方法参数值\n\nRPC响应消息\npublic class RpcResponseMessage extends Message &#123;\n    &#x2F;**\n     * 返回值\n     *&#x2F;\n    private Object returnValue;\n    &#x2F;**\n     * 异常值\n     *&#x2F;\n    private Exception exceptionValue;\n\n    @Override\n    public int getMessageType() &#123;\n        return RPC_MESSAGE_TYPE_RESPONSE;\n    &#125;\n    \n    \n    public void setReturnValue(Object returnValue) &#123;\n        this.returnValue &#x3D; returnValue;\n    &#125;\n\n    public void setExceptionValue(Exception exceptionValue) &#123;\n        this.exceptionValue &#x3D; exceptionValue;\n    &#125;\n    \n     public Object getReturnValue() &#123;\n        return returnValue;\n    &#125;\n\n    public Exception getExceptionValue() &#123;\n        return exceptionValue;\n    &#125;\n    \n    @Override\n    public String toString() &#123;\n        return &quot;RpcResponseMessage&#123;&quot; +\n                &quot;returnValue&#x3D;&quot; + returnValue +\n                &quot;, exceptionValue&#x3D;&quot; + exceptionValue +\n                &#39;&#125;&#39;;\n    &#125;\n&#125;\n\n响应消息中只需要获取返回结果和异常值\n服务器\npublic class RPCServer &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup boss &#x3D; new NioEventLoopGroup();\n        NioEventLoopGroup worker &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();\n\n        &#x2F;&#x2F; PRC 请求消息处理器\n        RpcRequestMessageHandler rpcRequestMessageHandler &#x3D; new RpcRequestMessageHandler();\n        try &#123;\n            ServerBootstrap serverBootstrap &#x3D; new ServerBootstrap();\n            serverBootstrap.channel(NioServerSocketChannel.class);\n            serverBootstrap.group(boss, worker);\n            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProtocolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(rpcRequestMessageHandler);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; serverBootstrap.bind(8080).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            boss.shutdownGracefully();\n            worker.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n服务器中添加了处理RPCRequest消息的handler\n客户端\npublic class RPCClient &#123;\n    public static void main(String[] args) &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();\n\n        &#x2F;&#x2F; PRC 请求消息处理器\n        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();\n        try &#123;\n            Bootstrap bootstrap &#x3D; new Bootstrap();\n            bootstrap.channel(NioSocketChannel.class);\n            bootstrap.group(group);\n            bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n                @Override\n                protected void initChannel(SocketChannel ch) throws Exception &#123;\n                    ch.pipeline().addLast(new ProtocolFrameDecoder());\n                    ch.pipeline().addLast(loggingHandler);\n                    ch.pipeline().addLast(messageSharableCodec);\n                    ch.pipeline().addLast(rpcResponseMessageHandler);\n                &#125;\n            &#125;);\n            Channel channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();\n            channel.closeFuture().sync();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            group.shutdownGracefully();\n        &#125;\n    &#125;\n&#125;\n\n通过接口Class获取实例对象的Factory\npublic class ServicesFactory &#123;\n    static HashMap&lt;Class&lt;?&gt;, Object&gt; map &#x3D; new HashMap&lt;&gt;(16);\n\n    public static Object getInstance(Class&lt;?&gt; interfaceClass) throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;\n        &#x2F;&#x2F; 根据Class创建实例\n        try &#123;\n            Class&lt;?&gt; clazz &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloService&quot;);\n            Object instance &#x3D; Class.forName(&quot;cn.nyimac.study.day8.server.service.HelloServiceImpl&quot;).newInstance();\n           \n            &#x2F;&#x2F; 放入 InterfaceClass -&gt; InstanceObject 的映射\n            map.put(clazz, instance);\n        &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;\n            e.printStackTrace();\n        &#125;  \n        return map.get(interfaceClass);\n    &#125;\n&#125;Copy\n\n\n\nb. RpcRequestMessageHandler@ChannelHandler.Sharable\npublic class RpcRequestMessageHandler extends SimpleChannelInboundHandler&lt;RpcRequestMessage&gt; &#123;\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcRequestMessage rpcMessage) &#123;\n        RpcResponseMessage rpcResponseMessage &#x3D; new RpcResponseMessage();\n        try &#123;\n            &#x2F;&#x2F; 设置返回值的属性\n            rpcResponseMessage.setSequenceId(rpcMessage.getSequenceId());\n            &#x2F;&#x2F; 返回一个实例\n            HelloService service &#x3D; (HelloService) ServicesFactory.getInstance(Class.forName(rpcMessage.getInterfaceName()));\n            \n            &#x2F;&#x2F; 通过反射调用方法，并获取返回值\n            Method method &#x3D; service.getClass().getMethod(rpcMessage.getMethodName(), rpcMessage.getParameterTypes());\n            &#x2F;&#x2F; 获得返回值\n            Object invoke &#x3D; method.invoke(service, rpcMessage.getParameterValue());\n            &#x2F;&#x2F; 设置返回值\n            rpcResponseMessage.setReturnValue(invoke);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            &#x2F;&#x2F; 设置异常\n            rpcResponseMessage.setExceptionValue(e);\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 向channel中写入Message\n    ctx.writeAndFlush(rpcResponseMessage);\n&#125;Copy\n\n远程调用方法主要是通过反射实现的，大致步骤如下\n\n通过请求消息传入被调入方法的各个参数\n通过全限定接口名，在map中查询到对应的类并实例化对象\n通过反射获取Method，并调用其invoke方法的返回值，并放入响应消息中\n若有异常需要捕获，并放入响应消息中\n\nc. RpcResponseMessageHandler@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n        System.out.println((String)msg.getReturnValue());\n    &#125;\n&#125;\n\n\n\nd. 客户端发送消息public class RPCClient &#123;\n    public static void main(String[] args) &#123;\n\t\t...\n           \n        &#x2F;&#x2F; 创建请求并发送\n\t\tRpcRequestMessage message &#x3D; new RpcRequestMessage(1,\n               &quot;cn.nyimac.study.day8.server.service.HelloService&quot;,\n               &quot;sayHello&quot;,\n               String.class,\n               new Class[]&#123;String.class&#125;,\n               new Object[]&#123;&quot;Nyima&quot;&#125;);\n\t\t\n        channel.writeAndFlush(message);   \n            \n        ...    \n    &#125;\n&#125;\n\n运行结果\n客户端\n1606 [nioEventLoopGroup-2-1] DEBUG cn.nyimac.study.day8.server.ChatServer  - RpcResponseMessage&#123;returnValue&#x3D;你好，Nyima, exceptionValue&#x3D;null&#125;\n\n\n\ne. 改进客户端public class RPCClientManager &#123;\n    &#x2F;**\n     * 产生SequenceId\n     *&#x2F;\n    private static AtomicInteger sequenceId &#x3D; new AtomicInteger(0);\n    private static volatile Channel channel &#x3D; null;\n    private static final Object lock &#x3D; new Object();\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F; 创建代理对象\n        HelloService service &#x3D; (HelloService) getProxy(HelloService.class);\n        &#x2F;&#x2F; 通过代理对象执行方法\n        System.out.println(service.sayHello(&quot;Nyima&quot;));\n        System.out.println(service.sayHello(&quot;Hulu&quot;));\n    &#125;\n\n    &#x2F;**\n     * 单例模式创建Channel\n     *&#x2F;\n    public static Channel getChannel() &#123;\n        if (channel &#x3D;&#x3D; null) &#123;\n            synchronized (lock) &#123;\n                if (channel &#x3D;&#x3D; null) &#123;\n                    init();\n                &#125;\n            &#125;\n        &#125;\n        return channel;\n    &#125;\n\n    &#x2F;**\n     * 使用代理模式，帮助我们创建请求消息并发送\n     *&#x2F;\n    public static Object getProxy(Class&lt;?&gt; serviceClass) &#123;\n        Class&lt;?&gt;[] classes &#x3D; new Class&lt;?&gt;[]&#123;serviceClass&#125;;\n        &#x2F;&#x2F; 使用JDK代理，创建代理对象\n        Object o &#x3D; Proxy.newProxyInstance(serviceClass.getClassLoader(), classes, new InvocationHandler() &#123;\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n                &#x2F;&#x2F; 创建请求消息\n                int id &#x3D; sequenceId.getAndIncrement();\n                RpcRequestMessage message &#x3D; new RpcRequestMessage(id, serviceClass.getName(),\n                        method.getName(), method.getReturnType(),\n                        method.getParameterTypes(),\n                        args);\n                &#x2F;&#x2F; 发送消息\n                getChannel().writeAndFlush(message);\n\n                &#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的\n                DefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());\n                &#x2F;&#x2F; 将Promise放入Map中\n                RpcResponseMessageHandler.promiseMap.put(id, promise);\n                &#x2F;&#x2F; 等待被放入Promise中结果\n                promise.await();\n                if (promise.isSuccess()) &#123;\n                    &#x2F;&#x2F; 调用方法成功，返回方法执行结果\n                    return promise.getNow();\n                &#125; else &#123;\n                    &#x2F;&#x2F; 调用方法失败，抛出异常\n                    throw new RuntimeException(promise.cause());\n                &#125;\n            &#125;\n        &#125;);\n        return o;\n    &#125;\n\n    private static void init() &#123;\n        NioEventLoopGroup group &#x3D; new NioEventLoopGroup();\n        LoggingHandler loggingHandler &#x3D; new LoggingHandler(LogLevel.DEBUG);\n        MessageSharableCodec messageSharableCodec &#x3D; new MessageSharableCodec();\n\n        &#x2F;&#x2F; PRC 请求消息处理器\n        RpcResponseMessageHandler rpcResponseMessageHandler &#x3D; new RpcResponseMessageHandler();\n\n        Bootstrap bootstrap &#x3D; new Bootstrap();\n        bootstrap.channel(NioSocketChannel.class);\n        bootstrap.group(group);\n        bootstrap.handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;\n            @Override\n            protected void initChannel(SocketChannel ch) throws Exception &#123;\n                ch.pipeline().addLast(new ProtocolFrameDecoder());\n                ch.pipeline().addLast(loggingHandler);\n                ch.pipeline().addLast(messageSharableCodec);\n                ch.pipeline().addLast(rpcResponseMessageHandler);\n            &#125;\n        &#125;);\n        try &#123;\n            channel &#x3D; bootstrap.connect(new InetSocketAddress(&quot;localhost&quot;, 8080)).sync().channel();\n            &#x2F;&#x2F; 异步关闭 group，避免Channel被阻塞\n            channel.closeFuture().addListener(future -&gt; &#123;\n                group.shutdownGracefully();\n            &#125;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n获得Channel\n\n建立连接，获取Channel的操作被封装到了init方法中，当连接断开时，通过addListener方法异步关闭group\n通过单例模式创建与获取Channel\n\n远程调用方法\n\n为了让方法的调用变得简洁明了，将RpcRequestMessage的创建与发送过程通过JDK的动态代理来完成\n通过返回的代理对象调用方法即可，方法参数为被调用方法接口的Class类\n\n远程调用方法返回值获取\n\n调用方法的是主线程，处理返回结果的是NIO线程（RpcResponseMessageHandler）。要在不同线程中进行返回值的传递，需要用到Promise\n\n在RpcResponseMessageHandler中创建一个Map\n\nKey为SequenceId\nValue为对应的Promise\n\n\n主线程的代理类将RpcResponseMessage发送给服务器后，需要创建Promise对象，并将其放入到RpcResponseMessageHandler的Map中。需要使用await等待结果被放入Promise中。获取结果后，根据结果类型（判断是否成功）来返回结果或抛出异常\n&#x2F;&#x2F; 创建Promise，用于获取NIO线程中的返回结果，获取的过程是异步的\nDefaultPromise&lt;Object&gt; promise &#x3D; new DefaultPromise&lt;&gt;(getChannel().eventLoop());\n&#x2F;&#x2F; 将Promise放入Map中\nRpcResponseMessageHandler.promiseMap.put(id, promise);\n&#x2F;&#x2F; 等待被放入Promise中结果\npromise.await();\nif (promise.isSuccess()) &#123;\n    &#x2F;&#x2F; 调用方法成功，返回方法执行结果\n    return promise.getNow();\n&#125; else &#123;\n    &#x2F;&#x2F; 调用方法失败，抛出异常\n    throw new RuntimeException(promise.cause());\n&#125;Copy\n\nNIO线程负责通过SequenceId获取并移除（remove）对应的Promise，然后根据RpcResponseMessage中的结果，向Promise中放入不同的值\n\n如果没有异常信息（ExceptionValue），就调用promise.setSuccess(returnValue)放入方法返回值\n如果有异常信息，就调用promise.setFailure(exception)放入异常信息\n\n&#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise\nPromise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());\nObject returnValue &#x3D; msg.getReturnValue();\nException exception &#x3D; msg.getExceptionValue();\nif (promise !&#x3D; null) &#123;\n    if (exception !&#x3D; null) &#123;\n        &#x2F;&#x2F; 返回结果中有异常信息\n        promise.setFailure(exception);\n    &#125; else &#123;\n        &#x2F;&#x2F; 方法正常执行，没有异常\n        promise.setSuccess(returnValue);\n    &#125;\n&#125;\n\nf. 改进 RpcResponseMessageHandler@ChannelHandler.Sharable\npublic class RpcResponseMessageHandler extends SimpleChannelInboundHandler&lt;RpcResponseMessage&gt; &#123;\n    static final Logger log &#x3D; LoggerFactory.getLogger(ChatServer.class);\n\n    &#x2F;**\n     * 用于存放Promise的集合，Promise用于主线程与NIO线程之间传递返回值\n     *&#x2F;\n    public static Map&lt;Integer, Promise&lt;Object&gt;&gt; promiseMap &#x3D; new ConcurrentHashMap&lt;&gt;(16);\n\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, RpcResponseMessage msg) throws Exception &#123;\n        &#x2F;&#x2F; 将返回结果放入对应的Promise中，并移除Map中的Promise\n        Promise&lt;Object&gt; promise &#x3D; promiseMap.remove(msg.getSequenceId());\n        Object returnValue &#x3D; msg.getReturnValue();\n        Exception exception &#x3D; msg.getExceptionValue();\n        if (promise !&#x3D; null) &#123;\n            if (exception !&#x3D; null) &#123;\n                &#x2F;&#x2F; 返回结果中有异常信息\n                promise.setFailure(exception);\n            &#125; else &#123;\n                &#x2F;&#x2F; 方法正常执行，没有异常\n                promise.setSuccess(returnValue);\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 拿到返回结果并打印\n        log.debug(&quot;&#123;&#125;&quot;, msg);\n    &#125;\n&#125;\n\n","slug":"聊天项目教程","date":"2022-04-11T13:23:45.000Z","categories_index":"项目","tags_index":"Java,Netty,Spring Boot,Maven","author_index":"张 凡"},{"id":"a5f30086118eef4097b37f892ce916b2","title":"常用命令","content":"Dockerdocker search [镜像名称]\t\t\t# 搜索镜像\ndocker pull\t[镜像名称[:版本号]] \t  # 拉取镜像\ndocker images\t\t# 查看本地镜像\ndocker exec -it [redis] bash\t\t# 以命令行形式进入容器内部\ndocker ps\t\t\t# 查看正在运行的容器\ndocker inspect [容器名]\t  \t\t # 查看容器信息,主要用来查看网络\n\n\n\n\n\nRedisKey操作\nkeys * \t    # 查看当前库的所有key\nexist key \t# 判断某个key是否存在\ndel key\t    # 删除指定key\nunlink key\t# 根据value 值进行非阻塞删除 真正的删除会在后面进行异步删除\ntype key\t# 判断key类型\nexpire key [10]\t# 为给定的 key 设置过期时间\nttl key\t\t# 查看还有多少秒过期，-1表示永不过期，-2表示已过期\nselect\t\t# 命令切换数据库\ndbsize\t\t# 查看当前数据库的 key 的数量\nflushdb \t# 清空当前库\nflushall\t# 通杀全部库\n\nString 操作\nset &lt;key&gt;&lt;value&gt;\t\t# 添加键值对\nget &lt;key&gt;\t\t\t    # 查询对应键值\nappend &lt;key&gt;&lt;value&gt;\t\t # 将给定的 &lt;value&gt; 追加到原值的末尾\nstrlen &lt;key&gt;\t\t\t# 获得值的长度\n\nList\nlpush&#x2F;rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....\t# 从左边&#x2F;右边插入一个或多个值。\nlpop&#x2F;rpop &lt;key&gt;\t\t\t\t\t# 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。\nrpoplpush &lt;key1&gt;&lt;key2&gt;\t\t\t # 从 &lt;key1&gt; 列表右边吐出一个值，插到 &lt;key2&gt; 列表左边。\nlrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;\t\t # 按照索引下标获得元素（从左到右）\nlrange mylist 0 -1 0\t\t\t # 左边第一个，-1右边第一个，（0 -1表示获取所有）\nlindex &lt;key&gt;&lt;index&gt;\t\t\t\t # 按照索引下标获得元素（从左到右）\nllen &lt;key&gt;\t\t\t\t\t\t# 获得列表长度\nlrem &lt;key&gt;&lt;n&gt;&lt;value&gt;\t\t\t # 从左边删除 n 个 value（从左到右）\nlset&lt;key&gt;&lt;index&gt;&lt;value&gt;\t\t\t # 将列表 key 下标为 index 的值替换成 value\n\nSet \nsadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... \t# 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略\nsmembers &lt;key&gt;\t\t\t\t# 取出该集合的所有值。\nsismember &lt;key&gt;&lt;value&gt;\t\t # 判断集合 &lt;key&gt; 是否为含有该 &lt;value&gt; 值，有返回 1，没有返回 0\nscard&lt;key&gt;\t\t\t\t\t# 返回该集合的元素个数。\nsrem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....\t# 删除集合中的某个元素\nsmove &lt;source&gt;&lt;destination&gt;value\t# 把集合中一个值从一个集合移动到另一个集合\nsinter &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的交集元素\nsunion &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的并集元素\n\nHash\nhset &lt;key&gt;&lt;field&gt;&lt;value&gt;\t\t# 给 &lt;key&gt; 集合中的 &lt;field&gt; 键赋值 &lt;value&gt;\nhget &lt;key1&gt;&lt;field&gt;\t\t\t    # 从 &lt;key1&gt; 集合 &lt;field&gt; 取出 value\nhmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...  # 批量设置 hash 的值\nhexists &lt;key1&gt;&lt;field&gt;\t\t\t# 查看哈希表 key 中，给定域 field 是否存在\nhkeys &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 field\nhvals &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 value\n\nZset\n","slug":"常用命令","date":"2022-04-11T13:18:09.000Z","categories_index":"常用命令","tags_index":"Linux,Redis,Docker","author_index":"张 凡"},{"id":"aad8a83fde81c29db907afa89d192a10","title":"LeetCode-剑指Offer篇","content":"剑指 Offer剑指 Offer II 4. 只出现一次的数字 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n输入：nums &#x3D; [0,1,0,1,0,1,100]\n输出：100\n\n\n解题思路：\n\n状态机 不会。\n\n位运算\n\n\nclass Solution &#123;\n    public int singleNumber(int[] nums) &#123;\n       int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; 32; i++) &#123;\n            int cnt &#x3D; 0;\n            for (int j &#x3D; 0; j &lt; nums.length; j++) &#123;\n                &#x2F;&#x2F;计算每一位和\n                cnt +&#x3D; (nums[j] &gt;&gt; i) &amp; 1;\n            &#125;\n            if (cnt % 3 !&#x3D; 0) &#123;\n                &#x2F;&#x2F;取余后只有 0 1 两种情况\n                &#x2F;&#x2F;边保存边左移。\n                ans &#x3D; ans | 1 &lt;&lt; i;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n剑指 Offer II 14. 剪绳子 II给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n输入: 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36\n2 &lt;&#x3D; n &lt;&#x3D; 1000\n\n\n解题思路:\n\n基本不等式+快速幂\n大数求余解法：大数越界： 当 a 增大时，最后返回的 $3^a$大小以指数级别增长，可能超出 int32 甚至 int64 的取值范围，导致返回值错误。大数求余问题： 在仅使用 int32 类型存储的前提下，正确计算 $x^a$ 对 p 求余（即 $x^a \\odot p$）的值。解决方案： 循环求余 、 快速幂求余 ，其中后者的时间复杂度更低，两种方法均基于以下求余运算规则推出：$(xy) \\odot p &#x3D; [(x \\odot p)(y \\odot p)] \\odot p(xy)⊙p&#x3D;[(x⊙p)(y⊙p)]⊙p$\n\n循环求余 可通过循环操作依次求 $x^1, x^2, …, x^{a-1}, x^a$  对 p 的余数，保证每轮中间值 rem 都在 int32 取值范围中。\n\n快速幂求余\n&#x2F;&#x2F; 求 (x^a) % p —— 快速幂求余\n   public long remainder(long num, int quotient, int MOD) &#123;\n       long rem &#x3D; 1;\n       while (quotient &gt; 0) &#123;\n           if ((quotient &amp; 1) &#x3D;&#x3D; 1) &#123;\n               rem *&#x3D;  num;\n               rem %&#x3D; MOD;\n           &#125;\n           num *&#x3D; num;\n           num %&#x3D; MOD;\n           quotient &gt;&gt;&#x3D; 1;\n       &#125;\n       return rem;\n   &#125;\n\n\n\nclass Solution &#123;\n    public int cuttingRope(int n) &#123;\n        final int MOD &#x3D; 1000000007;\n        int ans &#x3D; 0;\n        if (n &lt;&#x3D; 3) &#123;\n            return n-1;\n        &#125;\n        int residue &#x3D; n % 3;\n        int quotient &#x3D; n &#x2F; 3;\n        if (residue &#x3D;&#x3D; 0) &#123;\n            ans &#x3D; (int)remainder(3, quotient, MOD) % MOD;\n        &#125; else if (residue &#x3D;&#x3D; 1) &#123;\n            ans &#x3D; (int)((remainder(3, quotient - 1, MOD) * 4) % MOD);\n        &#125; else &#123;\n            ans &#x3D; (int)(remainder(3, quotient, MOD) * 2) % MOD;\n        &#125;\n        return ans;\n    &#125;\n    &#x2F;&#x2F; 求 (x^a) % p —— 快速幂求余\n    public long remainder(long num, int quotient, int MOD) &#123;\n        long rem &#x3D; 1;\n        while (quotient &gt; 0) &#123;\n            if ((quotient &amp; 1) &#x3D;&#x3D; 1) &#123;\n                rem *&#x3D;  num;\n                rem %&#x3D; MOD;\n            &#125;\n            num *&#x3D; num;\n            num %&#x3D; MOD;\n            quotient &gt;&gt;&#x3D; 1;\n        &#125;\n        return rem;\n    &#125;\n&#125;\n\n剑指 Offer II 15. 字符串中的所有变位词给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n变位词 指字母相同，但排列不同的字符串。\n输入: s &#x3D; &quot;abab&quot;, p &#x3D; &quot;ab&quot;\n输出: [0,1,2]\n解释:\n起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的变位词。\n起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的变位词。\n\n\n解题思路:\n\n滑动窗口来统计两个字符串中字符出现的次数，进行对比，当都为 0 且长度相等时就是变位词。\n\nclass Solution &#123;\n    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;\n        int N &#x3D; s.length();\n        int M &#x3D; p.length();\n        ArrayList&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        if (M &gt; N) &#123;\n            return list;\n        &#125;\n        int[] pCnt &#x3D; new int[26];\n        int[] sCnt &#x3D; new int[26];\n        for (char ch : p.toCharArray()) &#123;\n            pCnt[ch - &#39;a&#39;]++;\n        &#125;\n        int left &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            int x &#x3D; s.charAt(i) - &#39;a&#39;;\n            sCnt[x]++;\n            while (sCnt[x] &gt; pCnt[x]) &#123;\n                int l &#x3D; s.charAt(left) - &#39;a&#39;;\n                sCnt[l]--;\n                left++;\n            &#125;\n            if(i - left + 1 &#x3D;&#x3D; M)&#123;\n                list.add(left);\n            &#125;\n        &#125;\n        return list;\n    &#125;\n&#125;\n\n\n\n\n\n剑指 Offer II 30. 插入、删除和随机访问都是 O(1) 的容器设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：\ninsert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。\n示例 :\n输入: inputs &#x3D; [&quot;RandomizedSet&quot;, &quot;insert&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;, &quot;remove&quot;, &quot;insert&quot;, &quot;getRandom&quot;]\n[[], [1], [2], [2], [], [1], [2], []]\n输出: [null, true, false, true, 2, true, false, 2]\n解释:\nRandomizedSet randomSet &#x3D; new RandomizedSet();  &#x2F;&#x2F; 初始化一个空的集合\nrandomSet.insert(1); &#x2F;&#x2F; 向集合中插入 1 ， 返回 true 表示 1 被成功地插入\nrandomSet.remove(2); &#x2F;&#x2F; 返回 false，表示集合中不存在 2 \nrandomSet.insert(2); &#x2F;&#x2F; 向集合中插入 2 返回 true ，集合现在包含 [1,2] \nrandomSet.getRandom(); &#x2F;&#x2F; getRandom 应随机返回 1 或 2 \nrandomSet.remove(1); &#x2F;&#x2F; 从集合中移除 1 返回 true 。集合现在包含 [2] \nrandomSet.insert(2); &#x2F;&#x2F; 2 已在集合中，所以返回 false \nrandomSet.getRandom(); &#x2F;&#x2F; 由于 2 是集合中唯一的数字，getRandom 总是返回 2\n\n\n解题思路:\n\n本来数组是最合适的，随机按值访问采用hashMap保存&lt;值,小标&gt;下标，但是有删除操作，所以使用变长数组ArrayList。删除时用最后一个值替换，然后尾删。\n\nclass RandomizedSet &#123;\n    ArrayList&lt;Integer&gt; list;\n    HashMap&lt;Integer, Integer&gt; hashMap;\n    public RandomizedSet() &#123;\n        this.hashMap &#x3D; new HashMap&lt;&gt;();\n        this.list &#x3D; new ArrayList&lt;&gt;();\n    &#125;\n    public boolean insert(int val) &#123;\n        if (hashMap.containsKey(val)) &#123;\n            return false;\n        &#125;\n        int idx &#x3D; list.size();\n        list.add(idx, val);\n        hashMap.put(val, idx);\n        return true;\n    &#125;\n    public boolean remove(int val) &#123;\n        if (hashMap.containsKey(val)) &#123;\n            int idx &#x3D; hashMap.get(val);\n            list.set(idx, list.get(list.size() - 1));\n            hashMap.replace(list.get(list.size()-1),idx);\n            list.remove(list.size() - 1);\n            hashMap.remove(val);\n            return true;\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n    public int getRandom() &#123;\n        Random rand &#x3D; new Random();\n        int random &#x3D; rand.nextInt(hashMap.size());\n        return list.get(random);\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 37. 小行星碰撞给定一个整数数组 asteroids，表示在同一行的小行星。\n对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。\n找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。\n输入：asteroids &#x3D; [-2,-1,1,2]\n输出：[-2,-1,1,2]\n解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。\n\n输入：asteroids &#x3D; [5,10,-5]\n输出：[5,10]\n解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\n\n\n解题思路:\n\n栈。由于碰撞是单向的，所以使用栈可以很好的模拟。\n\nclass Solution &#123;\n    public int[] asteroidCollision(int[] asteroids) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; asteroids.length; i++) &#123;\n            if (stack.empty()) &#123;\n                stack.push(asteroids[i]);\n                continue;\n            &#125;\n            int top &#x3D; stack.peek();\n            if ((top ^ asteroids[i]) &gt;&#x3D; 0 || (top &lt; 0 &amp;&amp; asteroids[i] &gt; 0)) &#123;\n                stack.push(asteroids[i]);\n                continue;\n            &#125;\n            boolean collision &#x3D; false;\n            while (!stack.empty() &amp;&amp; (top &gt; 0 &amp;&amp; asteroids[i] &lt; 0)) &#123;\n                if (Math.abs(top) &gt; Math.abs(asteroids[i])) &#123;\n                    collision &#x3D; true;\n                    break;\n                &#125; else if (Math.abs(top) &lt; Math.abs(asteroids[i])) &#123;\n                    stack.pop();\n                    collision &#x3D; false;\n                    if (stack.empty()) &#123;\n                        break;\n                    &#125;\n                    top &#x3D; stack.peek();\n                    continue;\n                &#125; else &#123;\n                    collision &#x3D; true;\n                    stack.pop();\n                    break;\n                &#125;\n            &#125;\n            if (!collision) &#123;\n                stack.push(asteroids[i]);\n            &#125;\n        &#125;\n        Iterator&lt;Integer&gt; it &#x3D; stack.iterator();\n        int[] ans &#x3D; new int[stack.size()];\n        int i &#x3D; 0;\n        while (it.hasNext()) &#123;\n            ans[i++] &#x3D; it.next();\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 39. 直方图最大矩形面积给定非负整数数组 heights ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。\n求在该柱状图中，能够勾勒出来的矩形的最大面积。\n\n\n输入：heights &#x3D; [2,1,5,6,2,3]\n输出：10\n解释：最大的矩形为图中红色区域，面积为 10\n\n\n解题思路:\n\n单调栈。\n首先，要想找到第 i 位置最大面积是什么？\n是以i 为中心，向左找第一个小于 heights[i] 的位置 left_i；向右找第一个小于于 heights[i] 的位置 right_i，即最大面积为 heights[i] * (right_i - left_i -1)，如下图所示：\n所以，我们的问题就变成如何找 right_i 和 left_i ? \n最简单的思路就是，就是暴力法，直接分别在 i 左右移动。\n\n\n\n\nclass Solution &#123;\n    public int largestRectangleArea(int[] heights) &#123;\n        int ans &#x3D; 0;\n        Deque&lt;Integer&gt; stack &#x3D; new ArrayDeque&lt;&gt;();\n        int[] new_heights &#x3D; new int[heights.length + 2];\n        for (int i &#x3D; 1; i &lt; heights.length + 1; i++) new_heights[i] &#x3D; heights[i - 1];\n        for (int i &#x3D; 0; i &lt; new_heights.length; i++) &#123;\n            while (!stack.isEmpty() &amp;&amp; new_heights[stack.peek()] &gt; new_heights[i]) &#123;\n                int cur &#x3D; stack.pop();\n                ans &#x3D; Math.max(ans, (i - stack.peek()-1) * new_heights[cur]);\n            &#125;\n            stack.push(i);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n剑指 Offer II 40. 矩阵中最大的矩形给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。\n注意：此题 matrix 输入格式为一维 01 字符串数组。\n输入：matrix &#x3D; [&quot;10100&quot;,&quot;10111&quot;,&quot;11111&quot;,&quot;10010&quot;]\n输出：6\n解释：最大矩形如上图所示。\n\n\n\n\n解题思路：\n\n单调栈。\n\nclass Solution &#123;\n    public int maximalRectangle(String[] matrix) &#123;\n        int N &#x3D; matrix.length;\n        if (N &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int M &#x3D; matrix[0].length();\n        int[][] preSum &#x3D; new int[N][M + 2];\n        for (int j &#x3D; 1; j &lt;&#x3D; M; j++) &#123;\n            for (int i &#x3D; 0; i &lt; N; i++) &#123;\n                if (i &#x3D;&#x3D; 0) &#123;\n                    preSum[i][j] &#x3D; matrix[i].charAt(j - 1) - &#39;0&#39;;\n                &#125; else if (matrix[i].charAt(j - 1) !&#x3D; &#39;0&#39;) &#123;\n                    preSum[i][j] &#x3D; preSum[i - 1][j] + matrix[i].charAt(j - 1) - &#39;0&#39;;\n                &#125;\n            &#125;\n        &#125;\n        &#x2F;&#x2F;单调栈\n        Deque&lt;Integer&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        int ans &#x3D; 0;\n        for (int j &#x3D; 0; j &lt; N; j++) &#123;\n            int[] temp &#x3D; preSum[j];\n            for (int i &#x3D; 0; i &lt; M + 2; i++) &#123;\n                while (!deque.isEmpty() &amp;&amp; temp[deque.peek()] &gt; temp[i]) &#123;\n                    int cur &#x3D; deque.pop();\n                    int area &#x3D; (i - deque.peek() - 1) * (temp[cur]);\n                    ans &#x3D; area &gt; ans ? area : ans;\n                &#125;\n                deque.push(i);\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 47. 二叉树剪枝给定一个二叉树 根节点 root ，树的每个节点的值要么是 0，要么是 1。请剪除该二叉树中所有节点的值为 0 的子树。\n节点 node 的子树为 node 本身，以及所有 node 的后代。\n输入: [1,null,0,0,1]\n输出: [1,null,0,null,1] \n解释: \n只有红色节点满足条件“所有不包含 1 的子树”。\n图为返回的答案。\n\n\n\n\n解题思路:\n\n递归删除。\n\nclass Solution &#123;\n    public TreeNode pruneTree(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null &amp;&amp; root.val &#x3D;&#x3D; 0) &#123;\n            return null;\n        &#125;\n        root.left &#x3D; pruneTree(root.left);\n        root.right &#x3D; pruneTree(root.right);\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null &amp;&amp; root.val &#x3D;&#x3D; 0) &#123;\n            return null;\n        &#125;\n        return root;\n    &#125;\n&#125;\n\n剑指 Offer II 48. 序列化与反序列化二叉树序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。\n请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 &#x2F; 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n\n\n输入：root &#x3D; [1,2,3,null,null,4,5]\n输出：[1,2,3,null,null,4,5]\n\n\n解题思路:\n\n层次遍历来保存和反序列化。\n\npublic class Codec &#123;\n\n    &#x2F;&#x2F; Encodes a tree to a single string.\n    public String serialize(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return &quot;&quot;;\n        &#125;\n        Deque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;TreeNode&gt;();\n        StringBuilder ans &#x3D; new StringBuilder();\n        deque.offer(root);\n        ans.append(root.val);\n        ans.append(&#39;,&#39;);\n        while (!deque.isEmpty()) &#123;\n            TreeNode temp &#x3D; deque.poll();\n            if (temp.left &#x3D;&#x3D; null) &#123;\n                ans.append(&quot;null&quot;);\n            &#125; else &#123;\n                ans.append(temp.left.val);\n                deque.offer(temp.left);\n            &#125;\n            ans.append(&#39;,&#39;);\n            if (temp.right &#x3D;&#x3D; null) &#123;\n                ans.append(&quot;null&quot;);\n            &#125; else &#123;\n                ans.append(temp.right.val);\n                deque.offer(temp.right);\n            &#125;\n            ans.append(&#39;,&#39;);\n        &#125;\n        return ans.toString();\n    &#125;\n    &#x2F;&#x2F; Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) &#123;\n        if (data &#x3D;&#x3D; &quot;&quot;) &#123;\n            return null;\n        &#125;\n        String[] leaf &#x3D; data.split(&quot;,&quot;);\n        Deque&lt;TreeNode&gt; deque &#x3D; new ArrayDeque&lt;&gt;();\n        TreeNode root &#x3D; new TreeNode(Integer.parseInt(leaf[0]));\n        deque.offer(root);\n        int index &#x3D; 1;\n        while (!deque.isEmpty()) &#123;\n            TreeNode temp &#x3D; deque.poll();\n            if (leaf[index].equals(&quot;null&quot;) ) &#123;\n                temp.left &#x3D; null;\n            &#125; else &#123;\n                temp.left &#x3D; new TreeNode(Integer.parseInt(leaf[index]));\n                deque.offer(temp.left);\n            &#125;\n            index++;\n            if (leaf[index].equals(&quot;null&quot;)) &#123;\n                temp.right &#x3D; null;\n            &#125; else &#123;\n                temp.right &#x3D; new TreeNode(Integer.parseInt(leaf[index]));\n                deque.offer(temp.right);\n            &#125;\n            index++;\n        &#125;\n        return root;\n    &#125;\n&#125;\n\n剑指 Offer II 49. 从根节点到叶节点的路径数字之和给定一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。\n每条从根节点到叶节点的路径都代表一个数字：\n例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。计算从根节点到叶节点生成的 所有数字之和 。\n叶节点 是指没有子节点的节点。\n输入：root &#x3D; [4,9,0,5,1]\n输出：1026\n解释：\n从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495\n从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491\n从根到叶子节点路径 4-&gt;0 代表数字 40\n因此，数字总和 &#x3D; 495 + 491 + 40 &#x3D; 1026\n\n\n\n\n解题思路:\n\nDFS，到叶节点相加即可。\n\nclass Solution &#123;\n    private static int ans;\n    public int sumNumbers(TreeNode root) &#123;\n        ans &#x3D; 0;\n        DFS(root, 0);\n        return ans;\n    &#125;\n    public  void DFS(TreeNode root, int num) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;\n            ans +&#x3D; num * 10 + root.val;\n            return;\n        &#125;\n        DFS(root.left, num*10+root.val);\n        DFS(root.right, num*10+root.val);\n    &#125;\n&#125;\n\n剑指 Offer II 50. 向下的路径节点之和给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\n路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n输入：root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1], targetSum &#x3D; 8\n输出：3\n解释：和等于 8 的路径有 3 条，如图所示。\n\n\n\n\n解题思路:\n\n前缀和。\n​    统计以每个节点为「路径结尾」的合法数量的话，配合原本就是「从上往下」进行的数的遍历（最完整的路径必然是从原始根节点到当前节点的唯一路径），相当于只需要在完整路径中找到有多少个节点到当前节点的路径总和为 targetSum。\n​    于是这个树上问题彻底转换一维问题：求解从原始起点（根节点）到当前节点 b 的路径中，有多少节点 a 满足 sum[a…b]&#x3D;targetSum，由于从原始起点（根节点）到当前节点的路径唯一，因此这其实是一个「一维前缀和」问题。\n​    我们可以在进行树的遍历时，记录下从原始根节点 rootroot 到当前节点 curcur 路径中，从 rootroot 到任意中间节点 xx 的路径总和，配合哈希表，快速找到满足以 curcur 为「路径结尾」的、使得路径总和为 targetSumtargetSum 的目标「路径起点」有多少个。\n\n\nclass Solution &#123;\n    static Map&lt;Integer, Integer&gt; hashMap;\n    static int ans, tar;\n    public int pathSum(TreeNode root, int targetSum) &#123;\n        hashMap &#x3D; new HashMap&lt;&gt;();\n        ans &#x3D; 0;\n        if (root &#x3D;&#x3D; null) &#123;\n            return 0;\n        &#125;\n        tar &#x3D; targetSum;\n        hashMap.put(0, 1);\n        DFS(root, root.val);\n        return ans;\n    &#125;\n    &#x2F;&#x2F;DFS 从 root 节点出发的和为Sum的路径个数\n    public  void DFS(TreeNode root, int sum) &#123;\n        if (hashMap.containsKey(sum - tar)) &#123;\n            ans +&#x3D; hashMap.get(sum - tar);\n        &#125;\n        hashMap.put(sum, hashMap.getOrDefault(sum, 0) + 1);\n\n        if (root.left !&#x3D; null) DFS(root.left, sum + root.left.val);\n        if (root.right !&#x3D; null) DFS(root.right, sum + root.right.val);\n\n        hashMap.put(sum, hashMap.getOrDefault(sum, 0) - 1);\n    &#125;\n&#125;\n\n剑指 Offer II 53. 二叉搜索树中的中序后继给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。\n节点 p 的后继是值比 p.val 大的节点中键值最小的节点，即按中序遍历的顺序节点 p 的下一个节点。\n输入：root &#x3D; [5,3,6,2,4,null,null,1], p &#x3D; 6\n输出：null\n解释：因为给出的节点没有中序后继，所以答案就返回 null 了。\n\n\n\n\n解题思路:\n\n标记法。 二叉搜索树的中序后继的特点是：中序遍历时，当找到节点P后，下一个第一次访问的节点就是中序后继节点。\n\nclass Solution &#123;\n    static TreeNode ans;\n    static boolean isP;\n\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;\n        isP &#x3D; false;\n        ans &#x3D; null;\n        &#x2F;&#x2F;TreeNode pre &#x3D; null;\n        inOrder(root, p);\n        return ans;   \n    &#125;\n    public void inOrder(TreeNode root, TreeNode p) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        inOrder(root.left, p);\n        if (isP) &#123;\n            ans &#x3D; root;\n            isP &#x3D; false;\n        &#125;\n        if (p &#x3D;&#x3D; root) &#123;\n            isP &#x3D; true;\n        &#125;\n        inOrder(root.right, p);\n    &#125;\n&#125;\n\n剑指 Offer II 54. 所有大于等于节点的值之和给定一个二叉搜索树，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。节点的右子树仅包含键 大于 节点键的节点。左右子树也必须是二叉搜索树。\n输入：root &#x3D; [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\n\n解题思路:\n\n右-中-左遍历。\n\nclass Solution &#123;\n    static int ans;\n    public TreeNode convertBST(TreeNode root) &#123;\n        ans &#x3D; 0;\n        reverseOrder(root);\n        return root;\n    &#125;\n    public static void reverseOrder(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        reverseOrder(root.right);\n        ans +&#x3D; root.val;\n        root.val &#x3D; ans;\n\n        reverseOrder(root.left);\n    &#125;\n&#125;\n\n剑指 Offer II 55. 平衡二叉树输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n示例 1:\n给定二叉树 [3,9,20,null,null,15,7]\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回 true 。\n\n\n解题思路:\n\n自底而上递归。\n自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n\n\nclass Solution &#123;\n    static boolean ans &#x3D; true;\n    public boolean isBalanced(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        ans &#x3D; true;\n        DFS(root);\n        return ans;\n    &#125;\n    public int DFS(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return 0;\n        &#125;\n        int left &#x3D; DFS(root.left);\n        int right &#x3D; DFS(root.right);\n        if (ans &amp;&amp; Math.abs(left - right) &lt;&#x3D; 1) &#123;\n            return Math.max(left, right) + 1;\n        &#125; else &#123;\n            ans &#x3D; false;\n            return -1;\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer II 059. 数据流的第 K 大数值设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。\n请实现 KthLargest 类：\nKthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。\n输入：\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\n输出：\n[null, 4, 5, 5, 8, 8]\n\n解释：\nKthLargest kthLargest &#x3D; new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   &#x2F;&#x2F; return 4\nkthLargest.add(5);   &#x2F;&#x2F; return 5\nkthLargest.add(10);  &#x2F;&#x2F; return 5\nkthLargest.add(9);   &#x2F;&#x2F; return 8\nkthLargest.add(4);   &#x2F;&#x2F; return 8\n\n\n解题思路：\n\n大根堆。\n快排。\n\nclass KthLargest &#123;\n    PriorityQueue&lt;Integer&gt; queue;\n    int k;\n\n    public KthLargest(int k, int[] nums) &#123;\n        this.k &#x3D; k;\n        queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1 - o2);\n        int min &#x3D; k &lt; nums.length ? k : nums.length;\n        for (int i &#x3D; 0; i &lt; min; i++) &#123;\n            queue.offer(nums[i]);\n        &#125;\n\n        for (int i &#x3D; min; i &lt; nums.length; i++) &#123;\n            if (nums[i] &gt; queue.peek()) &#123;\n                queue.poll();\n                queue.offer(nums[i]);\n            &#125;\n        &#125;\n    &#125;\n\n    public int add(int val) &#123;\n        if (queue.size() &lt; k) &#123;\n            queue.offer(val);\n        &#125; else if (val &gt; queue.peek()) &#123;\n            queue.poll();\n            queue.offer(val);\n        &#125;\n        return queue.peek();\n    &#125;\n&#125;\n\n剑指 Offer II 055. 二叉搜索树迭代器实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：\nBSTIterator(TreeNode root) 初始化 BSTIterator 类的一个对象。BST 的根节点 root 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。boolean hasNext() 如果向指针右侧遍历存在数字，则返回 true ；否则返回 false 。int next()将指针向右移动，然后返回指针处的数字。注意，指针初始化为一个不存在于 BST 中的数字，所以对 next() 的首次调用将返回 BST 中的最小元素。\n可以假设 next() 调用总是有效的，也就是说，当调用 next() 时，BST 的中序遍历中至少存在一个下一个数字。\n输入\ninputs &#x3D; [&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\ninputs &#x3D; [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n输出\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\t3\n   &#x2F;  \\\n  7\t   15\n       &#x2F; \\\n      9   20\n解释\nBSTIterator bSTIterator &#x3D; new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    &#x2F;&#x2F; 返回 3\nbSTIterator.next();    &#x2F;&#x2F; 返回 7\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 9\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 15\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 True\nbSTIterator.next();    &#x2F;&#x2F; 返回 20\nbSTIterator.hasNext(); &#x2F;&#x2F; 返回 False\n\n\n解题思路:\n\n将二叉搜索树的值转换为顺序数组，然后进行操作即可。\n\nclass BSTIterator &#123;\n    static int next;\n    TreeNode root;\n    &#x2F;&#x2F; 中序遍历后有序的节点数组\n    List&lt;Integer&gt; array;\n    public BSTIterator(TreeNode root) &#123;\n        next &#x3D; 0;\n        this.root &#x3D; root;\n        array &#x3D; new ArrayList&lt;&gt;();\n        midOrder(root);\n    &#125;\n    public int next() &#123;\n        return array.get(next++);\n    &#125;\n    public boolean hasNext() &#123;\n        return next &lt; array.size();\n    &#125;\n    public void midOrder(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        midOrder(root.left);\n        array.add(root.val);\n        midOrder(root.right);\n    &#125;\n&#125;\n\n剑指 Offer II 060. 出现频率最高的 k 个数字给定一个整数数组 nums 和一个整数 k ，请返回其中出现频率前 k 高的元素。可以按 任意顺序 返回答案。\n示例 1:\n输入: nums &#x3D; [1,1,1,2,2,3], k &#x3D; 2\n输出: [1,2]\n\n\n解题思路:\n\nHashMap统计,然后PriorityQueue排序。\n\nclass Solution &#123;\n    public int[] topKFrequent(int[] nums, int k) &#123;\n        HashMap&lt;Integer, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        for (int num : nums) &#123;\n            hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n        &#125;\n        PriorityQueue&lt;Integer[]&gt; queue &#x3D; new PriorityQueue&lt;&gt;((o1, o2) -&gt; o1[1] - o2[1]);\n        int idx &#x3D; 0;\n        for (Map.Entry&lt;Integer, Integer&gt; en : hashMap.entrySet()) &#123;\n            if (idx &lt; k) &#123;\n                queue.offer(new Integer[]&#123;en.getKey(), en.getValue()&#125;);\n            &#125; else &#123;\n                if (en.getValue() &gt;&#x3D; queue.peek()[1]) &#123;\n                    queue.poll();\n                    queue.offer(new Integer[]&#123;en.getKey(), en.getValue()&#125;);\n                &#125;\n            &#125;\n            idx++;\n        &#125;\n        int[] ans &#x3D; new int[k];\n        idx &#x3D; 0;\n        Iterator&lt;Integer[]&gt; it &#x3D; queue.iterator();\n        while (it.hasNext()) &#123;\n            ans[idx++] &#x3D; it.next()[0];\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n剑指 Offer II 063. 替换单词在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。\n现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。\n需要输出替换之后的句子。\n输入：dictionary &#x3D; [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence &#x3D; &quot;the cattle was rattled by the battery&quot;\n输出：&quot;the cat was rat by the bat&quot;\n\n\n解题思路:\n\n前缀树。题目本质是找前缀。\n\nclass Solution &#123;\n    public String replaceWords(List&lt;String&gt; dictionary, String sentence) &#123;\n        trie root &#x3D; new trie();\n        Iterator&lt;String&gt; it &#x3D; dictionary.iterator();\n        while (it.hasNext()) &#123;\n            root.insert(it.next());\n        &#125;\n        String[] arr &#x3D; sentence.trim().split(&quot;\\\\s+&quot;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            ans.append(root.preSearch(arr[i])+&quot; &quot;);\n        &#125;\n        return ans.toString().trim();\n    &#125;\n    static class trie &#123;\n        trie[] child;\n        String isWord;\n        public trie() &#123;\n            child &#x3D; new trie[26];\n            isWord &#x3D; &quot;&quot;;\n        &#125;\n        public void insert(String word) &#123;\n            char[] chars &#x3D; word.toCharArray();\n            trie temp &#x3D; this;\n            for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n                char ch &#x3D; chars[i];\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    temp.child[ch - &#39;a&#39;] &#x3D; new trie();\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n            &#125;\n            temp.isWord &#x3D; word;\n        &#125;\n        public String preSearch(String word) &#123;\n            char[] chars &#x3D; word.toCharArray();\n            trie temp &#x3D; this;\n            for (int i &#x3D; 0; i &lt; chars.length; i++) &#123;\n                char ch &#x3D; chars[i];\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    return word;\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n                if (!temp.isWord.equals(&quot;&quot;)) &#123;\n                    return temp.isWord;\n                &#125;\n            &#125;\n            return word;\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer II 064. 神奇的字典设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。\n实现 MagicDictionary 类：\nMagicDictionary() 初始化对象void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。\n示例：\n输入\ninputs &#x3D; [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]\ninputs &#x3D; [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]\n输出\n[null, null, false, true, false, false]\n\n解释\nMagicDictionary magicDictionary &#x3D; new MagicDictionary();\nmagicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);\nmagicDictionary.search(&quot;hello&quot;); &#x2F;&#x2F; 返回 False\nmagicDictionary.search(&quot;hhllo&quot;); &#x2F;&#x2F; 将第二个 &#39;h&#39; 替换为 &#39;e&#39; 可以匹配 &quot;hello&quot; ，所以返回 True\nmagicDictionary.search(&quot;hell&quot;); &#x2F;&#x2F; 返回 False\nmagicDictionary.search(&quot;leetcoded&quot;); &#x2F;&#x2F; 返回 False\n\n\n解题思路:\n\n前缀树 + DFS。\n或者直接统计两个字符串不相同字符数，等于 1 就返回真。\n\nclass MagicDictionary &#123;\n    MagicDictionary[] child;\n    String word;\n    public MagicDictionary() &#123;\n        child &#x3D; new MagicDictionary[26];\n        word &#x3D; null;\n    &#125;\n    public void buildDict(String[] dictionary) &#123;\n        for (String word : dictionary) &#123;\n            MagicDictionary temp &#x3D; this;\n            for (char ch : word.toCharArray()) &#123;\n                if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                    temp.child[ch - &#39;a&#39;] &#x3D; new MagicDictionary();\n                &#125;\n                temp &#x3D; temp.child[ch - &#39;a&#39;];\n            &#125;\n            temp.word &#x3D; word;\n        &#125;\n    &#125;\n    static boolean ans;\n    public boolean search(String searchWord) &#123;\n        ans &#x3D; false;\n        char[] arr &#x3D; searchWord.toCharArray();\n        DFS(this, arr, 0, false);\n        return ans;\n    &#125;\n    public void DFS(MagicDictionary root, char[] arr, int idx, boolean change) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        if (arr.length &#x3D;&#x3D; idx) &#123;\n            if (root.word !&#x3D; null &amp;&amp; change) &#123;\n                ans &#x3D; ans || true;\n            &#125;else &#123;\n                ans &#x3D; ans || false;\n            &#125;\n            return;\n        &#125;\n        int index &#x3D; arr[idx] - &#39;a&#39;;\n        if (change &amp;&amp; root.child[index] &#x3D;&#x3D; null) &#123;\n            ans &#x3D; ans || false;\n            return;\n        &#125;\n        if (change &amp;&amp; root.child[index] !&#x3D; null) &#123;\n            DFS(root.child[index], arr, idx + 1, true);\n        &#125;\n\n        if (!change) &#123;\n            for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n                if (root.child[i] !&#x3D; null &amp;&amp; i !&#x3D; index) &#123;\n                    DFS(root.child[i], arr, idx + 1, true);\n                &#125;\n            &#125;\n            DFS(root.child[index], arr, idx + 1, false);\n        &#125;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 065. 最短的单词编码单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：\nwords.length &#x3D;&#x3D; indices.length助记字符串 s 以 ‘#’ 字符结尾对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 ‘#’ 字符结束（但不包括 ‘#’）的 子字符串 恰好与 words[i] 相等给定一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。\n输入：words &#x3D; [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]\n输出：10\n解释：一组有效编码为 s &#x3D; &quot;time#bell#&quot; 和 indices &#x3D; [0, 2, 5] 。\nwords[0] &#x3D; &quot;time&quot; ，s 开始于 indices[0] &#x3D; 0 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;\nwords[1] &#x3D; &quot;me&quot; ，s 开始于 indices[1] &#x3D; 2 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;\nwords[2] &#x3D; &quot;bell&quot; ，s 开始于 indices[2] &#x3D; 5 到下一个 &#39;#&#39; 结束的子字符串，如加粗部分所示 &quot;time#bell#&quot;\n\n\n解题思路:\n\n前缀树。 此题的本质是找后缀重合的单词。所以从后往前建立”后缀树”，然后搜索，可以优化为在建树的过程中计算。\n\nclass Solution &#123;\n    public int minimumLengthEncoding(String[] words) &#123;\n        Trie root &#x3D; new Trie();\n        for (String word : words) &#123;\n            root.insert(word);\n        &#125;\n        len  &#x3D; 0;\n        dfs(root, 0);\n        return len;\n    &#125;\n    public static int len;\n    public static void dfs(Trie root, int deep) &#123;\n        boolean flag &#x3D; false;\n        for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n            if (root.child[i] !&#x3D; null) &#123;\n                flag &#x3D; true;\n                dfs(root.child[i], deep + 1);\n            &#125;\n        &#125;\n        if (!flag) &#123;\n            len +&#x3D; deep;\n            if (root.word !&#x3D; null)&#123;\n                len +&#x3D; 1;\n            &#125;\n        &#125;\n    &#125;\n    static class Trie &#123;\n        Trie[] child;\n        String word;\n        &#x2F;&#x2F;后缀\n        public Trie() &#123;\n            child &#x3D; new Trie[26];\n            word &#x3D; null;\n        &#125;\n        public void insert(String word) &#123;\n            Trie temp &#x3D; this;\n            char[] chars &#x3D; word.toCharArray();\n            for (int i &#x3D; chars.length - 1; i &gt;&#x3D; 0; i--) &#123;\n                int idx &#x3D; chars[i] - &#39;a&#39;;\n                if (temp.child[idx] &#x3D;&#x3D; null) &#123;\n                    temp.child[idx] &#x3D; new Trie();\n                &#125;\n                temp &#x3D; temp.child[idx];\n            &#125;\n            temp.word &#x3D; word;\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer II 066. 单词之和实现一个 MapSum 类，支持两个方法，insert 和 sum：\nMapSum() 初始化 MapSum 对象void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。\n示例：\n输入：\ninputs &#x3D; [&quot;MapSum&quot;, &quot;insert&quot;, &quot;sum&quot;, &quot;insert&quot;, &quot;sum&quot;]\ninputs &#x3D; [[], [&quot;apple&quot;, 3], [&quot;ap&quot;], [&quot;app&quot;, 2], [&quot;ap&quot;]]\n输出：\n[null, null, 3, null, 5]\n解释：\nMapSum mapSum &#x3D; new MapSum();\nmapSum.insert(&quot;apple&quot;, 3);  \nmapSum.sum(&quot;ap&quot;);           &#x2F;&#x2F; return 3 (apple &#x3D; 3)\nmapSum.insert(&quot;app&quot;, 2);    \nmapSum.sum(&quot;ap&quot;);           &#x2F;&#x2F; return 5 (apple + app &#x3D; 3 + 2 &#x3D; 5)\n\n\n解题思路:\n\n前缀树。把节点存储的单词换为值即可，然后遍历。\n\nclass MapSum &#123;\n    MapSum[] child;\n    int val;\n    static int ans &#x3D; 0;\n    public MapSum() &#123;\n        val &#x3D; -1;\n        child &#x3D; new MapSum[26];\n    &#125;\n    public void insert(String key, int val) &#123;\n        MapSum temp &#x3D; this;\n        for (char ch : key.toCharArray()) &#123;\n            if (temp.child[ch - &#39;a&#39;] &#x3D;&#x3D; null) &#123;\n                temp.child[ch - &#39;a&#39;] &#x3D; new MapSum();\n            &#125;\n            temp &#x3D; temp.child[ch - &#39;a&#39;];\n        &#125;\n        temp.val &#x3D; val;\n    &#125;\n    public int sum(String prefix) &#123;\n        MapSum temp &#x3D; this;\n        for (char ch : prefix.toCharArray()) &#123;\n            int idx &#x3D; ch - &#39;a&#39;;\n            if (temp.child[idx] &#x3D;&#x3D; null) &#123;\n                return 0;\n            &#125;\n            temp &#x3D; temp.child[idx];\n        &#125;\n        ans &#x3D; 0;\n        DFS(temp);\n        return ans;\n    &#125;\n    public static void DFS(MapSum root) &#123;\n        if (root &#x3D;&#x3D; null) return;\n        if (root.val !&#x3D; -1) ans +&#x3D; root.val;\n        for (int i &#x3D; 0; i &lt; 26; i++) &#123;\n            if (root.child[i] !&#x3D; null) &#123;\n                DFS(root.child[i]);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 067. 最大的异或给定一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &lt; n 。\n示例 1：\n输入：nums &#x3D; [3,10,5,25,2,8]\n输出：28\n解释：最大运算结果是 5 XOR 25 &#x3D; 28.\n\n\n解题思路:\n\n异或。\n\n前缀树:\n搜索的方法异或值最大，我们就要尽量让每个异或位都和 num 对应的二进制位不同。\n如果 num 当前位为 0，就到 next[1] 去搜索；如果 num 当前位为 1，就到 next[0] 去搜索;如果与 num 当前位相反的那一位为空，那就只能到相同的那一位去搜索了。\n\n\nclass Solution &#123;\n    public int findMaximumXOR(int[] nums) &#123;\n        Trie trie &#x3D; new Trie();\n        int max &#x3D; -1;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            trie.build(nums[i]);\n            int val &#x3D; trie.search(nums[i]);\n            max &#x3D; max &gt; val ? max : val;\n        &#125;\n        return max;\n    &#125;\n    static class Trie &#123;\n        Trie[] child;\n\n        public Trie() &#123;\n            child &#x3D; new Trie[2];\n        &#125;\n\n        public void build(Integer num) &#123;\n            Trie temp &#x3D; this;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--) &#123;\n                int flag &#x3D; (num &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0 ? 0 : 1;\n                if (temp.child[flag] &#x3D;&#x3D; null) &#123;\n                    temp.child[flag] &#x3D; new Trie();\n                &#125;\n                temp &#x3D; temp.child[flag];\n            &#125;\n        &#125;\n\n        public int search(Integer val) &#123;\n            Trie temp &#x3D; this;\n            int ans &#x3D; 0;\n            for (int i &#x3D; 30; i &gt;&#x3D; 0; i--) &#123;\n                int flag &#x3D; (val &amp; (1 &lt;&lt; i)) &#x3D;&#x3D; 0 ? 0 : 1;\n                if (flag &#x3D;&#x3D; 1) &#123;\n                    if (temp.child[0] !&#x3D; null) &#123;\n                        temp &#x3D; temp.child[0];\n                        ans &#x3D; ans | (1 &lt;&lt; i);\n                    &#125; else &#123;\n                        temp &#x3D; temp.child[1];\n                    &#125;\n                &#125; else &#123;\n                    if (temp.child[1] !&#x3D; null) &#123;\n                        temp &#x3D; temp.child[1];\n                        ans &#x3D; ans | (1 &lt;&lt; i);\n                    &#125; else &#123;\n                        temp &#x3D; temp.child[0];\n                    &#125;\n                &#125;\n            &#125;\n            return ans;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n剑指 Offer II 070. 排序数组中只出现一次的数字给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。\n输入: nums &#x3D; [1,1,2,3,3,4,4,8,8]\n输出: 2\n\n\n解题思路：\n\n二分查找，区分 区间长度的奇偶 来进行二分。\n\npublic static int singleNonDuplicate(int[] nums) &#123;\n        int l &#x3D; 0;\n        int r &#x3D; nums.length - 1;\n        while (l &lt; r) &#123;\n            int mid &#x3D; (l + r) &gt;&gt; 1;\n            if ((mid &#x3D;&#x3D; 0 &amp;&amp; nums[mid] !&#x3D; nums[mid + 1]) || (mid &#x3D;&#x3D; nums.length - 1 &amp;&amp; nums[mid] !&#x3D; nums[mid - 1])) &#123;\n                return nums[mid];\n            &#125;\n            if (nums[mid] !&#x3D; nums[mid - 1] &amp;&amp; nums[mid] !&#x3D; nums[mid + 1]) &#123;\n                return nums[mid];\n            &#125;\n            if (mid - 1 &gt;&#x3D; 0 &amp;&amp; nums[mid] &#x3D;&#x3D; nums[mid - 1]) &#123;\n                if ((mid - l) % 2 &#x3D;&#x3D; 0) &#123;\n                    r &#x3D; mid - 2;\n                &#125; else &#123;\n                    l &#x3D; mid + 1;\n                &#125;\n            &#125;\n            if (mid + 1 &lt; nums.length &amp;&amp; nums[mid] &#x3D;&#x3D; nums[mid + 1]) &#123;\n                if ((r - mid) % 2 &#x3D;&#x3D; 0) &#123;\n                    l &#x3D; mid + 2;\n                &#125; else &#123;\n                    r &#x3D; mid - 1;\n                &#125;\n            &#125;\n        &#125;\n        return nums[l];\n    &#125;\n\n剑指 Offer II 071. 按权重生成随机数给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。\n例如，对于 w &#x3D; [1, 3]，挑选下标 0 的概率为 1 &#x2F; (1 + 3) &#x3D; 0.25 （即，25%），而选取下标 1 的概率为 3 &#x2F; (1 + 3) &#x3D; 0.75（即，75%）。\n也就是说，选取下标 i 的概率为 w[i] &#x2F; sum(w) 。\n输入：\ninputs &#x3D; [&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\ninputs &#x3D; [[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution &#x3D; new Solution([1, 3]);\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1，返回下标 1，返回该下标概率为 3&#x2F;4 。\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 1\nsolution.pickIndex(); &#x2F;&#x2F; 返回 0，返回下标 0，返回该下标概率为 1&#x2F;4 。\n\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\n诸若此类。\n\n\n解题思路:\n\n前缀和 + 二分查找。\n把权重和total求出来，在1~total上求随机数，然后和每个权重的区间(通过前缀和求)进行映射，求得下标随机数。\n w   3   1   4   2  total = 10 (0-3] 代表下标0  (3-4]代表1 (4-8] 代表2 ...\npre  3   4   8   10 代表具体随机的值。\n i   [1   2   3]   [4]   [5   6   7   8]   [9   10]\n\n\n\nclass Solution &#123;\n        int[] preSum;\n        int total;\n        &#x2F;&#x2F;  w   3   1   4   2\n        &#x2F;&#x2F; pre  3   4   (8   10] 代表具体随机的值。\n        &#x2F;&#x2F;  i   [1   2   3]   [4]   [5   6   7   8]   [9   10]\n        public Solution(int[] w) &#123;\n            preSum &#x3D; new int[w.length];\n            total &#x3D; Arrays.stream(w).sum();\n            for (int i &#x3D; 0; i &lt; w.length; i++) &#123;\n                preSum[i] &#x3D; i &#x3D;&#x3D; 0 ? w[0] : w[i] + preSum[i - 1];\n            &#125;\n\n        &#125;\n        public int pickIndex() &#123;\n            int seed &#x3D; (int) (Math.random() * total) + 1;\n            int idx &#x3D; Arrays.binarySearch(preSum, seed);\n            if (idx &lt; 0) &#123;\n                idx &#x3D; -idx -1;\n            &#125;\n            return idx;\n        &#125;\n    &#125;\n\n\n\n剑指 Offer II 073. 狒狒吃香蕉狒狒喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。\n狒狒可以决定她吃香蕉的速度 K （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉，下一个小时才会开始吃另一堆的香蕉。  \n狒狒喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。\n返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。\n输入: piles &#x3D; [3,6,7,11], H &#x3D; 8\n输出: 4\n\n\n解题思路:\n\n二分查找最小速度。\n\n&#96;&#96;&#96;java以此可以缩短判断时间。time +&#x3D; (pile-1)&#x2F;K + 1;&#x2F;&#x2F;time +&#x3D; pile % K &#x3D;&#x3D; 0 ? pile &#x2F; K : pile &#x2F; K + 1;\n  - 最大值范围确定可以直接赋值，省去了搜索最大值过程。\n\n&#96;&#96;&#96;java\nclass Solution &#123;\n    public int minEatingSpeed(int[] piles, int h) &#123;\n        int left &#x3D;1,right &#x3D; 1000000000;\n        while(left&lt;right)&#123;\n            int mid &#x3D; left + (right - left)&#x2F;2;\n            if(isFinished(piles,h,mid))&#123;\n                right &#x3D; mid;\n            &#125;else&#123;\n                left &#x3D; mid + 1;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n    private boolean isFinished(int[] piles,int h,int speed)&#123;\n        int time &#x3D; 0;\n        for(int pile:piles)&#123;\n            time +&#x3D; (pile-1)&#x2F;speed + 1;\n        &#125;\n        return time&lt;&#x3D;h;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 074. 合并区间以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。\n示例 1：\n输入：intervals &#x3D; [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n\n\n解题思路:\n\n按开始时间排序。\n可以合并的肯定是连续的。\n\n\nclass Solution &#123;\n    public int[][] merge(int[][] intervals) &#123;\n        if (intervals.length &#x3D;&#x3D; 0) &#123;\n            return new int[0][2];\n        &#125;\n        Arrays.sort(intervals,(o1, o2) -&gt; o1[0]-o2[0]);\n        List&lt;int[]&gt; merged &#x3D; new ArrayList&lt;int[]&gt;();\n        for (int i &#x3D; 0; i &lt; intervals.length; ++i) &#123;\n            int L &#x3D; intervals[i][0], R &#x3D; intervals[i][1];\n            if (merged.size() &#x3D;&#x3D; 0 || merged.get(merged.size() - 1)[1] &lt; L) &#123;\n                merged.add(new int[]&#123;L, R&#125;);\n            &#125; else &#123;\n                merged.get(merged.size() - 1)[1] &#x3D; Math.max(merged.get(merged.size() - 1)[1], R);\n            &#125;\n        &#125;\n        return merged.toArray(new int[merged.size()][]);\n    &#125;\n&#125;\n\n剑指 Offer II 079. 所有子集给定一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n\n解题思路:\n\n两种回溯方法。\n第一种，递归实现。 每个元素的两种情况往下遍历。\n第二种，for循环实现。每个元素及其后面的元素一起遍历。\n\n\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), nums, 0);\n        return ans;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums,\n                                 int idx) &#123;\n        if (idx &gt;&#x3D; nums.length) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(nums[idx]);\n        traceback(ans, list, nums, idx + 1);\n        list.remove(list.size() - 1);\n        traceback(ans, list, nums, idx + 1);\n    &#125;\n    public  void traceback2(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums,\n                                 int idx) &#123;\n        ans.add(new ArrayList&lt;&gt;(list));\n        for (int i &#x3D; idx; i &lt; nums.length; i++) &#123;\n            list.add(nums[i]);\n            traceback(ans, list, nums, i + 1);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer II 080. 含有 k 个元素的组合给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。\n输入: n &#x3D; 4, k &#x3D; 2\n输出:\n[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]\n\n\n解题思路：\n\n回溯方法。\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), 1, n, k);\n        return ans;\n    &#125;\n    public void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int idx, int n,\n                                 int k) &#123;\n        if (n - idx + 1 &lt; k)return;\n        if (k &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt;&#x3D; n; i++) &#123;\n            list.add(i);\n            traceback(ans, list, i + 1, n, k - 1);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n    public void traceback2(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int idx, int n,\n                                  int k) &#123;\n        if (n - idx + 1 &lt; k)return;\n        if (k &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(idx);\n        traceback(ans, list, idx + 1, n, k - 1);\n        list.remove(list.size() - 1);\n        traceback(ans, list, idx + 1, n, k );\n    &#125;\n&#125;\n\n剑指 Offer II 081. 允许重复选择元素的组合给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。\ncandidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 \n对于给定的输入，保证和为 target 的唯一组合数少于 150 个。\n输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7\n输出: [[7],[2,2,3]]\n\n\n解题思路:\n\n回溯法\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), candidates, 0, target);\n        return ans;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] candidates,\n                                 int idx, int target) &#123;\n        if (target &lt; 0 || idx &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        if (target &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt; candidates.length; i++) &#123;\n            list.add(candidates[i]);\n            traceback(ans, list, candidates, i, target - candidates[i]);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n    public  void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] candidates,\n                                 int idx, int target) &#123;\n        if (target &lt; 0 || idx &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        if (target &#x3D;&#x3D; 0) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        list.add(candidates[idx]);\n        &#x2F;&#x2F; 加上当前这个数\n        traceback(ans, list, candidates, idx, target - candidates[idx]);\n        list.remove(list.size() - 1);\n        if (idx + 1 &gt;&#x3D; candidates.length) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; 不加当前这个数\n        traceback(ans, list, candidates, idx + 1, target);\n    &#125;\n&#125;\n\n\n\n\n\n剑指 Offer II 082. 含有重复元素集合的组合给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。 \n输入: candidates &#x3D; [10,1,2,7,6,1,5], target &#x3D; 8,\n输出: [[1,1,6],[1,2,5],[1,7],[2,6]]\n\n\n解题思路:\n\n回溯法。去重用排序的方法。遇到相同的数就不再进行访问，但是要拿当前的这个数。\n\nclass Solution &#123;\n    static HashSet&lt;List&lt;Integer&gt;&gt; ans;\n    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        &#x2F;&#x2F; 为了避免重复答案\n        Arrays.sort(candidates);\n        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        traceback(candidates, ans, list, 0, 0, target);\n        return ans;\n    &#125;\n    public  void traceback(int[] candidates, List&lt;List&lt;Integer&gt;&gt; ans,\n                                 List&lt;Integer&gt; list, int idx, int sum,\n                                 int target) &#123;\n        if (sum &#x3D;&#x3D; target) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; idx; i &lt; candidates.length; i++) &#123;\n            if (sum + candidates[i] &gt; target) &#123;\n                break;\n            &#125;\n            if (i &gt; idx &amp;&amp; candidates[i] &#x3D;&#x3D; candidates[i-1])&#123;\n                &#x2F;&#x2F; 因为前面那个同样的数已经经历过dfs，再拿同样的数dfs就会得到重复的答案\n                continue;\n            &#125;\n            list.add(candidates[i]);\n            traceback(candidates, ans, list, i+1, sum + candidates[i], target);\n            list.remove(list.size() - 1);\n        &#125;\n    &#125;\n&#125;\n\n\n\n剑指 Offer II 083. 没有重复元素集合的全排列给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。\n输入：nums &#x3D; [1,2,3]\n输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n解题思路:\n\n回溯。\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        traceback(ans, new ArrayList&lt;&gt;(), nums);\n        return ans;\n    &#125;\n    public void traceback(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, int[] nums) &#123;\n        if (list.size() &#x3D;&#x3D; nums.length) &#123;\n            ans.add(new ArrayList&lt;&gt;(list));\n            return;\n        &#125;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            if (nums[i]&#x3D;&#x3D; -100)continue;\n            int temp &#x3D; nums[i];\n            nums[i] &#x3D; -100;\n            list.add(temp);\n            traceback(ans, list, nums);\n            list.remove(list.size() - 1);\n            nums[i] &#x3D; temp;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n剑指 Offer II 116. 省份数量有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。\n省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。\n给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。\n返回矩阵中 省份 的数量。\n\n\n输入：isConnected &#x3D; [[1,1,0],[1,1,0],[0,0,1]]\n输出：2\n\n\n解题思路:\n\nDFS\n\nBFS\n\n并查集。\n每找到两个联通的节点，将其祖先统一。 即就是 isConnected[i][j] &#x3D; 1 时，Union(i,j)\n\n\nclass Solution &#123;\n    public int findCircleNum(int[][] isConnected) &#123;\n        int N &#x3D; isConnected.length;\n        int[] original &#x3D; new int[N];\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            original[i] &#x3D; i;\n        &#125;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            for (int j &#x3D; 0; j &lt; i; j++) &#123;\n                if (isConnected[i][j] &#x3D;&#x3D; 1) &#123;\n                    &#x2F;&#x2F; 连接节点 i j\n                    int left &#x3D; i;\n                    int right &#x3D; j;\n                    &#x2F;&#x2F; 找左节点的 祖先\n                    while (original[left] !&#x3D; left) left &#x3D; original[left];\n                    &#x2F;&#x2F; 找右节点的 祖先\n                    while (original[right] !&#x3D; right) right &#x3D; original[right];\n                    &#x2F;&#x2F; 找到后将其中一个的祖先赋给另外一个, 这样就可以统一祖先了\n                    original[left] &#x3D; right;\n                &#125;\n            &#125;\n        &#125;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; N; i++) &#123;\n            if (original[i] &#x3D;&#x3D; i) &#123;\n                ans++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n\n剑指 Offer II 090. 环形房屋偷盗一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n输入：nums &#x3D; [1,2,3,1]\n输出：4\n解释：你可以先偷窃 1 号房屋（金额 &#x3D; 1），然后偷窃 3 号房屋（金额 &#x3D; 3）。\n     偷窃到的最高金额 &#x3D; 1 + 3 &#x3D; 4 。\n\n\n解题思路:\n\n动态规划 + 分类讨论。\n前后相接，只需要讨论第一个位置是否被抢，进行两次动态规划即可。\n抢 1 , 则不抢最后一个。不抢 1 , 则考虑抢最后一个。\n\n\nclass Solution &#123;\n    public int rob(int[] nums) &#123;\n        int n &#x3D; nums.length;\n        if (n &#x3D;&#x3D; 1) return nums[0];\n        if (n &#x3D;&#x3D; 2) return Math.max(nums[0], nums[1]);\n        int[] dp &#x3D; new int[n];\n        &#x2F;&#x2F; rob 0\n        dp[0] &#x3D; nums[0];\n        dp[1] &#x3D; Math.max(nums[0], nums[1]);\n        for (int j &#x3D; 2; j &lt; n - 1; j++) &#123;\n            dp[j] &#x3D; Math.max(nums[j] + dp[j - 2], dp[j - 1]);\n        &#125;\n        int ans &#x3D; dp[n - 2];\n        &#x2F;&#x2F; rob 1\n        dp[0] &#x3D; 0;\n        dp[1] &#x3D; nums[1];\n        for (int j &#x3D; 2; j &lt; n; j++) &#123;\n            dp[j] &#x3D; Math.max(nums[j] + dp[j - 2], dp[j - 1]);\n        &#125;\n        return Math.max(ans, dp[n - 1]);\n    &#125;\n&#125;\n\n剑指 Offer II 092. 翻转字符如果一个由 ‘0’ 和 ‘1’ 组成的字符串，是以一些 ‘0’（可能没有 ‘0’）后面跟着一些 ‘1’（也可能没有 ‘1’）的形式组成的，那么该字符串是 单调递增 的。\n我们给出一个由字符 ‘0’ 和 ‘1’ 组成的字符串 s，我们可以将任何 ‘0’ 翻转为 ‘1’ 或者将 ‘1’ 翻转为 ‘0’。\n返回使 s 单调递增 的最小翻转次数。\n输入：s &#x3D; &quot;010110&quot;\n输出：2\n解释：我们翻转得到 011111，或者是 000111。\n\n\n解题思路：\n\n动态规划。答案字符串左侧肯定都是 0 ，右侧都是 1 。所以枚举每一个分割点，统计一次左侧 1 出现的次数，右侧 0 出现的次数，加在一起便是需要反转的字符个数。\n\nclass Solution &#123;\n    public int minFlipsMonoIncr(String s) &#123;\n        int n &#x3D; s.length();\n        int[] pre &#x3D; new int[n];\n        int[] dp &#x3D; new int[n];\n        int num &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            num +&#x3D; s.charAt(i) - &#39;0&#39;;\n            pre[i] &#x3D; num;\n        &#125;\n        dp[0] &#x3D; n - pre[n - 1];\n        dp[n - 1] &#x3D; pre[n - 1];\n        int min &#x3D; Math.min(dp[0], dp[n - 1]);\n        for (int i &#x3D; 1; i &lt; n - 1; i++) &#123;\n            dp[i] &#x3D; pre[i - 1] + (n - 1 - i - pre[n - 1] + pre[i]);\n            min &#x3D; Math.min(min, dp[i]);\n        &#125;\n        return min;\n    &#125;\n&#125;\n\n剑指 Offer II 093. 最长斐波那契数列如果序列 X_1, X_2, …, X_n 满足下列条件，就说它是 斐波那契式 的：\n\nn &gt;&#x3D; 3\n对于所有 i + 2 &lt;&#x3D; n，都有 $X_i + X_{i+1} &#x3D; X_{i+2}$给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。\n\n（回想一下，子序列是从原序列  arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）\n输入: arr &#x3D; [1,3,7,11,12,14,18]\n输出: 3\n解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n\n\n解题思路:\n\n动态规划。\n&#x2F;*\n    *      1   2   3   4   5   6   7   8\n    *   1  1   2   2   2   2   2   2   2\n    *   2      1   3   2   2   2   2   2\n    *   3          1   3   4   2   2   2\n    *   4              1   3   3   4   2\n    *   5                  1   3   3   5\n    *   6                      1   3   3\n    *   7                          1   3\n    *   8                              1\n*&#x2F;\ndp[i][j]：表示以A[i],A[j]结尾的斐波那契数列的最大长度\n             dp[i][j]&#x3D;Len(......,A[i],A[j])\n             A[k]+A[i]&#x3D;&#x3D;A[j]\n dp[i][j] &#x3D; max (dp[k][i]+1) 其中 A[k]+A[i]&#x3D;&#x3D;A[j]\n\nclass Solution &#123;\n    public int lenLongestFibSubseq(int[] arr) &#123;\n        int n &#x3D; arr.length;\n        if (n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;\n            return 0;\n        &#125;\n        int[][] dp &#x3D; new int[n][n];\n        HashMap&lt;Integer, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;\n            hashMap.put(arr[i], i);\n        &#125;\n\n        for (int i &#x3D; 0; i &lt; n; i++) &#123;\n            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n                dp[i][j] &#x3D; 2;\n            &#125;\n        &#125;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            for (int j &#x3D; i + 1; j &lt; n; j++) &#123;\n                &#x2F;&#x2F; i 开始 j 结束 A[j] - A[i] &#x3D; A[k]\n                if (hashMap.containsKey(arr[j] - arr[i])) &#123;\n                    int idx &#x3D; hashMap.get(arr[j] - arr[i]);\n                    dp[i][j] &#x3D; Math.max(dp[i][j], dp[idx][i]+1);\n                    ans &#x3D; Math.max(dp[i][j], ans);\n                &#125;\n            &#125;\n        &#125;\n        return ans &gt;&#x3D; 3 ? ans : 0;\n    &#125;\n&#125;\n\n剑指 Offer II 095. 最长公共子序列给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。\n一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。\n输入：text1 &#x3D; &quot;abcde&quot;, text2 &#x3D; &quot;ace&quot; \n输出：3  \n解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。\n\n\n解题思路:\n\n动态规划。\n\n其中 dp[i][j] 表示 text1 [0:i]和 text2 [0:j] 的最长公共子序列的长度。\n       a   b   c   d   e\n   ij  0   0   0   0   0\na   0  1   1   1   1   1\nc   0  1   1   2   2   2\ne   0  1   1   2   2   3\n\nclass Solution &#123;\n    public int longestCommonSubsequence(String text1, String text2) &#123;\n        int m &#x3D; text1.length(), n &#x3D; text2.length();\n        int[][] dp &#x3D; new int[m + 1][n + 1];\n        for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;\n            char c1 &#x3D; text1.charAt(i - 1);\n            for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;\n                char c2 &#x3D; text2.charAt(j - 1);\n                if (c1 &#x3D;&#x3D; c2) &#123;\n                    dp[i][j] &#x3D; dp[i - 1][j - 1] + 1;\n                &#125; else &#123;\n                    dp[i][j] &#x3D; Math.max(dp[i - 1][j], dp[i][j - 1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];\n    &#125;\n&#125;\n\n剑指 Offer II 100. 三角形中最小路径之和给定一个三角形 triangle ，找出自顶向下的最小路径和。\n每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。\n输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]\n输出：11\n解释：如下面简图所示：\n   2\n  3 4\n 6 5 7\n4 1 8 3\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。\n\n\n解题思路:\n\n动态规划。\n\nclass Solution &#123;\n    public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;\n        int n &#x3D; triangle.size();\n        if (n &#x3D;&#x3D; 1) &#123;\n            return triangle.get(0).get(0);\n        &#125;\n        int[] preDp &#x3D; new int[n];\n        int[] dp &#x3D; new int[n];\n        preDp[0] &#x3D; triangle.get(0).get(0);\n        for (int i &#x3D; 1; i &lt; n; i++) &#123;\n            dp[0] &#x3D; preDp[0] + triangle.get(i).get(0);\n            dp[i] &#x3D; preDp[i - 1] + triangle.get(i).get(i);\n            for (int j &#x3D; 1; j &lt; i; j++) &#123;\n                dp[j] &#x3D; Math.min(preDp[j], preDp[j - 1]) + triangle.get(i).get(j);\n            &#125;\n            preDp &#x3D; Arrays.copyOf(dp, i+1);\n        &#125;\n        int min &#x3D; Integer.MAX_VALUE;\n        for (int i : dp) &#123;\n            if (i &lt; min) &#123;\n                min &#x3D; i;\n            &#125;\n        &#125;\n        return min;\n    &#125;\n&#125;\n\n剑指 Offer II 101. 分割等和子集给定一个非空的正整数数组 nums ，请判断能否将这些数字分成元素和相等的两部分。\n输入：nums &#x3D; [1,5,11,5]\n输出：true\n解释：nums 可以分割成 [1, 5, 5] 和 [11] 。\n\n\n解题思路:\n\nNP完全问题。动态规划转为0-1背包问题。\n能否从数组中选出若个数字，使它们的和等于 target &#x3D; sum &#x2F; 2，那么所有数字之和 sum 必须为偶数，若 sum 不为偶数则等和子集肯定不存在。有 n 个数字，每一步都判断该数字是否加入等和子集，最终需要判断组合的解的个数是否大于 0\n\n\nclass Solution &#123;\n    public boolean canPartition(int[] nums) &#123;\n        int sum &#x3D; Arrays.stream(nums).sum();\n        if (sum % 2 &#x3D;&#x3D; 1) &#123;\n            return false;\n        &#125;\n        sum &#x2F;&#x3D; 2;\n        boolean[][] dp &#x3D; new boolean[nums.length][sum + 1];\n        for (int i &#x3D; 0; i &lt;&#x3D; sum; i++) &#123;\n            dp[0][i] &#x3D; i &#x3D;&#x3D; nums[0] ? true : false;\n        &#125;\n        if (dp[0][sum]) &#123;\n            return true;\n        &#125;\n        for (int i &#x3D; 1; i &lt; nums.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt;&#x3D; sum; j++) &#123;\n                dp[i][j] &#x3D;\n                        dp[i - 1][j] || (j - nums[i] &gt; 0 &amp;&amp; dp[i - 1][j - nums[i]]) || j &#x3D;&#x3D; nums[i];\n            &#125;\n            if (dp[i][sum]) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n剑指 Offer II 102. 加减的目标值给定一个正整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 ‘+’ 或 ‘-‘ ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums &#x3D; [2, 1] ，可以在 2 之前添加 ‘+’ ，在 1 之前添加 ‘-‘ ，然后串联起来得到表达式 “+2-1” 。返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n输入：nums &#x3D; [1,1,1,1,1], target &#x3D; 3\n输出：5\n解释：一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 &#x3D; 3\n+1 - 1 + 1 + 1 + 1 &#x3D; 3\n+1 + 1 - 1 + 1 + 1 &#x3D; 3\n+1 + 1 + 1 - 1 + 1 &#x3D; 3\n+1 + 1 + 1 + 1 - 1 &#x3D; 3\n\n\n解题思路:\n\n动态规划。\n目标和target可以表达为:  \n负数(-neg) + 正数(pos) &#x3D; target\n-neg + (sum-neg) &#x3D; target\nsum - target &#x3D; 2*neg\n\n所以只需要找到用 num[i] 组合成neg即可，转换为背包问题。\n\n\nclass Solution &#123;\n    public int findTargetSumWays(int[] nums, int target) &#123;\n        int sum &#x3D; Arrays.stream(nums).sum();\n        target &#x3D; sum - target;\n        if (target &lt; 0 || target % 2 !&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        target &#x2F;&#x3D; 2;\n        int[] dp &#x3D; new int[target + 1];\n        dp[0] &#x3D; 1;\n        for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n            for (int j &#x3D; target; j &gt;&#x3D; 0; j--) &#123;\n                if (j - nums[i] &gt;&#x3D; 0)\n                    dp[j] &#x3D; dp[j - nums[i]] + dp[j];\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;\n\n\n\n\n\n剑指 Offer II 103. 最少的硬币数目给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n你可以认为每种硬币的数量是无限的。\n输入：coins &#x3D; [1, 2, 5], amount &#x3D; 11\n输出：3 \n解释：11 &#x3D; 5 + 5 + 1\n\n\n解题思路:\n\n动态规划。\ndp[j]表示价格为 j 时的最小硬币数，枚举价格。\ndp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);\namount  0   1   2   3   4   5   6   7   8   9   10  11\n    1   0   1   2   3   4   5   6   7   8   9   10  11\n    2   0   1   1   2   2   3   3   4   4   5   5   6\n    3   0   1   1   1   2   2   2   3   3   3   4   4\n\nclass Solution &#123;\n    public int coinChange(int[] coins, int amount) &#123;\n        if (amount &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int[] dp &#x3D; new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; coins.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt;&#x3D; amount; j++) &#123;\n                if (j - coins[i] &gt;&#x3D; 0) &#123;\n                    dp[j] &#x3D; Math.min(dp[j], dp[j - coins[i]] + 1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[amount] &gt; amount ? -1 : dp[amount];\n    &#125;\n&#125;\n\n剑指 Offer II 105. 岛屿的最大面积给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。\n一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。\n找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。\n输入: grid &#x3D; [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\n输出: 6\n解释: 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。\n\n\n解题思路:\n\nDFS。求得是最大岛屿面积，每次DFS要算出岛屿面积。\n\nclass Solution &#123;\n    public int maxAreaOfIsland(int[][] grid) &#123;\n        int ans &#x3D; 0;\n        for (int i &#x3D; 0; i &lt; grid.length; i++) &#123;\n            for (int j &#x3D; 0; j &lt; grid[0].length; j++) &#123;\n                if (grid[i][j] &#x3D;&#x3D; 1) &#123;\n                    ans &#x3D; Math.max(ans, DFS(grid, i, j));\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n    public int DFS(int[][] grid, int i, int j) &#123;\n        if (i &gt;&#x3D; grid.length || j &gt;&#x3D; grid[0].length || i &lt; 0 || j &lt; 0) &#123;\n            return 0;\n        &#125;\n        grid[i][j] &#x3D; 0;\n        int num &#x3D; 1;\n        if (i + 1 &lt; grid.length &amp;&amp; grid[i + 1][j] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i + 1, j);\n        if (i - 1 &gt;&#x3D; 0 &amp;&amp; grid[i - 1][j] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i - 1, j);\n        if (j + 1 &lt; grid[0].length &amp;&amp; grid[i][j + 1] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i, j + 1);\n        if (j - 1 &gt;&#x3D; 0 &amp;&amp; grid[i][j - 1] &#x3D;&#x3D; 1) num +&#x3D; DFS(grid, i, j - 1);\n        return num;\n    &#125;\n&#125;\n\n剑指 Offer II 106. 二分图存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。\n给定一个二维数组 graph ，表示图，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：\n不存在自环（graph[u] 不包含 u）。不存在平行边（graph[u] 不包含重复值）。如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。\n如果图是二分图，返回 true ；否则，返回 false 。\n\n\n输入：graph &#x3D; [[1,3],[0,2],[1,3],[0,2]]\n输出：true\n解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。\n\n\n解题思路:\n\n染色法+DFS。相邻的染上不同颜色，如果要染得颜色不一致，返回false。\n\nclass Solution &#123;\n    public  boolean ans;\n    public boolean isBipartite(int[][] graph) &#123;\n        ans &#x3D; true;\n        int[] color &#x3D; new int[graph.length];\n        for (int i &#x3D; 0; i &lt; graph.length &amp;&amp; ans; i++) &#123;\n            if (color[i] &#x3D;&#x3D; 0) DFS(graph, color, i, 1);\n        &#125;\n        return ans;\n    &#125;\n    &#x2F;&#x2F; 第i个节点为初始节点.\n    public  void DFS(int[][] graph, int[] color, int i, int rORg) &#123;\n        if (color[i] !&#x3D; 0) &#123;&#x2F;&#x2F; 节点已经染过色\n            &#x2F;&#x2F; 和需要染得颜色不一样\n            if (color[i] !&#x3D; rORg) ans &#x3D; false;\n            return;\n        &#125;\n        color[i] &#x3D; rORg;\n        for (int i1 : graph[i]) &#123;\n            &#x2F;&#x2F; 给与 i 相邻的节点都染上相反的颜色\n            DFS(graph, color, i1, -rORg);\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer 06. 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n输入：head &#x3D; [1,3,2]\n输出：[2,3,1]\n\n\n解题思路：\n用栈进行逆序。\nclass Solution &#123;\n    public int[] reversePrint(ListNode head) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        while (head !&#x3D; null) &#123;\n            stack.push(head.val);\n            head &#x3D; head.next;\n        &#125;\n        int size &#x3D; stack.size();\n        int[] array &#x3D; new int[size];\n        for(int i &#x3D; 0; i &lt; size; i++) &#123;\n            array[i] &#x3D; stack.pop();\n        &#125;\n        return array;\n    &#125;\n&#125;\n\n\n\n剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n输入：[“CQueue”,”deleteHead”,”appendTail”,”appendTail”,”deleteHead”,”deleteHead”][[],[],[5],[2],[],[]]输出：[null,-1,null,null,5,2]\n\n解题思路:\n双栈实现队列，当一个序列经过一个栈会变成倒序，经过两个栈会重新变为顺序。维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。\n\n加入队尾 appendTail()函数： 将数字 val 加入栈 A 即可。\n删除队首 deleteHead()函数： 有以下三种情况。\n当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。\n否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1−1 。\n否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。\n\n\n\nclass CQueue &#123;\n    private Stack&lt;Integer&gt; stackA;\n    private Stack&lt;Integer&gt; stackB;\n    public CQueue() &#123;\n        stackA &#x3D; new Stack&lt;Integer&gt;();\n        stackB &#x3D; new Stack&lt;Integer&gt;();\n    &#125;\n\n    public void appendTail(int value) &#123;\n        stackA.push(value);\n    &#125;\n\n    public int deleteHead() &#123;\n        if (stackB.isEmpty()) &#123;\n            if (stackA.isEmpty()) &#123;\n                return -1;\n            &#125; else &#123;\n                while (!stackA.empty()) &#123;\n                    stackB.push(stackA.pop());\n                &#125;\n            &#125;\n        &#125;\n        return stackB.pop();\n    &#125;\n&#125;\n\n&#x2F;**\n * Your CQueue object will be instantiated and called as such:\n * CQueue obj &#x3D; new CQueue();\n * obj.appendTail(value);\n * int param_2 &#x3D; obj.deleteHead();\n *&#x2F;\n\n剑指 Offer 14- I. 剪绳子给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。请问 k[0]k[1]…*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n示例 1：\n输入: 2\n输出: 1\n解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1\n    \n示例 2:\n输入: 10\n输出: 36\n解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36\n\n\n解题思路:\n\n数学推理。\n设将长度为 n 的绳子切为 a 段：$n &#x3D; n_1 + n_2 + … + n_a$ 本题等价于求解：$\\max(n_1 \\times n_2 \\times … \\times n_a)$\n以下公式为“算术几何均值不等式” ，等号当且仅当 $n_1 &#x3D; n_2 &#x3D; … &#x3D; n_a $时成立。$\\frac{n_1 + n_2 + … + n_a}{a} \\geq \\sqrt[a]{n_1 n_2 … n_a}$\n推论一： 将绳子 以相等的长度等分为多段 ，得到的乘积最大。\n即就是求下式的最值，求导后得最值点为 x &#x3D; e，取最近的整数点3。$$x^a&#x3D;x^{\\frac {x}{n}}&#x3D;(x^{\\frac {1}{x}})^n$$\n推论二： 尽可能将绳子以长度 33 等分为多段时，乘积最大。\n当 n≤3 时，按照规则应不切分，但由于题目要求必须剪成 m&gt;1 段，因此必须剪出一段长度为 1 的绳子，即返回 n - 1 。当 n&gt;3 时，求 n 除以 3 的 整数部分 a 和 余数部分 b （即 n &#x3D; 3a + b），并分为以下三种情况：当 b &#x3D; 0 时，直接返回 $3^a $\n当 b &#x3D; 1 时，要将一个 1 + 3 转换为 2+2，因此返回 $3^{a-1} \\times 4$\n当 b &#x3D; 2 时，返回 $3^a \\times 2$\n\n动态规划。\n\n\nclass Solution &#123;\n    public int cuttingRope(int n) &#123;\n        if (n &lt;&#x3D; 3) &#123;\n            return n - 1;\n        &#125;\n        int residue &#x3D; n % 3;\n        int quotient &#x3D; n &#x2F; 3;\n        if (residue &#x3D;&#x3D; 0) &#123;\n            return (int) (Math.pow(3,quotient));\n        &#125; else if (residue &#x3D;&#x3D; 1) &#123;\n            return (int) (Math.pow(3,quotient-1))*4;\n        &#125; else &#123;\n            return (int) (Math.pow(3,quotient)) *2 ;\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n剑指 Offer 24. 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例:\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n\n解题思路：\n头插法反转链表。\nclass Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode ans &#x3D; new ListNode();\n\n        ListNode temp &#x3D; head;\n        while (head !&#x3D; null) &#123;\n            temp &#x3D; head;\n            head &#x3D; head.next;\n\n            temp.next &#x3D; ans.next;\n            ans.next &#x3D; temp;\n\n        &#125;\n        return ans.next;\n    &#125;\n&#125;\n\n剑指 Offer 26. 树的子结构输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如:\n给定的树 A:  \n  3\n / \\\n4   5\n   / \\\n  1   2\n给定的树 B：\n   4 \n  /\n 1\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n\n解题思路：\n​    若树 B 是树 A 的子结构，则子结构的根节点可能为树 A 的任意一个节点。因此，判断树 B 是否是树 A 的子结构，需完成以下两步工作：\n\n先序遍历树 A 中的每个节点 $n_A$ 对应函数 isSubStructure(A, B)\n判断树 A 中 以 $n_A$为根节点的子树 是否包含树 B 。（对应函数 recur(A, B)）\n\nclass Solution &#123;\n    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;\n        if (A &#x3D;&#x3D; null || B &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n\n        return recur(A, B) || (isSubStructure(A.left, B) || isSubStructure(A.right, B));\n    &#125;\n    public  boolean recur(TreeNode A, TreeNode B) &#123;\n        if (B &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125; else if (A &#x3D;&#x3D; null) &#123;\n            return false;\n        &#125;\n\n        if (A.val !&#x3D; B.val) &#123;\n            return false;\n        &#125; else &#123;\n            return recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);\n        &#125;\n    &#125;\n&#125;\n\n剑指 Offer 28. 对称的二叉树请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n    1\n   / \\\n  2   2\n   \\   \\\n   3    3\n\n\n解题思路：\n递归判断。\n\n判断两节点 L.left 和 R.right 是否对称；\n判断两节点 L.right 和 R.left 是否对称；\n\nclass Solution &#123;\n    public boolean isSymmetric(TreeNode root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        return judge(root.left, root.right);\n    &#125;\n    public boolean judge(TreeNode left, TreeNode right) &#123;\n        if (left &#x3D;&#x3D; null &amp;&amp; right &#x3D;&#x3D; null) &#123;\n            return true;\n        &#125;\n        if (left !&#x3D; null &amp;&amp; right !&#x3D; null &amp;&amp; left.val &#x3D;&#x3D; right.val) &#123;\n            return judge(left.left, right.right) &amp;&amp; judge(left.right, right.left);\n        &#125; else &#123;\n            return false;\n        &#125;\n    &#125;\n&#125;\n\n\n\n剑指 Offer 30. 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。\nMinStack minStack &#x3D; new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.min();   --&gt; 返回 -2.\n\n\n解题思路：\n双栈实现最小栈。\n​    两个栈stack，minStack维持相同的大小，minStack的栈顶元素是当前对应的stack栈中的最小值。\n​    在栈插入时，stack正常插入，minStack插入时，将插入元素与栈顶元素相比，如果栈顶元素更小，则插入栈顶元素，如果插入元素小，就插入需要插入的元素。这样维持着最小栈，当弹出最小值时只需要将minStack中的栈顶元素弹出。\nclass MinStack &#123;\n    &#x2F;&#x2F;双栈实现最小栈\n    Stack&lt;Integer&gt; stack;\n    Stack&lt;Integer&gt; minStack;\n    public MinStack() &#123;\n        stack &#x3D; new Stack&lt;&gt;();\n        minStack &#x3D; new Stack&lt;&gt;();\n    &#125;\n    public void push(int x) &#123;\n        stack.push(x);\n        if (minStack.empty()) &#123;\n            minStack.push(x);\n            return;\n        &#125;\n        minStack.push(x &gt; minStack.peek() ? minStack.peek() : x);\n    &#125;\n    public void pop() &#123;\n        stack.pop();\n        minStack.pop();\n    &#125;\n    public int top() &#123;\n        return stack.peek();\n    &#125;\n    public int min() &#123;\n        return minStack.peek();\n    &#125;\n&#125;\n\n剑指 Offer 31. 栈的压入、弹出序列入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]\n输出：true\n解释：我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -&gt; 4,\npush(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n\n输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]\n输出：false\n解释：1 不能在 2 之前弹出。\n\n\n解题思路：\n\n模拟。创建一个栈，用出栈顺序和进栈顺序可以模拟是否可以为一个弹出序列。\n\nclass Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        if (pushed.length &#x3D;&#x3D; 0) &#123;\n            return true;\n        &#125;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        int pushIndex &#x3D; 0;\n        int popIndex &#x3D; 0;\n        while (pushIndex &lt; pushed.length &amp;&amp; popIndex &lt; popped.length) &#123;\n            if (stack.empty()) &#123;\n                stack.push(pushed[pushIndex++]);\n            &#125;\n            while (pushIndex &lt; pushed.length &amp;&amp; stack.peek() !&#x3D; popped[popIndex]) &#123;\n                stack.push(pushed[pushIndex++]);\n            &#125;\n            while (popIndex &lt; popped.length &amp;&amp; !stack.empty() &amp;&amp; stack.peek() &#x3D;&#x3D; popped[popIndex]) &#123;\n                popIndex++;\n                stack.pop();\n            &#125;\n            if (stack.empty() &amp;&amp; popIndex &#x3D;&#x3D; popped.length) &#123;\n                return true;\n            &#125;\n            if (pushIndex &#x3D;&#x3D; pushed.length &amp;&amp; !stack.empty()) &#123;\n                return false;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\nclass Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();\n        int i &#x3D; 0;\n        for(int num : pushed) &#123;\n            stack.push(num); &#x2F;&#x2F; num 入栈\n            while(!stack.isEmpty() &amp;&amp; stack.peek() &#x3D;&#x3D; popped[i]) &#123; &#x2F;&#x2F; 循环判断与出栈\n                stack.pop();\n                i++;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n\n\n\n\n\n\n剑指 Offer 34. 二叉树中和为某一值的路径输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n示例:\n给定如下二叉树，以及目标和 target &#x3D; 22，\n              5\n             &#x2F; \\\n            4   8\n           &#x2F;   &#x2F; \\\n          11  13  4\n         &#x2F;  \\    &#x2F; \\\n        7    2  5   1\n返回:\n[\n   [5,4,11,2],\n   [5,8,4,5]\n]\n\n\n解题思路:\n\nDFS\nBFS\n\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int target) &#123;\n        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; ans &#x3D; new ArrayList&lt;&gt;();\n        DFS(root, list, target, 0, ans);\n        return ans;\n    &#125;\n    public  void DFS(TreeNode root, List&lt;Integer&gt; list, int tar, int sum, List&lt;List&lt;Integer&gt;&gt; ans) &#123;\n        if (root &#x3D;&#x3D; null ) &#123;\n            return;\n        &#125;\n        &#x2F;&#x2F; if (root.val + sum &#x3D;&#x3D; tar &amp;&amp; (root.left !&#x3D; null || root.right !&#x3D; null)) &#123;\n        &#x2F;&#x2F;     return;\n        &#x2F;&#x2F; &#125;\n        if (root.val + sum &#x3D;&#x3D; tar &amp;&amp; root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;\n            list.add(root.val);\n            List&lt;Integer&gt; temp &#x3D; new ArrayList&lt;Integer&gt;();\n            Iterator&lt;Integer&gt; it &#x3D; list.iterator();\n            while (it.hasNext()) &#123;\n                temp.add(it.next());\n            &#125;\n            ans.add(temp);\n            list.remove(list.size() - 1);\n            return;\n        &#125;\n        list.add(root.val);\n        DFS(root.left, list, tar, sum + root.val, ans);\n        DFS(root.right, list, tar, sum + root.val, ans);\n        list.remove(list.size() - 1);\n\n    &#125;\n&#125;\n\n\n\n\n\n剑指 Offer 35. 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n\n\n输入：head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\n解题思路：\n​    使用Hash表保存新旧节点的映射关系，然后待新链表创建完成后再进行随机节点的复制。\nclass Solution &#123;\n    public Node copyRandomList(Node head) &#123;\n        Node ans &#x3D; new Node(0);\n        Node tail &#x3D; ans;\n        Node tempHead &#x3D; head;\n        HashMap&lt;Node, Node&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        while (tempHead !&#x3D; null) &#123;\n            Node temp &#x3D; new Node(tempHead.val);\n            temp.next &#x3D; tail.next;\n            tail.next &#x3D; temp;\n            hashMap.put(tempHead, temp);\n            tail &#x3D; tail.next;\n            tempHead &#x3D; tempHead.next;\n        &#125;\n\n        tempHead &#x3D; head;\n        tail &#x3D; ans.next;\n        while (tempHead !&#x3D; null) &#123;\n            if (tempHead.random !&#x3D; null) &#123;\n                tail.random &#x3D; hashMap.get(tempHead.random);\n            &#125;\n            &#x2F;&#x2F;System.out.println(tempHead+&quot;--&quot;+tempHead.random);\n            tempHead &#x3D; tempHead.next;\n            tail &#x3D; tail.next;\n        &#125;\n        return ans.next;\n\n    &#125;\n&#125;\n\n\n\n剑指 Offer 36. 二叉搜索树与双向链表输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n\n\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n\n解题思路:\n\n中序遍历，中序遍历排序二叉树，所得的结果序列递增。所以选择中序遍历，在遍历过程中修改指针。\n\nclass Solution &#123;\n    static Node pre, head;\n    public Node treeToDoublyList(Node root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return null;\n        &#125;\n        pre&#x3D; null;\n        head &#x3D; null;\n        midOrder(root);\n        head.left &#x3D; pre;\n        pre.right &#x3D; head;\n        return head;\n    &#125;\n    public void midOrder(Node root) &#123;\n        if (root &#x3D;&#x3D; null) &#123;\n            return;\n        &#125;\n        midOrder(root.left);\n&#x2F;&#x2F;      1. 修改前一个节点的后 为当前节点\n&#x2F;&#x2F;      2. 修改当前节点的前 为前一个节点\n&#x2F;&#x2F;      3. 更新当前节点为前一个节点\n        if (pre !&#x3D; null) &#123;\n            pre.right &#x3D; root;\n        &#125; else &#123;\n            head &#x3D; root;\n        &#125;\n        root.left &#x3D; pre;\n\n        pre &#x3D; root;\n        midOrder(root.right);\n\n    &#125;\n&#125;\n\n\n\n剑指 Offer 45. 把数组排成最小的数输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n输入: [3,30,34,5,9]\n输出: &quot;3033459&quot;\n\n\n解题思路:\n\n重写排序。\n设数组 nums 中任意两数字的字符串为 x 和 y ，则规定 排序判断规则 为：\n若拼接字符串 x + y &gt; y + x ，则 x “大于” y ；反之，若 x + y &lt; y + x，则 x “小于” y ；x “小于” y 代表：排序完成后，数组中 x 应在 y 左边；“大于” 则反之。\n根据以上规则，套用任何排序方法对 numsnums 执行排序即可。\n\n\nclass Solution &#123;\n    public String minNumber(int[] nums) &#123;\n        String[] number &#x3D; new String[nums.length];\n        for (int i &#x3D; 0; i &lt; number.length; i++) &#123;\n            number[i] &#x3D; String.valueOf(nums[i]);\n        &#125;\n        Arrays.sort(number, new Comparator&lt;String&gt;() &#123;\n            @Override\n            public int compare(String o1, String o2) &#123;\n                String s1 &#x3D; o1 + o2;\n                String s2 &#x3D; o2 + o1;\n                return s1.compareTo(s2);\n            &#125;\n        &#125;);\n        StringBuilder ans &#x3D; new StringBuilder();\n        for (String s : number) &#123;\n            ans.append(s);\n        &#125;\n        return ans.toString();\n    &#125;\n&#125;\n\n\n\n剑指 Offer 46. 把数字翻译成字符串给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n示例 1:\n输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot;\n\n\n解题思路：\n\n动态规划。$$dp[i] &#x3D; \\begin{cases}dp[i-1]+dp[i-2],&amp; 10\\le x_i x_{i-1} \\le25 \\dp[i-1],&amp;else \\\\end{cases}$$\n\nclass Solution &#123;\n    public int translateNum(int num) &#123;\n        String str &#x3D; String.valueOf(num);\n        int n &#x3D; str.length();\n        if (n &#x3D;&#x3D; 1) &#123;\n            return 1;\n        &#125;\n        if (n &#x3D;&#x3D; 2) &#123;\n            if (num &lt;&#x3D; 25) &#123;\n                return 2;\n            &#125;\n            return 1;\n        &#125;\n        int[] dp &#x3D; new int[str.length()];\n        dp[0] &#x3D; 1;\n        int temp &#x3D; Integer.parseInt(str.substring(0, 2));\n        dp[1] &#x3D; temp &lt;&#x3D; 25  &amp;&amp; temp &gt;&#x3D; 10? 2 : 1;\n        for (int i &#x3D; 2; i &lt; n; i++) &#123;\n            temp &#x3D; Integer.parseInt(str.substring(i - 1, i + 1));\n            if (temp &gt;&#x3D; 10 &amp;&amp; temp &lt;&#x3D; 25) &#123;\n                dp[i] &#x3D; dp[i - 1] + dp[i - 2];\n            &#125; else &#123;\n                dp[i] &#x3D; dp[i - 1];\n            &#125;\n        &#125;\n        return dp[n - 1];\n    &#125;\n&#125;\n\n\n\n剑指 Offer 41. 数据流中的中位数如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n例如，\n[2,3,4] 的中位数是 3\n[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5\n设计一个支持以下两种操作的数据结构：\nvoid addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。\n示例 1：\n输入：\n[&quot;MedianFinder&quot;,&quot;addNum&quot;,&quot;addNum&quot;,&quot;findMedian&quot;,&quot;addNum&quot;,&quot;findMedian&quot;]\n[[],[1],[2],[],[3],[]]\n输出：[null,null,null,1.50000,null,2.00000]\n\n\n解题思路:\n\n大顶堆 + 小顶堆。\n建立一个 小顶堆 AA 和 大顶堆 BB ，各保存列表的一半元素，且规定：\n\nA 保存 较大 的一半，长度为 $\\frac{N}{2}$ （N 为偶数）或 $\\frac{N+1}{2}$ （N为奇数）;\n\nBB 保存 较小 的一半，长度为 $\\frac{N}{2}$ （N 为偶数）或 $\\frac{N-1}{2} $（NN 为奇数）；\n随后，中位数可仅根据 A,B 的堆顶元素计算得到。\n\n\n\n\nclass MedianFinder &#123;\n    &#x2F;** initialize your data structure here. *&#x2F;\n    private PriorityQueue&lt;Integer&gt; smallHeap;\n        private PriorityQueue&lt;Integer&gt; bigHeap;\n    public MedianFinder() &#123;\n        smallHeap &#x3D; new PriorityQueue&lt;&gt;();\n            bigHeap &#x3D; new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123;\n                @Override\n                public int compare(Integer o1, Integer o2) &#123;\n                    return o2 - o1;\n                &#125;\n            &#125;);\n    &#125;\n    public void addNum(int num) &#123;\n        if (bigHeap.isEmpty() || num &lt;&#x3D; bigHeap.peek()) &#123;\n                bigHeap.offer(num);\n            &#125; else &#123;\n                smallHeap.offer(num);\n            &#125;\n            int N1 &#x3D; bigHeap.size();\n            int N2 &#x3D; smallHeap.size();\n            if (N1 - N2 &gt; 1) &#123;\n                smallHeap.offer(bigHeap.poll());\n            &#125;\n            if (N1 - N2 &lt;&#x3D; -1) &#123;\n                bigHeap.offer(smallHeap.poll());\n            &#125;\n    &#125;\n    public double findMedian() &#123;\n        int N1 &#x3D; bigHeap.size();\n            int N2 &#x3D; smallHeap.size();\n            if (N1 &#x3D;&#x3D; N2) &#123;\n                return ((double) smallHeap.peek() + bigHeap.peek()) &#x2F; 2;\n            &#125;\n            return bigHeap.peek();\n    &#125;\n&#125;\n&#x2F;**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj &#x3D; new MedianFinder();\n * obj.addNum(num);\n * double param_2 &#x3D; obj.findMedian();\n *&#x2F;\n\n\n\n剑指 Offer 48. 最长不含重复字符的子字符串请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n示例 1:\n输入: &quot;abcabcbb&quot;\n输出: 3 \n解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。\n\n\n解题思路：\n\n双指针+哈希表。\n哈希表存储字符最后一次出现的索引，遍历字符串，双指针统计最长不含重复字符的子串。\n右指针依次遍历每个字符。\n当右指针指向的元素在前面出现过时，更新左指针。$$left &#x3D; Math.max(hashMap.get(ch) + 1, left);$$\n\n\nclass Solution &#123;\n    public int lengthOfLongestSubstring(String s) &#123;\n         HashMap&lt;Character, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n        if (s.length() &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int max &#x3D; 1;\n        int left &#x3D; 0;\n        int right &#x3D; 0;\n        while (right &lt; s.length()) &#123;\n            char ch &#x3D; s.charAt(right);\n            if (hashMap.containsKey(ch)) &#123;\n                left &#x3D; Math.max(hashMap.get(ch) + 1, left);\n                hashMap.replace(ch, right);\n            &#125; else &#123;\n                hashMap.put(ch, right);\n            &#125;\n            max &#x3D; max &gt; right - left + 1 ? max : right - left + 1;\n            right++;\n        &#125;\n        return max;\n    &#125;\n&#125;\n\n剑指 Offer 49. 丑数我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n示例:\n输入: n &#x3D; 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n\n\n解题思路:\n\n动态规划。 和选择素数一样，只需要从1开始，选择所有丑数的2 、 3 、5 倍数，自然就是丑数，当需要顺序找到第几个时，需要用三个指针来判断顺序。\n\nclass Solution &#123;\n    public int nthUglyNumber(int n) &#123;\n        if (n &#x3D;&#x3D; 1) &#123;\n            return 1;\n        &#125;\n\n        int[] flag &#x3D; new int[n + 1];\n        flag[1] &#x3D; 1;\n        int p2 &#x3D; 1;\n        int p3 &#x3D; 1;\n        int p5 &#x3D; 1;\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            int num2 &#x3D; flag[p2] * 2;\n            int num3 &#x3D; flag[p3] * 3;\n            int num5 &#x3D; flag[p5] * 5;\n            int min &#x3D; Math.min(num2, Math.min(num3, num5));\n            flag[i] &#x3D; min;\n            if (min &#x3D;&#x3D; num2) &#123;\n                p2++;\n            &#125;\n            if (min &#x3D;&#x3D; num3) &#123;\n                p3++;\n            &#125;\n            if (min &#x3D;&#x3D; num5) &#123;\n                p5++;\n            &#125;\n        &#125;\n        return flag[n];\n    &#125;\n&#125;\n\n\n\n\n\n剑指 Offer 60. n个骰子的点数把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。\n 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n\n\n解题思路:\n\n暴力。超时\n\n动态规划。\n\n\n\n\n\n\n以此类推，前一次掷的骰子概率×1&#x2F;6，然后求和就好。\n\n\nclass Solution &#123;\n    public double[] dicesProbability(int n) &#123;\n        double[] dp &#x3D; new double[6];\n        Arrays.fill(dp, 1.0 &#x2F; 6);\n        for (int i &#x3D; 2; i &lt;&#x3D; n; i++) &#123;\n            double[] ans &#x3D; new double[i * 5 + 1];\n            for (int j &#x3D; 0; j &lt; dp.length; j++) &#123;\n                for (int k &#x3D; 0; k &lt; 6; k++) &#123;\n                    ans[j + k] +&#x3D; dp[j] &#x2F; 6.0;\n                &#125;\n            &#125;\n            dp &#x3D; ans;\n        &#125;\n        return dp;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n剑指 Offer 64. 求1+2+…+n求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n示例 1：\n输入: n &#x3D; 3\n输出: 6\n\n\n解题思路:\n\n递归。\n不使用循环时，递归是一个很好的办法，但是要求不使用if语句，所以难点是处理递归出口，解决办法是利用&amp;&amp;的短路运算性质。\n\n\nclass Solution &#123;\n    public int sumNums(int n) &#123;\n        boolean flag &#x3D; n &gt; 0 &amp;&amp; (n +&#x3D; sumNums(n - 1)) &gt; 0;\n        return n;\n    &#125;\n&#125;\n\n\n\n\n\n","slug":"LeetCode-剑指Offer篇","date":"2022-04-08T08:41:11.000Z","categories_index":"算法","tags_index":"Java,刷题,数据结构,算法","author_index":"张 凡"},{"id":"cd32aca21f1fb5eccdd0b0a556926460","title":"东野圭吾选摘","content":"东野圭吾摘选东野圭吾\n\n\n\n虚无的十字架“我看男人太没眼光了，只是因为憧憬结婚，没想到一步错，步步错。”\n任何事只从单方面观察，都无法把握真相。\n到底有谁可以断言，“这个杀人凶手只要在监狱关多少多少年，就可以改邪归正”，把杀人凶手绑在这种虚无的十字架上，到底有什么意义？\n事到如今，她终于为自己感到悲哀。花惠蹲了下来，双手捂住了脸，她从来没有像现在这样强烈地觉得，活下去是这么痛苦的一件事。\n东野圭吾严选TOP10合集一阵难以言说的孤独感突然向他袭来，他觉得自己被丢弃在看不到尽头的黑暗隧道里。一直陪伴着他的直子也不见了身影，只有她的声音还在。她已经去了另一个世界，这个世界里只有自己。他心中不禁升起一股怒火，自己成了那些不合理之事的牺牲品。我的人生在哪里？难道要一直这样吗？\n隔阂深处的不是愤怒，而是悲伤。\n不是得天独厚的人来跳舞，而是会跳的人才得天独厚\n当时自己是不是忘了更重要的事\n你根本就不了解什么是妻子。她们不同意离婚并不仅仅是为了维持安定的生活，而是无法忍受只有老公找到幸福。为了阻止这种情况发生，即使痛苦度日也可以忍受。\n作为刑警，我觉得女性的心理最难琢磨。\n有人会因案件而留下心灵创伤，他们也是受害者。刑警的职责就是寻找能够拯救受害者的线索。”\n所谓的孩子，终究只是这样的生物。他们误以为自己是凭一己之力长大的，很快便会忘记父母曾给予的保护。\n即便被孩子恨，父母也要将孩子引导到正确的方向，只有父母能这么做。\n我们普通人在决定胜负的紧要关头需要精神支柱，但比赛时孤身一人，无从依靠，拿什么做支柱呢？只有拿事实，就是自己曾付出努力这个事实，相信自己平时舍弃娱乐时间拼命训练，一定会有好结果。\n破坏中必有信息。这一点适用于所有案件\n圣女的救济一个女人，不管看上去再怎么弱不禁风，一旦与婚外情搭上关系，就会变得相当棘手。\n人的价值观是多种多样的。如果因地位烦恼还说得过去，但这对夫妇看起来幸福美满，还能举办家庭派对，至少表面上看来确实如此，而且也不需要为金钱奔波，因此她能够专心地做自己喜欢的拼布。我觉得她不是一个会因一时冲动而让这种生活泡汤的傻瓜，或许她打算等待丈夫和学生之间的婚外情自然消亡，这样一来相当于她没有失去任何东西。\n“对真柴太太心存怀疑的人，是无法抛弃瓶装水里有毒这种想法的，因为他们觉得除此之外没有其他办法，可如果凶手当时用的本来就是‘其他办法’，那么他们这些执着于瓶装水的人就永远都无法查明真相了。这不是陷阱是什么？所以我在想，如果真柴先生当时用的并不是瓶装水——”话说到一半，汤川突然顿住了，只见他吃惊地睁大了眼睛望着草薙身后。草薙转头一看，也如汤川一般呆住了。绫音此刻就站在起居室门口。\n“证明没有答案也是很重要的。”\n“在这一年里，绫音女士随时都可以毒杀真柴先生，但她反而始终在小心留意，不让他误饮毒药。一般的凶手都是千方百计设法杀人，这一次的凶手却正好相反，她为了不杀人而倾注了全部精力。从没出现过这样的凶手，古往今来，国内国外，都还没有。理论上可行，现实中却又不可能发生，所以我说这是个虚数解。”\n对她而言，所谓婚姻生活，就是守护站在绞刑架下的丈夫的日日夜夜。\n绑架游戏一星期有一万零八十分钟，努力个三十分钟，可以换来剩下约一万分钟的舒适，反过来说，要是舍不得那三十分钟的努力，那就一定要过那剩下不舒服的一万分钟了。”\n在决胜负时有没有直觉和决断力，就可以分辨出会成功的人和不会成功的人。\n这就是所谓的优秀人才！在不知不觉当中，不断地给自己补给，这种感觉不是教了就会的事情。”\n祈祷落幕时怎么看她都像是雾里看花，让人觉得是个有故事的人，有所保留又让人觉得有机可乘的感觉也是恰到好处。\n加贺以前就这样，不管什么事情，如果没有正当理由，他一定不会心安。\n在同她的对峙中，博美发现自己其实已完全继承了她的那份丑陋，不禁浑身发抖。她很艰难地遏制了当场冲上去勒死母亲的冲动。\n“而女儿越成长，越成功，对浅居忠雄来说就越是对自己命运的诅咒。自己的存在如果曝光，女儿就会身败名裂。换句话说，他本身就是潘多拉的魔盒。”\n波本威士忌倒入玻璃杯，冰块伴随着一阵声响在杯中坍塌。\n如今反省时，博美才发现自己曾经犯过很多小错误。加贺则将那些一个一个地收集起来，最终搭建起一座真实之城。真是个了不起的人，她打心眼里佩服。\n博美绝望地看着父亲。他的眼睛里闪着执着的光，却没有丝毫疯狂。那是看透一切下定决心的人才有的目光。\n“恭一郎今后会成为一个更优秀的人。如果留着这张照片，他在我心里的成长便停止了。那个孩子一定不希望这样。”\n如果把他的心比作水面，登纪子觉得那里应该总是如同镜子般平静，无论怎样的狂风肆虐都不会轻易掀起波澜。正因为有如此顽强的内心，他才能经受住如此多的试炼。\n湖畔难道你认为一个十一二岁的孩子会考虑到未来而自己说要就读私立中学吗？哪个小孩不讨厌读书呢？要是让他们自己做主，他们肯定会选轻松的路走。因此，父母更应该认真思考孩子的将来，他们该受怎样的教育，并做出决定。因为除了父母以外，其他人是不会帮他做决定的。\n坂崎的嘴微微地张着，黑眼珠往右上角移动。藤间站在他的背后，看着这一切。\n为了考试所读的书只能用来考试而已，这可是常识呀。\n不论是守护父母之爱的单纯原因，还是在升学主义的压力下，孩子恶意的反扑，换来的代价都是父母亲必须为孩子背上一辈子的罪。\n东野圭吾：盛夏方程式这个世界上不存在浪费的研究\n“你可以不喜欢理科，但要记住，总说什么‘不知道也没办法’这种话，早晚会犯大错的。”\n她不想让仙波这样牺牲，内心却又期待着他的好意。\n我不清楚的是，这里面有多少明确的杀意。就算把烟囱堵上，计划也不一定能成功。最好能成功——那个人大概抱着这样的想法。但杀意就是杀意。\n任何问题都一定有答案，”汤川的目光透过镜片，直视着恭平，“但不一定能马上推导出来。人生也是如此。现在无法立即回答的问题，将来你可能还会遇到很多。每一次烦恼都有价值，没必要焦虑。很多时候，为了找到答案，必须首先让自己成长，所以人类要学习、努力，不断磨炼自己。”\n红手指然而，感情的裂缝并非那么容易弥补。\n建立起温暖家庭的人，死时也会得到家人的关怀。而没能建立起像样家庭的人，死时偏偏渴望亲情，你不觉得他这样很自私吗？\n“其实你都明白，我只说一点。刑警并不是只破案就够了。什么时候破案、怎么破案才是最重要的。”\n长年相伴的夫妻之间的感情是旁人无法理解的，所以才能忍受照顾病人的辛苦。也许想过逃避，也许想过希望对方早点死，但真的到了那种时候，肯定不会松一口气。一旦从照顾病人中解脱出来，又会陷入强烈的自责。”\n虽然得了老年痴呆症，政惠现在还珍藏着和儿子的回忆。记忆中含辛茹苦养育儿子的经历，是治疗她的良药。\n对不起，非常……对不起。”他在榻榻米上磕着头，“是假话，全部都是假话。都是我编的，我妈不是凶手。”\n必须记住的是，越是老年人，或者说正因为是老年人，内心常常会有不可平复的伤痕。治疗的方法有许多，周围的人不能理解。所以我觉得，重要的不是理解，而是尊重。\n","slug":"东野圭吾选摘","date":"2022-04-08T08:06:49.000Z","categories_index":"文摘","tags_index":"东野圭吾","author_index":"张 凡"},{"id":"bb40d4f810e5d595a5fa95fdce59f1d5","title":"雪中悍刀行","content":"雪中悍刀行烽火戏诸侯\n\n\n◆ 第13章 莲花峰骑牛问道，武帝城竖剑留语(3)\n书到用时方恨少，事非经过不知难。\n文官或可扰政，一介匹夫是决不至于乱国的。\n◆ 第14章 莲花峰骑牛问道，武帝城竖剑留语(4)\n年轻时候觉着战死沙场，被敌人摘了去无妨，马革裹尸也是快事，但爵位越高，就难免越发珍惜，这并非单纯怕死，只不过徐骁一直坚持今日荣华，都是无数兄弟舍命拼出来的，太早下去阴曹地府，对不住那些个草草葬身大江南北各地的英魂，尤其是这些人大多都有家室、家族，总得有他照应着才放心。\n边境上每隔几年就是狼烟四起，只不过大半都是他亲手点燃的。\n饿治百病这个道理，父辈们的循循善诱不管如何情真意切，都讲不出那个味儿。\n◆ 第17章 赴城外杀人赏雪，上武当姜泥送书(2)\n舔着血行走江湖，没个捧场的知己多寂寞，要不然高手对决为啥都挑在楼顶山巅？最\n用刀最忌讳气机紊乱，他开始有些理解。\n后半辈子都在忙自污其身自辱其名勾当的名臣将相，还少吗？\n徐骁起身后，望向山脚，轻笑道：“能立于不败之地，还不是国手吗？”\n◆ 第30章 老掌教黄庭作嫁，小和尚秀色参禅(5)\n‘人心方寸，天心方丈’\n◆ 第31章 北凉歌再奠英灵，阴阳间喝酒换刀(1)\n世子殿下有什么好，一个身无分文的徐凤年就够了嘛。\n◆ 第32章 北凉歌再奠英灵，阴阳间喝酒换刀(2)\n小姑娘见世子殿下似乎不上马车，像是少了点什么，着急道：“徐凤年，你不送我啊？” 徐凤年抬头柔声道：“不了，怕出了城就忍不住把你抢回来。”\n◆ 第33章 北凉歌再奠英灵，阴阳间喝酒换刀(3)\n两人交情向来是八两桃换半斤李，没有无缘无故的帮忙\n有些时候言语最能气人，似乎比绣冬、春雷还要锋利些。\n◆ 第36章 忆王妃老卒瞑目，出凉州世子挎刀(1)\n“青牛道上车千乘，旗下孩童捧桑葚。”\n◆ 第39章 忆王妃老卒瞑目，出凉州世子挎刀(4)\n跟随大柱国征战多年，只是年轻时做骑兵遥遥见过一次，那时候扛纛的还是军中头号先锋王翦王巨灵，益阙血战，还未瞎眼的老许便是同大柱国一起冲出了城门，眼睁睁望着王将军跪地不起，双手托起万钧城门，任由辽东袍泽冲出城去，那时候徐将军还未封异姓王，还未受爵大柱国，只是回头看了一眼城门。\n只见瞎子老许如同癫狂，挣扎着起身，不顾大柱国的阻止，丢掉拐杖，跪于地上，用尽全身所有力气，用光了三十年转战六国的豪气，用光了十年苟延残喘的精神，死死压抑着一位老卒的激情哭腔，磕头道：“锦州十八老字营之一，鱼鼓营末等骑卒，许涌关，参见徐将军！”\n◆ 第40章 忆王妃老卒瞑目，出凉州世子挎刀(5)\n古往今来，敢用戟做趁手兵器的，莫不是一帮杀人如拾草芥的虎狼猛汉。\n◆ 第47章 晋兰亭鱼跃龙门，青城山怒斩马贼(2)\n更是一知半解、三分迷糊、十分头痛。\n◆ 第48章 晋兰亭鱼跃龙门，青城山怒斩马贼(3)\n“宁将军，一戟挑翻了那东禁副都尉，就算出气了？要我在场，还不得让你把他剥光了甲胄吊在城门上？你若是觉得做过头了，怕给我惹麻烦，得，那三碗酒，我后悔请你了。可若是觉得仍不解气，我再请你喝三碗，如何？” 宁峨眉蓦然生出一股豪壮意气，神采飞扬，更显得这位北凉第二牙雄壮非凡，“那宁峨眉可要再喝三碗！”\n他说，好姑娘就是可以长得不必好看，但一定要善良的姑娘，愿意等他练剑练出锦绣前程的傻姑娘。\n◆ 第53章 山河图随行细绘，青羊宫闯阵玉宵(3)\n望山跑死马\n◆ 第55章 山河图随行细绘，青羊宫闯阵玉宵(5)\n武夫独身破阵要一鼓作气先杀人，忌讳拖泥带水，往往会被阵法拖死。这与行军作战擒贼先擒王的道理异曲同工\n◆ 第57章 滚到术先手五十，北凉王悍然入宫(2)\n轻仇者寡恩，轻义者寡情，轻孝者最无情。\n“打盹猛虎不睁眼，睁眼便杀人。”\n◆ 第61章 小师叔踏鹤天象，李淳罡飞剑斩江(2)\n天高不算高，人心比天高。道大不算大，人情比道大。我辈修道无非修心。\n◆ 第62章 小师叔踏鹤天象，李淳罡飞剑斩江(3)\n最苦是相思，最远是阴阳。\n◆ 第67章 携初冬坐鼋观剑，春神湖战意喧天(2)\n本来对她的装束十分反感，一顿饭下来，反而好感增加许多，女子率性天真才美，再漂亮的女子，若矫揉造作起来，在徐凤年看来简直就是死罪。\n◆ 第82章 心安处即是吾乡，无禅道总归有情(2)\n徐凤年柔声道：“老黄，你是想说吾心安处即吾乡吗？” 独坐的徐凤年笑了，“嘿，你哪能说出这般文绉绉的大道理呀。\n◆ 第85章 心安处即是吾乡，无禅道总归有情(5)\n礼义廉耻可不在书上。\n◆ 第101章 听潮亭草论军政，老供奉巧算联姻(1)“世上少有真的聪明人，却也少有真的笨人，\n老剑神大声笑道：“天不生我李淳罡，剑道万古长如夜。”\n◆ 第104章 听潮亭草论军政，老供奉巧算联姻(4)\n胸中小不平，以酒消之，世间大不平，唯剑能消\n‘天下万般难事皆可在女子大腿上办妥’\n◆ 第113章 老供奉帷幄庙堂，穷书生曲水清谈(4)\n官场小吏的‘拖’字诀，能让尚书将军们都头疼，搁在你们身上，就要学会‘等’字诀。\n◆ 第115章 老供奉帷幄庙堂，穷书生曲水清谈(6)\n功到成处便是道德，事到济处便是天理\n◆ 第118章 话长卿国士无双，道姜泥去留彷徨(3)\n以后陈哥哥要是能够一脚踩入历史的泥泞，侥幸留下足印，一定也要让小叮咚陪着\n◆ 第123章 恼姜泥青衣相随，叹徐骁别京无回(3)\n自家人不帮自家人，再大的家业都得败光。\n◆ 第136章 世子兄弟喜相逢，轩辕世家生暗潮(1)\n士子想要名声鼎盛，何其难？奢望一诗出世惊鬼神？几乎不可能，没有文坛前辈暖场附和，没有鼓噪学子追捧造势，写得再好，也无非是“尚可”二字，时下那些个美玉名篇，其实在刚面世时可都名声不显，是几百年传承，大浪淘沙，逐渐被诗坛巨擘认可，点评复点评，赞誉叠赞誉，才得以水落石出，对此宋恪礼再熟悉不过。\n◆ 第139章 世子兄弟喜相逢，轩辕世家生暗潮(4)\n再者很多人和事，本就没对错可言，钻了牛角尖，一定要非此即彼，就没道理可言了。”\n◆ 第144章 儒圣徽山显神通，剑神重回地仙境(2)\n人生但苦无妨，良人当归即好。\n江湖健忘而薄情，便如那文人相轻，自古皆然。\n轩辕敬城请老祖宗赴死！\n◆ 第145章 儒圣徽山显神通，剑神重回地仙境(3)\n狗不以善吠为良，人不以善言为贤\n◆ 第146章 儒圣徽山显神通，剑神重回地仙境(4)\n轩辕敬城微笑道：“轩辕敬城与你说话，老祖宗自然可以当作耳边风。只是此时仙人与你说话，你怎的还是这般自负无知？”\n轩辕敬城缓缓跪下，朗声道：“天垂千象，地载万物，皇天后土，轩辕敬城跪天地，以求死！”\n◆ 第148章 轩辕青锋成新主，四大天师重聚首(1)\n天地是大，所站不过方寸地，人生苦短，才百年三万六千五百日，糊糊涂涂过了一辈子，就很好。\n◆ 第150章 轩辕青锋成新主，四大天师重聚首(3)\n鼠因粮绝潜踪去，犬为家贫放胆眠\n穷在闹市无人问，富在深山有远亲，\n◆ 第156章 徐渭熊执黑不败，羊皮裘借剑两千(3)\n世上伤病千百种，情伤病入膏肓，心病无药可救。\n◆ 第159章 赞剑神新老齐现，叹掌教终归下山(3)\n“你敢？！” 有言语伴随古剑清鸣声呼啸而至。 有一剑，由千里外武当山而来。 落于徐脂虎身前。 黄鹤驾临江南湖亭郡，一名年轻道士如流星坠落，瞬间来到报国寺院中。\n◆ 第160章 武帝城神仙斗法，莲花峰红衣羽化(1)\n『贫道立誓，愿为天地正道再修三百年！』 『只求天地开一线，让徐脂虎飞升！』\n◆ 第162章 武帝城神仙斗法，莲花峰红衣羽化(3)\n归根结底，仍是顺道而驰，有法可依。术道两者缺一不可，如人远行，术是脚力，道是路径，光有脚力，误入歧途，不过是画地为牢，走不长远。仅知方向，却不行走，无非望梅止渴。\n◆ 第168章 叹陵江剑破千甲，笑广陵尽挂凉刀(5)\n殿下一声‘袁二哥’，袁左宗这几百里路走得舒坦。\n◆ 第171章 女侠押镖走北莽，书生挎刀赴边关(2)\n阎王好说，小鬼难缠\n哪个孩子心中没有一个江湖？\n◆ 第175章 鱼龙帮涉险过关，徐凤年小试牛刀(1)\n刘妮蓉站在徐凤年身后，泪眼模糊地看着这个佩刀男子的背影，摇头道：“这不是我想要的江湖。”\n能跟小姐并肩作战，然后死在一起，哪怕尸体离得很远，这也是王大石最好的江湖。\n◆ 第176章 鱼龙帮涉险过关，徐凤年小试牛刀(2)\n身手不行，怨不得江湖太深。”\n◆ 第182章 出关后再生波澜，徐凤年金刚初显(1)\n风流总被雨打风吹去\n江南风景好，温柔乡是英雄冢，少年郎心性不坚定，早早见识到旖旎风情，很难有雄心壮志去建功立业。凉莽边境破败萧索，上了年纪的老人，很容易感怀世事，满胸沟壑皆是悲怆，英雄迟暮，就会伤心伤肺。\n◆ 第190章 武学宝典惹争抢，雁回关内风波荡(1)\n年轻人就像一张新弓，不被生活拉弦到一个夸张幅度后，是不会知道自己有多少潜力的。\n◆ 第218章 破茶楼世子听书，痴桃子惜别凤年(1)『董叔叔说过，国有利器，不示于人。君子藏器，待时而动。小人持器，叫嚣不停。』\n◆ 第226章 遇世子龙树北行，救牧民峡谷掠影(1)\n衣能暖十分，饭可饱七八胃，茶可喝到五六味\n◆ 第235章 小拓跋狼戾狠绝，徐凤年苦战魔头(5)\n低头登山一甲子，方知昆仑山巅有盏灯。\n◆ 第272章 敦煌城洛阳发威，黄沙地凤年御风(1)\n前辈万里借剑，不是要我走他那条阳关大道，而是指点了那条路上的风景气象给我看，并非要我改换道路，这才是可贵之处\n◆ 第274章 敦煌城洛阳发威，黄沙地凤年御风(3)\n，世间太多女子，心甘情愿被或皮囊优越或才情出众的男子用花言巧语骗去大好年华。\n◆ 第312章 徐凤年大战魔枭，世子爷一夜白头(3)有些人有些事，不提起，不代表忘记。往往是能轻易说出口的人事，才容易褪散。\n◆ 第331章 徐凤年又逢青衣，徽山主往见世子(4)\n既说用人不疑疑人不用。又说防人之心不可无。反正天底下的道理都给说光了，但道理太多，也就其实等于没说。\n◆ 第340章 徐凤年听潮摆子，五藩王启程赴京(1)\n谋士，谋己谋人谋兵谋国谋天下，依次层层递进，谋得自身太平，才可帮人出谋划策。\n◆ 第368章 徐凤年起程离京，幽燕庄骤生波澜(4)\n世上有心无力的事情太多了，做人不能把自己活活憋死，那才是真的枉费投胎来世上走一遭。\n◆ 第369章 观音宗寻衅幽燕，徐凤年临湖拒敌(1)\n匹夫一怒，血溅五步，人头抢地。天子之怒，伏尸百万，流血千里\n◆ 第384章 逐鹿山拦途邀客，刘松涛横空出世(2)\n站得高不能坐得太久，莫仗一时得意遮住后来人。\n◆ 第385章 逐鹿山拦途邀客，刘松涛横空出世(3)\n“若不回头，谁替你救苦救难；如能转念，何须我大慈大悲？”\n◆ 第386章 逐鹿山拦途邀客，刘松涛横空出世(4)\n情不知所起，一往而深。可惜大多由深转浅，相忘于江湖。\n◆ 第387章 逐鹿山拦途邀客，刘松涛横空出世(5)\n徐凤年冷笑道：“难怪师父曾说阴间阎王笑话阳间人人不像人。”\n◆ 第388章 逐鹿山九十相争，上阴宫凤年揽士(1)\n李玉斧即便可以淡看自己生死，也做不到淡看他人生死，这才是大牢笼。\n◆ 第393章 逐鹿山九十相争，上阴宫凤年揽士(6)\n纵横术之所以又被称作长短术，无外乎以己之长对敌之短\n◆ 第400章 快雪庄真武临世，春神湖神人大战(2)江湖上都开始流传一句箴言：“世人修道修长生，武当修道修平常。”\n◆ 第401章 快雪庄真武临世，春神湖神人大战(3)\n少年侠气，交结五都雄。肝胆洞，毛发耸。立谈中，死生同，一诺千金重，一诺千金重\n◆ 第420章 徐人屠慨谈生平，宋恪礼履新都尉(3)\n“记住一点，人在屋檐下，给人低头做事是本分，但也别忘了抬头做人，因为这是咱们打从娘胎落地起就不能丢掉的本分。”\n◆ 第425章 徐凤年整饬陵州，草原女栖身北凉(3)\n官场是江湖，大家都身不由己。官场也不是江湖，不能只以力服人。\n◆ 第435章 桃腮楼世子斫琴，柴扉院鹰隼捕谍(4)\n遇上好的女子，不管她如何舍不得你，作为有担当的男子，终归是要让她为你而骄傲的\n◆ 第439章 北凉道暗流涌动，凉王府年年有余(2)\n你说这有些人奇怪不奇怪，你每天给人一文钱，哪天不给了，他跳脚大骂。你每天打人一耳光，哪天不打了，他反而感恩戴德。\n◆ 第446章 织造局真假密信，试与探你来我往(3)\n官场学问说到底，无非就是‘挪位置’三字精髓\n◆ 第451章 纨绔子当街行凶，徐凤年收买人心(4)\n当官的之所以越来越圆滑，都是被恩师谆谆教诲过，被政敌坑惨过，被同僚飞黄腾达刺激过，给一点一点辛苦打熬出来的处世智慧。\n◆ 第453章 李功德开诚布公，神秘客挑衅世子(2)\n什么肉中刺，眼中钉才对。”\n◆ 第484章 龙王府金刚搏杀，青苍城大局底定(2)\n一部部史书，可不就是在孜孜不倦传授后辈读书人如何不见血地杀人吗？”\n◆ 第494章 太子篆密访徽山，张巨鹿酒馆独酌(2)\n“浪成于微澜之间，风起于青萍之末。惊蛰一过，百虫群出，闻风而动。”\n◆ 第529章 徽山紫衣锁横江，武当剑痴剑拦途(3)理解归理解，却很难认同。\n◆ 第566章 杨慎杏老马失蹄，蓟南骑全军覆没(3)\n幼虎虽未成纹，却有食牛之气\n◆ 第567章 元朴暗访宋雏凤，女帝南朝议军政（1）\n很多时候只要你不犯错，机会就来了。\n◆ 第569章 元朴暗访宋雏凤，女帝南朝议军政（3）\n不过是二十出头的年轻人，又是登顶江湖的人物，本该是最意气风发的时候，怎的如此暮气沉沉，比贫道这活了八十几年的老头子的心态还沧桑？\n◆ 第587章 小酒肆高人论枪，清凉山有客擅闯（1）\n卦不敢算尽，只因世道无常。情不敢至深，唯恐大梦一场。\n◆ 第593章 听潮湖神仙打架，铁剑楼帝师论政（3）\n“初生牛犊不怕虎，搁在家徒四壁的人物身上，是好事情，富贵险中求嘛，可要是你们这些身份清贵的年轻人还天不怕地不怕，就是于国有害了。\n◆ 第594章 听潮湖神仙打架，铁剑楼帝师论政（4）\n有了念想，就会怕死，也不想死。\n◆ 第603章 故人他乡忆故人，相濡相忘缠不清（5）你要是离开庙堂不当北凉王，只做个江湖人，该有多惬意？\n天雨虽宽，不润无根之草。\n◆ 第612章 徐凤年大杀莽骑，莽郡主狼狈就擒（1）\n人生天地间，有天地在，我辈谁不是束手束脚的牵线傀儡？这座牢笼，有人侥幸跳得出去，但是肯定没人打得破。\n◆ 第614章 徐凤年大杀莽骑，莽郡主狼狈就擒（3）\n心胸再狭小的男子，大概也会被这里日复一日的天高地阔给撑出了气量。\n◆ 第690章 四国士联手造局，徐凤年评点风流(4)\n吾心安处，实实有净土，实实有莲池。\n◆ 第697章 怀阳关诸将议事，广陵道西楚告捷(1)\n他这个如同当婆婆的在儿子跟儿媳吵架的时候，帮儿媳才是真的帮儿子。\n◆ 第738章 韩谷子西行遇险，徐凤年单骑退敌(2)姑娘问我行不行，我从来都是说行的。\n◆ 第775章 北凉道四线皆战，龙象军苦战流州 (2)\n有些人自己无脊梁，便看不得别人有风骨，不但不自惭形秽，还要吐口水甚至是使绊子\n◆ 第780章 议事堂激辩战局，北凉军大破莽寇 (2)\n“少年人要心忙，忙起来，则能震摄浮气。老年人要心闲，闲下去，方可乐享余年。\n◆ 第827章 谢家郎芝兰玉树，入幕宾相谈甚欢(2)世间男儿，有几个逃得过“青梅竹马”这柄天下头等厉害的杀人飞剑？\n◆ 第845章 吕丹田飞剑寻衅，徐凤年南渡示威(2)\n“你才是来者”好像有点来者不善的意思啊。\n◆ 第908章 湖边亭风波起伏，樊白奴与虎谋皮(1)年轻人离家十年不算久，上了年纪的人，那就是出门一步即远行”\n有些遗憾，就像一条老狗匍匐在街角的独自呜咽，细细悠悠，挠心挠肺。\n◆ 第923章 北安镇群雄毕至，小酒楼风波骤起(4)\n功名利禄浓于酒，醉得人心死不醒\n◆ 第927章 青苍城待客种檀，逃暑镇宗师聚首(1)\n“无醇酒美人，不愿来此人间。无快剑挚友，不愿老此江湖。\n◆ 第946章 清凉山卖家筹粮，小城镇老卒赴关(1)\n风起于青萍之末，浪成于微澜之间\n◆ 第1016章 徐凤年与女相逢，父与女携归北凉(2)人活一世，成年后不论是苦是福，那都怨不得天地父母了。\n","slug":"雪中悍刀行","date":"2022-04-08T07:26:43.000Z","categories_index":"文摘","tags_index":"雪中悍刀行","author_index":"张 凡"},{"id":"a6d58241b7800a45a8082a7ce6caaf95","title":"三体","content":"三体刘慈欣\n\n\n\n 在中国，任何超脱飞扬的思想都会砰然坠地的，现实的引力太沉重了。\n城市就是森林，每一个男人都是猎手，每一个女人都是陷阱。\n你看经济学的基本公理就是人类的唯利是图，没有这个前提，整个经济学就将崩溃；社会学的基本设定还没有定论，但可能比经济学的更黑暗，真理总沾着灰尘……\n给岁月以文明，给时光以生命。\n“我只是喜欢这艘飞船，这可是我们两个世纪前的梦想，你也知道，为了有一天能造出这样的飞船，我都做过些什么……”章北海看着东方延绪，以前他目光中的某种坚如磐石的东西消失了，只透出疲惫的空白和深深的悲哀，这使他看上去仿佛变了一个人，不再是那个冷静又冷酷、深思熟虑行动果敢的强者，而是一个被往昔的沉重岁月压弯了腰的人。看着他，东方延绪生出了从未有过的关切和怜悯之情。\n“真实的宇宙就是这么黑。”罗辑伸手挥挥，像抚摸天鹅绒般感受着黑暗的质感，“宇宙就是一座黑暗森林，每个文明都是带枪的猎人，像幽灵般潜行于林间，轻轻拨开挡路的树枝，竭力不让脚步发出一点儿声音，连呼吸都小心翼翼……他必须小心，因为林中到处都有与他一样潜行的猎人。如果他发现了别的生命，不管是不是猎人，不管是天使还是魔鬼，不管是娇嫩的婴儿还是步履蹒跚的老人，也不管是天仙般的少女还是天神般的男孩，能做的只有一件事：开枪消灭之。在这片森林中，他人就是地狱，就是永恒的威胁，任何暴露自己存在的生命都将很快被消灭。这就是宇宙文明的图景，这就是对费米悖论的解释。”\n想逃避现实，最好的方式就是深深介入现实之中。\n医治不死病，佛度有缘人。\n如果千秋功罪真有人评说，现在已经可以派一个人去解释岁月造成的误会。\n和云天明一样，她也要在无边的黑暗中漂流了。\n阶梯计划已经被历史遗忘，云天明的大脑永远迷失在茫茫太空中。但就是这个已经没入虚无的人，却给他爱的人留下了一个实实在在的世界，一个由一颗恒星和两颗行星构成的世界。\n罗辑盘腿端坐在白色大厅正中，面对着那堵弧形白墙，他的头发和胡须都很长，但不乱，梳理得很整齐，也都是纯白色，几乎与白墙融为一体，这使得他穿的整洁的黑色中山装格外醒目。他端坐在那里，呈一个稳定的倒丁字形，仿佛是海滩上一只孤独的铁锚，任岁月之风从头项吹过，任时间之浪在面前咆哮，巍然不动，以不可思议的坚定等待着一艘永不归航的船。他的右手握着一个红色的条状物，那就是执剑者的剑柄——引力波广播的启动开关。他的存在使这个空眼球有了眸子，虽然与大厅相比只是一个黑点，却使荒凉和茫然消失了，眼睛有了神。而罗辑本人的眼睛从这个方向是看不到的，他对来人丝毫没有反应，只是盯着面前的白墙。\n就这样，罗辑与三体世界对视了五十四年，他由一个玩世不恭的人，变成一位面壁五十四年的真正面壁者，一位五十四年执剑待发的地球文明的守护人。\n断了的骨头长好后，愈合的断裂处长得比原来还粗，这在医学上叫超量恢复，是说如果人体有机会弥补以前缺少的某些东西，那么这些东西可能恢复到比不缺少它们的人更多。\n要生存就得竞争。\n弱小和无知不是生存的障碍，傲慢才是。\n她两次处于仅次于上帝的位置上，却两次以爱的名义把世界推向深渊，而这一次已没人能为她挽回。\n","slug":"三体","date":"2022-04-08T04:12:25.000Z","categories_index":"文摘","tags_index":"三体","author_index":"张 凡"},{"id":"144f0b4d9b9f80ea377106e9c6a54a45","title":"Linux基础","content":"\n\nLinux简介​    Linux，全称 GNU&#x2F;Linux，是一种免费使用和自由传播的类 UNIX 操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到 Minix 和 Unix 思想的启发，是一个基于 POSIX 的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的 Unix 工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。\n​    Linux不仅系统性能稳定，而且是开源软件。其核心防火墙组件性能高效、配置简单，保证了系统的安全。在很多企业网络中，为了追求速度和安全，Linux不仅仅是被网络运维人员当作服务器使用，甚至当作网络防火墙，这是Linux的一大亮点。\n​    Linux的基本思想有两点：\n​    第一，一切都是文件；\n​    第二，每个文件都有确定的用途。\n​    其中第一条详细来讲就是系统中的所有都归结为一个文件，包括命令、硬件和软件设备、操作系统、进程等等对于操作系统内核而言，都被视为拥有各自特性或类型的文件。至于说Linux是基于Unix的，很大程度上也是因为这两者的基本思想十分相近。\n服务器通常使用的两套组合是:LAMP(Linux + Apache + Mysql + PHP) 和 LNMP(Linux + Nginx + Mysql + PHP)组合。\nLinux安装常见的安装方式有三种，这里我们使用的购买的云服务器：\n\n虚拟机安装\n\n本地安装\n\n云服务器安装，这里使用的是腾讯云服务器\n\n\n云服务器登录配置\n首先要配置防火墙\n\n\n可以修改登录密码。\n\n下载Xshell和Xftp来进行远程连接和文件传输。\n\n\nLinux 系统启动过程Linux启动时我们会看到许多启动信息。\nLinux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：\n\n内核的引导。\n运行 init。\n系统初始化。\n建立终端。\n用户登录系统。\n\ninit程序的类型：\n\nSysV: init, CentOS 5之前, 配置文件： &#x2F;etc&#x2F;inittab。\nUpstart: init,CentOS 6, 配置文件： &#x2F;etc&#x2F;inittab, &#x2F;etc&#x2F;init&#x2F;*.conf。\nSystemd： systemd, CentOS 7,配置文件： &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system、 &#x2F;etc&#x2F;systemd&#x2F;system。\n\n1、内核引导BIOS -&gt; &#x2F;boot\n当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。\n操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。\n2、运行init&#x2F;boot -&gt; init程序 -&gt; 读取&#x2F;etc&#x2F;inittab -&gt; 运行级别\n​    init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。\n​    许多程序需要开机启动，在Linux就叫做”守护进程”（daemon）。init进程的一大任务，就是去运行这些开机启动的程序。但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。\n​    也就是说，启动时根据”运行级别”，确定要运行哪些程序。Linux系统有7个运行级别(runlevel)：\n\n\n\n运行级别\n系统操作\n\n\n\n运行级别0\n系统停机状态，系统默认运行级别不能设为0，否则不能正常启动\n\n\n运行级别1\n单用户工作状态，root权限，用于系统维护，禁止远程登陆\n\n\n运行级别2\n多用户状态(没有NFS)\n\n\n运行级别3\n完全的多用户状态(有NFS)，登陆后进入控制台命令行模式\n\n\n运行级别4\n系统未使用，保留\n\n\n运行级别5\nX11控制台，登陆后进入图形GUI模式\n\n\n运行级别6\n系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动\n\n\n3、系统初始化init -&gt; rc.sysinit -&gt; &#x2F;etc&#x2F;init.d\n​    在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。\n​    它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。\nl5:5:wait:&#x2F;etc&#x2F;rc.d&#x2F;rc 5\n\n​    这一行表示以5为参数运行&#x2F;etc&#x2F;rc.d&#x2F;rc，&#x2F;etc&#x2F;rc.d&#x2F;rc是一个Shell脚本，它接受5作为参数，去执行&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录下的所有的rc启动脚本，&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下。\n​    而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以&#x2F;var&#x2F;lock&#x2F;subsys&#x2F;下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。\n​    这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。\n​    至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。\n4、建立终端init -&gt; rc.sysinit -&gt; &#x2F;etc&#x2F;init.d -&gt; 建立终端\n​    rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。\n​    init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：\n1:2345:respawn:&#x2F;sbin&#x2F;mingetty tty1\n2:2345:respawn:&#x2F;sbin&#x2F;mingetty tty2\n3:2345:respawn:&#x2F;sbin&#x2F;mingetty tty3\n4:2345:respawn:&#x2F;sbin&#x2F;mingetty tty4\n5:2345:respawn:&#x2F;sbin&#x2F;mingetty tty5\n6:2345:respawn:&#x2F;sbin&#x2F;mingetty tty6\n\n​    从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。\n​    同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。\n5、用户登录系统一般来说，用户的登录方式有三种：\n\n（1）命令行登录\n\n（2）ssh登录\n\n（3）图形界面登录\n\n\n​    对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。\n​    Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。然后 login 会对用户名进行分析：如果用户名不是 root，且存在 &#x2F;etc&#x2F;nologin 文件，login 将输出 nologin 文件的内容，然后退出。\n​    这通常用来系统维护时防止非root用户登录。只有&#x2F;etc&#x2F;securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。\n​    &#x2F;etc&#x2F;usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。\n文件系统目录结构​    Linux一切皆文件，根目录就是 / 。\n[root@VM-4-9-centos &#x2F;]# ls\nbin   data  etc   lib    lost+found  mnt  proc  run   srv  tmp  var\nboot  dev   home  lib64  media       opt  root  sbin  sys  usr\n\n一级目录\n\n\n一级目录\n功能（作用）\n\n\n\n&#x2F;bin\n存放系统命令，普通用户和 root 都可以执行。放在 &#x2F;bin 下的命令在单用户模式下也可以执行\n\n\n&#x2F;boot\n系统启动目录，保存与系统启动相关的文件，如内核文件和启动引导程序（grub）文件等\n\n\n&#x2F;dev\n设备文件保存位置\n\n\n&#x2F;etc\n配置文件保存位置。系统内所有采用默认安装方式（rpm 安装）的服务配置文件全部保存在此目录中，如用户信息、服务的启动脚本、常用服务的配置文件等\n\n\n&#x2F;home\n普通用户的主目录（也称为家目录）。在创建用户时，每个用户要有一个默认登录和保存自己数据的位置，就是用户的主目录，所有普通用户的主目录是在 &#x2F;home&#x2F; 下建立一个和用户名相同的目录。如用户 liming 的主目录就是 &#x2F;home&#x2F;liming\n\n\n&#x2F;lib\n系统调用的函数库保存位置\n\n\n&#x2F;media\n挂载目录。系统建议用来挂载媒体设备，如软盘和光盘\n\n\n&#x2F;mnt\n挂载目录。早期 Linux 中只有这一个挂载目录，并没有细分。系统建议这个目录用来挂载额外的设备，如 U 盘、移动硬盘和其他操作系统的分区\n\n\n&#x2F;misc\n挂载目录。系统建议用来挂载 NFS 服务的共享目录。虽然系统准备了三个默认挂载目录 &#x2F;media&#x2F;、&#x2F;mnt&#x2F;、&#x2F;misc&#x2F;，但是到底在哪个目录中挂载什么设备可以由管理员自己决定。例如，笔者在接触 Linux 的时候，默认挂载目录只有 &#x2F;mnt&#x2F;，所以养成了在 &#x2F;mnt&#x2F; 下建立不同目录挂载不同设备的习惯，如 &#x2F;mnt&#x2F;cdrom&#x2F; 挂载光盘、&#x2F;mnt&#x2F;usb&#x2F; 挂载 U 盘，都是可以的\n\n\n&#x2F;opt\n第三方安装的软件保存位置。这个目录是放置和安装其他软件的位置，手工安装的源码包软件都可以安装到这个目录中。不过笔者还是习惯把软件放到 &#x2F;usr&#x2F;local&#x2F; 目录中，也就是说，&#x2F;usr&#x2F;local&#x2F; 目录也可以用来安装软件\n\n\n&#x2F;root\nroot 的主目录。普通用户主目录在 &#x2F;home&#x2F; 下，root 主目录直接在“&#x2F;”下\n\n\n&#x2F;sbin\n保存与系统环境设置相关的命令，只有 root 可以使用这些命令进行系统环境设置，但也有些命令可以允许普通用户查看\n\n\n&#x2F;srv\n服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据\n\n\n&#x2F;tmp\n临时目录。系统存放临时文件的目录，在该目录下，所有用户都可以访问和写入。建议此目录中不能保存重要数据，最好每次开机都把该目录清空\n\n\n&#x2F;lost+found\n当系统意外崩溃或意外关机时，产生的一些文件碎片会存放在这里。在系统启动的过程中，fsck 工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如，&#x2F;lost+found 就是根分区的备份恢复目录，&#x2F;boot&#x2F;lost+found 就是 &#x2F;boot 分区的备份恢复目录\n\n\n&#x2F;proc\n虚拟文件系统。该目录中的数据并不保存在硬盘上，而是保存到内存中。主要保存系统的内核、进程、外部设备状态和网络状态等。如 &#x2F;proc&#x2F;cpuinfo 是保存 CPU 信息的，&#x2F;proc&#x2F;devices 是保存设备驱动的列表的，&#x2F;proc&#x2F;filesystems 是保存文件系统列表的，&#x2F;proc&#x2F;net 是保存网络协议信息的……\n\n\n&#x2F;sys\n虚拟文件系统。和 &#x2F;proc 目录相似，该目录中的数据都保存在内存中，主要保存与内核相关的信息\n\n\n&#x2F;usr\n全称为 Unix Software Resource，此目录用于存储系统软件资源。FHS 建议所有开发者，应把软件产品的数据合理的放置在 &#x2F;usr 目录下的各子目录中，而不是为他们的产品创建单独的目录。\n\n\n&#x2F;var\n&#x2F;var 目录用于存储动态数据，例如缓存、日志文件、软件运行过程中产生的文件等。通常，此目录下含一些子目录。\n\n\n重要的子目录Linux &#x2F;usr目录\n\n\n\n子目录\n功能（作用）\n\n\n\n&#x2F;usr&#x2F;bin&#x2F;\n存放系统命令，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行\n\n\n&#x2F;usr&#x2F;sbin&#x2F;\n存放根文件系统不必要的系统管理命令，如多数服务程序，只有 root 可以使用。\n\n\n&#x2F;usr&#x2F;lib&#x2F;\n应用程序调用的函数库保存位置\n\n\n&#x2F;usr&#x2F;XllR6&#x2F;\n图形界面系统保存位置\n\n\n&#x2F;usr&#x2F;local&#x2F;\n手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置\n\n\n&#x2F;usr&#x2F;share&#x2F;\n应用程序的资源文件保存位置，如帮助文档、说明文档和字体目录\n\n\n&#x2F;usr&#x2F;src&#x2F;\n源码包保存位置。我们手工下载的源码包和内核源码包都可以保存到这里。不过笔者更习惯把手工下载的源码包保存到 &#x2F;usr&#x2F;local&#x2F;src&#x2F; 目录中，把内核源码保存到 &#x2F;usr&#x2F;src&#x2F;linux&#x2F; 目录中\n\n\n&#x2F;usr&#x2F;include\nC&#x2F;C++ 等编程语言头文件的放置目录\n\n\nLinux &#x2F;var 目录\n\n\n\n&#x2F;var子目录\n功能（作用）\n\n\n\n&#x2F;var&#x2F;lib&#x2F;\n程序运行中需要调用或改变的数据保存位置。如 MySQL 的数据库保存在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 目录中\n\n\n&#x2F;var&#x2F;log&#x2F;\n登陆文件放置的目录，其中所包含比较重要的文件如 &#x2F;var&#x2F;log&#x2F;messages, &#x2F;var&#x2F;log&#x2F;wtmp 等。\n\n\n&#x2F;var&#x2F;run&#x2F;\n一些服务和程序运行后，它们的 PID（进程 ID）保存位置\n\n\n&#x2F;var&#x2F;spool&#x2F;\n里面主要都是一些临时存放，随时会被用户所调用的数据，例如 &#x2F;var&#x2F;spool&#x2F;mail&#x2F; 存放新收到的邮件，&#x2F;var&#x2F;spool&#x2F;cron&#x2F; 存放系统定时任务。\n\n\n&#x2F;var&#x2F;www&#x2F;\nRPM 包安装的 Apache 的网页主目录\n\n\n&#x2F;var&#x2F;nis和&#x2F;var&#x2F;yp\nNIS 服务机制所使用的目录，nis 主要记录所有网络中每一个 client 的连接信息；yp 是 linux 的 nis 服务的日志文件存放的目录\n\n\n&#x2F;var&#x2F;tmp\n一些应用程序在安装或执行时，需要在重启后使用的某些文件，此目录能将该类文件暂时存放起来，完成后再行删除\n\n\nLinux链接概念​    Linux 链接分两种，一种被称为硬链接（Hard Link），另一种被称为符号链接（Symbolic Link）。默认情况下，ln 命令产生硬链接。\n硬连接\n​    硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。\n​    比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。\n​    硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。\n软连接\n​    另外一种连接称之为符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。\n​    比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。\nln创建链接命令\nln [参数][源文件或目录][目标文件或目录]\n\n选项与参数：\n\n-b 删除，覆盖以前建立的链接\n-d 允许超级用户制作目录的硬链接\n-f 强制执行\n-i 交互模式，文件存在则提示用户是否覆盖\n-n 把符号链接视为一般目录\n-s 软链接(符号链接)\n-v 显示详细的处理过程\n\n[root@VM-4-9-centos home]# ls\nkdum.sh  lighthouse  test1\n[root@VM-4-9-centos home]# touch f1\t\t\t\t\t\t\t#创建文件f1\n[root@VM-4-9-centos home]# ls\nf1  kdum.sh  lighthouse  test1\n[root@VM-4-9-centos home]# ln f1 f2\t\t\t\t\t\t\t#创建硬链接f2 指向f1指向的文件\n[root@VM-4-9-centos home]# ls\nf1  f2  kdum.sh  lighthouse  test1\n[root@VM-4-9-centos home]# ls -al\ntotal 32\ndrwxr-xr-x.  4 root       root        4096 Jun 18 16:50 .\ndr-xr-xr-x. 19 root       root        4096 Jun 18 16:50 ..\n-rw-r--r--   2 root       root           0 Jun 18 16:49 f1\t\t#此时f1和f2都是文件,指向同一物理文件\n-rw-r--r--   2 root       root           0 Jun 18 16:49 f2\t\t#此时f1和f2都是文件,指向同一物理文件\n-rwxr-xr-x   1 root       root       14704 Jun 17 20:55 kdum.sh\ndrwx------   5 lighthouse lighthouse  4096 May 18 10:10 lighthouse\ndrwxr-xr-x   2 root       root        4096 Jun 17 20:56 test1\n[root@VM-4-9-centos home]# ln -s  f1 f3\t\t\t\t\t\t\t#创建软链接f3 指向f1\n[root@VM-4-9-centos home]# ls -al\ntotal 32\ndrwxr-xr-x.  4 root       root        4096 Jun 18 16:50 .\ndr-xr-xr-x. 19 root       root        4096 Jun 18 16:50 ..\n-rw-r--r--   2 root       root           0 Jun 18 16:49 f1\n-rw-r--r--   2 root       root           0 Jun 18 16:49 f2\nlrwxrwxrwx   1 root       root           2 Jun 18 16:50 f3 -&gt; f1\t#软链接f3 指向f1\n-rwxr-xr-x   1 root       root       14704 Jun 17 20:55 kdum.sh\ndrwx------   5 lighthouse lighthouse  4096 May 18 10:10 lighthouse\ndrwxr-xr-x   2 root       root        4096 Jun 17 20:56 test1\n[root@VM-4-9-centos home]# echo &quot;hello world&quot; &gt;&gt; f1\t\t\t\t#f1文件写入\n[root@VM-4-9-centos home]# cat f1\nhello world\n[root@VM-4-9-centos home]# ls\nf1  f2  f3  kdum.sh  lighthouse  test1\n[root@VM-4-9-centos home]# cat f2\t\t\t\t\t\t\t\t#f2文件也同时写入\nhello world\n[root@VM-4-9-centos home]# cat f3\t\t\t\t\t\t\t\t#f3指向的f1内容\nhello world\n[root@VM-4-9-centos home]# ll\ntotal 32\n-rw-r--r-- 2 root       root          12 Jun 18 16:51 f1\n-rw-r--r-- 2 root       root          12 Jun 18 16:51 f2\nlrwxrwxrwx 1 root       root           2 Jun 18 16:50 f3 -&gt; f1\n-rwxr-xr-x 1 root       root       14704 Jun 17 20:55 kdum.sh\ndrwx------ 5 lighthouse lighthouse  4096 May 18 10:10 lighthouse\ndrwxr-xr-x 2 root       root        4096 Jun 17 20:56 test1\n[root@VM-4-9-centos home]# rm  f1\t\t\t\t\t\t\t#删除f1\nrm: remove regular file ‘f1’? y\n[root@VM-4-9-centos home]# ls\nf2  f3  kdum.sh  lighthouse  test1\n[root@VM-4-9-centos home]# cat f2\t\t\t\t\t\t\t#f2正常访问\nhello world\n[root@VM-4-9-centos home]# cat f1\t\t\t\t\t\t\t#f3由于f1已经删除而访问失败\ncat: f1: No such file or directory\n\n\n\n\n\n\n常用命令开关机登录​    Windows开机会启动很多服务 “service”，在Linux中叫做守护进程”daemon”。\n​    在开关机前，最好进行内存-硬盘的数据同步，使用 sync 命令来进行数据同步。\nsync # 将数据由内存同步到硬盘中\n\nshutdown关机\nhalt\t\t\t\t#立刻关机\npoweroff\t\t\t#立刻关机\nshutdown -h now \t#立刻关机(root用户使用)\nshutdown -h 10 \t\t#10分钟后自动关机\n\nreboot重启\nreboot\nshutdown -r now \t#立刻重启(root用户使用)\nshutdown -r 10 \t\t#过10分钟自动重启(root用户使用)\nshutdown -r 20:35\t#在时间为20:35时候重启(root用户使用)\n\n\n\n目录管理​    最常用的目录命令为:\ncd .. \t#返回上一级目录\ncd .&#x2F; \t#当前目录\nls \t\t#展示当前目录下的文件及文件夹\n\n\n\nls列出目录\nls -a #查看全部文件,包括隐藏文件\nls -l #查看文件详细信息\n#可以组合使用\nls -al #查看全部文件,包括隐藏文件的详细信息\n\n\n\ncd切换目录\ncd &#x2F;xxx&#x2F;xxx # 以绝对路径进入到&#x2F;xxx&#x2F;xxx\ncd ..&#x2F;xxx \t# 相对路径进入到&#x2F;xxx\ncd ~\t\t#返回当前的用户目录\n\n\n\npwd显示目录\n​    显示当前用户所在目录。\n[root@VM-4-9-centos ~]# cd &#x2F;\n[root@VM-4-9-centos &#x2F;]# pwd\n&#x2F;\n[root@VM-4-9-centos ~]# cd ~\n[root@VM-4-9-centos ~]# pwd\n&#x2F;root\n[root@VM-4-9-centos ~]# cd &#x2F;bin\n[root@VM-4-9-centos bin]# pwd\n&#x2F;bin\n[root@VM-4-9-centos bin]# cd &#x2F;usr&#x2F;local\n[root@VM-4-9-centos local]# pwd\n&#x2F;usr&#x2F;local\n\n\n\nmkdir创建目录\nmkdir [-mp] 目录名称\n\n选项与参数：\n\n-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～\n-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！\n\nmkdir test1 \t\t\t#创建目录\nmkdir -p test2&#x2F;test3\t #递归创建目录\n\n\n\nrmdir删除空目录\n​    只能删除空目录。\nrmdir [-p] 目录名称 \n\n选项与参数：\n\n-p ：连同上一级『空的』目录也一起删除\n\ncp复制文件或目录\n​    cp 即拷贝文件和目录。\ncp [-adfilprsu] 来源档(source) 目标档(destination)\n\n选项与参数：\n\n-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)\n-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；\n-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；\n-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)\n-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；\n-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；\n-r：递归持续复制，用於目录的复制行为；(常用)\n-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；\n-u：若 destination 比 source 旧才升级 destination ！\n\n[root@VM-4-9-centos home]# ls \nkdump-lib.sh  lighthouse  test1\n[root@VM-4-9-centos home]# cp kdump-lib.sh  test1&#x2F; \t\t#复制文件\n[root@VM-4-9-centos home]# cd test1&#x2F;\n[root@VM-4-9-centos test1]# ls\nkdump-lib.sh\n[root@VM-4-9-centos home]# cp kdump-lib.sh test1&#x2F;\t\t#如果文件重复存在,会询问是否覆盖\ncp: overwrite ‘test1&#x2F;kdump-lib.sh’? y  \n\n\n\nrm 移除文件或目录\nrm [-fir] 文件或目录\n\n选项与参数：\n\n-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；\n-i ：互动模式，在删除前会询问使用者是否动作\n-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！\n\n[root@VM-4-9-centos home]# ls\nkdump-lib.sh  lighthouse  test1\n[root@VM-4-9-centos home]# rm kdump-lib.sh  -i\nrm: remove regular file ‘kdump-lib.sh’? y\n[root@VM-4-9-centos home]# ls\nlighthouse  test1\n\nrm -rf &#x2F;  #删除操作系统在内的所有文件!!!!!!!!!删库跑路\n\n\n\nmv(移动文件与目录,或修改名称)\nmv [-fiu] source destination\n\n选项与参数：\n\n-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；\n-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！\n-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)\n\n[root@VM-4-9-centos test1]# ls\nkdump-lib.sh\n[root@VM-4-9-centos test1]# mv kdump-lib.sh ..&#x2F;  #移动文件到上一级目录 \n[root@VM-4-9-centos test1]# cd ..\n[root@VM-4-9-centos home]# ls\nkdump-lib.sh  lighthouse  test1\n\n[root@VM-4-9-centos home]# mv kdump-lib.sh kdum.sh #重命名文件或文件夹\n[root@VM-4-9-centos home]# ls\nkdum.sh  lighthouse  test1\n\n\n\n\n\n\n\n文件内容查看Linux系统中使用以下命令来查看文件的内容：\n\ncat 由第一行开始显示文件内容\ntac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！\nnl  显示的时候，顺道输出行号！\nmore 一页一页的显示文件内容 \nless 与 more 类似，但是比 more 更好的是，他可以往前翻页！\nhead 只看头几行 (-n命令显示头部 n行)\ntail 只看尾巴几行\n\n[注意]\n​    q :退出 空格:代表下翻页  回车: 下一行 f显示行号  \n​    向上查找 : /[目标字符串] 向下查找: ?[目标字符串] \n​    查找时,n:下一个 N: 上一个\n#命令测试\n[root@VM-4-9-centos &#x2F;]# cd &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;\n[root@VM-4-9-centos network-scripts]# cat ifcfg-eth0  \t\t\t\t\t#从第一行开始显示\n# Created by cloud-init on instance boot automatically, do not edit.\n#\nBOOTPROTO&#x3D;dhcp\nDEVICE&#x3D;eth0\nHWADDR&#x3D;52:54:00:27:a8:37\nONBOOT&#x3D;yes\nPERSISTENT_DHCLIENT&#x3D;yes\nTYPE&#x3D;Ethernet\nUSERCTL&#x3D;no\n[root@VM-4-9-centos network-scripts]# tac ifcfg-eth0 \t\t\t\t\t#从末尾反向开始显示\nUSERCTL&#x3D;no\nTYPE&#x3D;Ethernet\nPERSISTENT_DHCLIENT&#x3D;yes\nONBOOT&#x3D;yes\nHWADDR&#x3D;52:54:00:27:a8:37\nDEVICE&#x3D;eth0\nBOOTPROTO&#x3D;dhcp\n#\n# Created by cloud-init on instance boot automatically, do not edit.\n[root@VM-4-9-centos network-scripts]# nl ifcfg-eth0 \t\t\t\t\t#加行号开始显示\n     1\t# Created by cloud-init on instance boot automatically, do not edit.\n     2\t#\n     3\tBOOTPROTO&#x3D;dhcp\n     4\tDEVICE&#x3D;eth0\n     5\tHWADDR&#x3D;52:54:00:27:a8:37\n     6\tONBOOT&#x3D;yes\n     7\tPERSISTENT_DHCLIENT&#x3D;yes\n     8\tTYPE&#x3D;Ethernet\n     9\tUSERCTL&#x3D;no\n[root@VM-4-9-centos network-scripts]# head -n 5 ifcfg-eth0 \n# Created by cloud-init on instance boot automatically, do not edit.\n#\nBOOTPROTO&#x3D;dhcp\nDEVICE&#x3D;eth0\nHWADDR&#x3D;52:54:00:27:a8:37\n\n\n\n\n\n\n\n文件权限和属性​    Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux 系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在 Linux 中我们通常使用以下两个命令来修改文件或目录的所属用户与权限：\n\nchown (change ownerp) ： 修改所属用户与组。\nchmod (change mode) ： 修改用户的权限。\n\n​    我们以/目录下的目录为例，查看他们的权限和属性。\n[root@VM-4-9-centos &#x2F;]# ls -al\ntotal 80\ndr-xr-xr-x.  19 root root  4096 Jun 18 11:08 .\ndr-xr-xr-x.  19 root root  4096 Jun 18 11:08 ..\nlrwxrwxrwx.   1 root root     7 Mar  7  2019 bin -&gt; usr&#x2F;bin\ndr-xr-xr-x.   5 root root  4096 May 17 10:32 boot\ndrwxr-xr-x    2 root root  4096 Nov  5  2019 data\ndrwxr-xr-x   20 root root  3040 Jun 17 11:27 dev\ndrwxr-xr-x.  96 root root 12288 Jun 17 11:27 etc\ndrwxr-xr-x.   4 root root  4096 Jun 17 20:57 home\nlrwxrwxrwx.   1 root root     7 Mar  7  2019 lib -&gt; usr&#x2F;lib\nlrwxrwxrwx.   1 root root     9 Mar  7  2019 lib64 -&gt; usr&#x2F;lib64\ndrwx------.   2 root root 16384 Mar  7  2019 lost+found\ndrwxr-xr-x.   2 root root  4096 Apr 11  2018 media\ndrwxr-xr-x.   2 root root  4096 Apr 11  2018 mnt\ndrwxr-xr-x.   5 root root  4096 Jan  8 18:18 opt\ndr-xr-xr-x  102 root root     0 Jun 17 11:26 proc\ndr-xr-x---.   6 root root  4096 May 17 10:31 root\ndrwxr-xr-x   24 root root   880 Jun 17 11:28 run\nlrwxrwxrwx.   1 root root     8 Mar  7  2019 sbin -&gt; usr&#x2F;sbin\ndrwxr-xr-x.   2 root root  4096 Apr 11  2018 srv\ndr-xr-xr-x   13 root root     0 Jun 17 17:11 sys\ndrwxrwxrwt.   8 root root  4096 Jun 18 10:54 tmp\ndrwxr-xr-x.  14 root root  4096 Jan  8 18:19 usr\ndrwxr-xr-x.  20 root root  4096 Jan  8 18:19 var\n\n[文件类型和权限][硬链接个数][创建者名][所属组名][大小][上一次修改时间][文件名]\n\n\n文件属性lrwxrwxrwx.   1 root root     7 Mar  7  2019 bin -&gt; usr&#x2F;bin\ndr-xr-xr-x.   5 root root  4096 May 17 10:32 boot\n\n在 Linux 中第一个字符代表这个文件是目录、文件或链接文件等等。\n\n当为 d 则是目录\n当为 - 则是文件；\n若是 l 则表示为链接文档(link file)；\n若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；\n若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。\n\n​    \n文件权限lrwxrwxrwx.   1 root root     7 Mar  7  2019 bin -&gt; usr/bin\ndr-xr-xr-x.   5 root root  4096 May 17 10:32 boot\n\n​    接下来的字符中，以三个为一组，且均为 rwx 的三个参数的组合。其中， r 代表可读(read)、 w 代表可写(write)、 x 代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号 - 而已。每个文件的属性由左边第一部分的 10 个字符来确定（如下图）。\n\n​    在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。\n文件权限修改​    Linux文件属性有两种设置方法，一种是数字，一种是符号。\nchmod更改文件9个属性\nchmod [-R] xyz 文件或目录\n\n选项与参数：\n\nxyz : 就是数字类型的权限属性，为 rwx 属性数值的相加。\n-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更\n\n​    Linux 文件的基本权限就有九个，分别是 owner&#x2F;group&#x2F;others(拥有者&#x2F;组&#x2F;其他) 三种身份各有自己的 read&#x2F;write&#x2F;execute 权限。\n先复习一下刚刚上面提到的数据：文件的权限字符为： -rwxrwxrwx ， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照如下：\nr:4   w:2   x:1\n\n每种身份(owner&#x2F;group&#x2F;others)各自的三个权限(r&#x2F;w&#x2F;x)分数是需要累加的，例如当权限为： -rwxrwx— 分数则是：\n\nowner &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\ngroup &#x3D; rwx &#x3D; 4+2+1 &#x3D; 7\nothers&#x3D; — &#x3D; 0+0+0 &#x3D; 0\n\n所以等我们设定权限的变更时，该文件的权限数字就是 770。\n-rwxr-xr-x   1 root       root       14704 Jun 17 20:55 kdum.sh\n[root@VM-4-9-centos home]# chmod 777 kdum.sh\n-rwxrwxrwx   1 root       root       14704 Jun 17 20:55 kdum.sh\n[root@VM-4-9-centos home]# chmod 755 kdum.sh \n-rwxr-xr-x   1 root       root       14704 Jun 17 20:55 kdum.sh\n\n\n\nchgrp：更改文件属组\nchgrp [-R] 属组名 文件名\n\n参数选项\n\n-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。\n\nchown：更改文件属主，也可以同时更改文件属组\n语法：\nchown [–R] 属主名 文件名\nchown [-R] 属主名：属组名 文件名\n\n\n\n\n\nVim编辑器​    所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。但是目前我们使用比较多的是 vim 编辑器。vim 具有程序编辑的能力，可以主动的以字体颜色辨别语法的正确性，方便程序设计。\nvi&#x2F;vim 的使用​    基本上 vi&#x2F;vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。 这三种模式的作用分别是：\n\n\n命令模式用户刚刚启动 vi&#x2F;vim，便进入了命令模式。\n此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。\n以下是常用的几个命令：\n\ni 切换到输入模式，以输入字符。\nx 删除当前光标所在处的字符。\n: 切换到底线命令模式，以在最底一行输入命令。\n\n若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。\n命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。\n输入模式在命令模式下按下i就进入了输入模式。\n在输入模式中，可以使用以下按键：\n\n字符按键以及Shift组合，输入字符\nENTER，回车键，换行\nBACK SPACE，退格键，删除光标前一个字符\nDEL，删除键，删除光标后一个字符\n方向键，在文本中移动光标\nHOME&#x2F;END，移动光标到行首&#x2F;行尾\nPage Up&#x2F;Page Down，上&#x2F;下翻页\nInsert，切换光标为输入&#x2F;替换模式，光标将变成竖线&#x2F;下划线\nESC，退出输入模式，切换到命令模式\n\n底线命令模式在命令模式下按下:（英文冒号）就进入了底线命令模式。底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。在底线命令模式中，基本的命令有（已经省略了冒号）：\n\nq 退出程序\nw 保存文件\n\n按ESC键可随时退出底线命令模式。\n:wq\n\n常用操作\n\n\n功能键\n作用\n\n\n\n[Ctrl] + [f]\n屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)\n\n\n[Ctrl] + [b]\n屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)\n\n\n0 或功能键[Home]\n这是数字『 0 』：移动到这一行的最前面字符处 (常用)\n\n\n$ 或功能键[End]\n移动到这一行的最后面字符处(常用)\n\n\ngg\n移动到这个档案的第一行，相当于 1G 啊！ (常用)\n\n\nn\nn 为数字。光标向下移动 n 行(常用)\n\n\n&#x2F;word\n向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 &#x2F;vbird 即可！ (常用)\n\n\n?word\n向光标之上寻找一个字符串名称为 word 的字符串。\n\n\nn\n这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 &#x2F;vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！\n\n\nN\n这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 &#x2F;vbird 后，按下 N 则表示『向上』搜寻 vbird 。\n\n\nx, X\n在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)\n\n\ndd\n删除游标所在的那一整行(常用)\n\n\nndd\nn 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 (常用)\n\n\nyy\n复制游标所在的那一行(常用)\n\n\nu\n复原前一个动作。(常用)\n\n\n[Ctrl]+r\n重做上一个动作。(常用)\n\n\n.\n不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)\n\n\n:wq\n储存后离开，若为 :wq! 则为强制储存后离开 (常用)\n\n\n用户和用户组管理​    Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。\n​    用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。\n​    每个用户账号都拥有一个唯一的用户名和各自的口令。\n​    用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。\n实现用户账号的管理，要完成的工作主要有如下几个方面：\n\n用户账号的添加、删除与修改。\n用户口令的管理。\n用户组的管理。\n\n用户账号的管理useradd添加新的用户\n使用root用户添加，其他用户初始没有权限。\nuseradd [选项] [用户名]\n\n参数说明：\n\n选项:\n\n-c comment 指定一段注释性描述。\n-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。\n-g 用户组 指定用户所属的用户组。\n-G 用户组，用户组 指定用户所属的附加组。\n-s Shell文件 指定用户的登录Shell。\n-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。\n\n\n用户名:\n指定新账号的登录名。\n\n\n[本质]:这个命令在 /etc/passwd 中添加了一个用户的信息，同时更新其他系统文件如/etc/shadow, /etc/group等。\n[root@VM-4-9-centos &#x2F;]# adduser -m zhangfan \n[root@VM-4-9-centos &#x2F;]# cd home&#x2F;\n[root@VM-4-9-centos home]# ls\nlighthouse  test1  zhangfan  \n\n\n\nuserdel删除帐号\nuserdel [选项] [用户名]\n\n常用的选项是 -r，它的作用是把用户的主目录一起删除。\n[root@VM-4-9-centos etc]# userdel -r zhangfan\n[root@VM-4-9-centos etc]# cd &#x2F;home\n[root@VM-4-9-centos home]# ls\nlighthouse  test1 \n\n\n\nusermod修改帐号\nusermod [选项] [用户名]\n\n常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。\n另外，有些系统可以使用选项：-l 新用户名\n这个选项指定一个新的账号，即将原来的用户名改为新的用户名。\n[root@VM-4-9-centos home]# usermod -d &#x2F;home&#x2F;zhang zhangfan\nusermod: user &#39;zhangfan&#39; does not exist\n[root@VM-4-9-centos home]# useradd -m  zhangfan\n[root@VM-4-9-centos home]# usermod -d &#x2F;home&#x2F;zhang zhangfan\n[root@VM-4-9-centos home]# ls\nkdum.sh  lighthouse  test1  zhangfan  zhang.txt\n[root@VM-4-9-centos home]# cat &#x2F;etc&#x2F;passwd\nroot:x:0:0:root:&#x2F;root:&#x2F;bin&#x2F;bash\n...\nzhangfan:x:1001:1001::&#x2F;home&#x2F;zhang:&#x2F;bin&#x2F;bash\n\n\n\nsu切换用户\n[root@F4N ~]# su zhangfan\n[zhangfan@F4N root]$ \n\n\n\npasswd密码管理\npasswd 选项 用户名\n\n可使用的选项：\n\n-l 锁定口令，即禁用账号。\n-u 口令解锁。\n-d 使账号无口令。\n-f 强迫用户下次登录时修改口令。\n\n如果默认用户名，则修改当前用户的口令。\n如果是超级用户，可以用下列形式指定任何用户的口令：\n# passwd [username] \nNew password:******* \nRe-enter new password:*******\n\n假设当前用户是普通，则下面的命令修改该用户自己的口令：\n$ passwd \nOld password:****** \nNew password:******* \nRe-enter new password:*******\n\n\n\n锁定用户\n[root@F4N home]# passwd -l zhangfan  \t#冻结账户\nLocking password for user zhangfan.\npasswd: Success\n\n[root@F4N home]# passwd -d zhangfan \t#删除密码而达到锁定目的\nRemoving password for user zhangfan.\npasswd: Success\n\n\n\n用户组​    每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。用户组的管理涉及用户组的添加、删除和修改。\n​    组的增加、删除和修改实际上就是对/etc/group文件的更新。\ngroupadd创建用户组\ngroupadd 选项 用户组\n\n可以使用的选项有：\n\n-g GID 指定新用户组的组标识号（GID）。\n-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。\n\n[root@F4N home]# groupadd zhangfan\n[root@F4N home]# cat &#x2F;etc&#x2F;group\nroot:x:0:\n...\nzhangfan:x:1001: #新组的组标识号是在当前已有的最大组标识号的基础上加1。\n[root@F4N home]# groupadd -g 250 zhangfan2\n[root@F4N home]# cat &#x2F;etc&#x2F;group\nroot:x:0:\n...\nzhangfan:x:1001:\nzhangfan2:x:250:\n\n\n\ngroupmod修改用户组\ngroupmod 选项 用户组\n\n常用的选项有：\n\n-g GID 为用户组指定新的组标识号。\n-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。\n-n新用户组 将用户组的名字改为新名字\n\n# groupmod –g 10000 -n group3 group2\n此命令将组group2的标识号改为10000，组名修改为group3。\n\n\n\ngroupdel删除组\ngroupdel 用户组\n\n\n\n用户账号有关的系统文件完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。\n与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括&#x2F;etc&#x2F;passwd, &#x2F;etc&#x2F;shadow, &#x2F;etc&#x2F;group等。\n下面分别介绍这些文件的内容。\n1、&#x2F;etc&#x2F;passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在&#x2F;etc&#x2F;passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。\n这个文件对所有用户都是可读的。它的内容类似下面的例子：\n＃ cat &#x2F;etc&#x2F;passwd\n\nroot:x:0:0:Superuser:&#x2F;:\ndaemon:x:1:1:System daemons:&#x2F;etc:\nbin:x:2:2:Owner of system commands:&#x2F;bin:\nsys:x:3:3:Owner of system files:&#x2F;usr&#x2F;sys:\nadm:x:4:4:System accounting:&#x2F;usr&#x2F;adm:\nuucp:x:5:5:UUCP administrator:&#x2F;usr&#x2F;lib&#x2F;uucp:\nauth:x:7:21:Authentication administrator:&#x2F;tcb&#x2F;files&#x2F;auth:\ncron:x:9:16:Cron daemon:&#x2F;usr&#x2F;spool&#x2F;cron:\nlisten:x:37:4:Network daemon:&#x2F;usr&#x2F;net&#x2F;nls:\nlp:x:71:18:Printer administrator:&#x2F;usr&#x2F;spool&#x2F;lp:\nsam:x:200:50:Sam san:&#x2F;home&#x2F;sam:&#x2F;bin&#x2F;sh\n\n从上面的例子我们可以看到，&#x2F;etc&#x2F;passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：\n用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell\n\n1）”用户名”是代表用户账号的字符串。\n通常长度不超过8个字符，并且由大小写字母和&#x2F;或数字组成。登录名中不能有冒号(:)，因为冒号在这里是分隔符。\n为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。\n2）“口令”一些系统中，存放着加密后的用户口令字。\n虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于&#x2F;etc&#x2F;passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到&#x2F;etc&#x2F;shadow文件中，而在&#x2F;etc&#x2F;passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。\n3）“用户标识号”是一个整数，系统内部用它来标识用户。\n一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。\n通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。\n4）“组标识号”字段记录的是用户所属的用户组。\n它对应着&#x2F;etc&#x2F;group文件中的一条记录。\n5)“注释性描述”字段记录着用户的一些个人情况。\n例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。\n6)“主目录”，也就是用户的起始工作目录。\n它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。\n7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。\nShell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX&#x2F;TOPS-20 type C Shell), bash(Bourne Again Shell)等。\n系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为&#x2F;bin&#x2F;sh。\n用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。\n利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。\n8)系统中有一类用户称为伪用户（pseudo users）。\n这些用户在&#x2F;etc&#x2F;passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。\n常见的伪用户如下所示：\n伪 用 户 含 义 \nbin 拥有可执行的用户命令文件 \nsys 拥有系统文件 \nadm 拥有帐户文件 \nuucp UUCP使用 \nlp lp或lpd子系统使用 \nnobody NFS使用\n\n\n2、拥有帐户文件1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。\n由于&#x2F;etc&#x2F;passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是&#x2F;etc&#x2F;shadow文件。 有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。\n2、&#x2F;etc&#x2F;shadow中的记录行与&#x2F;etc&#x2F;passwd中的一一对应，它由pwconv命令根据&#x2F;etc&#x2F;passwd中的数据自动产生\n它的文件格式与&#x2F;etc&#x2F;passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：\n登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n\n“登录名”是与&#x2F;etc&#x2F;passwd文件中的登录名相一致的用户账号\n“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { .&#x2F;0-9A-Za-z }中的字符，则对应的用户不能登录。\n“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。\n“最小时间间隔”指的是两次修改口令之间所需的最小天数。\n“最大时间间隔”指的是口令保持有效的最大天数。\n“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。\n“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。\n“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。\n\n下面是&#x2F;etc&#x2F;shadow的一个例子：\n＃ cat &#x2F;etc&#x2F;shadow\n\nroot:Dnakfw28zf38w:8764:0:168:7:::\ndaemon:*::0:0::::\nbin:*::0:0::::\nsys:*::0:0::::\nadm:*::0:0::::\nuucp:*::0:0::::\nnuucp:*::0:0::::\nauth:*::0:0::::\ncron:*::0:0::::\nlisten:*::0:0::::\nlp:*::0:0::::\nsam:EkdiSECLWPdSa:9740:0:0::::\n\n3、用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。\n每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。\n当一个用户同时是多个组中的成员时，在&#x2F;etc&#x2F;passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。\n用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。\n用户组的所有信息都存放在&#x2F;etc&#x2F;group文件中。此文件的格式也类似于&#x2F;etc&#x2F;passwd文件，由冒号(:)隔开若干个字段，这些字段有：\n组名:口令:组标识号:组内用户列表\n\n\n“组名”是用户组的名称，由字母或数字构成。与&#x2F;etc&#x2F;passwd中的登录名一样，组名不应重复。\n“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。\n“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。\n“组内用户列表”是属于这个组的所有用户的列表&#x2F;b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。\n\n&#x2F;etc&#x2F;group文件的一个例子如下：\nroot::0:root\nbin::2:root,bin\nsys::3:root,uucp\nadm::4:root,adm\ndaemon::5:root,daemon\nlp::7:root,lp\nusers::20:root,sam\n\n\n\n\n\n磁盘管理Linux磁盘管理好坏直接关系到整个系统的性能问题。\nLinux磁盘管理常用三个命令为df、du和fdisk。\n\ndf：列出文件系统的整体磁盘使用量\ndu：检查磁盘空间使用量\nfdisk：用于磁盘分区\n\ndf 检查文件系统的磁盘空间占用情况df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。\n语法：\ndf [-ahikHTm] [目录或文件名]\n\n选项与参数：\n\n-a ：列出所有的文件系统，包括系统特有的 &#x2F;proc 等文件系统；\n-k ：以 KBytes 的容量显示各文件系统；\n-m ：以 MBytes 的容量显示各文件系统；\n-h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；\n-H ：以 M&#x3D;1000K 取代 M&#x3D;1024K 的进位方式；\n-T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；\n-i ：不用硬盘容量，而以 inode 的数量来显示\n\n[root@F4N home]# df -h\nFilesystem      Size  Used Avail Use% Mounted on\ndevtmpfs        908M     0  908M   0% &#x2F;dev\ntmpfs           919M   24K  919M   1% &#x2F;dev&#x2F;shm\ntmpfs           919M  556K  919M   1% &#x2F;run\ntmpfs           919M     0  919M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup\n&#x2F;dev&#x2F;vda1        59G  3.8G   53G   7% &#x2F;\ntmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;0\n\n\n\ndu 对文件和目录磁盘使用的空间的查看Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的，这里介绍Linux du命令。\n语法：\ndu [-ahskm] 文件或目录名称\n\n选项与参数：\n\n-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。\n-h ：以人们较易读的容量格式 (G&#x2F;M) 显示；\n-s ：列出总量而已，而不列出每个各别的目录占用容量；\n-S ：不包括子目录下的总计，与 -s 有点差别。\n-k ：以 KBytes 列出容量显示；\n-m ：以 MBytes 列出容量显示；\n\n[root@F4N home]# du -sm &#x2F;*    #查看占用最多的文件夹\n0\t&#x2F;bin\n123\t&#x2F;boot\n1\t&#x2F;data\n0\t&#x2F;dev\n37\t&#x2F;etc\n...\n1\t&#x2F;srv\n0\t&#x2F;sys\n1\t&#x2F;tmp\n2791\t&#x2F;usr\n761\t&#x2F;var\n\nfdisk 磁盘分区表fdisk 是 Linux 的磁盘分区表操作工具。\n语法：\nfdisk [-l] 装置名称\n\n选项与参数：\n\n-l ：输出后面接的装置所有的分区内容。若仅有 fdisk -l 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来。\n\n[root@F4N mnt]# fdisk -l\n\nDisk &#x2F;dev&#x2F;vda: 64.4 GB, 64424509440 bytes, 125829120 sectors\nUnits &#x3D; sectors of 1 * 512 &#x3D; 512 bytes\nSector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes\nI&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes\nDisk label type: dos\nDisk identifier: 0x0009ac89\n\n   Device Boot      Start         End      Blocks   Id  System\n&#x2F;dev&#x2F;vda1   *        2048   125829086    62913519+  83  Linux\n\n\n\n\n\n磁盘挂载与卸除Linux 的磁盘挂载使用 mount 命令，卸载使用 umount 命令。\n磁盘挂载语法：\nmount [-t 文件系统] [-L Label名] [-o 额外选项] [-n]  装置文件名  挂载点\n\n用默认的方式，将刚刚创建的 &#x2F;dev&#x2F;hdc6 挂载到 &#x2F;mnt&#x2F;hdc6 上面！\n[root@www ~]# mkdir &#x2F;mnt&#x2F;hdc6\n[root@www ~]# mount &#x2F;dev&#x2F;hdc6 &#x2F;mnt&#x2F;hdc6\n[root@www ~]# df\nFilesystem           1K-blocks      Used Available Use% Mounted on\n.....中间省略.....\n&#x2F;dev&#x2F;hdc6              1976312     42072   1833836   3% &#x2F;mnt&#x2F;hdc6\n\n磁盘卸载命令 umount 语法：\numount [-fn] 装置文件名或挂载点\n\n选项与参数：\n\n-f ：强制卸除！可用在类似网络文件系统 (NFS) 无法读取到的情况下；\n-n ：不升级 &#x2F;etc&#x2F;mtab 情况下卸除。\n\n卸载&#x2F;dev&#x2F;hdc6\n[root@www ~]# umount &#x2F;dev&#x2F;hdc6     \n\n\n\n\n\n进程管理ps查看进程信息\nLinux ps （英文全拼：process status）命令用于显示当前进程的状态，类似于 windows 的任务管理器。\nps [options] [--help]\n\n参数：\n\n-A 列出所有的进程\n\n-a 列出当前运行的进程\n\n-w 显示加宽可以显示较多的资讯\n\n-au 显示较详细的资讯\n\n-aux 显示所有包含其他使用者的行程\n\nau(x) 输出格式 :\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\n\n\nUSER: 行程拥有者\nPID: pid\n%CPU: 占用的 CPU 使用率\n%MEM: 占用的记忆体使用率\nVSZ: 占用的虚拟记忆体大小\nRSS: 占用的记忆体大小\nTTY: 终端的次要装置号码 (minor device number of tty)\nSTAT: 该行程的状态:\nD: 无法中断的休眠状态 (通常 IO 的进程)\nR: 正在执行中\nS: 静止状态\nT: 暂停执行\nZ: 不存在但暂时无法消除\nW: 没有足够的记忆体分页可分配\n&lt;: 高优先序的行程\nN: 低优先序的行程\nL: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I&#x2F;O)\n\n\nSTART: 行程开始时间\nTIME: 执行的时间\nCOMMAND:所执行的指令\n\n\n\n[root@F4N &#x2F;]# ps -au\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot      1334  0.0  0.0 110208   868 ttyS0    Ss+  Jun17   0:00 &#x2F;sbin&#x2F;agetty --keep-baud 115200,38400,9600 ttyS0\nroot      1335  0.0  0.0 110208   856 tty1     Ss+  Jun17   0:00 &#x2F;sbin&#x2F;agetty --noclear tty1 linux\nroot     19471  0.0  0.1 116420  3044 pts&#x2F;0    Ss   15:11   0:00 -bash\nroot     30682  0.0  0.0 155452  1868 pts&#x2F;0    R+   16:19   0:00 ps -au\n\n[root@F4N &#x2F;]# ps -aux|grep mysql\nroot     31007  0.0  0.0 112812   972 pts&#x2F;0    R+   16:21   0:00 grep --color&#x3D;auto mysql\n# | 在linux中成为管道符 A|B\n#grep进行过滤,筛选符合条件的字符串\n\n\n\npstree进程树状图\nLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。\npstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]\n\n常用:\n\n-p 显示父id\n-u 显示用户组\n\n[root@F4N &#x2F;]# pstree -pu\nsystemd(1)─┬─YDLive(1698)─┬─&#123;YDLive&#125;(1699)\n           │              ├─&#123;YDLive&#125;(1700)\n...\n           ├─rshim(1045)───&#123;rshim&#125;(1065)\n           ├─rsyslogd(1262)─┬─&#123;rsyslogd&#125;(1280)\n           │                └─&#123;rsyslogd&#125;(1313)\n           ├─sgagent(1819)───&#123;sgagent&#125;(1820)\n           ├─sshd(1556)─┬─sshd(19464)───bash(19471)───pstree(32457)\n           │            └─sshd(19489)───sftp-server(19506)\n           ├─systemd-journal(365)\n           ├─systemd-logind(563)\n           ├─systemd-udevd(397)\n           ├─tat_agent(1275)─┬─&#123;tat_agent&#125;(1281)\n           │                 ├─&#123;tat_agent&#125;(1320)\n           │                 ├─&#123;tat_agent&#125;(1321)\n           │                 └─&#123;tat_agent&#125;(1325)\n           └─tuned(1040)─┬─&#123;tuned&#125;(1367)\n                         ├─&#123;tuned&#125;(1368)\n                         ├─&#123;tuned&#125;(1386)\n                         └─&#123;tuned&#125;(1392)\n\n\n\nkill结束进程\nkill [-s &lt;信息名称或编号&gt;][程序]　或　kill [-l &lt;信息编号&gt;]\n\n参数说明：\n\n-l &lt;信息编号&gt; 　若不加&lt;信息编号&gt;选项，则 -l 参数会列出全部的信息名称。\n-s &lt;信息名称或编号&gt; 　指定要送出的信息。\n[程序] 　[程序]可以是程序的PID或是PGID，也可以是工作编号。\n\n使用 kill -l 命令列出所有可用信号。\n最常用的信号是：\n\n1 (HUP)：重新加载进程。\n9 (KILL)：杀死一个进程。\n15 (TERM)：正常停止一个进程。\n\n杀死进程\n# kill 12345\n\n彻底杀死进程\n# kill -9 123456\n\n\n\n硬件信息查看lscpu命令\nlscpu命令能够查看 CPU 和处理单元的信息。该命令没有任何其他选项或者别的功能。\nlscpu\n\n\n\nlspci查看PCI总线\nlspci是另一个命令行工具，可以用来列出所有的 PCI 总线，还有与 PCI 总线相连的设备的详细信息，比如 VGA 适配器、显卡、网络适配器、usb 端口、SATA 控制器等。\nlspci -v | grep &quot;VGA&quot; -A 12 #可以过滤出特定设备的信息\n\n\n\n防火墙设置查看防火墙状态:\nsystemctl status firewalld\n\n开启防火墙:\nsystemctl start firewalld\n\n关闭防火墙:\nsystemctl stop firewalld\n\n开机启动和禁用防火墙:\nsystemctl disable firewalld #开机禁用\nsystemctl enable firewalld \t#开机启用 \n\n防火墙配置立刻生效:\nfirewall-cmd --reload\n\n查看防火墙开放的端口:\nfirewall-cmd --zone&#x3D;public --list-ports\n\n打开某一端口:\nfirewall-cmd --permanent --zone&#x3D;public --add-port&#x3D;3306&#x2F;tcp\n#–zone #作用域\n#–add-port&#x3D;80&#x2F;tcp #添加端口，格式为：端口&#x2F;通讯协议\n#–permanent #永久生效，没有此参数重启后失效\n#firewall-cmd --reload 并不中断用户连接，即不丢失状态信息\n#开放端口后需重载防火墙\nfirewall-cmd --reload\n\n关闭某一端口:\nfirewall-cmd --zone&#x3D;public --remove-port&#x3D;8081&#x2F;tcp --permanent  \n\n\n\n\n\n\n\n程序安装一般安装软件有三种方式:\n\nrpm。\n​    Linux rpm 命令用于管理套件。\n​    rpm（英文全拼：redhat package manager） 原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。\n\n解压缩。\n\nyum在线安装。\nyum常用命令:\n\n列出所有可更新的软件清单命令：yum check-update\n更新所有软件命令：yum update\n仅安装指定的软件命令：yum install \n仅更新指定的软件命令：yum update \n列出所有可安裝的软件清单命令：yum list\n删除软件包命令：yum remove \n查找软件包命令：yum search \n清除缓存命令:\nyum clean packages: 清除缓存目录下的软件包\nyum clean headers: 清除缓存目录下的 headers\nyum clean oldheaders: 清除缓存目录下旧的 headers\nyum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的 headers\n\n\n\n\n\nJDK安装使用的解压缩安装，官方下载JDK，jdk-8u161-linux-x64.tar.gz，在&#x2F;usr目录下java文件夹，将jdk.gz放入，然后进行解压缩\ntar -zxvf jdk-8u161-linux-x64.tar.gz\n\n[root@F4N etc]# cd &#x2F;usr&#x2F;java&#x2F;\n[root@F4N java]# ls\njdk1.8.0_161  jdk-8u161-linux-x64.tar.gz\n\n然后在/etc/profile文件中添加环境变量:\nvim &#x2F;etc&#x2F;profile\n\n在profile文件末尾中添加如下环境变量:\n# Java Environment Path\nexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.8.0_161\nexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATH\nexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar\n\n执行source命令让文件生效:\nsource &#x2F;etc&#x2F;profile\n\n查看Java是否安装成功，出现版本号表示安装成功。\n[root@F4N etc]# source &#x2F;etc&#x2F;profile\n[root@F4N etc]# java -version\njava version &quot;1.8.0_161&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_161-b12)\nJava HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)\n\n\n\nTomcat安装\n下载 tomcat9 的压缩包tar.gz。\n下载地址：https://downloads.apache.org/tomcat/tomcat-9/v9.0.48/bin/apache-tomcat-9.0.48.tar.gz\n\n将下载的压缩包上传到云服务器的/usr目录下，新建目录 tomcat ，将压缩包移入并解压。\ntar -zxvf apache-tomcat-9.0.48.tar.gz\n\n解压后，进入/usr/tomcat/apache-tomcat-9.0.48/bin目录，执行startup.sh \n#启动 .&#x2F;startup.sh \n#终止 .&#x2F;shutdown.sh \n\n[root@F4N bin]# .&#x2F;startup.sh \nUsing CATALINA_BASE:   &#x2F;usr&#x2F;tomcat&#x2F;apache-tomcat-9.0.48\nUsing CATALINA_HOME:   &#x2F;usr&#x2F;tomcat&#x2F;apache-tomcat-9.0.48\nUsing CATALINA_TMPDIR: &#x2F;usr&#x2F;tomcat&#x2F;apache-tomcat-9.0.48&#x2F;temp\nUsing JRE_HOME:        &#x2F;usr&#x2F;java&#x2F;jdk1.8.0_161\nUsing CLASSPATH:       &#x2F;usr&#x2F;tomcat&#x2F;apache-tomcat-9.0.48&#x2F;bin&#x2F;bootstrap.jar:&#x2F;usr&#x2F;tomcat&#x2F;apache-tomcat-9.0.48&#x2F;bin&#x2F;tomcat-juli.jar\nUsing CATALINA_OPTS:   \nTomcat started.\n\n由于Tomcat使用的是8080端口，需要在防火墙中打开对应的端口访问权限\n[root@F4N bin]# systemctl status firewalld \t\t\t#查看防火墙状态，如果是关闭（dead）的，需要打开防火墙\n● firewalld.service - firewalld - dynamic firewall daemon\n   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;firewalld.service; disabled; vendor preset: enabled)\n   Active: active (running) since Tue 2021-06-22 10:15:18 CST; 26min ago\n     Docs: man:firewalld(1)\n Main PID: 10649 (firewalld)\n   CGroup: &#x2F;system.slice&#x2F;firewalld.service\n           └─10649 &#x2F;usr&#x2F;bin&#x2F;python2 -Es &#x2F;usr&#x2F;sbin&#x2F;firewalld --nofork --nopid\n\nJun 22 10:15:18 F4N systemd[1]: Starting firewalld - dynamic firewall daemon...\nJun 22 10:15:18 F4N systemd[1]: Started firewalld - dynamic firewall daemon.\nJun 22 10:15:18 F4N firewalld[10649]: WARNING: AllowZoneDrifting is enabled. This is considered an insecu... now.\nJun 22 10:19:42 F4N firewalld[10649]: WARNING: AllowZoneDrifting is enabled. This is considered an insecu... now.\nJun 22 10:28:48 F4N firewalld[10649]: WARNING: AllowZoneDrifting is enabled. This is considered an insecu... now.\nJun 22 10:32:34 F4N firewalld[10649]: WARNING: AllowZoneDrifting is enabled. This is considered an insecu... now.\nHint: Some lines were ellipsized, use -l to show in full.\n[root@F4N bin]# systemctl start firewalld\t\t\t#打开防火墙\n[root@F4N bin]# firewall-cmd --list-ports\t\t\t#查看开启的端口号,如果没有开启,需要手动开启端口\n3306&#x2F;tcp 80&#x2F;tcp 443&#x2F;tcp 22&#x2F;tcp 3389&#x2F;tcp 8080&#x2F;tcp\n[root@F4N bin]# firewall-cmd --permanent --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp\t#打开8080端口\nsuccess\n[root@F4N bin]# firewall-cmd --reload\t\t\t\t#重启防火墙\nsuccess\n\n在云服务器防火墙配置中打开8080端口\n\n\n可以通过公网IP地址进行访问了\n\n\n\nDocker安装​    Docker 是一个开源的应用容器引擎，基于 Go语言 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n​    容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\n\n卸载旧版本Docker\n[root@F4N bin]#  yum remove docker \\\n&gt;                   docker-client \\\n&gt;                   docker-client-latest \\\n&gt;                   docker-common \\\n&gt;                   docker-latest \\\n&gt;                   docker-latest-logrotate \\\n&gt;                   docker-logrotate \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror, langpacks\nNo Match for argument: docker\nNo Match for argument: docker-client\nNo Match for argument: docker-client-latest\nNo Match for argument: docker-common\nNo Match for argument: docker-latest\nNo Match for argument: docker-latest-logrotate\nNo Match for argument: docker-logrotate\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n安装前置需要的一些软件包\nyum install -y lvm2 device-mapper-persistent-data yum-utils\n\n[root@F4N bin]# yum install -y lvm2 device-mapper-persistent-data yum-utils\nLoaded plugins: fastestmirror, langpacks\nLoading mirror speeds from cached hostfile\nPackage 7:lvm2-2.02.187-6.el7_9.5.x86_64 already installed and latest version\nPackage device-mapper-persistent-data-0.8.5-3.el7_9.2.x86_64 already installed and latest version\nPackage yum-utils-1.1.31-54.el7_8.noarch already installed and latest version\nNothing to do\n\n安装Docker，使用阿里云镜像\n[root@F4N bin]# yum-config-manager   --add-repo   http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\nLoaded plugins: fastestmirror, langpacks\nadding repo from: http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo\ngrabbing file http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo to &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo\nrepo saved to &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repo\n\n更新yum软件包索引\nyum makecache fast\n\n下载安装Docker CE\nyum -y install docker-ce docker-ce-cli containerd.io\n\n启动docker\nsystemctl start docker\n\n测试docker是否安装成功,并运行hello world程序\n[root@F4N bin]# docker version\nClient: Docker Engine - Community\n Version:           20.10.7\n API version:       1.41\n Go version:        go1.13.15\n Git commit:        f0df350\n Built:             Wed Jun  2 11:58:10 2021\n OS&#x2F;Arch:           linux&#x2F;amd64\n Context:           default\n Experimental:      true\n\nServer: Docker Engine - Community\n Engine:\n  Version:          20.10.7\n  API version:      1.41 (minimum version 1.12)\n  Go version:       go1.13.15\n  Git commit:       b0f5bc3\n  Built:            Wed Jun  2 11:56:35 2021\n  OS&#x2F;Arch:          linux&#x2F;amd64\n  Experimental:     false\n containerd:\n  Version:          1.4.6\n  GitCommit:        d71fcd7d8303cbf684402823e425e9dd2e99285d\n runc:\n  Version:          1.0.0-rc95\n  GitCommit:        b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7\n docker-init:\n  Version:          0.19.0\n  GitCommit:        de40ad0\n  \n[root@F4N bin]# docker run hello-world\nUnable to find image &#39;hello-world:latest&#39; locally\nlatest: Pulling from library&#x2F;hello-world\nb8dfde127a29: Pull complete \nDigest: sha256:9f6ad537c5132bcce57f7a0a20e317228d382c3cd61edae14650eec68b2b345c\nStatus: Downloaded newer image for hello-world:latest\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\nTo generate this message, Docker took the following steps:\n 1. The Docker client contacted the Docker daemon.\n 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.\n    (amd64)\n 3. The Docker daemon created a new container from that image which runs the\n    executable that produces the output you are currently reading.\n 4. The Docker daemon streamed that output to the Docker client, which sent it\n    to your terminal.\n\nTo try something more ambitious, you can run an Ubuntu container with:\n $ docker run -it ubuntu bash\n\nShare images, automate workflows, and more with a free Docker ID:\n https:&#x2F;&#x2F;hub.docker.com&#x2F;\n\nFor more examples and ideas, visit:\n https:&#x2F;&#x2F;docs.docker.com&#x2F;get-started&#x2F;\n\n","slug":"Linux基础","date":"2022-04-08T03:19:19.000Z","categories_index":"互联网八股","tags_index":"Linux,Linux命令","author_index":"张 凡"},{"id":"21192bc96d4d1e6c92e0c329a20feea9","title":"Java IO/集合类","content":"集合类容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对(两个对象)的映射表。\nCollectiona. SetSet:注重独一无二的性质,该体系集合可以知道某物是否已近存在于集合中,不会存储重复的元素\n用于存储无序(存入和取出的顺序不一定相同)元素，值不能重复。\n1. HashSet基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。\nHashSet是通过对HashMap进行了一层包装而实现的,也就是说HashSet里面有一个HashMap(适配器模式)。\n&#x2F;&#x2F;HashSet是对HashMap的简单包装\npublic class HashSet&lt;E&gt;\n&#123;\n\t......\n\tprivate transient HashMap&lt;E,Object&gt; map;&#x2F;&#x2F;HashSet里面有一个HashMap\n    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT &#x3D; new Object();\n    public HashSet() &#123;\n        map &#x3D; new HashMap&lt;&gt;();\n    &#125;\n    ......\n    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换\n        return map.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;\n\n\n\n2. TreeSet基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。\nTreeSet和TreeMap二者在Java里有着相同的实现，TreeSet仅仅是对TreeMap做了一层包装，也就是说TreeSet里面有一个TreeMap(适配器模式)。\n&#x2F;&#x2F; TreeSet是对TreeMap的简单包装\npublic class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;\n    implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable\n&#123;\n\t......\n    private transient NavigableMap&lt;E,Object&gt; m;\n    &#x2F;&#x2F; Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT &#x3D; new Object();\n    public TreeSet() &#123;\n        this.m &#x3D; new TreeMap&lt;E,Object&gt;();&#x2F;&#x2F; TreeSet里面有一个TreeMap\n    &#125;\n    ......\n    public boolean add(E e) &#123;\n        return m.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;\n\n\n\n\n\n\n3. LinkedHashSet具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\nLinkedHashSet是对LinkedHashMap的简单包装，对LinkedHashSet的函数调用都会转换成合适的LinkedHashMap方法，因此LinkedHashSet的实现非常简单，这里不再赘述。\npublic class LinkedHashSet&lt;E&gt;\n    extends HashSet&lt;E&gt;\n    implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123;\n    ......\n    &#x2F;&#x2F; LinkedHashSet里面有一个LinkedHashMap\n    public LinkedHashSet(int initialCapacity, float loadFactor) &#123;\n        map &#x3D; new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);\n    &#125;\n\t......\n    public boolean add(E e) &#123;&#x2F;&#x2F;简单的方法转换\n        return map.put(e, PRESENT)**null;\n    &#125;\n    ......\n&#125;\n\n\n\n\n\n\nb. ListList 是一个接口，它继承于Collection的接口。它代表着有序的队列。当我们讨论List的时候，一般都和Set作比较。\n1. ArrayList基于动态数组实现，支持随机访问。\nArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。\n每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小，容器内存储元素的个数不能多于当前容量。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。\n前面已经提过，Java泛型只是编译器提供的语法糖，所以这里的数组是一个Object数组，以便能够容纳任何类型的对象。\nadd(int index, E e) 需要先对元素进行移动，然后完成插入操作，也就意味着该方法有着线性的时间复杂度。\ntrimToSize() 将底层数组的容量调整为当前列表保存的实际元素的大小的功能。\n自动扩容机制数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现。在实际添加大量元素前，我也可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。\n数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。这种操作的代价是很高的，因此在实际使用时，我们应该尽量避免数组容量的扩张。当我们可预知要保存的元素的多少时，要在构造ArrayList实例时，就指定其容量，以避免数组扩容的发生。或者根据实际需求，通过调用ensureCapacity方法来手动增加ArrayList实例的容量。\n扩容操作最终是通过grow()方法完成的,其核心代码如下:\n&#x2F;**\n* Increases the capacity to ensure that it can hold at least the\n* number of elements specified by the minimum capacity argument.\n*\n* @param minCapacity the desired minimum capacity\n*&#x2F;\nprivate void grow(int minCapacity) &#123;\n    &#x2F;&#x2F; overflow-conscious code\n    int oldCapacity &#x3D; elementData.length;\n    int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1);\n    if (newCapacity - minCapacity &lt; 0)\n        newCapacity &#x3D; minCapacity;\n    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)\n        newCapacity &#x3D; hugeCapacity(minCapacity);\n    &#x2F;&#x2F; minCapacity is usually close to size, so this is a win:\n    elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n&#125;\n\nprivate static int hugeCapacity(int minCapacity) &#123;\n    if (minCapacity &lt; 0) &#x2F;&#x2F; overflow\n        throw new OutOfMemoryError();\n    return (minCapacity &gt; MAX_ARRAY_SIZE) ?\n        Integer.MAX_VALUE :\n    MAX_ARRAY_SIZE;\n&#125;\n\n\n\n\n\n2. LinkedList基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。\n不仅如此，LinkedList 还可以用作栈、队列和双向队列。\nprivate static class Node&lt;E&gt; &#123;\n    E item;\n    Node&lt;E&gt; next;\n    Node&lt;E&gt; prev;\n\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item &#x3D; element;\n        this.next &#x3D; next;\n        this.prev &#x3D; prev;\n    &#125;\n&#125;\n\n3. Vector和 ArrayList 类似，但它是线程安全的。\n4. Stack 和 QueueJava里有一个叫做Stack的类，却没有叫做Queue的类(它是个接口名字)。\n当需要使用栈时，Java已不推荐使用Stack，而是推荐使用更高效的ArrayDeque；\n既然Queue只是一个接口，*当需要使用队列时也就首选ArrayDeque了(次选是LinkedList*)**。\n5. DequeDeque的含义是“double ended queue”，即双端队列，它既可以当作栈使用，也可以当作队列使用。\nArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，该数组还必须是循环的，即**循环数组(circular array)**，也就是说数组的任何一点都可能被看作起点或者终点。\n**ArrayDeque是非线程安全的(not thread-safe)**，当多个线程同时使用的时候，需要程序员手动同步；另外，该容器不允许放入null元素。\n其中,JDK中对于双端队列的插入很有一套:\n&#x2F;&#x2F;addFirst(E e)\npublic void addFirst(E e) &#123;\n    if (e ** null)&#x2F;&#x2F;不允许放入null\n        throw new NullPointerException();\n    elements[head &#x3D; (head - 1) &amp; (elements.length - 1)] &#x3D; e;&#x2F;&#x2F;2.下标是否越界\n    if (head ** tail)&#x2F;&#x2F;1.空间是否够用\n        doubleCapacity();&#x2F;&#x2F;扩容\n&#125;\n\n空间问题是在插入之后解决的，因为tail总是指向下一个可插入的空位，也就意味着elements数组至少有一个空位，所以插入元素的时候不用考虑空间问题。\n下标越界的处理: head = (head - 1) &amp; (elements.length - 1)就可以了，这段代码相当于取余，同时解决了head为负值的情况。因为elements.length必需是2的指数倍(扩容决定的)，elements - 1就是二进制低位全1，跟head - 1相与之后就起到了取模的作用，如果head - 1为负数(其实只可能是-1)，则相当于对其取相对于elements.length的补码。\n扩容原理\n其逻辑是申请一个更大的数组(原数组的两倍)，然后将原数组复制过去。过程如下图所示:\n\n\n图中我们看到，为了保持循环数组的性质,复制分两次进行，第一次复制head右边的元素，第二次复制head左边的元素。\n\nc. QueueQueue有两种常见的实现，LinkedList和PriorityQueue\nLinkedList前面已经介绍过。\nPriorityQueue基于堆结构实现，可以用它来实现优先队列。\n优先队列的作用是能保证每次取出的元素都是队列中权值最小的(Java的优先队列每次取最小元素，C++的优先队列每次取最大元素)。这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序(*natural ordering*)，也可以通过构造时传入的比较器(Comparator，类似于C++的仿函数)。\n​    Java中PriorityQueue实现了Queue接口，不允许放入null元素；其通过堆实现，具体说是通过完全二叉树(complete binary tree)实现的小顶堆**(任意一个非叶子节点的权值，都不大于其左右子节点的权值)，也就意味着可以通过数组来作为PriorityQueue的底层实现。**\n\n\nleftNo &#x3D; parentNo*2+1\nrightNo &#x3D; parentNo*2+2\nparentNo &#x3D; (nodeNo-1)&#x2F;2\n\n新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。源码中实现调整结构的代码如下:\n&#x2F;&#x2F;siftUp()\nprivate void siftUp(int k, E x) &#123;\n    while (k &gt; 0) &#123;\n        int parent &#x3D; (k - 1) &gt;&gt;&gt; 1;&#x2F;&#x2F;parentNo &#x3D; (nodeNo-1)&#x2F;2\n        Object e &#x3D; queue[parent];\n        if (comparator.compare(x, (E) e) &gt;&#x3D; 0)&#x2F;&#x2F;调用比较器的比较方法\n            break;\n        queue[k] &#x3D; e;\n        k &#x3D; parent;\n    &#125;\n    queue[k] &#x3D; x;\n&#125;\n\n添加元素时,先默认添加到末尾,然后调整结构;删除堆顶元素时,先默认将最后一个元素放置到堆顶,然后再进行调整。\nMapa. HashMap-JDK7基于哈希表实现。\n根据对冲突的处理方式不同，哈希表有两种实现方式，一种开放地址方式(Open addressing)，另一种是冲突链表方式(Separate chaining with linked lists)。*Java7 HashMap采用的是冲突链表方式。*\n\n\n​    HashMap的put()和get()方法可以在常数时间内完成。但在对HashMap进行迭代时，需要遍历整个table以及后面跟的冲突链表。因此对于迭代比较频繁的场景，不宜将HashMap的初始大小设的过大。\n​    有两个参数可以影响HashMap的性能: 初始容量(inital capacity)和负载系数(load factor)。初始容量指定了初始table的大小，负载系数用来指定自动扩容的临界值。当entry的数量超过capacity * load_factor时，容器将自动扩容并重新哈希。对于插入元素较多的场景，将初始容量设大可以减少重新哈希的次数。\n将对象放入到HashMap或HashSet中时，有两个方法需要特别关心: hashCode()和equals()。\nhashCode()方法决定了对象会被放到哪个bucket里，\n当多个对象的哈希值冲突时，equals()方法决定了这些对象是否是“同一个对象”。\n所以，如果要将自定义的对象放入到HashMap或HashSet中，需要@Override  hashCode()和equals()方法。\n​    get(Object key)方法根据指定的key值返回对应的value，该方法调用了getEntry(Object key)得到相应的entry，然后返回entry.getValue()。因此getEntry()是算法的核心。 算法思想是首先通过hash()函数得到对应bucket的下标，然后依次遍历冲突链表，通过key.equals(k)方法来判断是否是要找的那个entry。\n&#x2F;&#x2F; HashMap 查找\n&#x2F;&#x2F;getEntry()方法\nfinal Entry&lt;K,V&gt; getEntry(Object key) &#123;\n\t......\n\tint hash &#x3D; (key ** null) ? 0 : hash(key);\n    for (Entry&lt;K,V&gt; e &#x3D; table[hash&amp;(table.length-1)];&#x2F;&#x2F;得到冲突链表\n         e !&#x3D; null; e &#x3D; e.next) &#123;&#x2F;&#x2F;依次遍历冲突链表中的每个entry\n        Object k;\n        &#x2F;&#x2F;依据equals()方法判断是否相等\n        if (e.hash ** hash &amp;&amp;\n            ((k &#x3D; e.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return e;\n    &#125;\n    return null;\n&#125;\n\n​    put(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于getEntry()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry，插入方式为头插法。\n&#x2F;&#x2F;addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        resize(2 * table.length);&#x2F;&#x2F;自动扩容，并重新哈希\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        bucketIndex &#x3D; hash &amp; (table.length-1);&#x2F;&#x2F;hash%table.length\n    &#125;\n    &#x2F;&#x2F;在冲突链表头部插入新的entry\n    Entry&lt;K,V&gt; e &#x3D; table[bucketIndex];\n    table[bucketIndex] &#x3D; new Entry&lt;&gt;(hash, key, value, e);\n    size++;\n&#125;\n\n\n\nb. HashMap-JDK8+Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。\n根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。\n为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。\n来一张图简单示意一下吧：\n\n\n简单分析一下插入操作的过程:\npublic V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n\n&#x2F;&#x2F; 第四个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作\n&#x2F;&#x2F; 第五个参数 evict 我们这里不关心\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n               boolean evict) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    \n    &#x2F;&#x2F; 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度\n    &#x2F;&#x2F; 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量\n    if ((tab &#x3D; table) ** null || (n &#x3D; tab.length) ** 0)\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) ** null)\n        tab[i] &#x3D; newNode(hash, key, value, null);\n\n    else &#123;&#x2F;&#x2F; 数组该位置有数据\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点\n        if (p.hash ** hash &amp;&amp;\n            ((k &#x3D; p.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            e &#x3D; p;\n        &#x2F;&#x2F; 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树\n        else if (p instanceof TreeNode)\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 到这里，说明数组该位置上是一个链表\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; 插入到链表的最后面(Java7 是插入到链表的最前面)\n                if ((e &#x3D; p.next) ** null) &#123;\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个\n                    &#x2F;&#x2F; 会触发下面的 treeifyBin，也就是将链表转换为红黑树\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash);\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果在该链表中找到了&quot;相等&quot;的 key(** 或 equals)\n                if (e.hash ** hash &amp;&amp;\n                    ((k &#x3D; e.key) ** key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    &#x2F;&#x2F; 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node\n                    break;\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; e!&#x3D;null 说明存在旧值的key与要插入的key&quot;相等&quot;\n        &#x2F;&#x2F; 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值\n        if (e !&#x3D; null) &#123;\n            V oldValue &#x3D; e.value;\n            if (!onlyIfAbsent || oldValue ** null)\n                e.value &#x3D; value;\n            afterNodeAccess(e);\n            return oldValue;\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容\n    if (++size &gt; threshold)\n        resize();\n    afterNodeInsertion(evict);\n    return null;\n&#125;\n\nresize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。\n\nc. TreeMap基于红黑树实现。\nTreeMap底层通过红黑树(Red-Black tree)实现，也就意味着containsKey(), get(), put(), remove()都有着log(n)的时间复杂度。\n出于性能原因，TreeMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将TreeMap包装成(wrapped)同步的:\nSortedMap m &#x3D; Collections.synchronizedSortedMap(new TreeMap(...));\n\n\n\n\n\n\n\n\n\nd. HashTable和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\ne. LinkedHashMap使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。\nLinkedHashMap实现了Map接口，即允许放入key为null的元素，也允许插入value为null的元素。从名字上可以看出该容器是linked list和HashMap的混合体，也就是说它同时满足HashMap和linked list的某些特性。\n可将LinkedHashMap看作采用linked list增强的HashMap。\n\n\n\n\n​    事实上LinkedHashMap是HashMap的直接子类，二者唯一的区别是LinkedHashMap在HashMap的基础上，采用双向链表(doubly-linked list)的形式将所有entry连接起来，这样是为保证元素的迭代顺序跟插入顺序相同。上图给出了LinkedHashMap的结构图，主体部分跟HashMap完全一样，多了header指向双向链表的头部(是一个哑元)，该双向链表的迭代顺序就是entry的插入顺序。\n​    除了可以保迭代历顺序，这种结构还有一个好处 : 迭代LinkedHashMap时不需要像HashMap那样遍历整个table，而只需要直接遍历header指向的双向链表即可，也就是说LinkedHashMap的迭代时间就只跟entry的个数相关，而跟table的大小无关。\n​    出于性能原因，LinkedHashMap是非同步的(not synchronized)，如果需要在多线程环境使用，需要程序员手动同步；或者通过如下方式将LinkedHashMap包装成(wrapped)同步的:\nMap m &#x3D; Collections.synchronizedMap(new LinkedHashMap(...));\n\n与HashMap不同的是,对插入和删除操作来说:\n\n从table的角度看，新的entry需要插入(或删除)到对应的bucket里，当有哈希冲突时，采用头插法将新的entry插入(或删除)到冲突链表的头部。\n从header的角度看，新的entry需要插入(或删除)到双向链表的尾部。\n\nput(K key, V value)方法是将指定的key, value对添加到map里。该方法首先会对map做一次查找，看是否包含该元组，如果已经包含则直接返回，查找过程类似于get()方法；如果没有找到，则会通过addEntry(int hash, K key, V value, int bucketIndex)方法插入新的entry。\n&#x2F;&#x2F; LinkedHashMap.addEntry()\nvoid addEntry(int hash, K key, V value, int bucketIndex) &#123;\n    if ((size &gt;&#x3D; threshold) &amp;&amp; (null !&#x3D; table[bucketIndex])) &#123;\n        resize(2 * table.length);&#x2F;&#x2F; 自动扩容，并重新哈希\n        hash &#x3D; (null !&#x3D; key) ? hash(key) : 0;\n        bucketIndex &#x3D; hash &amp; (table.length-1);&#x2F;&#x2F; hash%table.length\n    &#125;\n    &#x2F;&#x2F; 1.在冲突链表头部插入新的entry\n    HashMap.Entry&lt;K,V&gt; old &#x3D; table[bucketIndex];\n    Entry&lt;K,V&gt; e &#x3D; new Entry&lt;&gt;(hash, key, value, old);\n    table[bucketIndex] &#x3D; e;\n    &#x2F;&#x2F; 2.在双向链表的尾部插入新的entry\n    e.addBefore(header);\n    size++;\n&#125;\n\n\n\n\n\nI&#x2F;Oa. 本地IO1. IO理解分类 - 从传输方式上从数据传输方式或者说是运输方式角度看，可以将 IO 类分为:\n\n字节流\n字符流\n\n字节是个计算机看的，字符才是给人看的\n2. 字节流和字符流的区别\n字节流读取单个字节，字符流读取单个字符(一个字符根据编码的不同，对应的字节也不同，如 UTF-8 编码是 3 个字节，中文编码是 2 个字节。)\n字节流用来处理二进制文件(图片、MP3、视频文件)，字符流用来处理文本文件(可以看做是特殊的二进制文件，使用了某种编码，人可以阅读)。\n\n\n\n&#x2F;*\n *  流的体系结构\n *  抽象基类             节点流                缓存流\n *  InputStream         FileInputStream     BufferedInputStream\n *  OutputStream        FileOutputStream    BufferedOutputSteam\n *  Reader              FileReader          BufferedReader\n *  Writer              FileWriter          BufferedWriter\n * *&#x2F;\n\n3. FileReader&#x2F;&#x2F; 测试 FileReader\n&#x2F;&#x2F; 为了保证资源一定可以被关闭,使用try-catch-finally来关闭资源\npublic static void testFileReader() &#123;\n    FileReader fr &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F; 1. 实例化File类对象\n        File file &#x3D; new File(&quot;Interview\\\\hello.txt&quot;); &#x2F;&#x2F; 路径相较于当前工程\n        &#x2F;&#x2F; 2. 提供具体的流\n        fr &#x3D; new FileReader(file);\n        &#x2F;&#x2F; 3. 数据的读入过程\n        &#x2F;&#x2F; RETURN The character read, or -1 if the end of the stream has been reached\n        &#x2F;&#x2F; 返回一个读入的字符,如果到达文件末尾返回-1\n        int data;\n        while ((data &#x3D; fr.read()) !&#x3D; -1) &#123;\n            System.out.print((char) data);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            &#x2F;&#x2F; 4. 关闭流操作\n            &#x2F;&#x2F; JVM 虽然有垃圾回收机制,但对于物理连接无能为力,比如: 数据库连接、输入输出流、Socket\n            if (fr !&#x3D; null) fr.close();\n            &#x2F;&#x2F; 因为 fr可能在前面由于打开失败而为null,不能直接close\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\npublic static void testFileReader1() &#123;\n    FileReader fr &#x3D; null;\n    try &#123;\n        File file &#x3D; new File(&quot;Interview&#x2F;&#x2F;hello.txt&quot;);\n        fr &#x3D; new FileReader(file);\n        char[] cBuf &#x3D; new char[5];\n        &#x2F;&#x2F; RETURN   The number of characters read,\n        &#x2F;&#x2F;          or -1 if the end of the stream has been reached\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            &#x2F;&#x2F;错误写法1\n            &#x2F;&#x2F;System.out.println(Arrays.toString(cBuf));&#x2F;&#x2F;\n            &#x2F;&#x2F;错误写法2\n            &#x2F;&#x2F;for (int i &#x3D; 0; i &lt; cBuf.length; i++) &#123;\n            &#x2F;&#x2F;   System.out.print(cBuf[i]);\n            &#x2F;&#x2F;&#125;\n            &#x2F;&#x2F; 正确1\n            for (int i &#x3D; 0; i &lt; len; i++) &#123;\n                System.out.print(cBuf[i]);\n            &#125;\n            &#x2F;&#x2F; 正确2\n            String s &#x3D; new String(cBuf, 0, len);\n            System.out.print(s);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n4. FileWriter\t&#x2F;&#x2F; 从内存中写出数据到磁盘的文件里。\n\t&#x2F;*\n     *  输出操作 对应File可以不存在,会自动创建,不会爆异常\n     *          如果存在,可以根据第二个参数确定是否追加,默认不追加,进行覆盖\n     *          FileWriter fw &#x3D; new FileWriter(file,false&#x2F;true);\n     * *&#x2F;\npublic static void TestFileWriter() throws IOException &#123;\n\n    FileWriter fw &#x3D; null;\n    try &#123;\n        File file &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;helloWriter.txt&quot;);\n        System.out.println(file.getAbsolutePath());\n        &#x2F;&#x2F; file文件本身没有写出的能力,\n        fw &#x3D; new FileWriter(file, false);\n        fw.write(&quot;Fuck F4N!&quot;);\n        fw.write(&quot;2022-3-11&quot;);\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        if (fw !&#x3D; null) fw.close();\n    &#125;\n&#125;\n\n5. 复制操作&#x2F;&#x2F; 对文件的读写,做一个复制操作\npublic static void TestFileReaderWriter() throws IOException &#123;\n    FileReader fr &#x3D; null;\n    FileWriter fw &#x3D; null;\n    try &#123;\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;helloWriter.txt&quot;);\n\n\n        fr &#x3D; new FileReader(srcFile);\n        fw &#x3D; new FileWriter(destFile,true);\n        char[] cBuf &#x3D; new char[5];\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            fw.write(cBuf, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fw !&#x3D; null) fw.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n6. FileInputOutputStream处理图片处理图片、视频等需要用字节流，字节流处理字符可能出现乱码问题，尤其是中文。但实际上，如果只进行复制操作，而在程序中不进行加工，就没什么影响。\n文本文件：.txt .java .c .cpp …\n非文本文件: .jpg .mp3 .doc .ppt …\n &#x2F;&#x2F; 使用字节流处理图片\npublic static void ImgTestFileInputOutputStream   () throws IOException &#123;\n    FileInputStream fr &#x3D; null;\n    FileOutputStream fw &#x3D; null;\n    try &#123;\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;copyimg.jpg&quot;);\n\n        fr &#x3D; new FileInputStream(srcFile);\n        fw &#x3D; new FileOutputStream(destFile);\n        byte[] cBuf &#x3D; new byte[5];\n        int len;\n        while ((len &#x3D; fr.read(cBuf)) !&#x3D; -1) &#123;\n            fw.write(cBuf, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        try &#123;\n            if (fw !&#x3D; null) fw.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n        try &#123;\n            if (fr !&#x3D; null) fr.close();\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n7. 缓冲流BufferedInputStream\nBufferedOutputSteam\nBufferedReader\nBufferedWriter\n\n缓冲流使用要先套接到已有的”流”之上\nBufferedInputStream bis &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;)));\n\n如果使用BufferedReader和BufferedWriter,可以使用String进行读取。\n开发会优先使用缓冲流， 因为缓冲流内部提供了缓冲区 ，速度会快很多。\npublic static void TestBufferStream() throws IOException &#123;\n    &#x2F;*非文本文件的复制*&#x2F;\n    BufferedInputStream bis &#x3D; null;\n    BufferedOutputStream bos &#x3D; null;\n    try &#123;\n        &#x2F;&#x2F; 造文件\n        File srcFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg.jpg&quot;);\n        File destFile &#x3D; new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;CopyIMG.jpg&quot;);\n        &#x2F;&#x2F; 造节点流\n        FileInputStream fis &#x3D; new FileInputStream(srcFile);\n        FileOutputStream fos &#x3D; new FileOutputStream(destFile);\n        &#x2F;&#x2F; 造缓冲流\n        bis &#x3D; new BufferedInputStream(fis);\n        bos &#x3D; new BufferedOutputStream(fos);\n        &#x2F;&#x2F; 简写\n        &#x2F;&#x2F; bis &#x3D; new BufferedInputStream(new FileInputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;testimg&quot; +\n        &#x2F;&#x2F;                    &quot;.jpg&quot;)));\n        &#x2F;&#x2F; bos &#x3D; new BufferedOutputStream(new FileOutputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;CopyIMG&quot; +\n        &#x2F;&#x2F;                    &quot;.jpg&quot;)));\n\n        byte[] buffer &#x3D; new byte[10];\n        int len;\n        while ((len &#x3D; bis.read(buffer)) !&#x3D; -1) &#123;\n            bos.write(buffer, 0, len);\n        &#125;\n    &#125; catch (IOException e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 资源关闭\n        &#x2F;&#x2F; 先关外层的流,再关内层的流\n        bis.close();\n        bos.close();\n        &#x2F;&#x2F; 其实,关闭外层流时,会自动关闭内层流,也就是说下面的内层的流可以省略\n        &#x2F;&#x2F; fis.close();\n        &#x2F;&#x2F; fos.close();\n    &#125;\n&#125;\n\n8. 统计一个文件中字符出现次数&#x2F;&#x2F; 统计 comment.txt中每个字符出现的次数\npublic static void wordCount() throws IOException &#123;\n    BufferedReader br &#x3D; new BufferedReader(new FileReader(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;comment.txt&quot;)));\n    BufferedWriter bw &#x3D; new BufferedWriter(new FileWriter(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;commentCount.txt&quot;)));\n    HashMap&lt;Character, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;();\n    int ch;\n    while ((ch &#x3D; br.read()) !&#x3D; -1) &#123;\n        char c &#x3D; (char) ch;\n        hashMap.put(c, hashMap.getOrDefault(c, 0) + 1);\n    &#125;\n    br.close();\n    for (Map.Entry&lt;Character, Integer&gt; en : hashMap.entrySet()) &#123;\n        char c &#x3D; en.getKey();\n        switch (c)&#123;\n            case &#39; &#39;:\n                bw.write(&quot;空格 &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\t&#39;:\n                bw.write(&quot;tab &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\r&#39;:\n                bw.write(&quot;回车 &#x3D; &quot;+en.getValue());\n                break;\n            case &#39;\\n&#39;:\n                bw.write(&quot;换行 &#x3D; &quot;+en.getValue());\n                break;\n            default:\n                bw.write(c+&quot; &#x3D; &quot;+en.getValue());\n                break;\n        &#125;\n        bw.newLine();\n    &#125;\n    bw.close();\n&#125;\n\n9. 转换流转换流提供了 字节流 到 字符流 的转换。\n&#x2F;*\n *  转换流:\n *  InputStreamReader ： 将一个字节的输入流 转换为 字符 的输入流\n *  OutputStreamWriter ：将一个字符的输出流 转换为 字节 的输出流\n *  实现了 字节流 到 字符流之间的转换。\n *\n *  从 字节 --&gt; 字符 是一种解码\n *  从 字符 --&gt; 字节 是一种编码\n *\n *  这个过程存在字符集的设置问题\n * *&#x2F;\n\npublic static void main(String[] args) throws IOException &#123;\n    &#x2F;* 实现字节流到输入流的转换 *&#x2F;\n    FileInputStream fis &#x3D; new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;comment.txt&quot;);\n    FileOutputStream fos &#x3D; new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;commentGBK.txt&quot;);\n    &#x2F;&#x2F; 参数二指明字符集,根据读取的文件字符集来确定\n    InputStreamReader isr &#x3D; new InputStreamReader(fis, &quot;UTF-8&quot;);\n    OutputStreamWriter osw &#x3D; new OutputStreamWriter(fos, &quot;GBK&quot;);\n    char[] cbuf &#x3D; new char[20];\n    int len;\n    while ((len &#x3D; isr.read(cbuf)) !   &#x3D; -1) &#123;\n        String s &#x3D; new String(cbuf, 0, len);\n        System.out.print(s);\n        osw.write(s);\n    &#125;\n    isr.close();\n    osw.close();\n&#125;\n\n10. 标准的输入输出流&#x2F;*\n *  标准的输入流\n *  System.in: 标准的输入流,默认从键盘输入\n *  System.out: 标准的输出流,默认从控制台输出\n *\n *  System类的setIn(InputStream is) &#x2F; setOut(PrintStream ps)方式重新指定输入输出的流\n* *&#x2F;\n\n&#x2F;&#x2F; 实现一个输入转为大写的程序\n&#x2F;&#x2F; 1. 用Scanner实现\n&#x2F;&#x2F; 2. 用System.in实现\n&#x2F;&#x2F;    System.in --&gt; 转换流 --&gt; BufferedReader 的 readLine()\n\nInputStreamReader isr &#x3D; new InputStreamReader(System.in);\nBufferedReader br &#x3D; new BufferedReader(isr);\nwhile (true)&#123;\n    String s &#x3D; br.readLine();\n    if (&quot;e&quot;.equalsIgnoreCase(s) || &quot;exit&quot;.equalsIgnoreCase(s) )&#123;\n        System.out.println(&quot;EXIT.&quot;);\n        break;\n    &#125;\n    System.out.println(s.toUpperCase());\n&#125;\nbr.close();\n\n\n\n11. 打印流&#x2F;&#x2F; 打印流\n&#x2F;&#x2F; PrintStream PrintWriter\n&#x2F;&#x2F; 它们提供了一系列的 print println方法\n&#x2F;&#x2F; 可以使用System.setOut()设置答应的目标,默认为显示器\nFileOutputStream fos &#x3D; new FileOutputStream(new File(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\nPrintStream stream &#x3D; new PrintStream(fos);\n&#x2F;&#x2F; 把输入目的地改为文件,而不是显示器\nif (stream !&#x3D; null) System.setOut(stream);\nSystem.out.println();\n\n12. 数据流主要是为了 为了方便操作Java语言中的基本类型和 String\n&#x2F;&#x2F;        DataInputStream 套接到 InputStream\n&#x2F;&#x2F;        DataOutputStream 套接到 OutputStream\nDataOutputStream dos &#x3D; new DataOutputStream(new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\ndos.writeUTF(&quot;中国&quot;);\n&#x2F;&#x2F; 刷新操作 flush-冲洗\ndos.flush();\ndos.writeInt(23);\ndos.flush();\ndos.writeBoolean(true);\ndos.close();\n\nDataInputStream dis &#x3D; new DataInputStream(new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;hello.txt&quot;));\nString country &#x3D; dis.readUTF();\nint age &#x3D; dis.readInt();\nboolean b &#x3D; dis.readBoolean();\nSystem.out.println(country+&quot; &quot;+age+&quot; &quot;+b);\ndis.close();\n\n13. 对象流:ObjectInputStream和ObjectOutputStream\n\n用以存储和读取 对象类型 和 基本类型 的处理流\n通过 序列化 与 反序列化 来进行对对象数据的 保存、传输、读取。\nObjectOutputStream 和 ObjectInputStream 不能序列化 static和transient 修饰的成员变量\n对象序列化 : 将内存中的Java对象转换为平台无关的二进制流 这样就可以将对象进行与平台无关的 传输和保存\n实现了Serializable接口的对象 可以转化为 字节数据\n\n&#x2F;&#x2F; Object 类型的写入\nObjectOutputStream oos &#x3D; new ObjectOutputStream(new FileOutputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;Object.dat&quot;));\noos.writeObject(new String(&quot;我爱北京&quot;));\noos.flush();\noos.close();\n\n&#x2F;&#x2F; Object 读入\nObjectInputStream ois &#x3D; new ObjectInputStream(new FileInputStream(&quot;Interview&#x2F;&#x2F;IO&#x2F;&#x2F;Object.dat&quot;));\nString str &#x3D;(String) ois.readObject();\nSystem.out.println(str);\nois.close();\n\n自定义对象实现 Serializable接口 来进行序列化和反序列化,需要提供一个serialVersionUID来进行一个标识,确保可以还原和区分。与此同时，必须保证自定义的类的属性字段也都可以序列化，基础类型默认可以序列化。\nclass Person implements Serializable &#123;\n    &#x2F;&#x2F; 序列版本号\n   \n    private static final long serialVersionUID &#x3D; 46516164984L;\n    private String name;\n    private int age;\n\n    @Override\n    public String toString() &#123;\n        return &quot;Person&#123;&quot; +\n            &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n            &quot;, age&#x3D;&quot; + age +\n            &#39;&#125;&#39;;\n    &#125;\n\n    public Person(String name, int age) &#123;\n        this.name &#x3D; name;\n        this.age &#x3D; age;\n    &#125;\n&#125;\n\nserialVersionUID使用来表示类的不同版本间的兼容性，如果没有显示定义，JVM会自动生成一个，但这样可能会在修改类时产生问题，导致序列化失败。  \n14. 随机存取文件流RandomAccessFile 直接继承 Object , 随机存取文件流的特殊指出在于 既可以作为输入流,也可以作为输出流。\n如果文件已经存在,写时会从头进行覆盖。\n\n可以使用seek()函数进行指针的移动。\n要实现插入需要先将后面的数据向后移动再插入。\n\n如果文件不存在，则会自动创建。\n基本知识点汇总\n流的三种分类方式\n\n流向: 输入流、输出流\n数据单位：字节流、字符流\n流的角色：节点流、处理流\n\n\n写出4个IO流中的抽象基类,4个文件流,4个缓冲流\n抽象基类:\n\nInputStream\nOutputStream\nReader\nWriter\n\n文件流:\n\nFileReader\nFileWriter\nFileInputStream\nFileOutputStream\n\n缓冲流:\n\nBufferedReader\nBufferedWriter\nBufferedInputStream\nBufferedOutputStream\n\n转换流:InputSteamReader OutputStreamWriter\n\n字符流和字节流分别的使用情景\n字节流: 主要用来处理非文本文件\n字符流: 主要用来处理文本文件\n\n\nb. BIO NIO AIO 异同BIO: 同步阻塞型。 服务器为客户端一个连接一个线程，数据未准备好时阻塞。\n\n适用于连接数目少，并固定的架构，这种方式对服务器资源要求比较高，低并发的情况下。JDK1.4之前的唯一选择\n\nNIO: 同步非阻塞型。由一个中央选择器进行IO请求的接收，并轮询访问是否有已经准备好的IO请求，有就会去处理。\n\n适用于连接数目较多，但单个连接比较短的情况，比如聊天服务器、弹幕系统、服务器通讯等.JDK1.4开始支持\n\nAIO: 异步非阻塞。客户端IO请求先由操作系统(OS)进行处理,数据处理好后通知服务器处理程序来进行处理。\n\n适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持\n\n在文中我们一再说明JAVA AIO框架在windows下使用windows IOCP技术，在Linux下使用epoll多路复用IO技术模拟异步IO，这个从JAVA AIO框架的部分类设计上就可以看出来。\n\n\n\nBIO\nNIO\nAIO\n\n\n\nSocket\nSocketChannel\nAsynchronousSocketChannel\n\n\nServerSocket\nServerSocketChannel\nAsynchornousServerSocketChannel\n\n\nc. Unix IO 类型一个输入操作通常包括两个阶段:\n\n等待数据准备好\n从内核向进程复制数据\n\n​    对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。\nUnix 下有五种 I&#x2F;O 模型:\n\n阻塞式 I&#x2F;O\n非阻塞式 I&#x2F;O\nI&#x2F;O 复用(select 和 poll)\n信号驱动式 I&#x2F;O(SIGIO)\n异步 I&#x2F;O(AIO)\n\n1. 阻塞式IO应用进程被阻塞，直到数据复制到应用进程缓冲区中才返回。\n应该注意到，在阻塞的过程中，其它程序还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其他程序还可以执行，因此不消耗 CPU 时间，这种模型的执行效率会比较高。\n2. 非阻塞式 I&#x2F;O应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I&#x2F;O 是否完成，这种方式称为轮询(polling)。\n由于 CPU 要处理更多的系统调用，因此这种模型是比较低效的。\n3. I&#x2F;O 复用使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读，这一过程会被阻塞，当某一个套接字可读时返回。之后再使用 recvfrom 把数据从内核复制到进程中。\n它可以让单个进程具有处理多个 I&#x2F;O 事件的能力。又被称为 Event Driven I&#x2F;O，即事件驱动 I&#x2F;O。\n如果一个 Web 服务器没有 I&#x2F;O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。并且相比于多进程和多线程技术，I&#x2F;O 复用不需要进程线程创建和切换的开销，系统开销更小。\n4. 信号驱动 I&#x2F;O应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。\n相比于非阻塞式 I&#x2F;O 的轮询方式，信号驱动 I&#x2F;O 的 CPU 利用率更高。\n5. 异步 I&#x2F;O进行 aio_read 系统调用会立即返回，应用进程继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。\n异步 I&#x2F;O 与信号驱动 I&#x2F;O 的区别在于，异步 I&#x2F;O 的信号是通知应用进程 I&#x2F;O 完成，而信号驱动 I&#x2F;O 的信号是通知应用进程可以开始 I&#x2F;O。\ne. BIOBIO就是: blocking IO。最容易理解、最容易实现的IO工作方式，应用程序向操作系统请求网络IO操作，这时应用程序会一直等待；另一方面，操作系统收到请求后，也会等待数据完成，直到网络上有数据传到监听端口；操作系统在收集数据后，会把数据发送给应用程序；最后应用程序受到数据，并解除等待状态。\n\n阻塞IO 和 非阻塞IO\n\n​    这两个概念是程序级别的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 前者等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)\n\n同步IO 和 非同步IO\n\n​    这两个概念是操作系统级别的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序。\n1. 传统BIO以前大多数网络通信方式都是阻塞模式的，即:\n\n客户端向服务器端发出请求后，客户端会一直等待(不会再做其他事情)，直到服务器端返回结果或者网络出现问题。\n服务器端同样的，当在处理某个客户端A发来的请求时，另一个客户端B发来的请求会等待，直到服务器端的这个处理线程完成上一个处理。\n\n2. 传统的BIO的问题\n同一时间，服务器只能接受来自于客户端A的请求信息；虽然客户端A和客户端B的请求是同时进行的，但客户端B发送的请求信息只能等到服务器接受完A的请求数据后，才能被接受。\n由于服务器一次只能处理一个客户端请求，当处理完成并返回后(或者异常时)，才能进行第二次请求的处理。很显然，这样的处理方式在高并发的情况下，是不能采用的。\n\n3. 多线程方式 - 伪异步方式上面说的情况是服务器只有一个线程的情况，那么读者会直接提出我们可以使用多线程技术来解决这个问题:\n\n当服务器收到客户端X的请求后，(读取到所有请求数据后)将这个请求送入一个独立线程进行处理，然后主线程继续接受客户端Y的请求。\n客户端一侧，也可以使用一个子线程和服务器端进行通信。这样客户端主线程的其他工作就不受影响了，当服务器端有响应信息的时候再由这个子线程通过 监听模式&#x2F;观察模式(等其他设计模式)通知主线程。\n\n但是使用线程来解决这个问题实际上是有局限性的:\n\n虽然在服务器端，请求的处理交给了一个独立线程进行，但是操作系统通知accept()的方式还是单个的。也就是，实际上是服务器接收到数据报文后的“业务处理过程”可以多线程，但是数据报文的接受还是需要一个一个的来(下文的示例代码和debug过程我们可以明确看到这一点)\n在linux系统中，可以创建的线程是有限的。我们可以通过cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;threads-max 命令查看可以创建的最大线程数。当然这个值是可以更改的，但是线程越多，CPU切换所需的时间也就越长，用来处理真正业务的需求也就越少。\n创建一个线程是有较大的资源消耗的。\n如果您的应用程序大量使用长连接的话，线程是不会关闭的。这样系统资源的消耗更容易失控。\n\nBIO的问题关键不在于是否使用了多线程(包括线程池)处理这次请求，而在于accept()、read()的操作点都是被阻塞。\n即: 异步IO模式 就是为了解决这样的并发性存在的。\nf. NIO通俗理解: NIO 是可以做到用一个线程来处理多个请求的操作。假如有1000个请求，可以根据实际情况，分配20~80个线程来进行处理，不需要像阻塞式IO非要分配1000个线程。\n\n\n新的输入&#x2F;输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I&#x2F;O 的不足，提供了高速的、面向块的 I&#x2F;O。\nI&#x2F;O 与 NIO 最重要的区别是数据打包和传输的方式，I&#x2F;O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n\n面向流的 I&#x2F;O 一次处理一个字节数据: 一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I&#x2F;O 通常相当慢。\n\n面向块的 I&#x2F;O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I&#x2F;O 缺少一些面向流的 I&#x2F;O 所具有的优雅性和简单性。\n\n\nI&#x2F;O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\nNIO 与普通 I&#x2F;O 的区别主要有以下两点:\n\nNIO 是非阻塞的\nNIO 面向块，I&#x2F;O 面向流\n\n1. 通道与缓冲区通道 Channel 是对原 I&#x2F;O 包中的流的模拟，可以通过它读取和写入数据。\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n通道包括以下类型:\n\nFileChannel: 从文件中读写数据；\nDatagramChannel: 通过 UDP 读写网络中数据；\nSocketChannel: 通过 TCP 读写网络中数据；\nServerSocketChannel: 可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。\n\n\n发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读&#x2F;写进程。\n缓冲区包括以下类型:\n\nByteBuffer\nCharBuffer\nShortBuffer\nIntBuffer\nLongBuffer\nFloatBuffer\nDoubleBuffer\n\n\n使用 NIO 快速复制文件的实例:\nprivate static final String FILE_PATH &#x3D; &quot;Interview&#x2F;&#x2F;NIO&#x2F;&#x2F;&quot;;\npublic static void main(String[] args) throws IOException &#123;\n    &#x2F;*输入字节流*&#x2F;\n    FileInputStream fin &#x3D; new FileInputStream(FILE_PATH + &quot;hello.txt&quot;);\n    &#x2F;*输入通道*&#x2F;\n    FileChannel fcin &#x3D; fin.getChannel();\n    &#x2F;*输出管道*&#x2F;\n    FileOutputStream fout &#x3D; new FileOutputStream(FILE_PATH + &quot;out.txt&quot;);\n    &#x2F;*输出字节流*&#x2F;\n    FileChannel fcout &#x3D; fout.getChannel();\n    &#x2F;* 为缓冲区分配 1024 个字节 *&#x2F;\n    ByteBuffer buffer &#x3D; ByteBuffer.allocateDirect(1024);\n    while (true) &#123;\n        int read &#x3D; fcin.read(buffer);\n        if (read ** -1) break;\n        &#x2F;*切换读写*&#x2F;\n        buffer.flip();\n        &#x2F;* 把缓冲区的内容写入输出文件中 *&#x2F;\n        fcout.write(buffer);\n        &#x2F;* 清空缓冲区 *&#x2F;\n        buffer.clear();\n    &#125;\n    fcout.close();\n    fcin.close();\n&#125;\n\n\n\n2. Selector(选择器)有Selector选择器来在收到访问后,轮询的查找是否已经有准备好的IO请求可以进行返回处理,如果有,则去单独阻塞的处理请求。\n3. NIO - IO多路复用详解目前流程的多路复用IO实现主要包括四种: select、poll、epoll、kqueue。下表是他们的一些重要特性的比较:\n\n\n\nIO模型\n相对性能\n关键思路\n操作系统\nJAVA支持情况\n\n\n\nselect\n较高\nReactor\nwindows&#x2F;Linux\n支持,Reactor模式(反应器设计模式)。Linux操作系统的 kernels 2.4内核版本之前，默认使用select；而目前windows下对同步IO的支持，都是select模型\n\n\npoll\n较高\nReactor\nLinux\nLinux下的JAVA NIO框架，Linux kernels 2.6内核版本之前使用poll进行支持。也是使用的Reactor模式\n\n\nepoll\n高\nReactor&#x2F;Proactor\nLinux\nLinux kernels 2.6内核版本及以后使用epoll进行支持；Linux kernels 2.6内核版本之前使用poll进行支持；另外一定注意，由于Linux下没有Windows下的IOCP技术提供真正的 异步IO 支持，所以Linux下使用epoll模拟异步IO\n\n\nkqueue\n高\nProactor\nLinux\n目前JAVA的版本不支持\n\n\n多路复用IO技术最适用的是“高并发”场景，所谓高并发是指1毫秒内至少同时有上千个连接请求准备好。其他情况下多路复用IO技术发挥不出来它的优势。另一方面，使用JAVA NIO进行功能实现，相对于传统的Socket套接字实现要复杂一些，所以实际应用中，需要根据自己的业务需求进行技术选择。\ng. AIO异步非阻塞。客户端IO请求先由操作系统(OS)进行处理,数据处理好后通知服务器处理程序来进行处理。\n当进行读写操作时，只需要直接调用API的read和write方法即可，这两种方法均是异步的。\n\n适用于 连接数目多,且连接较长(重操作)的架构,比如相册服务器,充分发挥OS参加IO操作,比较复杂,JDK7开始支持\n\n","slug":"Java-IO-集合类","date":"2022-04-08T02:22:24.000Z","categories_index":"互联网八股","tags_index":"Java,IO","author_index":"张 凡"},{"id":"7972c32d39f314ccb6f804289f8a291c","title":"Git基础","content":"分布式版本控制系统\n简单理论四个工作区域：\n\n工作目录\n暂存区（Index\\Stage）\n仓库区（Repository）\n远程仓库（Remote）\n\n\n\n\n\n基本配置$ git config -l 查看基础配置\n本地存放位置 Git\\etc\\gitconfig中\n$ git config -l\ndiff.astextplain.textconv&#x3D;astextplain\nfilter.lfs.clean&#x3D;git-lfs clean -- %f\nfilter.lfs.smudge&#x3D;git-lfs smudge -- %f\nfilter.lfs.process&#x3D;git-lfs filter-process\nfilter.lfs.required&#x3D;true\nhttp.sslbackend&#x3D;openssl\nhttp.sslcainfo&#x3D;D:&#x2F;Software&#x2F;Git&#x2F;mingw64&#x2F;ssl&#x2F;certs&#x2F;ca-bundle.crt\ncore.autocrlf&#x3D;true\ncore.fscache&#x3D;true\ncore.symlinks&#x3D;false\npull.rebase&#x3D;false\ncredential.helper&#x3D;manager-core\ncredential.https:&#x2F;&#x2F;dev.azure.com.usehttppath&#x3D;true\ninit.defaultbranch&#x3D;master\ncore.repositoryformatversion&#x3D;0\ncore.filemode&#x3D;false\ncore.bare&#x3D;false\ncore.logallrefupdates&#x3D;true\ncore.symlinks&#x3D;false\ncore.ignorecase&#x3D;true\n\n\n\n$ git config --global --list 查看本地配置文件\n本地存放位置 C:\\Users\\Admin\\gitconfig中\n第一次进入会显示如下，需要配置用户名和email\n$ git config --global --list\nfatal: unable to read config file &#39;C:&#x2F;Users&#x2F;Admin&#x2F;.gitconfig&#39;: No such file or directory\n\n配置用户名和邮箱\n$ git config --global user.name &quot;SlowHot&quot;\n$ git config --global user.email  &quot;244167780@qq.com&quot;\n\n\n\nssh-keygen绑定SSH公匙\n$ ssh-keygen -t rsa \nGenerating public&#x2F;private rsa key pair.\nEnter file in which to save the key (&#x2F;c&#x2F;Users&#x2F;Admin&#x2F;.ssh&#x2F;id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in &#x2F;c&#x2F;Users&#x2F;Admin&#x2F;.ssh&#x2F;id_rsa\nYour public key has been saved in &#x2F;c&#x2F;Users&#x2F;Admin&#x2F;.ssh&#x2F;id_rsa.pub\nThe key fingerprint is:\nSHA256:vLaGaZt7hUVVXHSNKgqLw5j3DwqPSScs0+JcuUkz7lo Admin@DESKTOP-UKF002H\nThe key&#39;s randomart image is:\n+---[RSA 3072]----+\n|           ..o.+&#x3D;|\n|          .   o o|\n|         .   .   |\n|      ..  o .    |\n|   + . oS+ .     |\n| oo * . o..      |\n|+ *E.o.oo.       |\n|o&#x3D;&#x3D;B&#x3D;.&#x3D;+o.       |\n| +&#x3D;&#x3D;o.+*o        |\n+----[SHA256]-----+\n\nC:\\Users\\Admin.ssh\\id_rsa.pub中生成SHA256公匙。将公匙复制到GitHub的setting中，来绑定本地电脑。\n\n\n\n\n工作流程初始有两种选择选择1.创建一个本地仓库 或 2.直接克隆\n\n本地仓库搭建\n$ git init\n\n直接克隆clone\n$ git clone [url]\n\n查看工作文件夹中的文件状态(有新增文件Untracked files)\n $ git status [filename]\n On branch master\nYour branch is up to date with &#39;origin&#x2F;master&#39;.\n\nUntracked files:\n  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)\n        &quot;Git\\345\\255\\246\\344\\271\\240.md&quot;\n\nnothing added to commit but untracked files present (use &quot;git add&quot; to track)\n\n\n添加文件\n$ git add .\n\n再次查看文件状态（Changes to be committed）\n$ git status\nOn branch master\nYour branch is up to date with &#39;origin&#x2F;master&#39;.\n\nChanges to be committed:\n  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)\n        new file:   &quot;Git\\345\\255\\246\\344\\271\\240.md&quot;\n\n\n提交到本地仓库\n$ git commit -m &quot;commit message&quot;\n[master 7665630] commit message\n 1 file changed, 119 insertions(+)\n create mode 100644 &quot;Git\\345\\255\\246\\344\\271\\240.md&quot;\n\n\n查看文件状态(nothing to commit)\n$ git status\nOn branch master\nYour branch is ahead of &#39;origin&#x2F;master&#39; by 1 commit.\n  (use &quot;git push&quot; to publish your local commits)\n\nnothing to commit, working tree clean\n\n\nPush到远程仓库\n$ git push\nEnumerating objects: 4, done.\nCounting objects: 100% (4&#x2F;4), done.\nDelta compression using up to 8 threads\nCompressing objects: 100% (3&#x2F;3), done.\nWriting objects: 100% (3&#x2F;3), 1.67 KiB | 1.67 MiB&#x2F;s, done.\nTotal 3 (delta 0), reused 0 (delta 0), pack-reused 0\nTo github.com:NPU-FanZhang&#x2F;JavaNote.git\n   9a7a3c8..7665630  master -&gt; master\n\n\nPull从远程仓库更新（Pull）\n$ git pull\nAlready up to date.\n\n下次打开项目前，进行远程仓库更新（Pull）\n$ git pull\nAlready up to date.\n\nBranch 分支管理新建分支\ngit branch [newbranch] [master] # 新建一个基于master分支 newbranch\ngit checkout [newbranch]\n\n# 然后将新建的分支提交到 远程git服务器\n# push 方法1\ngit push -u origin\n#新建分支第一次push，会提示：\n  fatal: The current branch newbr has no upstream branch.\n  To push the current branch and set the remote as upstream, use\n    git push --set-upstream origin newbranch\n#输入这行命令，然后输入用户名和密码，就push成功了。\ngit push --set-upstream origin [newbranch]\n　　以后的push就只需要输入git push origin\n　　\n# push 方法2\n# 新建了一个叫[newbranch]的分支，而github网站上还没有，可以直接：\ngit push -u origin [newbranch]\n　　这样一个新分支就创建好了。\n\n# push 方法3\n# 提交到github的分支有多个，提交时可以用这样的格式：\ngit push -u origin local:remote\n　　比如：git push -u origin dev:master\n　　表明将本地的dev分支（冒号前）push到github的master分支（冒号后）。\n　　如果左边不写为空，将会删除远程的右边分支。\n\n切换分支\ngit checkout [branch]\n\n删除分支\ngit branch -d [branch]\t#删除本地名为branch的分支\ngit push origin --delete [branch]\t#删除远程仓库中名为branch的分支\n\n合并分支\n#例如将branch合并到master\ngit checkout [master]\t#切换到主分支\ngit merge --no-ff [branch]\t#然后把develop分支merge过来\n#参数意义：\n　　不用参数的默认情况下，是执行快进式合并。\n　　使用参数--no-ff，会执行正常合并，在master分支上生成一个新节点。\n　　merge的时候如果遇到冲突，就手动解决，然后重新add，commit即可。\n\n查看分支\ngit remote show origin # 查看远程分支和本地分支的对应关系\ngit branch # 查看 本地分支\ngit branch -r\t# 查看 远程分支\ngit branch -a\t# 查看 本地远程分支\n\n\n\n\n\n\n","slug":"Git基础","date":"2022-04-07T13:36:21.000Z","categories_index":"互联网八股","tags_index":"Git","author_index":"张 凡"},{"id":"fc14e6deadca9621a12ce14639191e3e","title":"Java Visual Machine","content":"JVM(Java Visual Machine)JVM java二进制字节码运行的环境\nJVM 是java程序可移植性的基石。\n好处:\n\n一次编译，到处执行\n\n自动内存管理\n\n常见错误检查（数组越界检查）\n\n\nJVM组成部分\n\nJVM内存结构\n字节码结构\nJava类加载机制\nGC垃圾回收\n\n\n\n\n\n1. JVM的内存结构JVM 运行时数据区的分类：\n\n\nJVM 运行时数据区的结构：\n\n\n\n线程私有：程序计数器、虚拟机栈、本地方法区\n线程共享：堆、方法区, 堆外内存（Java7的永久代或JDK8的元空间、代码缓存）\n\na. 程序计数器Program Counter Register 程序计数器 (寄存器)\n\n作用:用于保存JVM中下一条所要执行的指令的地址\n特点\n线程私有\nCPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码\n程序计数器是每个线程所私有的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令\n\n\n不会存在内存溢出\n\n\n\nb. 虚拟机栈\n每个线程运行需要的内存空间，称为虚拟机栈\n\n每个栈由多个栈帧Frame组成，对应着每次调用方法时所占用的内存\n\n每个栈帧保存着 方法的参数、局部  变量、返回地址\n\n\n\n每个线程只能有一个活动栈帧，对应着当前正在执行的方法，对应着栈顶的栈帧。\n\n\n问题辨析\n\n垃圾回收是否涉及栈内存？\n不需要。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n\n\n栈内存的分配越大越好吗？\n不是。因为物理内存是一定的，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\n可以使用 -Xss 1M 来指定栈内存大小\n\n\n方法内的局部变量是否是线程安全的？\n如果方法内局部变量没有逃离方法的作用范围，则是线程安全的，因为每个方法都有自己的栈帧，有自己的局部变量内存。\n如果局部变量引用了对象，并逃离了方法的作用范围，则需要考虑线程安全问题\n\n\n\n内存溢出\nJava.lang.stackOverflowError 栈内存溢出\n发生原因\n\n虚拟机栈中，栈帧过多（无限递归）\n每个栈帧所占用过大\n\n线程运行诊断\nCPU占用过高\n\nLinux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程\n\ntop命令，查看是哪个进程占用CPU过高\nps H -eo pid, tid（线程id）, %cpu | grep [刚才通过top查到的进程号]通过ps命令进一步查看是哪个线程占用CPU过高\njstack 进程id 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来对比定位，注意jstack查找出的线程id是16进制的，需要转换\n\n\n\n程序长时间计算不出结果\n\n可能是进程死锁,同样也可以用 jstack 进程id  来进行排查\n\nc. 本地方法栈​    一些带有native关键字的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法，非常多。\nd. 堆定义\n通过new关键字创建的对象都会被放在堆内存\n特点\n\n所有线程共享，堆内存中的对象都需要考虑线程安全问题\n有垃圾回收机制\n\n堆内存溢出\njava.lang.OutofMemoryError ：java heap space. 堆内存溢出\n-Xmx8m  可以设置堆内存大小\n\n堆内存诊断\njps\njmap\njconsole\njvirsalvm\n\n\n\ne. 方法区  方法区（method area）只是 JVM 规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而永久代（PermGen）是 Hotspot 虚拟机特有的概念， Java8 的时候又被元空间取代了，永久代和元空间都可以理解为方法区的落地实现。\n方法区用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。\nJDK8以后 取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中,使用元空间代替。\n内存溢出\n\n1.8以前会导致永久代内存溢出\n1.8以后会导致元空间内存溢出\n\n常量池\n常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息\n二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）\n一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池。\n# StringTable 串池1、String table又称为String pool，字符串常量池，其存在于堆中(1.7之前存在于方法区(永久代)中,jdk1.7之后存放在堆中(因为永久代不常回收))。最重要的一点，String table中存储的并不是String类型的对象，存储的而是指向String对象的索引，真实对象还是存储在堆中。2、此外String table里面不存在相同的两个字符串。3、此外String对象调用intern()方法时，会先在String table中查找是否存在于该对象相同的字符串，若存在直接返回String table中字符串的引用，若不存在则在String table中创建一个与该对象相同的字符串。\n特征\n\n通过HashTable实现\n用来放字符串对象且里面的元素不重复\n常量池中的字符串仅是符号，只有在被用到时才会转化为对象\n利用串池的机制，来避免重复创建字符串对象\n字符串变量拼接的原理是StringBuilder\n字符串常量拼接的原理是编译器优化\n可以使用intern方法，主动将串池中还没有的字符串对象放入串池中\n注意：无论是串池还是堆里面的字符串，都是对象\nStringTable中的数据也会发生垃圾回收。\n\nStringTable 性能调优\n\n如果代码中常量较多,可以通过 -XX:StringTableSize = 桶个数 来扩大串池大小而大大加快程序访问速度。\n同样重复字符串较多时,也可以使用将其添加到串池来减少内存。\n\nintern方法 1.6\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中\n如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n注意：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象都不是同一个对象\nintern方法 1.8\n调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中\n\n如果串池中没有该字符串对象，则放入成功\n如果有该字符串对象，则放入失败\n\n无论放入是否成功，都会返回串池中的字符串对象\n注意：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象\n例子1\nString s1 &#x3D; &quot;a&quot;; &#x2F;&#x2F; 放入常量池中的串池 StringTable\nString s2 &#x3D; &quot;b&quot;; &#x2F;&#x2F; 放入常量池中的串池 StringTable\nString s3 &#x3D; &quot;ab&quot;;&#x2F;&#x2F; 放入常量池中的串池 StringTable\n\nString s4 &#x3D; s1 + s2; &#x2F;&#x2F;新建了对象 等价于下面这句话\n&#x2F;&#x2F; new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()\n&#x2F;&#x2F; new String(&quot;ab&quot;)\n\nString s5 &#x3D; &quot;a&quot; + &quot;b&quot;; &#x2F;&#x2F; 编译期优化 ,发现存在于常量池\nSystem.out.println(s3 ** s4); &#x2F;&#x2F; false\nSystem.out.println(s3 ** s5); &#x2F;&#x2F; true\n\n例子2\nString x &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 此时串池加入 [&quot;ab&quot;]\nString s &#x3D; new String(&quot;a&quot;)+new String(&quot;b&quot;); \n&#x2F;&#x2F; 此时 串池加入[&quot;a&quot;,&quot;b&quot;]   \n&#x2F;&#x2F; 堆内存中加入三个对象 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)  \nString s2 &#x3D; s.intern(); \n&#x2F;&#x2F; 1.8+ 将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则放入,返回串池中的对象地址\n&#x2F;&#x2F; 1.6  将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则把这个对象拷贝一份,放入串池,返回串池中的对象地址\nSystem.out.println(s2 ** x); &#x2F;&#x2F;1.8 true  1.6 true\nSystem.out.println(s ** x);  &#x2F;&#x2F;1.8 false 1.6 false\n\n例子3,对比上面例子2\nString s &#x3D; new String(&quot;a&quot;)+new String(&quot;b&quot;); \n&#x2F;&#x2F; 此时 串池加入[&quot;a&quot;,&quot;b&quot;]   \n&#x2F;&#x2F; 堆内存中加入三个对象 new String(&quot;a&quot;) new String(&quot;b&quot;) new String(&quot;ab&quot;)  \nString s2 &#x3D; s.intern(); \n&#x2F;&#x2F; 1.8+ 将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则放入,返回串池中的对象地址\n&#x2F;&#x2F; 1.6  将这个字符串对象尝试放入串池中,如果有则不会放入,如果没有则把这个对象拷贝一份,放入串池(这个对象和原本的对象已经不属于同一个对象),返回串池中的对象地址\nString x &#x3D; &quot;ab&quot;; &#x2F;&#x2F; 此时串池已经有 [&quot;ab&quot;],是 s 的地址,将x的地址给x\nSystem.out.println(s2 ** x); &#x2F;&#x2F;1.8 true  1.6 true\nSystem.out.println(s ** x);  &#x2F;&#x2F;1.8 true  1.6 false\n\n例子4\nString x2 &#x3D; new String(&quot;c&quot;)+new String(&quot;d&quot;); &#x2F;&#x2F; new String(&quot;cd&quot;)\nString x1 &#x3D; &quot;cd&quot;;\nx2.intern();\nSystem.out.println(x1 ** x2);  &#x2F;&#x2F;1.8 false  1.6 false 原因相同 都是因为常量池中已经有ab了\n\nString x2 &#x3D; new String(&quot;c&quot;)+new String(&quot;d&quot;); &#x2F;&#x2F; new String(&quot;cd&quot;)\nx2.intern();\nString x1 &#x3D; &quot;cd&quot;;\nSystem.out.println(x1 ** x2);  &#x2F;&#x2F;1.8 true  1.6 false 原因不同 1.8由于没有拷贝,所以还相等 1.6由于池中是拷贝的对象,所以不相等.\n\n\n\n\n\n# Direct Memory 直接内存​    由于Java无法直接调用主机的内存,所以在使用普通的io访问时,会在内存中先开辟一个缓存,然后在java堆内存中也开辟一块缓存,读取访问时,会将系统内存的缓存读取到java堆内存中再进行访问,而这一步实际上是冗余操作,如果可以有办法直接访问主机内存,就可以大大提高大文件的访问速度。\n​    直接内存就是通过java调用系统调用在内存中开辟一块内存，叫直接内存，Java和操作系统都可以直接访问,无需将代码从系统内存复制到Java堆内存，从而提高了效率.\n&#x2F;&#x2F;通过ByteBuffer申请1M的直接内存\nByteBuffer byteBuffer &#x3D; ByteBuffer.allocateDirect(_1M);\n\n\n属于操作系统，常见于NIO操作时，用于数据缓冲区\n分配回收成本较高，但读写性能高\n内存不够使用时,会造成OutOfMemory内存溢出错误。\n不受JVM内存回收管理,但会通过unsafe.freeMemory来手动释放\n\n传统阻塞IO：\n\n\n直接内存：\n\n\n\n\n\n\n释放原理\n直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过unsafe.freeMemory来手动释放。\n直接内存的回收机制总结\n\n使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法\nByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存\n\n2. GC Garbage Collectora. 如何确定一个对象是垃圾呢?\n根可达算法 \n\nJVM中的垃圾回收器通过可达性分析来探索所有存活的对象\n扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果找不到，则表示可以回收\n可以作为GC Root的对象\n虚拟机栈（栈帧中的本地变量表）中引用的对象。　\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI（即一般说的Native方法）引用的对象\n被加锁的对象一般不会被回收\n\n\n\n\n引用计数算法\n弊端：循环引用永远不可删除，早期python使用了这种算法。\n\n\n# 常见引用\n强引用\n被强引用关联的对象不会被回收。\n只有GC Root都不引用该对象时，才会回收强引用对象\n使用 new 一个新对象的方式来创建强引用。\nObject obj &#x3D; new Object();\n\n软引用\n软引用就是强引用引用的对象,一般不会被回收\n当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象\n被软引用关联的对象只有在内存不够的情况下才会被回收。\n使用 SoftReference 类来创建软引用。\nObject obj &#x3D; new Object();\nSoftReference&lt;Object&gt; sf &#x3D; new SoftReference&lt;Object&gt;(obj);\nobj &#x3D; null;  &#x2F;&#x2F; 使对象只被软引用关联\n\n弱引用\n被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收(发生Full GC)发生之前。\n使用 WeakReference 类来实现弱引用。\nObject obj &#x3D; new Object();\nWeakReference&lt;Object&gt; wf &#x3D; new WeakReference&lt;Object&gt;(obj);\nobj &#x3D; null;\n\n软引用和弱引用的主要区别就是回收情况,软引用是内存不够才回收,弱引用是下次一定回收.\n\n虚引用\n又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。\n为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。\n使用 PhantomReference 来实现虚引用。\nObject obj &#x3D; new Object();\nPhantomReference&lt;Object&gt; pf &#x3D; new PhantomReference&lt;Object&gt;(obj);\nobj &#x3D; null; \n\n终结器引用\nfinalize()\nfinalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。\n当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。\n\n\nb. 主要的垃圾回收算法:\nMark-Sweep(标记清除算法)\n速度快,但会造成内存碎片\n\nCopying(拷贝)\n将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。\n主要不足是只使用了内存的一半。\n现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。\nHotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象\n总有一半内存用不了，速度很快\n\nMark-Compact(标记整理压缩)\n边回收边整理,慢,但不会有内存碎片\n\n\nc. 分代垃圾回收\n\n大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。\n当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 Minor GC\nMinor GC 会将伊甸园和幸存区FROM存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换两个幸存区(复制算法)\n再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 stop the world， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1\n如果幸存区中的对象的寿命超过某个阈值（最大为15，4bit），就会被放入老年代中\n如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发Full GC，扫描新生代和老年代中所有不再使用的对象并回收\nMinor GC 和 Full GC\n\nMinor GC: 发生在新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\nFull GC: 发生在老年代上，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。\n\n# 内存分配策略1.对象优先在 Eden 分配\n大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。\n2.大对象直接进入老年代\n大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。\n经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。\n-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。\n如果所有的空间都放不下,并且不能回收,就会爆内存溢出。\n3.长期存活的对象进入老年代\n为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。\n-XX:MaxTenuringThreshold 用来定义年龄的阈值。\n4.动态对象年龄判定\n虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。\n5.空间分配担保\n在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。\n如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。\nd. 垃圾回收器\n\n\n\n1、串行\n\n单线程\n堆内存较小，适合个人电脑\nSerial SerialOld\n\n\n\n安全点：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象\n因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入阻塞状态\nSerial 收集器\nSerial收集器是最基本的、发展历史最悠久的收集器\n特点：单线程、简单高效（与其他收集器的单线程相比），采用复制算法。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）\nParNew 收集器\nParNew收集器其实就是Serial收集器的多线程版本\n特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题\nSerial Old 收集器\nSerial Old是Serial收集器的老年代版本\n特点：同样是单线程收集器，采用标记-整理算法\n2、吞吐量优先\n\n多线程\n堆内存大，多核CPU\n让单位时间内，STW的时间最短(单次时间可能较长,总时间可能较短)\n\n\n\nParallel Scavenge 收集器\n与吞吐量关系密切，故也称为吞吐量优先收集器\n特点：属于新生代收集器也是采用复制算法的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）\n该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：GC自适应调节策略（与ParNew收集器最重要的一个区别）\nGC自适应调节策略：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。\nParallel Scavenge收集器使用两个参数控制吞吐量：\n\nXX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间\nXX:GCRatio 直接设置吞吐量的大小\n\nParallel Old 收集器\n是Parallel Scavenge收集器的老年代版本\n特点：多线程，采用标记-整理算法（老年代没有幸存区）\n3、响应时间优先\n\n多线程\n堆内存大，单核CPU\n让单次的STW的时间最短（单次时间短,总时间可能较长,用户不可查）\n\nCMS垃圾回收器\nConcurrentMarkSweepGC  并发(Concurrent是并发,不是并行) 标记 \n一种以获取最短回收停顿时间为目标的老年代收集器,配合ParNewGC一起使用\n特点：基于标记-清除算法实现。并发收集、低停顿，但是会产生内存碎片\n应用场景：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b&#x2F;s服务\nCMS收集器的运行过程分为下列4步：\n初始标记：标记GC Roots能直接到的对象。速度很快但是仍存在Stop The World问题\n并发标记：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行\n重新标记：为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题\n并发清除：对标记的对象进行清除回收\nCMS收集器的内存回收过程是与用户线程一起并发执行的\n# G1 垃圾回收器G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。\n适用场景\n\n同时注重吞吐量和低延迟（响应时间）\n超大堆内存（内存大的），会将堆内存划分为多个大小相等的区域\n整体上是标记-整理算法，两个区域之间是复制算法\n\nG1采用了分区(Region)的思路，将整个堆空间分成若干个大小相等的内存区域，每次分配对象空间将逐段地使用内存。因此，在堆的使用上，G1并不要求对象的存储一定是物理上连续的，只要逻辑上连续即可；每个分区也不会确定地为某个代服务，可以按需在年轻代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize&#x3D;n可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。\n\n\nG1垃圾回收阶段:\n\n\n\n\n1、阶段1 Young Collection\n应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。\n同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。\n2、阶段2 Young Collection + CM（Concurrent Mark）\nCMS和G1在并发标记时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。\nGC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。\n并发标记过程中，删除了所有从灰色到白色的引用，会产生漏标。此时白色对象应该被回收\n产生漏标问题的条件有两个：\n\n黑色对象指向了白色对象\n灰色对象指向白色对象的引用消失\n\n所以要解决漏标问题，打破两个条件之一即可：\n\n跟踪黑指向白的增加 incremental update：增量更新，关注引用的增加，把黑色重新标记为灰色，下次重新扫描属性。CMS采用该方法。\n记录灰指向白的消失 SATB snapshot at the beginning：关注引用的删除，当灰–&gt;白消失时，要把这个 引用 推到GC的堆栈，保证白还能被GC扫描到。G1采用该方法。\n\n3、阶段3 Mixed Collection\n年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比IHOP阈值-XX: InitiatingHeap OccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。\n为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排。\ne. 垃圾回收调优# 通过这个命令可以查看GC的调优指令\nC:\\Users\\Lenovo\\.jdks\\azul-13.0.8\\bin&gt;java -XX:+PrintFlagsFinal -version | findstr &quot;GC&quot;\n\n确定目标\n低延迟&#x2F;高吞吐量？ 选择合适的GC\n\nCMS G1 ZGC\nParallelGC\nZing\n\n最快的GC是不发生GC\n首先排除减少因为自身编写的代码而引发的内存问题\n\n查看Full GC前后的内存占用，考虑以下几个问题\n数据是不是太多？\n数据表示是否太臃肿\n对象图\n对象大小\n\n\n是否存在内存泄漏\n\n\n\n新生代调优\n\n新生代的特点\n所有的new操作分配内存都是非常廉价的\nTLAB\n\n\n死亡对象回收零代价\n大部分对象用过即死（朝生夕死）\nMInor GC 所用时间远小于Full GC\n\n\n新生代内存越大越好么？\n不是\n新生代内存太小：频繁触发Minor GC，会STW，会使得吞吐量下降\n新生代内存太大：老年代内存占比有所降低，会更频繁地触发Full GC。而且触发Minor GC时，清理新生代所花费的时间会更长\n\n\n新生代内存设置为内容纳[并发量*(请求-响应)]的数据为宜\n\n\n\n幸存区调优\n\n幸存区需要能够保存 当前活跃对象+需要晋升的对象\n晋升阈值配置得当，让长时间存活的对象尽快晋升\n\n老年代调优\n\n内存越大越好\n先不尝试做调优,如果没触发Full GC ,则说明已经较优,先尝试新生代调优\n观察Full GC时老年代内存占用,调整大小\n\nJVM GC 面试题\nCMS和G1的异同\n\n\n\n\n\n\n3. 类加载a. 类字节码一个简单的helloworld文件编译后的二进制字节码文件形式如下：\n[root@VM-4-9-centos java-demo]# javac -parameters -d .  HelloWorld.java \n[root@VM-4-9-centos java-demo]# od -t xC HelloWorld.class\n# 行号是8进制   后面为16进制\n0000000 ca fe ba be 00 00 00 34 00 1f 0a 00 06 00 11 09\n0000020 00 12 00 13 08 00 14 0a 00 15 00 16 07 00 17 07\n0000040 00 18 01 00 06 3c 69 6e 69 74 3e 01 00 03 28 29\n0000060 56 01 00 04 43 6f 64 65 01 00 0f 4c 69 6e 65 4e\n0000100 75 6d 62 65 72 54 61 62 6c 65 01 00 04 6d 61 69\n0000120 6e 01 00 16 28 5b 4c 6a 61 76 61 2f 6c 61 6e 67\n0000140 2f 53 74 72 69 6e 67 3b 29 56 01 00 10 4d 65 74\n0000160 68 6f 64 50 61 72 61 6d 65 74 65 72 73 01 00 04\n0000200 61 72 67 73 01 00 0a 53 6f 75 72 63 65 46 69 6c\n0000220 65 01 00 0f 48 65 6c 6c 6f 57 6f 72 6c 64 2e 6a\n0000240 61 76 61 0c 00 07 00 08 07 00 19 0c 00 1a 00 1b\n0000260 01 00 0c 48 65 6c 6c 6f 20 77 6f 72 6c 64 21 07\n0000300 00 1c 0c 00 1d 00 1e 01 00 0a 48 65 6c 6c 6f 57\n0000320 6f 72 6c 64 01 00 10 6a 61 76 61 2f 6c 61 6e 67\n0000340 2f 4f 62 6a 65 63 74 01 00 10 6a 61 76 61 2f 6c\n0000360 61 6e 67 2f 53 79 73 74 65 6d 01 00 03 6f 75 74\n0000400 01 00 15 4c 6a 61 76 61 2f 69 6f 2f 50 72 69 6e\n0000420 74 53 74 72 65 61 6d 3b 01 00 13 6a 61 76 61 2f\n0000440 69 6f 2f 50 72 69 6e 74 53 74 72 65 61 6d 01 00\n0000460 07 70 72 69 6e 74 6c 6e 01 00 15 28 4c 6a 61 76\n0000500 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b 29 56\n0000520 00 21 00 05 00 06 00 00 00 00 00 02 00 01 00 07\n0000540 00 08 00 01 00 09 00 00 00 1d 00 01 00 01 00 00\n0000560 00 05 2a b7 00 01 b1 00 00 00 01 00 0a 00 00 00\n0000600 06 00 01 00 00 00 02 00 09 00 0b 00 0c 00 02 00\n0000620 09 00 00 00 25 00 02 00 01 00 00 00 09 b2 00 02\n0000640 12 03 b6 00 04 b1 00 00 00 01 00 0a 00 00 00 0a\n0000660 00 02 00 00 00 05 00 08 00 07 00 0d 00 00 00 05\n0000700 01 00 0e 00 00 00 01 00 0f 00 00 00 02 00 10\n0000717\n\n根据 JVM 规范，类文件结构如下\n#u4 表示长度   后面代表项\nu4 \t\t\t  magic\nu2             minor_version;    \nu2             major_version;    \nu2             constant_pool_count;    \ncp_info        constant_pool[constant_pool_count-1];    \nu2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   \nu2             fields_count;    \nfield_info     fields[fields_count];   \nu2             methods_count;    \nmethod_info    methods[methods_count];    \nu2             attributes_count;    \nattribute_info attributes[attributes_count];Copy\n\n\n\n**魔数 **magic\nu4 magic\n对应字节码文件的0~3个字节\n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n**版本 **major_version;  \n0000000 ca fe ba be 00 00 00 34 00 23 0a 00 06 00 15 09\n34H &#x3D; 52，代表JDK8\n常量池 constant_pool_count;    \n00 23(35) 表示常量池有#1 ~ #34项\n后面的字节码要对照 编码表,比如 0a 00 06 00 15 中 \n0a 表示这是个方法\n00 06 和00 15表示他引用常量池的#6 和 #21来获得方法的 所属类和方法名,后面以此类推。\n访问标识 access_flags 和 继承信息\nu2             access_flags;    \nu2             this_class;    \nu2             super_class;   \nu2             interfaces_count;    \nu2             interfaces[interfaces_count];   \n\n\n\nfields信息\nu2             fields_count;    \nfield_info     fields[fields_count]; \n\n\n\n方法\nu2             methods_count;    \nmethod_info    methods[methods_count];    \n\n\n\n附加属性\nu2             attributes_count;    \nattribute_info attributes[attributes_count];Copy\n\n\n\n# javap 反编译class文件[root@VM-4-9-centos java-demo]# javap -v HelloWorld.class \n# 类文件信息\nClassfile &#x2F;java-demo&#x2F;HelloWorld.class\n  Last modified Mar 9, 2022; size 463 bytes\n  MD5 checksum 9d73b329c5539fa860d172779e6ce0eb\n  Compiled from &quot;HelloWorld.java&quot;\npublic class HelloWorld\n  minor version: 0\n  major version: 52\n  flags: ACC_PUBLIC, ACC_SUPER\n# 常量池\nConstant pool:\n   #1 &#x3D; Methodref          #6.#17         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n   #2 &#x3D; Fieldref           #18.#19        &#x2F;&#x2F; java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;\n   #3 &#x3D; String             #20            &#x2F;&#x2F; Hello world!\n   #4 &#x3D; Methodref          #21.#22        &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V\n   #5 &#x3D; Class              #23            &#x2F;&#x2F; HelloWorld\n   #6 &#x3D; Class              #24            &#x2F;&#x2F; java&#x2F;lang&#x2F;Object\n   #7 &#x3D; Utf8               &lt;init&gt;\n   #8 &#x3D; Utf8               ()V\n   #9 &#x3D; Utf8               Code\n  #10 &#x3D; Utf8               LineNumberTable\n  #11 &#x3D; Utf8               main\n  #12 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V\n  #13 &#x3D; Utf8               MethodParameters\n  #14 &#x3D; Utf8               args\n  #15 &#x3D; Utf8               SourceFile\n  #16 &#x3D; Utf8               HelloWorld.java\n  #17 &#x3D; NameAndType        #7:#8          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V\n  #18 &#x3D; Class              #25            &#x2F;&#x2F; java&#x2F;lang&#x2F;System\n  #19 &#x3D; NameAndType        #26:#27        &#x2F;&#x2F; out:Ljava&#x2F;io&#x2F;PrintStream;\n  #20 &#x3D; Utf8               Hello world!\n  #21 &#x3D; Class              #28            &#x2F;&#x2F; java&#x2F;io&#x2F;PrintStream\n  #22 &#x3D; NameAndType        #29:#30        &#x2F;&#x2F; println:(Ljava&#x2F;lang&#x2F;String;)V\n  #23 &#x3D; Utf8               HelloWorld\n  #24 &#x3D; Utf8               java&#x2F;lang&#x2F;Object\n  #25 &#x3D; Utf8               java&#x2F;lang&#x2F;System\n  #26 &#x3D; Utf8               out\n  #27 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;\n  #28 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream\n  #29 &#x3D; Utf8               println\n  #30 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V\n  \n# 方法信息\n&#123;\n# 构造方法\n  public HelloWorld();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1\n         0: aload_0\n         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 2: 0\n# main 方法\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V\n    flags: ACC_PUBLIC, ACC_STATIC   # 访问修饰符\n    Code:\n      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1   # 栈信息\n         0: getstatic     #2                  &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;\n         3: ldc           #3                  &#x2F;&#x2F; String Hello world!\n         5: invokevirtual #4                  &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V\n         8: return\n      LineNumberTable:\n        line 5: 0\n        line 7: 8\n    MethodParameters:\n      Name                           Flags\n      args\n&#125;\nSourceFile: &quot;HelloWorld.java&quot;\n\njava字节码文件的执行流程:\n\n\n# 方法调用编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在后\n不同方法在调用时，对应的虚拟机指令有所区别\n\n私有、构造、被final修饰的方法，在调用时都使用invokespecial指令\n普通成员方法在调用时，使用invokespecial指令。因为编译期间无法确定该方法的内容，只有在运行期间才能确定\n静态方法在调用时使用invokestatic指令\n\n# 多态原理因为普通成员方法需要在运行时才能确定具体的内容，所以虚拟机需要调用invokevirtual指令\n在执行invokevirtual指令时，经历了以下几个步骤\n\n先通过栈帧中对象的引用找到对象\n分析对象头，找到对象实际的Class\nClass结构中有vtable 虚方法表\n查询vtable找到方法的具体地址\n执行方法的字节码\n\n# 异常处理\n可以看到多出来一个 Exception table 的结构，[from, to) 是前闭后开（也就是检测2~4行）的检测范围，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号\n\n8行的字节码指令 astore_2 是将异常对象引用存入局部变量表的2号位置（为e）\n\nﬁnally 中的代码被复制多份，分别放入 try 流程，catch 流程以及 catch剩余的异常类型流程\n\n注意：虽然从字节码指令看来，每个块中都有finally块，但是finally块中的代码只会被执行一次\n\n由于 ﬁnally 中的 ireturn 被插入了所有可能的流程，因此返回结果肯定以ﬁnally的为准\n\n至于字节码中第 2 行，似乎没啥用，且留个伏笔，看下个例子\n\n跟上例中的 ﬁnally 相比，发现没有 athrow 了，这告诉我们：如果在 ﬁnally 中出现了 return，会吞掉异常\n\n所以不要在finally中进行返回操作\n\n\nb. 语法糖所谓的 语法糖 ，其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利\n注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。\n1. 默认构造函数public class Candy1 &#123;\n&#125;\n\n经过编译期优化后\npublic class Candy1 &#123;\n   &#x2F;&#x2F;这个无参构造器是java编译器帮我们加上的\n   public Candy1() &#123;\n      &#x2F;&#x2F;即调用父类 Object 的无参构造方法，即调用 java&#x2F;lang&#x2F;Object.&quot; &lt;init&gt;&quot;:()V\n      super();\n   &#125;\n&#125;\n\n2. 自动拆装箱基本类型和其包装类型的相互转换过程，称为拆装箱\n在JDK 5以后，它们的转换可以在编译期自动完成\npublic class Demo2 &#123;\n   public static void main(String[] args) &#123;\n      Integer x &#x3D; 1;\n      int y &#x3D; x;\n   &#125;\n&#125;\n\n转换过程如下\npublic class Demo2 &#123;\n   public static void main(String[] args) &#123;\n      &#x2F;&#x2F;基本类型赋值给包装类型，称为装箱\n      Integer x &#x3D; Integer.valueOf(1);\n      &#x2F;&#x2F;包装类型赋值给基本类型，称谓拆箱\n      int y &#x3D; x.intValue();\n   &#125;\n&#125;\n\n3. 泛型集合取值泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理：\npublic class Demo3 &#123;\n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; new ArrayList&lt;&gt;();\n      list.add(10);\n      Integer x &#x3D; list.get(0);\n   &#125;\n&#125;\n\n对应字节码\nCode:\n    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1\n       0: new           #2                  &#x2F;&#x2F; class java&#x2F;util&#x2F;ArrayList\n       3: dup\n       4: invokespecial #3                  &#x2F;&#x2F; Method java&#x2F;util&#x2F;ArrayList.&quot;&lt;init&gt;&quot;:()V\n       7: astore_1\n       8: aload_1\n       9: bipush        10\n      11: invokestatic  #4                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Integer.valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;\n      &#x2F;&#x2F;这里进行了泛型擦除，实际调用的是add(Objcet o)\n      14: invokeinterface #5,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.add:(Ljava&#x2F;lang&#x2F;Object;)Z\n\n      19: pop\n      20: aload_1\n      21: iconst_0\n      &#x2F;&#x2F;这里也进行了泛型擦除，实际调用的是get(Object o)   \n      22: invokeinterface #6,  2            &#x2F;&#x2F; InterfaceMethod java&#x2F;util&#x2F;List.get:(I)Ljava&#x2F;lang&#x2F;Object;\n      &#x2F;&#x2F;这里进行了类型转换，将Object转换成了Integer\n      27: checkcast     #7                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;Integer\n      30: astore_2\n      31: returnCopy\n\n所以调用get函数取值时，有一个类型转换的操作\nInteger x &#x3D; (Integer) list.get(0);\n\n如果要将返回结果赋值给一个int类型的变量，则还有自动拆箱的操作\nint x &#x3D; (Integer) list.get(0).intValue();\n\n\n\n4. 可变参数public class Demo4 &#123;\n   public static void foo(String... args) &#123;\n      &#x2F;&#x2F;将args赋值给arr，可以看出String...实际就是String[] \n      String[] arr &#x3D; args;\n      System.out.println(arr.length);\n   &#125;\n\n   public static void main(String[] args) &#123;\n      foo(&quot;hello&quot;, &quot;world&quot;);\n   &#125;\n&#125;\n\n可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为：\npublic class Demo4 &#123;\n   public Demo4 &#123;&#125;\n\n    \n   public static void foo(String[] args) &#123;\n      String[] arr &#x3D; args;\n      System.out.println(arr.length);\n   &#125;\n\n   public static void main(String[] args) &#123;\n      foo(new String[]&#123;&quot;hello&quot;, &quot;world&quot;&#125;);\n   &#125;\n&#125;\n\n注意，如果调用的是foo()，即未传递参数时，等价代码为foo(new String[]{})，创建了一个空数组，而不是直接传递的null\n5. foreachpublic class Demo5 &#123;\n\tpublic static void main(String[] args) &#123;\n        &#x2F;&#x2F;数组赋初值的简化写法也是一种语法糖。\n\t\tint[] arr &#x3D; &#123;1, 2, 3, 4, 5&#125;;\n\t\tfor(int x : arr) &#123;\n\t\t\tSystem.out.println(x);\n\t\t&#125;\n\t&#125;\n&#125;\n\n编译器会帮我们转换为\npublic class Demo5 &#123;\n    public Demo5 &#123;&#125;\n\n\tpublic static void main(String[] args) &#123;\n\t\tint[] arr &#x3D; new int[]&#123;1, 2, 3, 4, 5&#125;;\n\t\tfor(int i&#x3D;0; i&lt;arr.length; ++i) &#123;\n\t\t\tint x &#x3D; arr[i];\n\t\t\tSystem.out.println(x);\n\t\t&#125;\n\t&#125;\n&#125;\n\n如果是集合使用foreach\npublic class Demo5 &#123;\n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);\n      for (Integer x : list) &#123;\n         System.out.println(x);\n      &#125;\n   &#125;\n&#125;\n\n集合要使用foreach，需要该集合类实现了Iterable接口，因为集合的遍历需要用到迭代器Iterator\npublic class Demo5 &#123;\n    public Demo5 &#123;&#125;\n    \n   public static void main(String[] args) &#123;\n      List&lt;Integer&gt; list &#x3D; Arrays.asList(1, 2, 3, 4, 5);\n      &#x2F;&#x2F;获得该集合的迭代器\n      Iterator&lt;Integer&gt; iterator &#x3D; list.iterator();\n      while(iterator.hasNext()) &#123;\n         Integer x &#x3D; iterator.next();\n         System.out.println(x);\n      &#125;\n   &#125;\n&#125;\n\n6. switch字符串public class Demo6 &#123;\n   public static void main(String[] args) &#123;\n      String str &#x3D; &quot;hello&quot;;\n      switch (str) &#123;\n         case &quot;hello&quot; :\n            System.out.println(&quot;h&quot;);\n            break;\n         case &quot;world&quot; :\n            System.out.println(&quot;w&quot;);\n            break;\n         default:\n            break;\n      &#125;\n   &#125;\n&#125;\n\n在编译器中执行的操作\npublic class Demo6 &#123;\n   public Demo6() &#123;\n      \n   &#125;\n   public static void main(String[] args) &#123;\n      String str &#x3D; &quot;hello&quot;;\n      int x &#x3D; -1;\n      &#x2F;&#x2F;通过字符串的hashCode+value来判断是否匹配\n      switch (str.hashCode()) &#123;\n         &#x2F;&#x2F;hello的hashCode\n         case 99162322 :\n            &#x2F;&#x2F;再次比较，因为字符串的hashCode有可能相等\n            if(str.equals(&quot;hello&quot;)) &#123;\n               x &#x3D; 0;\n            &#125;\n            break;\n         &#x2F;&#x2F;world的hashCode\n         case 11331880 :\n            if(str.equals(&quot;world&quot;)) &#123;\n               x &#x3D; 1;\n            &#125;\n            break;\n         default:\n            break;\n      &#125;\n\n      &#x2F;&#x2F;用第二个switch在进行输出判断\n      switch (x) &#123;\n         case 0:\n            System.out.println(&quot;h&quot;);\n            break;\n         case 1:\n            System.out.println(&quot;w&quot;);\n            break;\n         default:\n            break;\n      &#125;\n   &#125;\n&#125;\n\n过程说明：\n\n在编译期间，单个的switch被分为了两个\n第一个用来匹配字符串，并给x赋值\n字符串的匹配用到了字符串的hashCode，还用到了equals方法\n使用hashCode是为了提高比较效率，使用equals是防止有hashCode冲突（如BM和C.）\n\n\n第二个用来根据x的值来决定输出语句\n\n\n\n7. 枚举类enum SEX &#123;\n   MALE, FEMALE;\n&#125;\t\n\n转换后的代码\npublic final class Sex extends Enum&lt;Sex&gt; &#123;   \n   &#x2F;&#x2F;对应枚举类中的元素\n   public static final Sex MALE;    \n   public static final Sex FEMALE;    \n   private static final Sex[] $VALUES;\n   \n    static &#123;       \n    \t&#x2F;&#x2F;调用构造函数，传入枚举元素的值及ordinal\n    \tMALE &#x3D; new Sex(&quot;MALE&quot;, 0);    \n        FEMALE &#x3D; new Sex(&quot;FEMALE&quot;, 1);   \n        $VALUES &#x3D; new Sex[]&#123;MALE, FEMALE&#125;; \n   &#125;\n \t\n   &#x2F;&#x2F;调用父类中的方法\n    private Sex(String name, int ordinal) &#123;     \n        super(name, ordinal);    \n    &#125;\n   \n    public static Sex[] values() &#123;  \n        return $VALUES.clone();  \n    &#125;\n    public static Sex valueOf(String name) &#123; \n        return Enum.valueOf(Sex.class, name);  \n    &#125;   \n&#125;\n\n8. 匿名内部类public class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(&quot;running...&quot;);\n         &#125;\n      &#125;;\n   &#125;\n&#125;C\n\n转换后的代码\npublic class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      &#x2F;&#x2F;用额外创建的类来创建匿名内部类对象\n      Runnable runnable &#x3D; new Demo8$1();\n   &#125;\n&#125;\n\n&#x2F;&#x2F;创建了一个额外的类，实现了Runnable接口\nfinal class Demo8$1 implements Runnable &#123;\n   public Demo8$1() &#123;&#125;\n\n   @Override\n   public void run() &#123;\n      System.out.println(&quot;running...&quot;);\n   &#125;\n&#125;\n\n如果匿名内部类中引用了局部变量\npublic class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 1;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(x);\n         &#125;\n      &#125;;\n   &#125;\n&#125;\n\n转化后代码\npublic class Demo8 &#123;\n   public static void main(String[] args) &#123;\n      int x &#x3D; 1;\n      Runnable runnable &#x3D; new Runnable() &#123;\n         @Override\n         public void run() &#123;\n            System.out.println(x);\n         &#125;\n      &#125;;\n   &#125;\n&#125;\n\nfinal class Demo8$1 implements Runnable &#123;\n   &#x2F;&#x2F;多创建了一个变量\n   int val$x;\n   &#x2F;&#x2F;变为了有参构造器\n   public Demo8$1(int x) &#123;\n      this.val$x &#x3D; x;\n   &#125;\n\n   @Override\n   public void run() &#123;\n      System.out.println(val$x);\n   &#125;\n&#125;\n\n\n\nc. 类加载机制1. 加载\n将类的字节码载入方法区（1.8后为元空间，在本地内存中）中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有：\n_java_mirror 即 java 的类镜像，例如对 String 来说，它的镜像类就是 String.class，作用是把 klass 暴露给 java 使用\n_super 即父类\n_ﬁelds 即成员变量\n_methods 即方法\n_constants 即常量池\n_class_loader 即类加载器\n_vtable 虚方法表\n_itable 接口方法\n\n\n如果这个类还有父类没有加载，先加载父类\n加载和链接可能是交替运行的\ninstanceKlass保存在方法区。JDK 8以后，方法区位于元空间中，而元空间又位于本地内存中\n_java_mirror则是保存在堆内存中\nInstanceKlass和*.class(JAVA镜像类)互相保存了对方的地址\n类的对象在对象头中保存了*.class的地址。让对象可以通过其找到方法区中的instanceKlass，从而获取类的各种信息\n\n2. 链接a. 验证验证类是否符合 JVM规范，安全性检查\nb. 准备为 static 变量分配空间，设置默认值\n\nstatic变量在 JDK 7 以前是存储与instanceKlass末尾。但在JDK 7以后就存储在_java_mirror末尾了\nstatic变量在分配空间和赋值是在两个阶段完成的。分配空间在准备阶段完成，赋值在初始化阶段完成\n如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶段完成\n如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成\n\nc. 解析将常量池中的符号引用解析为直接引用\n\n未解析时，常量池中的看到的对象仅是符号，未真正的存在于内存中\n解析以后，会将常量池中的符号引用解析为直接引用\n\n3. 初始化初始化阶段就是 执行类构造器clinit()方法的过程，虚拟机会保证这个类的『构造方法』的线程安全\n\nclinit()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的\n\na. 初始化发生时机类的初始化的懒惰的，以下情况会初始化\n\nmain 方法所在的类，总会被首先初始化\n首次访问这个类的静态变量或静态方法时\n子类初始化，如果父类还没初始化，会引发\n子类访问父类的静态变量，只会触发父类的初始化\nClass.forName\nnew 会导致初始化\n\n以下情况不会初始化\n\n访问类的 static ﬁnal 静态常量（基本类型和字符串）\n类对象.class 不会触发初始化\n创建该类对象的数组\n类加载器的.loadClass方法\nClass.forNamed的参数2为false时\n\n验证类是否被初始化，可以看改类的静态代码块是否被执行\nd. 类加载器​    Java虚拟机设计团队有意把类加载阶段中的“通过一个类的全限定名来获取描述该类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（ClassLoader）类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。\n​    站在Java虚拟机的角度来讲，只存在两种不同的类加载器: 启动类加载器: 它使用C++实现(这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的)，是虚拟机自身的一部分；所有其他的类加载器: 这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。\n​    对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等\n以JDK 8为例\n\n\n\n名称\n加载的类\n说明\n\n\n\nBootstrap ClassLoader（启动类加载器）\nJAVA_HOME/jre/lib\n无法直接访问\n\n\nExtension ClassLoader(拓展类加载器)\nJAVA_HOME/jre/lib/ext\n上级为Bootstrap，显示为null\n\n\nApplication ClassLoader(应用程序类加载器)\nclasspath\n上级为Extension\n\n\n自定义类加载器\n自定义\n上级为Application\n\n\n1. 启动类加载器可通过在控制台输入指令，使得类被启动类加器加载\n2. 拓展类加载器​    如果classpath和 JAVA_HOME/jre/lib/ext下有同名类，加载时会使用拓展类加载器加载。\n​    当应用程序类加载器发现拓展类加载器已将该同名类加载过了，则不会再次加载。\n3. 双亲委派模式双亲委派模式，即调用类加载器  ClassLoader 的 loadClass 方法时，查找类的规则\nloadClass源码\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve)\n    throws ClassNotFoundException\n&#123;\n    synchronized (getClassLoadingLock(name)) &#123;\n        &#x2F;&#x2F; 首先查找该类是否已经被该类加载器加载过了\n        Class&lt;?&gt; c &#x3D; findLoadedClass(name);\n        &#x2F;&#x2F;如果没有被加载过\n        if (c ** null) &#123;\n            long t0 &#x3D; System.nanoTime();\n            try &#123;\n                &#x2F;&#x2F;看是否被它的上级加载器加载过了 Extension的上级是Bootstarp，但它显示为null\n                if (parent !&#x3D; null) &#123;\n                    c &#x3D; parent.loadClass(name, false);\n                &#125; else &#123;\n                    &#x2F;&#x2F;看是否被启动类加载器加载过\n                    c &#x3D; findBootstrapClassOrNull(name);\n                &#125;\n            &#125; catch (ClassNotFoundException e) &#123;\n                &#x2F;&#x2F; ClassNotFoundException thrown if class not found\n                &#x2F;&#x2F; from the non-null parent class loader\n                &#x2F;&#x2F;捕获异常，但不做任何处理\n            &#125;\n            if (c ** null) &#123;\n                &#x2F;&#x2F;如果还是没有找到，先让拓展类加载器调用findClass方法去找到该类，如果还是没找到，就抛出异常\n                &#x2F;&#x2F;然后让应用类加载器去找classpath下找该类\n                long t1 &#x3D; System.nanoTime();\n                c &#x3D; findClass(name);\n                &#x2F;&#x2F; 记录时间\n                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);\n                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);\n                sun.misc.PerfCounter.getFindClasses().increment();\n            &#125;\n        &#125;\n        if (resolve) &#123;\n            resolveClass(c);\n        &#125;\n        return c;\n    &#125;\n&#125;\n\n于是要显示的调用Classd的forName方法使用一个能加载驱动的加载器加载驱动 \n4. 自定义类加载器使用场景\n\n想加载非 classpath 随意路径中的类文件\n通过接口来使用实现，希望解耦时，常用在框架设计\n这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器\n\n步骤\n\n继承ClassLoader父类\n要遵从双亲委派机制，重写 ﬁndClass 方法\n不是重写loadClass方法，否则不会走双亲委派机制\n\n\n读取类文件的字节码\n调用父类的 deﬁneClass 方法来加载类\n使用者调用该类加载器的 loadClass 方法\n\n破坏双亲委派模式\n\n双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK1.2面世以前的“远古”时代\n建议用户重写findClass()方法，在类加载器中的loadClass()方法中也会调用该方法\n\n\n双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的\n如果有基础类型又要调用回用户的代码，此时也会破坏双亲委派模式\n\n\n双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的\n这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等\n\n\n\n4. JVM 运行期优化a. 分层编译JVM 将执行状态分成了 5 个层次：\n\n0层：解释执行，用解释器将字节码翻译为机器码\n1层：使用 C1 即时编译器编译执行（不带 proﬁling）\n2层：使用 C1 即时编译器编译执行（带基本的profiling）\n3层：使用 C1 即时编译器编译执行（带完全的profiling）\n4层：使用 C2 即时编译器编译执行\n\nproﬁling 是指在运行过程中收集一些程序执行状态的数据，例如【方法的调用次数】，【循环的 回边次数】等\n1. 即时编译器（JIT）与解释器的区别\n解释器\n将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释\n是将字节码解释为针对所有平台都通用的机器码\n\n\n即时编译器\n将一些字节码编译为机器码，并存入 Code Cache，下次遇到相同的代码，直接执行，无需再编译\n根据平台类型，生成平台特定的机器码\n\n\n\n​    对于大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。 执行效率上简单比较一下 Interpreter &lt; C1 &lt; C2，总的目标是发现热点代码（hotspot名称的由 来），并优化这些热点代码。\n2. C2 JIT 逃逸分析逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术\n逃逸分析的 JVM 参数如下：\n\n开启逃逸分析：-XX:+DoEscapeAnalysis\n关闭逃逸分析：-XX:-DoEscapeAnalysis\n显示分析结果：-XX:+PrintEscapeAnalysis\n\n逃逸分析技术在 Java SE 6u23+ 开始支持，并默认设置为启用状态，可以不用额外加这个参数。\nb. 方法内联1. 内联函数内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来直接进行替换。\n2. JVM内联函数C++是否为内联函数由自己决定，Java由编译器决定。Java不支持直接声明为内联函数的，如果想让他内联，你只能够向编译器提出请求: 关键字final修饰 用来指明那个函数是希望被JVM内联的，如\npublic final void doSomething() &#123;  \n        &#x2F;&#x2F; to do something  \n&#125;\n\n总的来说，一般的函数都不会被当做内联函数，只有声明了final后，编译器才会考虑是不是要把你的函数变成内联函数\nJVM内建有许多运行时优化。首先短方法更利于JVM推断。流程更明显，作用域更短，副作用也更明显。如果是长方法JVM可能直接就跪了。\n如果JVM监测到一些小方法被频繁的执行，它会把方法的调用替换成方法体本身，如：\nprivate int add4(int x1, int x2, int x3, int x4) &#123; \n    &#x2F;&#x2F;这里调用了add2方法\n    return add2(x1, x2) + add2(x3, x4);  \n&#125;  \n\nprivate int add2(int x1, int x2) &#123;  \n    return x1 + x2;  \n&#125;\n\n方法调用被替换后\nprivate int add4(int x1, int x2, int x3, int x4) &#123;  \n    &#x2F;&#x2F;被替换为了方法本身\n    return x1 + x2 + x3 + x4;  \n&#125;\n\n4. 字段优化   字段优化即就是在方法内联时,如果需要进行字段访问,会先将参数等字段存到缓存,访问会加快速度。 \n5. 反射优化​    如果一个方法调用通过反射调用,在多次循环调用(默认15次)后,会由编译器优化为从反射调用变为正常调用，即直接调用 Reflect1.foo()。\n5. Java 内存模型Java内存模型和Java内存结构的区别：\n\n内存模型-Java Memory Model(JMM): JMM定义了一套在多线程读写共享数据(成员变量、数组等)时，对数据的可见性、有序性和原子性的规则。\n内存结构：就是程序在运行时，线程的内存划分。\n\na.  原子性对于一个静态变量的多线程访问,不同运行可能会产生不同结果,这是为什么呢? \n因为Java中对静态变量的自增自减操作并不是原子操作。\ni++的字节码:\ngetstatic\t\ti\t# 获取静态变量值\niconst_1\t\t\t# 准备常量1\nidd\t\t\t\t\t# 自增\nputstatic\t\ti\t# 将修改后值存入静态变量\n\ni–的字节码:\ngetstatic\t\ti\t# 获取静态变量值\niconst_1\t\t\t# 准备常量1\nisub\t\t\t\t# 自减\nputstatic\t\ti\t# 将修改后值存入静态变量\n\n本质上，静态变量是存储在线程共享内存中的，不同线程访问切换时，可能会导致上述字节码不是顺序执行的，从而导致结果不确定性。\n1. 解决方案synchronized(同步关键字)\n\n语法如下\nsynchronized(对象)&#123;\n\t&#x2F;&#x2F; 要作为原子操作的代码\n&#125;\n\n\nsynchronized 只能给对象加锁,加锁的整个代码块都是原子操作\n可以把synchronized代码块看做一个房间,对象就是房间号,而这个房间同时只能由一个线程进入执行。\n注意 synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。\n但缺点是 synchronized 是属于重量级操作，性能相对更低。\n\nb. 可见性static Boolean run &#x3D; true;\npublic static void main(String[] args) throws InterruptedException &#123;\n    new Thread(()-&gt;&#123;\n        while (run) &#123;\n            &#x2F;&#x2F;如果run为真，则一直执行\n        &#125;\n    &#125;).start();\n\n    Thread.sleep(1000);\n    System.out.println(&quot;改变run的值为false&quot;);\n    &#x2F;&#x2F;这时想要线程退出,但线程并不会退出\n    run &#x3D; false;\n&#125;\n\n上述线程的循环永远退不出,原因是 静态变量run的改变在主内存中,子线程将run读取到自己的高速缓存中后,和主线程断绝了同步导致无法停止。\n\n\n1. 解决方法\n使用volatile易变关键字\n它可以用来修饰成员变量和静态成员变量（放在主存中的变量），他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存\n\n&#x2F;&#x2F;使用易变关键字\nvolatile static Boolean run &#x3D; true;\npublic static void main(String[] args) throws InterruptedException &#123;\n\tnew Thread(()-&gt;&#123;\n\t\twhile (run) &#123;\n\t\t\t&#x2F;&#x2F;如果run为真，则一直执行\n\t\t&#125;\n\t&#125;).start();\n\n\tThread.sleep(1000);\n\tSystem.out.println(&quot;改变run的值为false&quot;);\n\trun &#x3D; false;\n&#125;\n\n可见性，它保证的是在多个线程之间，一个线程对volatile变量的修改对另一个线程可见， 不能保证原子性，仅适用在一个写线程，多个读线程的情况。\n\n如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到 对 run 变量的修改了，想一想为什么？\n\n因为println()里面使用了synchronized关键字\npublic void println(String x) &#123;\n\t\t&#x2F;&#x2F;使用了synchronized关键字\n        synchronized (this) &#123;\n            print(x);\n            newLine();\n        &#125;\n    &#125;\n\n\n\nc. 有序性在执行如下操作时:\nstatic int i;\nstatic int j;\n&#x2F;&#x2F; 在某个线程内执行如下赋值操作\n\ni&#x3D; xxxxxxx; &#x2F;&#x2F; 假设这个指令比较耗时\nj &#x3D; yyy;\n\nJVM 在不影响正确性的情况下,对一些不相关语句的执行顺序进行调整。上面这个例子可能会 先给j赋值再给i赋值。\n这在同一个线程内，不会造成问题，多线程可能会造成错误结果。\n1. 指令重排JVM 会在不影响正确性的前提下，可以调整语句的执行顺序\n这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。\n2. 解决办法volatile修饰的变量，可以禁用指令重排\n\n禁止的是加volatile关键字变量之前的代码被重排序\n\nd. CAS 与原子类1.CASCAS 即 Compare and swap ,它体现了一种乐观锁的思想,比如多个线程要对一个共享的整型变量执行+1操作:\n&#x2F;&#x2F; 不断尝试\nwhile(true)&#123;\n    int old &#x3D; 共享变量;     &#x2F;&#x2F; 拿到当前值0\n    int result &#x3D; old + 1;  &#x2F;&#x2F; 在旧值0基础上+1 结果为1\n   \t&#x2F;* \n   \t如果这时候别的线程把共享变量改成5 本线程为1就作废\n   \tcompareAndSwap(old,result) false 重新尝试\n    直到compareAndSwap(old,result)返回true,然后退出循环\n   \t*&#x2F;\n    if(compareAndSwap(old,result))&#123;\n        &#x2F;&#x2F; 成功,退出循环\n    &#125;\n&#125;\n\n获取共享变量时,为了保证该变量的可见性,需要用volatile修饰。结合CAS和volatile可以实现无锁并发，适用于竞争不激烈、多核CPU的情况下。\n\n因为没有使用 synchronized ，所以线程不会陷入阻塞，这是提升效率的因素之一。\n如果竞争激烈，可以想到重试必然发生，反而会影响效率。\n\nCAS底层依赖一个Unsafe类来直接调用操作系统底层的CAS指令。\n2.JUCJUC(java.util.concurrent)中提供了原子操作类,可以提供线程安全的操作。如：AtomicInteger,AtomicBoolean等,他们底层就采用了 CAS+volatile 实现无锁并发。\n# 乐观锁与悲观锁\nCAS 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。\nsynchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。\n\n# SynchronizedJava HotSpot JVM中,每个对象都有对象头(class指针,MarkWord),Mark Word 平时存储这个对象的HashCode、分代年龄等，加锁时，这些信息就根据情况被替换为标记位、线程锁记录指针、重量级锁指针、线程ID等内容。\n1. 轻量级锁​    轻量级锁使用场景：当一个对象被多个线程所访问，但访问的时间是错开的（不存在竞争），此时就可以使用轻量级锁来优化。它可以减少重量级锁对线程的阻塞带来地线程开销。从而提高并发性能。\n​    如果当前对象没有被锁定，那么锁标志位位01状态，JVM在执行当前线程时，首先会在当前线程栈帧中创建锁记录Lock Record的空间用于存储锁对象目前的Mark Word的拷贝。\n​    然后，虚拟机使用CAS操作将标记字段Mark Word拷贝到锁记录中，并且将Mark Word更新为指向Lock Record的指针。如果更新成功了，那么这个线程就有用了该对象的锁，并且对象Mark Word的锁标志位更新为(Mark Word中最后的2bit)00，即表示此对象处于轻量级锁定状态\n2. 轻量级锁-锁膨胀​    轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头中，如果成功，则表示没有发生竞争关系。如果失败，表示当前锁存在竞争关系。锁就会膨胀成重量级锁。\n3. 重量级锁-自旋锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 (此过程是不可逆的)\n重量级锁竞争时，还可以使用自旋来优化，如果当前线程在自旋成功（使用锁的线程退出了同步块，释放了锁****），这时就可以避免线程进入阻塞状态。\n4. 偏向锁轻量级锁在没有竞争时，每次重入（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。\n所以引入了偏向锁对性能进行优化：在第一次cas时会将线程的ID写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。\ne. 锁优化原则\n减少上锁时间\n减小锁的粒度-将一个锁拆分为多个锁提高并发度\n锁粗化-多次循环进入锁不如同步块内多次循环\n锁消除-通过JVM逃逸分析,如锁对象的局部变量不会被其他线程访问,就会忽略所有的同步操作。\n读写分离\n\n","slug":"Java-Visual-Machine","date":"2022-04-07T12:46:48.000Z","categories_index":"互联网八股","tags_index":"Java,JVM,Java虚拟机","author_index":"张 凡"},{"id":"696c711dc425c21ecfe6691bc40887b7","title":"JUC","content":"1. JUC 概述所谓JUC是 java.util.concurrent 工具包的简称，这是一个处理线程的工具包，可以实现程序的多线程高并发。\n多线程编程的一般步骤:\n\n创建资源类,在资源类创建属性和操作方法。\n在资源类操作方法:判断、操作、通知\n创建多个线程，调用资源类的操作方法。\n防止虚拟唤醒问题\n\n多线程锁的演变\n\n无锁：多线程抢夺资源\nsynchronized和ReentrantLock，都是独占，每次只可以一个操作，不能共享\nReentrantReadWriteLock，读读可以共享，提升性能，但是不能多人写。缺点：造成死锁（一直读，不能写），读进程不能写，写进程可以读。\n写锁降级为读锁（一般等级写锁高于读锁）\n\na. 进程和线程1. 进程（Process）\n计算机中的程序关于某数据集合上的一次运行活动\n进程是线程的容器\n程序是指令、数据及其组织形式的描述，进程是程序的实体\n系统进行资源分配和调度的基本单位，是操作系统结构的基础\n\n2. 线程（Thread）\n操作系统能够进行运算调度的最小单位\n被包含在进程之中，是进程中的实际运作单位\n一条线程指的是进程中一个单一顺序的控制流\n\n通俗易懂理解\n\n进程代表一个程序的执行，而线程是程序中的某个单元执行流\n程序一旦运行就是进程；进程是资源分配的最小单位而线程是程序执行的最小单位。一个进程中可以并发多个线程，每条线程并行执行不同的任务\n\nb. 线程的状态通过线程枚举类的状态可以看到,线程的状态有: 创建(new)、就绪(runnable)、运行(running)、阻塞(blocked)、time waiting、waiting、消亡（dead）\n\n\n\n\nc. 串行、并行和并发串行(serial):表示所有任务都一一按先后顺序进行并行(parallel):同时取得多个任务，并同时去执行所取得的这些任务并发(concurrent):多个程序可以同时运行、也可以是多进程同时运行或多指令可以同时运行,但并发不一定并行，也可以说并发事件之间不一定要同一时刻发生。 \n通俗易懂的理解  \n\n并发是同一时刻多个线程在访问同一个资源\n并行是多项工作一起执行，之后再汇总\n\n举例比如：多个人访问同个网址，为多个线程访问一个网址，多对一此为并发。而并行是多个工作一起执行，每个工作都是一个资源一个线程。之后合并起来就是一个并行工作\n结合以上的搭配可以产生多路复用或异步的方式\n实际上，对于单核心 CPU 来说，同一时刻只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同时运行起来了，但实际上这些程序中的进程不是一直霸占 CPU 的，而是执行一会停一会\nd. wait和sleep的区别\nwait: Object 的方法，会释放锁，调用它的前提是当前线程占有锁(即代码要在 synchronized 中)\nsleep: Thread 的静态方法，任何对象实例都能调用。不会释放锁，也不需要占用锁\n\n相同点 : 都可以被 interrupted 方法中断,在哪里等待,就在哪里恢复\ne. 管程管程在java中是锁，在操作系统中是monitor监视器\n代表一种同步机制，同一时间内只能有一个线程访问且被保护数据\n比如jvm的同步基于进入和退出，是管程对象实现\n\n每个对象都有一个monitor管程对象，都会随着java的对象进行创建和销毁\n管程对象对临界区加锁和解锁\n\n大意就是进加锁，退是解锁，通过管程对象管理。\n2. Synchronized造成线程安全主要原因是因为数据共享，为了解决这种情况，引出 synchronized，它是 Java 中的关键字，是一种同步锁（对方法或者代码块中存在共享数据的操作）。\n修饰对象的方式\n\n修饰代码块\n修饰方法\n修饰静态方法\n修饰一个类\n\n一个简单的例子\npublic class sync &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket &#x3D; new Ticket();\n        &#x2F;*2个售票员售出30张票*&#x2F;\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller1&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller2&quot;).start();\n    &#125;\n    static class Ticket &#123;\n        public int number &#x3D; 30;\n        public synchronized void sale() &#123;\n            if (number &gt; 0)\n                System.out.println(Thread.currentThread().getName() + &quot;买了1张票&quot; + &quot;,剩余&quot; + (--number) + &quot;张票&quot;);\n            else System.out.println(Thread.currentThread().getName() + &quot;没买到&quot;);\n        &#125;\n    &#125;\n&#125;\n\nseller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\n...\nseller1买了1张票,剩余2张票\nseller1买了1张票,剩余1张票\nseller1买了1张票,剩余0张票\n&#x2F;&#x2F; synchronized不能响应中断,所以访问共享资源时,会在一个线程执行完再执行下一个\nseller1没买到\nseller1没买到\n...\nseller3没买到\nseller3没买到\nseller3没买到\n...\nseller2没买到\nseller2没买到\n\n在实现sale()方法时,加上synchronized关键字,不能响应中断,当第一个线程进入后,访问共享资源时,只有当线程结束才会释放；不加synchronized关键字，两个线程会同时进入这个方法。\n3. 创建线程的方式实际上只有一种方式,就是构造Thread类,其他的是衍生出来的。\n构造Thread类，又衍生出两种方式，一是继承Thread类，二是实现Runnable接口，但无论是那种方式，最终也要创建Thread类的对象或其子类对象。\na. 继承 Thread 类class MyThread extends Thread &#123;\n    @Override\n    public void run() &#123;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;----&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\npublic class ThreadDemo &#123;\n    public static void main(String[] args) &#123;\n        System.out.println(Thread.currentThread().getName() + &quot; &#96;&#x3D; main&quot;);\n        MyThread myThread &#x3D; new MyThread();\n        myThread.start();\n    &#125;\n&#125;\n\n\n\nb. 实现 Runnable接口public class InheritedInterface &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;--- in Runnable ---&quot;);\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new MyThread());\n        t1.start();\n    &#125;\n&#125;\n\nc. 实现 Callable 接口class MyThread implements Callable&lt;String&gt; &#123;\n    @Override\n    public String call() throws Exception &#123;\n        System.out.println(Thread.currentThread().getName());\n        return &quot;hello world&quot;;\n    &#125;\n&#125;\n\npublic class ThreadDemo &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        FutureTask futureTask &#x3D; new FutureTask(new MyThread());\n        Thread thread &#x3D; new Thread(futureTask);\n        thread.start();\n        &#x2F;&#x2F; 获取返回值\n        System.out.println(futureTask.get());\n    &#125;\n&#125;\n\n\n\nd. 使用线程池&#x2F;&#x2F; 一池多线程\nExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);  &#x2F;&#x2F; 实际生产中,自定义线程池来进行线程创建\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为3的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n        threadPool1.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool1.shutdown();\n&#125;\n\n\n\n* Runbale与Callable的区别public static class MyThread implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        \n    &#125;\n&#125;\nprivate static class MyThreadCall implements Callable&#123;\n    @Override\n    public Object call() throws Exception &#123;\n        return null;\n    &#125;\n&#125;\n\n\nCallable实现的方法是call(),Runnable实现的方法是run().\nCallable的任务执行后有返回值，而Runnable的任务没有返回值\ncall方法可以抛出异常，run方法不可以\n运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。\n\n4. Lock 接口public interface Lock &#123;\n\tvoid lock();\n\tvoid lockInterruptibly() throws InterruptedException;\n\tboolean tryLock();\n\tboolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n\tvoid unlock();\n\tCondition newCondition();\n&#125;\n\nLock接口为锁和等待条件提供一个框架的接口和类，不同于内置同步和监视器。\nLock是接口，可通过实现类同步访问，多个接口实现类：可重入锁等。\n\nReentrantLock(可重入锁) 是唯一实现了 Lock 接口的类，并且 ReentrantLock 提供了更多的方法\n\nReentrantReadWriteLock 里面提供了很多丰富的方法，不过最主要的有两个方法：readLock()和 writeLock()用来获取读锁和写锁writeLock();来获取读锁readLock();获取写锁\n\n\n一个Lock锁的例子\npublic class sync &#123;\n    public static void main(String[] args) &#123;\n        Ticket ticket &#x3D; new Ticket();\n        &#x2F;*3个售票员售出30张票*&#x2F;\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller1&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller2&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 40; i++) &#123;\n                ticket.sale();\n            &#125;\n        &#125;, &quot;seller3&quot;).start();\n    &#125;\n\n    static class Ticket &#123;\n        public int number &#x3D; 30;\n        private final ReentrantLock lock &#x3D; new ReentrantLock();\n\n        public void sale() &#123;\n            &#x2F;&#x2F; 加锁\n            lock.lock();\n            try &#123;\n                if (number &gt; 0)\n                    System.out.println(Thread.currentThread().getName() + &quot;买了1张票&quot; + &quot;,剩余&quot; + (--number) + &quot;张票&quot;);\n                else System.out.println(Thread.currentThread().getName() + &quot;没买到&quot;);\n            &#125; finally &#123;\n                &#x2F;&#x2F; 解锁 为了避免解锁前出现异常而导致没有解锁,需放入finally中\n                lock.unlock();\n            &#125;\n\n        &#125;\n    &#125;\n&#125;\n\nseller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller1买了1张票,剩余25张票\nseller1买了1张票,剩余24张票\n...&#x2F;&#x2F; lock可以响应中断,所以也有其他线程能买到票\nseller3买了1张票,剩余6张票\nseller3买了1张票,剩余5张票\nseller3买了1张票,剩余4张票\nseller3买了1张票,剩余3张票\nseller3买了1张票,剩余2张票\nseller3买了1张票,剩余1张票\nseller3买了1张票,剩余0张票\nseller3没买到\nseller3没买到\nseller3没买到\nseller3没买到\n...\n\n\n\nLock与synchronized的区别\n\nlock不是Java语言内置的,synchronized是Java语言的关键字,因此是内置特性。\nlock和synchronized的很大不同时，synchronized是自动的上锁和释放锁，而lock需要用户去手动释放锁，否则可能会死锁。\n发生异常时,synchronized会自动释放锁,而lock不会，所以unlock解锁需要放在try&#x2F;finally的finally语句块中。\nlock可以让等待锁的线程响应中断,而synchronized不行,线程会一直等待下去。\nlock可以知道有没有成功获得锁,而synchronized不行。\n资源竞争不激烈时,两者性能差不多;资源竞争激烈时,lock性能高很多。\n\n5. 线程间通信线程间通信的模型有两种：共享内存和消息传递\na. synchronized实现线程同步一个线程synchronized实现通信的例子\n实现一个由两个线程操作同一个变量,交换进行01切换的类\npublic class communication &#123;\n    public static void main(String[] args) &#123;\n        Share share &#x3D; new Share();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;AA&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;, &quot;BB&quot;).start();\n    &#125;\n\n    &#x2F;*实现一个由两个线程操作同一个变量,进行01切换的类*&#x2F;\n    static class Share &#123;\n        private int number &#x3D; 0;\n        public synchronized void add() throws InterruptedException &#123;\n            &#x2F;&#x2F; 不是0时进行等待\n            if (number !&#x3D; 0) this.wait();\n            number++;\n            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n            &#x2F;&#x2F; 通知其他线程\n            this.notifyAll();\n        &#125;\n        public synchronized void minus() throws InterruptedException &#123;\n            if (number !&#x3D; 1) this.wait();\n            number--;\n            System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n            &#x2F;&#x2F; 通知其他线程\n            this.notifyAll();\n        &#125;\n    &#125;\n&#125;\n\nAA::1\nBB::0\nAA::1\nBB::0\nAA::1\nBB::0\n\n如果在方法中不加synchronized,会报错java.lang.IllegalMonitorStateException\njava.lang.IllegalMonitorStateException是在调用object的wait和notify，notifyAll方法的时候可能会出现的异常。 \n在调用上述三个方法的时候，线程必须获得该对象的对象级别锁，换句话说，出现这个异常的原因是因为，调用wait和notify，notifyAll的对象没有在同步方法（synchronized修饰的方法）或者同步代码块（synchronized（x）{}）中。\nwait()和notify()方法的调用必须具有内置锁 synchronized(this) 的代码块内或同步方法才能调用，否则就会报该错误。\n如果用了显式锁 Lock 就不要用 wait() 和 notify() 了，它们是两套加锁机制，不能混着用的。\n* 虚假唤醒问题如果再添加两个线程去操作变量,可能会造成虚假唤醒问题。\npublic static void main(String[] args) &#123;\n    Share share &#x3D; new Share();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.add();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;AA&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.minus();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;BB&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.add();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;CC&quot;).start();\n    new Thread(() -&gt; &#123;\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            try &#123;\n                share.minus();\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n    &#125;, &quot;DD&quot;).start();\n&#125;\nAA::1\nDD::0\nCC::1\nBB::0\nCC::1\nBB::0\nCC::1\nBB::0\nDD::-1  &#x2F;&#x2F; 出现了-1\nAA::0\nAA::1\nDD::0\n\n如果一个线程执行完毕后，通知其他线程，该线程又进入等待睡眠，可能会因为某些原因被唤醒后，if结构的语句就不会判断了，一直往下执行，所以需要将if换成while结构，每次都判断。因为wait在哪里睡眠就在哪里被唤醒，结果被某个异常唤醒了后回不去了，if结构不会在判断了，需要更改为while\nwhile(number !&#x3D; 0) &#123; &#x2F;&#x2F;判断number值是否是0，如果不是0，等待\n    this.wait(); &#x2F;&#x2F;在哪里睡，就在哪里醒\n&#125;\n\n实现中断和虚假唤醒是可能的，需要将 this.wait() 其while方法用在循环中\nb. Lock 实现线程通信使用lock进行线程间通信,需要配合Condition接口使用。\nCondition的作用是对锁进行更精确的控制。\nCondition中的await()方法相当于Object的wait()方法，Condition中的signal()方法相当于Object的notify()方法，Condition中的signalAll()相当于Object的notifyAll()方法。\ncondition可以通俗的理解为条件队列。当一个线程在调用了await方法以后，直到线程等待的某个条件为真的时候才会被唤醒。这种方式为线程提供了更加简单的等待&#x2F;通知模式。Condition必须要配合锁一起使用，因为对共享状态变量的访问发生在多线程环境下。一个Condition的实例必须与一个Lock绑定，因此Condition一般都是作为Lock的内部实现。\n不同的是，Object中的wait(),notify(),notifyAll()方法是和”同步锁”(synchronized关键字)捆绑使用的；而Condition是需要与”互斥锁”&#x2F;“共享锁”捆绑使用的。\npublic interface Condition &#123;\n\t&#x2F;&#x2F; 造成当前线程在接到信号或被中断之前一直处于等待状态。\n\tvoid await()\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。\n    boolean await(long time, TimeUnit unit)\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定等待时间之前一直处于等待状态。\n    long awaitNanos(long nanosTimeout)\n    &#x2F;&#x2F; 造成当前线程在接到信号之前一直处于等待状态。\n    void awaitUninterruptibly()\n    &#x2F;&#x2F; 造成当前线程在接到信号、被中断或到达指定最后期限之前一直处于等待状态。\n    boolean awaitUntil(Date deadline)\n    &#x2F;&#x2F; 唤醒一个等待线程。\n    void signal()\n    &#x2F;&#x2F; 唤醒所有等待线程。\n    void signalAll()\n&#125;\n\n\n\n1. Lock 实现简单互斥操作。lock实现一个由四个线程操作同一个变量,进行01切换的类\npublic class LockCommunication &#123;\n    public static void main(String[] args) &#123;\n        Share share &#x3D; new Share();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;AA&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;BB&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.add();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;CC&quot;).start();\n        new Thread(() -&gt; &#123;\n            for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n                try &#123;\n                    share.minus();\n                &#125; catch (InterruptedException e) &#123;\n                    e.printStackTrace();\n                &#125;\n            &#125;\n        &#125;,&quot;DD&quot;).start();\n    &#125;\n\n    &#x2F;*lock实现一个由四个线程操作同一个变量,进行01切换的类*&#x2F;\n    static class Share &#123;\n        private int number &#x3D; 0;\n        &#x2F;&#x2F; 新建锁对象\n        private ReentrantLock lock &#x3D; new ReentrantLock();\n        &#x2F;&#x2F;  \n        private Condition condition &#x3D; lock.newCondition();\n        &#x2F;&#x2F; +1\n        public void add() throws InterruptedException &#123;\n            lock.lock();\n            try &#123;\n                while (number !&#x3D; 0) &#123;\n                    condition.await();\n                &#125;\n                number++;\n                System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n                &#x2F;&#x2F; 通知全部\n                condition.signalAll();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n        &#x2F;&#x2F;-1\n        public void minus() throws InterruptedException &#123;\n\n            lock.lock();\n            try &#123;\n                while (number !&#x3D; 1) &#123;\n                    condition.await();\n                &#125;\n                number--;\n                System.out.println(Thread.currentThread().getName() + &quot;::&quot; + number);\n                condition.signalAll();\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n\n2. Lock实现线程间通信定制化（自定义执行顺序）实现一个三个线程按顺序轮换执行即A-&gt;B-&gt;C-&gt;A-&gt;B-&gt;C….\n实现思路就是用一个信号flag来控制。\n\n\n&#x2F;* lock 实现一个三个线程按顺序轮换执行即A-&gt;B-&gt;C-&gt;A-&gt;B-&gt;C....*&#x2F;\nstatic class Custom &#123;\n    &#x2F;&#x2F; 1--&gt;A 2--&gt;B 3--&gt;C\n    private int flag &#x3D; 1;\n    private ReentrantLock lock &#x3D; new ReentrantLock();\n    &#x2F;&#x2F; 创建三个 condition\n    private Condition c1 &#x3D; lock.newCondition();\n    private Condition c2 &#x3D; lock.newCondition();\n    private Condition c3 &#x3D; lock.newCondition();\n    &#x2F;&#x2F; 打印3轮 参数为第几轮\n    public void print3(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 1) c1.await();\n            for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 2;\n            &#x2F;&#x2F; 通知c2\n            c2.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n    public void print6(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 2) c2.await();\n            for (int i &#x3D; 0; i &lt; 6; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 3;\n            &#x2F;&#x2F; 通知c3\n            c3.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n    public void print9(int loop) &#123;\n        &#x2F;&#x2F; 上锁\n        lock.lock();\n        try &#123;\n            while (flag !&#x3D; 3) c3.await();\n            for (int i &#x3D; 0; i &lt; 9; i++) &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; :: &quot; + i + &quot; 轮数 :&quot; + loop);\n            &#125;\n            &#x2F;&#x2F; 修改标志位\n            flag &#x3D; 1;\n            &#x2F;&#x2F; 通知c1\n            c1.signal();\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放锁\n            lock.unlock();\n        &#125;\n    &#125;\n&#125;\n\n\n\n6. 集合线程安全a. ArrayList线程不安全问题打开ArrayList的源码,以add方法为例,显然他并没有使用synchronized或者lock进行并发控制,\n&#x2F;**\n * This helper method split out from add(E) to keep method\n * bytecode size under 35 (the -XX:MaxInlineSize default value),\n * which helps when add(E) is called in a C1-compiled loop.\n *&#x2F;\nprivate void add(E e, Object[] elementData, int s) &#123;\n    if (s &#96; elementData.length)\n        elementData &#x3D; grow();\n    elementData[s] &#x3D; e;\n    size &#x3D; s + 1;\n&#125;\n\n编写一个多线程同时进行插入操作的程序,很容易会出现以下错误ConcurrentModificationException并发修改异常。\npublic static void main(String[] args) &#123;\n    ArrayList&lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();\n    for (int i &#x3D; 0; i &lt; 20; i++) &#123;\n        new Thread(() -&gt; &#123;\n            list.add(UUID.randomUUID().toString().substring(0,8));\n            System.out.println(list);\n        &#125;, String.valueOf(i)).start();\n    &#125;\n&#125;\n\n\n\n常用的解决方案：\n\n\n\n使用Vector,是线程安全的，但是由于使用了synchronized同步锁，导致同一时间内只有一个线程能访问，效率较低。比较古老，JDK1.0 时期的解决方案。\nList&lt;String&gt; list &#x3D; new Vector&lt;&gt;();\n\n使用**Collections.synchronizedList()**来解决,也比较古老\nList&lt;String&gt; list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());\n\n使用CopyOnWrite;使用CopyOnWrite（写时复制）技术解决了这个问题，这一般需要很大的内存开销。\nList&lt;String&gt; list &#x3D; new CopyOnWriteArrayList&lt;&gt;();\n\n&#x2F;**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;)\n*&#x2F;\npublic boolean add(E e) &#123;\n    final ReentrantLock lock &#x3D; this.lock;\n    lock.lock();\n    try &#123;\n        Object[] elements &#x3D; getArray();\n        int len &#x3D; elements.length;\n        Object[] newElements &#x3D; Arrays.copyOf(elements, len + 1);\n        newElements[len] &#x3D; e;\n        setArray(newElements);\n        return true;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;\n\nb. HashSet&#x2F;HashMap线程不安全问题Set&lt;String&gt; set &#x3D; new HashSet&lt;&gt;();\nfor (int i &#x3D; 0; i &lt; 20; i++) &#123;\n    new Thread(() -&gt; &#123;\n        set.add(UUID.randomUUID().toString().substring(0, 8));\n        System.out.println(set);\n    &#125;, String.valueOf(i)).start();\n&#125;\n\n在执行后,同样也会出现 java.util.ConcurrentModificationException异常\nException in thread &quot;19&quot; java.util.ConcurrentModificationException\n\tat java.base&#x2F;java.util.HashMap$HashIterator.nextNode(HashMap.java:1495)\n\tat java.base&#x2F;java.util.HashMap$KeyIterator.next(HashMap.java:1518)\n\tat java.base&#x2F;java.util.AbstractCollection.toString(AbstractCollection.java:456)\n\tat java.base&#x2F;java.lang.String.valueOf(String.java:3352)\n\tat java.base&#x2F;java.io.PrintStream.println(PrintStream.java:977)\n\tat collect.lambda$main$0(collect.java:21)\n\tat java.base&#x2F;java.lang.Thread.run(Thread.java:830)\n\n同样也可以使用 Collections.synchronizedSet() CopyOnWriteArraySet 解决并发问题。\nSet&lt;String&gt; set &#x3D; Collections.synchronizedSet(new HashSet&lt;&gt;());\nSet&lt;String&gt; set &#x3D; new CopyOnWriteArraySet&lt;&gt;();\n\n\n\nHashMap\nHashSet底层通过HashMap实现,HashSet通过给HashMap中的&lt;K,V&gt;的V给一个默认值PERSENT来生成HashSet。\nArrayList扩容默认一半，HashMap扩容默认一倍。\n可以使用ConcurrentHashMap Collections.synchronizedMap() 来解决并发问题。\nConcurrentHashMap在多线程编程中，将会是非常常用的类。\nMap&lt;String,String&gt; map &#x3D; new ConcurrentHashMap&lt;&gt;();\nMap&lt;String,String&gt; map &#x3D; Collections.synchronizedMap(new HashMap&lt;String, String&gt;());\n\n\n\n7. 多线程锁这里重点关注的是线程执行顺序问题,锁是如何影响线程的执行顺序的。\na. 8种加锁情况synchronized实现同步的基础：java中的每一个对象都可以作为锁。this和class也是一种对象。\n具体表现为一下3中形式。\n\n 对于普通同步方法，锁是当前实例对象，锁的是当前对象this，\n\n\n 对于同步方法块，锁的是synchronized括号里配置的对象。\n\n\n 对于静态同步方法，锁是当前类的class对象\n\n\n\n下面的程序,默认先创建线程sendA,再创建线程sendB\npublic class LockProblem &#123;\n    static class Phone &#123;\n        public synchronized void sendA() throws Exception &#123;\n            &#x2F;&#x2F;TimeUnit.SECONDS.sleep(2);\n            System.out.println(&quot;---sendA---&quot;);\n        &#125;\n        public synchronized void sendB() throws Exception &#123;\n            System.out.println(&quot;---sendB---&quot;);\n        &#125;\n    &#125;\n&#125;\n\n\n标准访问时,执行顺序如何? 不一定,取决于操作系统,但一般先start的先执行\nsynchronized加给普通方法,是锁的类对象,即This指针。\n对象锁\n\n一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其他的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法。\n锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法\n\nPhone phone &#x3D; new Phone();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendA();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;A&quot;).start();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendB();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;B&quot;).start();\n\nA方法内先设置暂停2秒方法,执行顺序如何? 先打印A,B等待A执行结束后打印B\npublic synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\n\n这是由于sendA方法加了synchronized,而sendA先抢到了这把对象锁，所以会在A打印结束后再打印B，即B要等待A完成才会执行。\n\n新增一个普通方法(不加synchronized),执行顺序如何?先执行普通方法\n普通方法为加锁,并非共享资源,不存在争抢。\npublic void sayHello()&#123;\n    System.out.println(&quot;---Hello---&quot;);\n&#125;\n\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sendA();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;A&quot;).start();\n\nnew Thread(() -&gt; &#123;\n    try &#123;\n        phone.sayHello();\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125;\n&#125;, &quot;B&quot;).start();\n\n两个资源类,分别执行时,哪个先执行?先打印B,A sleep结束后打印A\n两个资源类生成的是两个锁，互相无关\nPhone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\n\nphone.sendA();\nphone2.sendB();\n\n两个静态同步方法,一个资源类,哪个先执行? 先打印A,B等待A完成后执行\n锁的是类,即.class文件,和第六种锁相似,生成再多的类对象,公用的是一个锁\npublic static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\n\npublic static synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;\n\n两个静态同步方法,两个资源类,哪个先执行? 先打印A,B等待A完成后执行\n锁的是类,即.class文件,和第六种锁相似,生成再多的类对象,公用的是一个锁\npublic static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\n\npublic static synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;\nPhone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\n\nphone.sendA();\nphone2.sendB();\n\n\n\n1个静态同步方法,1个普通同步方法,1个资源类,哪个先执行? 先打印B,A sleep结束后打印A\n对象和类都有锁，两把锁互相不冲突，所以B先打印，等A sleep结束后打印A。\npublic static synchronized void sendA() throws Exception &#123;\n    TimeUnit.SECONDS.sleep(2);\n    System.out.println(&quot;---sendA---&quot;);\n&#125;\npublic synchronized void sendB() throws Exception &#123;\n    System.out.println(&quot;---sendB---&quot;);\n&#125;\nphone.sendA();\nphone.sendB();\n\n1个静态同步方法,1个普通同步方法,2个资源类,哪个先执行? 先打印B,A sleep结束后打印A。\n对象和类都有锁，两把锁互相不冲突，所以B先打印，等A sleep结束后打印A。\nPhone phone &#x3D; new Phone();\nPhone phone2 &#x3D; new Phone();\nphone.sendA();\nphone2.sendB();\n\nb. 公平锁和非公平锁\n公平锁：效率相对低\n非公平锁：效率高，但是线程容易饿死\n\nReentrantLock(true)为公平锁ReentrantLock(false)为非公平锁\npublic ReentrantLock() &#123;\n    sync &#x3D; new NonfairSync();\n&#125;\npublic ReentrantLock(boolean fair) &#123;\n    sync &#x3D; fair ? new FairSync() : new NonfairSync();\n&#125;\n\n公平锁的源码,很简单，它创建了一个访问的循环队列,队列中有线程就排队等候。\n&#x2F;**\n* Sync object for fair locks\n*&#x2F;\nstatic final class FairSync extends Sync &#123;\n    private static final long serialVersionUID &#x3D; -3000897897090466540L;\n    &#x2F;**\n         * Fair version of tryAcquire.  Don&#39;t grant access unless\n         * recursive call or no waiters or is first.\n         *&#x2F;\n    @ReservedStackAccess\n    protected final boolean tryAcquire(int acquires) &#123;\n        final Thread current &#x3D; Thread.currentThread();\n        int c &#x3D; getState();\n        if (c &#96; 0) &#123;\n            if (!hasQueuedPredecessors() &amp;&amp;\n                compareAndSetState(0, acquires)) &#123;\n                setExclusiveOwnerThread(current);\n                return true;\n            &#125;\n        &#125;\n        else if (current &#96; getExclusiveOwnerThread()) &#123;\n            int nextc &#x3D; c + acquires;\n            if (nextc &lt; 0)\n                throw new Error(&quot;Maximum lock count exceeded&quot;);\n            setState(nextc);\n            return true;\n        &#125;\n        return false;\n    &#125;\n&#125;\n\n\n\n非公平锁的情况\nprivate final ReentrantLock lock &#x3D; new ReentrantLock(false);\n\n之前实现的买表实例,非公平锁的情况下,seller2和seller3都不能买到票，票全都被线程1买走了。\nseller1买了1张票,剩余29张票\nseller1买了1张票,剩余28张票\nseller1买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller1买了1张票,剩余25张票\nseller1买了1张票,剩余24张票\nseller1买了1张票,剩余23张票\nseller1买了1张票,剩余22张票\nseller1买了1张票,剩余21张票\n...\nseller2没买到\n...\nseller3没买到\n\n\n\n公平锁的情况\nprivate final ReentrantLock lock &#x3D; new ReentrantLock(true);\n\nseller1买了1张票,剩余29张票\nseller2买了1张票,剩余28张票\nseller3买了1张票,剩余27张票\nseller1买了1张票,剩余26张票\nseller2买了1张票,剩余25张票\nseller3买了1张票,剩余24张票\nseller1买了1张票,剩余23张票\nseller2买了1张票,剩余22张票\nseller3买了1张票,剩余21张票\n...\n\nc. 可重入锁可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。\n可重入锁的意义之一在于防止死锁。\n实现原理是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。\n如果同一个线程再次请求这个锁，计数器将递增；\n每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。\nSynchronized(隐式) 和 Lock(显式) 都是可重入锁。\n可重入的实例\n由此可见,加锁过程中可以重复进入这个锁对象,而不会说\n&#x2F;&#x2F;synchronized\nObject o &#x3D; new Object();\nnew Thread(() -&gt; &#123;\n    synchronized (o) &#123;\n        System.out.println(Thread.currentThread().getName()+&quot;外层&quot;);\n        synchronized (o)&#123;\n            System.out.println(Thread.currentThread().getName()+&quot;中层&quot;);\n            synchronized (o)&#123;\n                System.out.println(Thread.currentThread().getName()+&quot;内层&quot;);\n            &#125;\n        &#125;\n    &#125;\n&#125;, &quot;t1&quot;).start();\n\n&#x2F;&#x2F;lock\nReentrantLock lock &#x3D; new ReentrantLock();\nnew Thread(() -&gt; &#123;\n    try &#123;\n        lock.lock();\n        System.out.println(Thread.currentThread().getName() + &quot;外层&quot;);\n        try &#123;\n            lock.lock();\n            System.out.println(Thread.currentThread().getName() + &quot;内层&quot;);\n        &#125; finally &#123;\n            &#x2F;&#x2F; 内部是自己的锁不释放锁也可以正常执行,这也是可重入锁的特点\n            &#x2F;&#x2F; 但是内部是其他的锁不释放则不行 \n\t\t   &#x2F;&#x2F; lock.unlock();\n        &#125;\n    &#125; finally &#123;\n        lock.unlock();\n    &#125;\n&#125;, &quot;t2&quot;).start();\n\n\n\n8. 死锁两个或以上的进程因为争夺资源而造成互相等待资源的现象称为死锁。如果没有外力的作用，他们一般不能再执行下去\n\n\n\n\n产生死锁的必要条件：\n\n互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。\n请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。\n不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。\n环路等待条件：在发生死锁时，必然存在一个进程–资源的环形链。\n\n查看进程堆栈信息的指令\n\nwindows  jps\nLinux   ps -ef\n\n9. Callable 接口对比Callable接口和Runnable接口\n\nCallable实现的方法是call(),Runnable实现的方法是run().\nCallable的任务执行后有返回值，而Runnable的任务没有返回值\ncall方法可以抛出异常，run方法不可以\n\npublic class InheritedInterface &#123;\n    public static class MyThread implements Runnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;--- in Runnable ---&quot;);\n        &#125;\n    &#125;\n    private static class MyThreadCall implements Callable&lt;String&gt; &#123;\n        @Override\n        public String call() throws Exception &#123;\n            System.out.println(&quot;--- in Callable ---&quot;);\n            return &quot;Callable Return&quot;;\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        Thread t1 &#x3D; new Thread(new MyThread());\n        FutureTask futureTask &#x3D; new FutureTask(new MyThreadCall());\n        Thread t2 &#x3D; new Thread(futureTask);\n        t1.start();\n        t2.start();\n        System.out.println(futureTask.get());\n    &#125;\n&#125;\n\n通过Thread创建线程\n\nRunnable Thread t1 &#x3D; new Thread(new MyThread());\n\nCallable Thread t2 &#x3D; new Thread(new FutureTask(new MyThreadCall()));\n不可以通过**new Thread(new MyThread2());**创建线程,因为Thread的构造函数中没有Callable接口的参数设置直接替换不可以，只能用下面这种线程创建方法（找一个类，即和Runnable接口有关系，又和Callable接口有关系）\n\n\n\n\n发现Runnable接口有实现类FutureTask（中间对象）,FutureTask的构造函数有Callable参数，通过FutureTask创建线程对象\n也可以使用lamda表达式来简写\n&#x2F;&#x2F;lam表达式\nFutureTask&lt;Integer&gt; futureTask2 &#x3D; new FutureTask&lt;&gt;(()-&gt;&#123;\n    System.out.println(Thread.currentThread().getName()+&quot; come in callable&quot;);\n    return 1024;\n&#125;);\n\n\n\n如果两个线程都调用了同一个FutureTask,那么FutureTask中的call方法只会执行一次\nFutureTask futureTask &#x3D; new FutureTask(new MyThreadCall());\nnew Thread(futureTask,&quot;A&quot;),start();\nnew Thread(futureTask,&quot;B&quot;),start();\n\n\n\nCallable返回值\nCallable接口返回值通过 futureTask.get()来调用,只要调用futureTask.get(),主线程就要阻塞等待线程执行完毕,因此:一般放在最后调用线程的返回值,为了尽量让线程计算完再获取返回值\n\n**get()**获取结果\n**isDone()**判断是否计算结束\n\n10. 辅助类a. 减少计数 CountDownLatchCountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。\n如果不加 CountDownLatch类，会出现线程混乱执行，同学还未离开教室班长就已经锁门了\npublic static void main(String[] args) throws InterruptedException &#123;\n    &#x2F;*实现5个同学陆续离开教室,全部离开后锁门*&#x2F;\n    &#x2F;*设置计数器*&#x2F;\n    CountDownLatch countDownLatch &#x3D; new CountDownLatch(5);\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        new Thread(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName()+&quot;离开&quot;);\n            &#x2F;&#x2F; 计数器 -1\n            countDownLatch.countDown();\n        &#125;, &quot;No.&quot; + i).start();\n    &#125;\n    &#x2F;&#x2F;等待\n    countDownLatch.await();\n    System.out.println(Thread.currentThread().getName()+&quot;锁门&quot;);\n&#125; \nNo.0离开\nNo.2离开\nNo.3离开\nNo.1离开\nNo.4离开\nmain锁门\n\n\n\nb. 循环栅栏 CyclicBarrier该类是一个同步辅助类，允许一组线程互相等待，直到到达某个公共屏障点，会执行定义的代码。\n在设计一组固定大小的线程的程序中，这些线程必须互相等待，这个类很有用，因为barrier在释放等待线程后可以重用，所以称为循环barrier\n下面这个例子中:\n\n每7个线程执行后,定义的 new CyclicBarrier(NUMBER, () -&gt; &#123;System.out.println(&quot;---集齐7颗龙珠召唤神龙---&quot;);&#125;);中的代码才会执行。\n只有前面7个线程都执行完毕，后面的一轮线程才会开始执行\ncyclicBarrier.await();之后的代码必须等达到CyclicBarrier的屏障才会执行\nawait()在所有的参与者都已经在此barrier上调用await方法之前，一直等待。\n\n&#x2F;* 集齐7颗龙珠召唤神龙 *&#x2F;\nfinal int NUMBER &#x3D; 7;\nCyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(NUMBER, () -&gt; &#123;\n    System.out.println(&quot;---集齐7颗龙珠召唤神龙---&quot;);\n&#125;);\n\n&#x2F;&#x2F; 集齐龙珠的过程\nfor (int i &#x3D; 0; i &lt; 15; i++) &#123;\n    new Thread(() -&gt; &#123;\n        try &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;星龙珠已收集.&quot;);\n            &#x2F;&#x2F; 等待\n            cyclicBarrier.await();\n            &#x2F;&#x2F; cyclicBarrier.await();之后的代码必须等达到CyclicBarrier的屏障才会执行\n            System.out.println(&quot;WDNMD&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; catch (BrokenBarrierException e) &#123;\n            e.printStackTrace();\n        &#125;\n\n    &#125;, String.valueOf(i + 1)).start();\n&#125;\n1星龙珠已收集.\n3星龙珠已收集.\n2星龙珠已收集.\n4星龙珠已收集.\n5星龙珠已收集.\n6星龙珠已收集.\n7星龙珠已收集.\n8星龙珠已收集.\n---集齐7颗龙珠召唤神龙---\n9星龙珠已收集.\nWDNMD\n10星龙珠已收集.\n11星龙珠已收集.\n12星龙珠已收集.\nWDNMD\nWDNMD\nWDNMD\n13星龙珠已收集.\nWDNMD\nWDNMD\nWDNMD\n15星龙珠已收集.\n14星龙珠已收集.\n---集齐7颗龙珠召唤神龙---\nWDNMD\nWDNMD\n...\n\n\n\nc. 信号灯 Semaphore一个计数信号量，从概念上将，信号量维护了一个许可集，如有必要，在许可可用前会阻塞每一个acquire()，然后在获取该许可。每个release()添加一个许可，从而可能释放一个正在阻塞的获取者。但是，不使用实际的许可对象，Semaphore只对可用许可的号码进行计数，并采取相应的行动\n具体常用的构造方法有：Semaphore(int permits)创建具有给定的许可数和非公平的公平设置的Semapore\n具体常用的方法有：acquire()从此信号量获取一个许可，在提供一个许可前一直将线程阻塞，否则线程被中断release()释放一个许可，将其返回给信号量\n设置许可数量Semaphore semaphore &#x3D; new Semaphore(3);一般acquire(）都会抛出异常，release在finally中执行\n&#x2F;*Semaphore实现6辆汽车停到3个停车位*&#x2F;\n&#x2F;&#x2F; 构造函数传参为许可数量\nSemaphore semaphore &#x3D; new Semaphore(3);\n\nfor (int i &#x3D; 0; i &lt; 6; i++) &#123;\n    new Thread(() -&gt; &#123;\n        try &#123;\n            &#x2F;&#x2F; 获取许可\n            semaphore.acquire();\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了车位&quot;);\n            &#x2F;&#x2F; 随机停车时间\n            TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n            System.out.println(Thread.currentThread().getName() + &quot;离开了车位&quot;);\n        &#125; catch (InterruptedException e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            &#x2F;&#x2F; 释放\n            semaphore.release();\n        &#125;\n    &#125;, i + &quot;号车&quot;).start();\n&#125;\n1号车抢到了车位\n0号车抢到了车位\n2号车抢到了车位\n0号车--离开了车位\n2号车--离开了车位\n3号车抢到了车位\n4号车抢到了车位\n1号车--离开了车位\n5号车抢到了车位\n5号车--离开了车位\n4号车--离开了车位\n3号车--离开了车位\n\n\n\n11. 读写锁悲观锁：单独每个人完成事情的时候，执行上锁解锁。解决并发中的问题，不支持并发操作，只能一个一个操作，效率低乐观锁：每执行一件事情，都会比较数据版本号，谁先提交，谁先提交版本号\n表锁：整个表操作，不会发生死锁行锁：每个表中的单独一行进行加锁，会发生死锁\n读锁：共享锁（可以有多个人读），会发生死锁写锁：独占锁（只能有一个人写），会发生死锁\n读写锁：一个资源可以被多个读线程访问，也可以被一个写线程访问，但不能同时存在读写线程，读写互斥，读共享\n编程方式\n&#x2F;&#x2F; 创建读写锁对象\nprivate ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n&#x2F;&#x2F;添加写锁\nrwLock.writeLock().lock();\n&#x2F;&#x2F; 释放锁\nrwLock.writeLock().unlock();\n&#x2F;&#x2F; 添加读锁\nrwLock.readLock().lock();\n&#x2F;&#x2F; 释放读锁\nrwLock.readLock().unlock();\n\n\n\n模拟一个读写Map的实例\npublic class WriteReadLock &#123;\n    public static void main(String[] args) &#123;\n        MyCache myCache &#x3D; new MyCache();\n        &#x2F;&#x2F;  创建线程放数据\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            final int num &#x3D; i;\n            new Thread(() -&gt; &#123;\n                myCache.put(num + &quot;&quot;, num + &quot;&quot;);\n            &#125;, String.valueOf(i)).start();\n        &#125;\n\n        &#x2F;&#x2F;  创建线程取数据\n        for (int i &#x3D; 0; i &lt; 3; i++) &#123;\n            final int num &#x3D; i;\n            new Thread(() -&gt; &#123;\n                myCache.get(num + &quot;&quot;);\n            &#125;, String.valueOf(i)).start();\n        &#125;\n    &#125;\n    static class MyCache &#123;\n        &#x2F;&#x2F; 创建Map集合\n        private Map&lt;String, Object&gt; map &#x3D; new HashMap&lt;&gt;();\n        private ReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\n\n        &#x2F;&#x2F; 放数据\n        public void put(String key, Object val) &#123;\n            &#x2F;&#x2F;添加写锁\n            rwLock.writeLock().lock();\n\n            try &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 正在进行写操作 &quot; + key);\n                TimeUnit.MICROSECONDS.sleep(300);\n                map.put(key, val);\n                System.out.println(Thread.currentThread().getName() + &quot; 写完了 &quot; + key);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                &#x2F;&#x2F; 释放锁\n                rwLock.writeLock().unlock();\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 取数据\n        public Object get(String key) &#123;\n            &#x2F;&#x2F; 添加读锁\n            rwLock.readLock().lock();\n\n            Object res &#x3D; null;\n            try &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 正在进行读操作 &quot; + key);\n                TimeUnit.MICROSECONDS.sleep(300);\n                res &#x3D; map.get(key);\n                System.out.println(Thread.currentThread().getName() + &quot; 读完了 &quot; + key);\n            &#125; catch (InterruptedException e) &#123;\n                e.printStackTrace();\n            &#125; finally &#123;\n                &#x2F;&#x2F; 释放读锁\n                rwLock.readLock().unlock();\n            &#125;\n            return res;\n        &#125;\n    &#125;\n&#125;\n\n不加读写锁之前,出现读写不互斥,未写完就读等问题\n2 正在进行读操作 2\n1 正在进行读操作 1\n2 正在进行写操作 2\n0 正在进行读操作 0\n0 正在进行写操作 0\n1 正在进行写操作 1\n2 读完了 2\t\t\t&#x2F;&#x2F; 还未写完就读了\n1 读完了 1\n0 写完了 0\n2 写完了 2\n0 读完了 0\n1 写完了 1\n\n加了锁之后\n1 正在进行读操作 1   &#x2F;&#x2F; 读操作并发\n0 正在进行读操作 0\t  &#x2F;&#x2F; 读操作并发\n2 正在进行读操作 2   &#x2F;&#x2F; 读操作并发\n2 读完了 2\n1 读完了 1\n0 读完了 0\n1 正在进行写操作 1   &#x2F;&#x2F; 写操作独占\n1 写完了 1\n2 正在进行写操作 2   &#x2F;&#x2F; 写操作独占\n2 写完了 2\n0 正在进行写操作 0   &#x2F;&#x2F; 写操作独占\n0 写完了 0\n\n\n\n* 锁降级将写锁降为读锁。降级后读锁不能升级为写锁。\nJDK8中对锁降级的说明:获取写锁后,在写锁释放之前,可以获得读锁。而读锁过程中不能获得写锁。\nReentrantReadWriteLock rwLock &#x3D; new ReentrantReadWriteLock();\nReentrantReadWriteLock.ReadLock readLock &#x3D; rwLock.readLock();\nReentrantReadWriteLock.WriteLock writeLock &#x3D; rwLock.writeLock();\n\n&#x2F;&#x2F; 锁降级\n\n&#x2F;&#x2F; 获取写锁\nwriteLock.lock();\nSystem.out.println(&quot;---Write---&quot;);\n\n&#x2F;&#x2F; 获取读锁\nreadLock.lock();\nSystem.out.println(&quot;---Read---&quot;);\n\nwriteLock.unlock();\nreadLock.unlock();\n\n&#x2F;&#x2F;------结果----------\n&#x2F;&#x2F; ---Write---  \n&#x2F;&#x2F; ---Read---\n\n&#x2F;&#x2F; 如果读锁中获得写锁\n&#x2F;&#x2F; 获取读锁\nreadLock.lock();\nSystem.out.println(&quot;---Read---&quot;);\n&#x2F;&#x2F; 获取写锁\nwriteLock.lock();\nSystem.out.println(&quot;---Write---&quot;);\n\nreadLock.unlock();\nwriteLock.unlock();\n\n&#x2F;&#x2F; ----结果----\n---Read---\n写不能执行\n\n\n\n12. 阻塞队列\n\n阻塞队列是共享队列（多线程操作），一端输入，一端输出,不能无限放队列，满了之后就会进入阻塞，取出也同理\n\n当队列是空的，从队列中获取元素的操作将会被阻塞\n当队列是满的，从队列中添加元素的操作将会被阻塞\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增\n\n使用阻塞队列BlockingQueue好处在于不用关心真实的线程的阻塞与唤醒过程,不用关心实现细节.\n\n\na. 阻塞队列的分类\nArrayBlockingQueue  基于数组的阻塞队列,由数组结构组成的有界阻塞队列\nArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，无法并行\n\nLinkedBlockingQueue  基于链表的阻塞队列由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列\n\n\n  之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能\n\nDelayQueue 使用优先级队列实现的延迟无界阻塞队列\nDelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞\n\nPriorityBlockingQueue 基于优先级的阻塞队列支持优先级排序的无界阻塞队列,不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者\n\nSynchronousQueue 一种无缓冲的等待队列相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区）不存储元素的阻塞队列，也即单个元素的队列\n声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者\n而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理\n\nLinkedTransferQueue 由链表结构组成的无界阻塞 TransferQueue 队列由链表组成的无界阻塞队列\n预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，生成一个节点（节点元素为 null）入队，消费者线程被等待在这个节点上，生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回\n\nLinkedBlockingDeque由链表结构组成的双向阻塞队列\n阻塞有两种情况\n插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException异常读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数\n\n\nb. 阻塞队列使用BlockingQueue queue &#x3D; new ArrayBlockingQueue&lt;String&gt;(3);\n&#x2F;&#x2F; 第一组\nqueue.add(&quot;a&quot;);  &#x2F;&#x2F; 向队列中加元素\nqueue.offer(&quot;c&quot;, 100, TimeUnit.SECONDS); &#x2F;&#x2F; 设置超时失效\nqueue.element(); &#x2F;&#x2F; 返回队列头元素\nqueue.remove();  &#x2F;&#x2F; 移除队列头\n&#x2F;&#x2F; 第二组\nqueue.offer(&quot;a&quot;); \nqueue.poll();\nqueue.peek();\n&#x2F;&#x2F; 第三组\nqueue.put(&quot;a&quot;);  &#x2F;&#x2F; 超过容量阻塞\nqueue.take();       &#x2F;&#x2F; 空了会阻塞\n\n\n\n13. 线程池 ThreadPool线程池：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。\n线程池不仅能够保证内核的充分利用，还能防止过分调度。\n线程池特点：\n\n降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。\n提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。\n提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n线程池框架：\nJava 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类。\n\n\n线程池根据容量特点可以分为三类：\n这三类都使用的是 ThreadPoolExecutor 来创建的线程池。\n\n一池N线程\n&#x2F;&#x2F; 一池多线程\nExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);\n\n一池一线程\n&#x2F;&#x2F; 一池一线程\nExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();\n\n线程池可扩容\n&#x2F;&#x2F; 线程池可扩容\nExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();\n\n线程池使用实例\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F; 一池多线程\n    ExecutorService threadPool1 &#x3D; Executors.newFixedThreadPool(3);\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为3的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 10; i++) &#123;\n            threadPool1.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool1.shutdown();\n    &#125;\n\n    &#x2F;&#x2F; 一池一线程\n    ExecutorService threadPool2 &#x3D; Executors.newSingleThreadExecutor();\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为1的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n            threadPool2.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool2.shutdown();\n    &#125;\n\n    &#x2F;&#x2F; 线程池可扩容\n    ExecutorService threadPool3 &#x3D; Executors.newCachedThreadPool();\n    try &#123;\n        &#x2F;*模拟5个线程放入大小为1的线程池*&#x2F;\n        for (int i &#x3D; 0; i &lt; 155; i++) &#123;\n            threadPool3.execute(() -&gt; &#123;\n                System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n            &#125;);\n        &#125;\n    &#125; catch (Exception e) &#123;\n        e.printStackTrace();\n    &#125; finally &#123;\n        &#x2F;&#x2F; 关闭线程池\n        threadPool3.shutdown();\n    &#125;\n&#125;\n\n\n\na. ThreadPoolExecutor 参数含义一池N线程、一池一线程、线程池可扩容, 这三个底层都是通过ThreadPoolExecutor实现线程池创建的。\n&#x2F;**\n* Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial\n* parameters.\n*\n* @param corePoolSize the number of threads to keep in the pool, even\n*        if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set\n* @param maximumPoolSize the maximum number of threads to allow in the\n*        pool\n* @param keepAliveTime when the number of threads is greater than\n*        the core, this is the maximum time that excess idle threads\n*        will wait for new tasks before terminating.\n* @param unit the time unit for the &#123;@code keepAliveTime&#125; argument\n* @param workQueue the queue to use for holding tasks before they are\n*        executed.  This queue will hold only the &#123;@code Runnable&#125;\n*        tasks submitted by the &#123;@code execute&#125; method.\n* @param threadFactory the factory to use when the executor\n*        creates a new thread\n* @param handler the handler to use when execution is blocked\n*        because the thread bounds and queue capacities are reached\n* @throws IllegalArgumentException if one of the following holds:&lt;br&gt;\n*         &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt;\n*         &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt;\n*         &#123;@code maximumPoolSize &lt;&#x3D; 0&#125;&lt;br&gt;\n*         &#123;@code maximumPoolSize &lt; corePoolSize&#125;\n* @throws NullPointerException if &#123;@code workQueue&#125;\n*         or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null\n*&#x2F;\npublic ThreadPoolExecutor(int corePoolSize,\t\t\t\t\t&#x2F;&#x2F; 常驻线程数量\n                          int maximumPoolSize,\t\t\t\t&#x2F;&#x2F; 最大线程数量\n                          long keepAliveTime,\t\t\t\t&#x2F;&#x2F; 线程存活时间\n                          TimeUnit unit,\t\t\t\t\t&#x2F;&#x2F; 存活时间单位\n                          BlockingQueue&lt;Runnable&gt; workQueue,  &#x2F;&#x2F; 阻塞队列\n                          ThreadFactory threadFactory,\t\t  &#x2F;&#x2F; 线程工厂,用于创建线程\n                          RejectedExecutionHandler handler) &#123;  &#x2F;&#x2F; 拒绝策略,当线程池爆满时的拒绝接收线程的策略\n    if (corePoolSize &lt; 0 ||\n        maximumPoolSize &lt;&#x3D; 0 ||\n        maximumPoolSize &lt; corePoolSize ||\n        keepAliveTime &lt; 0)\n        throw new IllegalArgumentException();\n    if (workQueue &#96; null || threadFactory &#96; null || handler &#96; null)\n        throw new NullPointerException();\n    this.corePoolSize &#x3D; corePoolSize;\n    this.maximumPoolSize &#x3D; maximumPoolSize;\n    this.workQueue &#x3D; workQueue;\n    this.keepAliveTime &#x3D; unit.toNanos(keepAliveTime);\n    this.threadFactory &#x3D; threadFactory;\n    this.handler &#x3D; handler;\n&#125;\n\n\n\nRejectedExecutionHandler 线程池的饱和拒绝策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略:\n\nAbortPolicy: 直接抛出异常，默认策略；\nCallerRunsPolicy: 用调用者所在的线程来执行任务；\nDiscardOldestPolicy: 丢弃阻塞队列中靠最前的任务，并执行当前任务；\nDiscardPolicy: 直接丢弃任务；\n\nb. 线程池工作流程\n\n1.在创建了线程池后,等待提交过来的任务请求.\n2.当调用execute()方法添加一个请求任务时,线程池就会做如下判断:\n 2.1 如果正在运行的线程数量小于corePoolSize,那么马上创建线程运行这个任务\n 2.2 如果正在运行的线程数量大于或等于corePoolSize,那么将这个任务放入队列\n 2.3 如果这时候队列满了且正在运行的线程数量还小于maximumPoolSize,那么还是要创建非核心线程立刻运行这个任务\n 2.4 如果对队列满了且正在运行的线程数量大于或等于maximumPoolSize,那么线程池会启动饱和拒绝策略来执行.\n3.当一个线程完成任务时,它会从队列中取下一个任务来执行.\n4.当一个线程无事可做超过一定的时间(keepAliveTime)时,线程池会判断:\n 4.1 如果当前运行的线程数大于corePoolSize,那么这个线程就会被停掉\n 4.2 所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小\nc. 自定义线程池实际在开发中不使用Executors创建，而是通过ThreadPoolExecutor的方式，规避资源耗尽风险\nExecutors线程池的弊端:\n\nFixedThreadPool和SingleThreadExecutor 允许的请求队列长度为Integer.MAX_VALUE(0x7fffffff);*可能会造成大量的请求堆积,导致*OOM.\nCachedThreadPool和 ScheduledThreadPoolExecutor 允许创建线程数量为 Integer.MAX_VALUE(0x7fffffff);,可能会创建大量线程,导致OOM.\n\n如何自定义线程池\nExecutorService threadPool &#x3D; new ThreadPoolExecutor(\n    corePoolSize 2,\n    maximumPoolSize 5,\n    keepAliveTime 2L,\n    TimeUnit.SECONDS,\n    new ArrayBlockingQueue&lt;&gt;(3),\n    Executors.defaultThreadFactory(),\n    new ThreadPoolExecutor.AbortPolicy());\n\n&#x2F;&#x2F; 自定义线程池使用\ntry &#123;\n    &#x2F;*模拟5个线程放入大小为5的线程池*&#x2F;\n    for (int i &#x3D; 0; i &lt; 5; i++) &#123;\n        threadPool.execute(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot; 办理业务&quot;);\n        &#125;);\n    &#125;\n&#125; catch (Exception e) &#123;\n    e.printStackTrace();\n&#125; finally &#123;\n    &#x2F;&#x2F; 关闭线程池\n    threadPool.shutdown();\n&#125;\n\n\n\n\n\n14. 拆分(Fork)合并(Join)框架Fork&#x2F;Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。\n将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，该算法相当于递归，二分。\npublic class ForkJoinDemo &#123;\n    static class fibonacci extends RecursiveTask&lt;Integer&gt; &#123;\n        final int n;\n        &#x2F;&#x2F; 创建有参构造\n        fibonacci(int n) &#123; this.n &#x3D; n; &#125;\n        @Override\n        protected Integer compute() &#123;\n            if (n &lt;&#x3D; 1) return n;\n            fibonacci f1 &#x3D; new fibonacci(n - 1);\n            f1.fork();\n            fibonacci f2 &#x3D; new fibonacci(n - 2);\n            return f2.compute() + f1.join();\n        &#125;\n    &#125;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 创建任务对象\n        fibonacci f &#x3D; new fibonacci(10);\n        &#x2F;&#x2F; 创建分支合并池对象\n        ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();\n        ForkJoinTask&lt;Integer&gt; forkJoinTask &#x3D; forkJoinPool.submit(f);\n        &#x2F;&#x2F; 获取合并之后的结果\n        Integer res &#x3D; forkJoinTask.get();\n        System.out.println(res);\n        &#x2F;&#x2F; 关闭池对象\n        forkJoinPool.shutdown();\n    &#125;\n&#125;\n\n\n\n15. CompletableFuture 异步回调CompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息\n类中的具体引用类以及接口：\n\n\nCompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的CompletableFuture 类\n异步调用没有返回值方法runAsync异步调用有返回值方法supplyAsync\n主线程调用 get 方法会阻塞\npublic class CompletableFutureDemo &#123;\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        &#x2F;&#x2F; 异步调用 无返回值\n        CompletableFuture&lt;Void&gt; completableFuture &#x3D; CompletableFuture.runAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;--异步调用 无返回值&quot;);\n        &#125;);\n        completableFuture.get();\n\n        &#x2F;&#x2F; 异步调用 有返回值\n        CompletableFuture&lt;Integer&gt; completableFuture1 &#x3D; CompletableFuture.supplyAsync(() -&gt; &#123;\n            System.out.println(Thread.currentThread().getName() + &quot;----异步调用 有返回值&quot;);\n            int i  &#x3D;1 &#x2F; 0;\n            return 1024;\n        &#125;);\n        completableFuture1.whenComplete((t, u) -&gt; &#123;\n            System.out.println(&quot;--t&#x3D;&quot; + t);\n            System.out.println(&quot;--u&#x3D;&quot; + u);\n        &#125;).get();\n    &#125;\n&#125;\nForkJoinPool.commonPool-worker-19--异步调用 无返回值\nForkJoinPool.commonPool-worker-19----异步调用 有返回值\n--t&#x3D;null &#x2F;&#x2F; 没异常为 1024 即返回值\n--u&#x3D;java.util.concurrent.CompletionException: java.lang.ArithmeticException: &#x2F; by zero\nException in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.ArithmeticException: &#x2F; by zero\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2070)\n\tat CompletableFutureDemo.main(CompletableFutureDemo.java:21)\nCaused by: java.lang.ArithmeticException: &#x2F; by zero\n\tat CompletableFutureDemo.lambda$main$1(CompletableFutureDemo.java:15)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture$AsyncSupply.run(CompletableFuture.java:1771)\n\tat java.base&#x2F;java.util.concurrent.CompletableFuture$AsyncSupply.exec(CompletableFuture.java:1763)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:290)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1016)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1665)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1598)\n\tat java.base&#x2F;java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:183)\n\n\n\n\n\n","slug":"JUC","date":"2022-04-07T12:19:18.000Z","categories_index":"互联网八股","tags_index":"Java,JUC","author_index":"张 凡"},{"id":"7f77c660cadf02b64dd36120e903f5f0","title":"Mysql","content":"1. 概述MySQL 的基本架构示意图，从中你可以清楚地看到 SQL 语句在 MySQL 的各个功能模块中的执行过程。\n\n\n一条SQL语句的执行流程如下:\n\n建立连接。先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。\n在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。\n\n如果用户名或密码不对，你就会收到一个”Access denied for user”的错误，然后客户端程序结束执行。\n如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。\n\n这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\n\n\n查询缓存。连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。\n​    MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之**前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。&#96;key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。\n但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。\n​    查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表。\n需要注意的是，&#96;MySQL 8.0 版本直接将查询缓存的整块功能删掉了**，也就是说 8.0 开始彻底没有这个功能了。\n\n\n语法分析。如果没有命中查询缓存，就要开始真正执行语句了。\n首先，MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。\n你输入的是由多个字符串和空格组成的一条 SQL 语句，MySQL 需要识别出里面的字符串分别是什么，代表什么。\n做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。\n\n\n语法优化。优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n所有的现代数据库都在用基于成本的优化（即CBO）来优化查询。道理是针对每个运算设置一个成本，通过应用成本最低廉的一系列运算，来找到最佳的降低查询成本的方法。对于联接操作，我会专注于它们的时间复杂度，但是，数据库优化器计算的是它们的 CPU 成本、磁盘 I&#x2F;O 成本、和内存需求。\n优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。\n\n\n&#96;SQl执行**。\n开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误，在工程实现上，如果命中查询缓存，会在查询缓存返回结果的时候，做权限验证。查询也会在优化器之前调用 precheck 验证权限。\n如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。\nmysql&gt; select * from T where ID&#x3D;10;\n\n比如我们这个例子中的表 T 中，ID 字段没有索引，那么执行器的执行流程是这样的：\n\n调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；\n调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。\n执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。\n\n至此，这个语句就执行完成了。\n对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。\n\n\n日志记录。日志记录是数据的一个重要组成部分，这是DBA进行恢复，查错，优化的主要依据。\n日志记录在更新操作上显得尤为重要，Mysql有两个主要日志：&#96;redo log（重做日志）和 binlog（归档日志）**\na. redo Log\n举个例子来介绍一下日志的记录方式，如果有人要赊账或者还账的话，掌柜一般有两种做法：\n\n一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；\n另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。\n\n在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。\n这整个过程想想都麻烦。相比之下，还是先在粉板上记一下方便。\n​    而粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 &#96;WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。**\n​    当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。\n​    InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。\n\n\n有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。\nb. BinLog\n​    上面我们聊到的粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。\n​    最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。\n这两种日志有以下三点不同。\n\nredo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。\nredo log 是物理日志**，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志**，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。\nredo log 是循环写的，空间固定会用完**；binlog 是可以追加写入的**。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\n以一条更新或插入记录为例,日志的写过程如下:\n\n引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。\n执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\n执行器调用引擎的提交事务接口，引擎把刚刚写入的 &#96;redo log 改成提交（commit）状态**，更新完成。\n\n将 redo log 的写入拆成了两个步骤：prepare 和 commit，这就是****”两阶段提交”****。\n为什么必须有“两阶段提交”呢？\n这是为了让两份日志之间的逻辑一致。由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。如果当一个日志写完之后,而另外一个未写完,那么就会造成数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。\n\n\n2. 事务隔离事务的四个特性: ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）\n\n原子性: 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。\n回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\n\n一致性: 数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。\n\n隔离性: 一个事务所做的修改在最终提交以前，对其它事务是不可见的。\n\n持久性: 一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\n可以通过数据库备份和恢复来实现，在系统发生崩溃时，使用备份的数据库进行数据恢复。\n\n\n\n主要讲事务的隔离性。\n​    隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。&#96;SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。**\n\n读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。\n读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。\n可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。\n串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。\n\n在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。\n在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。\n在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。\n这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；\n而“串行化”隔离级别下直接用加锁的方式来避免并行访问。\n\n为什么建议你尽量不要使用长事务。\n长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。\n实现事务隔离的原理InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。\nInnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。普通查询语句是一致性读，一致性读会根据 row trx_id 和一致性视图确定数据版本的可见性。\n\n对于可重复读，查询只承认在事务启动前就已经提交完成的数据；\n对于读提交，查询只承认在语句启动前就已经提交完成的数据；\n\n而当前读，总是读取已经提交完成的最新版本。\n你也可以想一下，为什么表结构不支持“可重复读”？这是因为表结构没有对应的行数据，也没有 row trx_id，因此只能遵循当前读的逻辑。\n3. 索引索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。索引的出现是为了提高查询效率，但是实现索引的方式却有很多种，所以这里也就引入了索引模型的概念。可以用于提高读写效率的数据结构很多，这里我先给你介绍三种常见、也比较简单的数据结构，它们分别是哈希表、有序数组和搜索树。\na. 哈希表\n哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。\nb. 有序数组\n有序数组在等值查询和范围查询场景中的性能就都非常优秀。如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。\n有序数组索引只适用于静态存储引擎，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。\nc. 搜索树\n二叉搜索树的查询复杂度是 $O(log_2(N))$ ，为了保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是 O(log(N))。 二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。\n为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。这里，“N 叉”树中的“N”取决于数据块的大小。\n以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。\na. InnoDB 的索引模型在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，&#96;InnoDB 使用了 B+ 树索引模型**，所以数据都是存储在 B+ 树中的。\n索引类型分为主键索引和非主键索引。\n主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。\n非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。\n根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？\n\n如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；\n如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。\n\n主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。\n1. 覆盖索引由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？\n也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。\n由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。\n\n2. 最左前缀B+ 树这种索引结构，可以利用索引的“最左前缀”，来定位记录。关于最左前缀,看下面这个例子:\n\n\n\n当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。\n如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是”where name like ‘张 %’”。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。\n\n\n3. 索引下推在不得不回表时,如果查询语句对联合索引上的其他字段有特别约束,可以先进行筛选再回表。\nb. 索引选择和实践普通索引和唯一索引应该怎么选择。其实，这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。所以，我建议你尽量选择普通索引。\n当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InooDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。\n需要说明的是，虽然名字叫作 change buffer，实际上它是可以持久化的数据。也就是说，change buffer 在内存中有拷贝，也会被写入到磁盘上。\n如果所有的更新后面，都马上伴随着对这个记录的查询，那么你应该关闭 change buffer。而在其他情况下，change buffer 都能提升更新性能。\n在实际使用中，你会发现，普通索引和 change buffer 的配合使用，对于数据量大的表的更新优化还是很明显的。\n创建索引可以使用的方式有：\n\n直接创建完整索引，这样可能比较占用空间；\n创建前缀索引，节省空间，但会增加查询扫描次数，并且不能使用覆盖索引；\n倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；\n创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。\n\n在实际应用中，你要根据业务字段的特点选择使用哪种方式。\n4. 锁根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n但是加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、以及检查锁状态)都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\na. 全局锁全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 &#96;Flush tables with read lock (FTWRL)**。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的写语句会被阻塞。\n全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。\n以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。注意，在备份过程中整个库完全处于只读状态。\n但是让整库都只读，听上去就很危险：\n\n如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；\n如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。\n\nb. 表级锁MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。\n表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。\n在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。\n另一类表级的锁是 MDL（metadata lock)。&#96;MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。**你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。\n\n读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。\n读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。\n\nc. 行锁MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。\n1. 两阶段锁加锁和解锁分为两个阶段进行。\n在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。\n如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。\n两段锁协议可能会造成死锁。\n我们可以主动进行死锁检测，主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。死锁检测要耗费大量的 CPU 资源。\n减少死锁的方案：\n\n如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。\n\n控制并发度\n\n将一行改成逻辑上的多行来减少锁冲突。\n\n\n","slug":"Mysql","date":"2022-04-07T06:17:50.000Z","categories_index":"互联网八股","tags_index":"数据库,Mysql","author_index":"张 凡"},{"id":"d1660779e842dc0a9949e0b888a18409","title":"Reids","content":"1. NoSQLNoSQL（ NoSQL &#x3D; Not Only SQL ），意即不仅仅是 SQL，泛指非关系型的数据库。\nNoSQL 不依赖业务逻辑方式存储，而以简单的 key-value 模式存储。因此大大的增加了数据库的扩展能力。\n\n不遵循 SQL 标准。\n不支持 ACID。\n远超于 SQL 的性能。\n\n适用于的场景\n\n对数据高并发的读写；\n海量数据的读写；\n对数据高可扩展性的。\n\n不适用的场景\n\n需要事务支持；\n基于 sql 的结构化查询存储，处理复杂的关系，需要即席查询。\n\n常见的 NoSQL 数据库\n\nRedis\nMongoDB\n\n2. Redis 简介Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\nRedis 与其他 key - value 缓存产品有以下三个特点：\n\nRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\nRedis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\nRedis支持数据的备份，即master-slave模式的数据备份。\n\nRedis 优势\n\n性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s 。\n丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n丰富的特性 – Redis还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。\n\n3. 数据类型及操作Redis 的基本类型有五个: String、List、Set、Hash、Zset\nRedis 新数据类型: Bitmaps、HyperLogLog、Geospatial\n原子性\n所谓 原子 操作是指不会被线程调度机制打断的操作；\n这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。\n\n在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。\n在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。\n\nRedis 单命令的原子性主要得益于 Redis 的单线程。\nKey操作\nkeys * \t    # 查看当前库的所有key\nexist key \t# 判断某个key是否存在\ndel key\t    # 删除指定key\nunlink key\t# 根据value 值进行非阻塞删除 真正的删除会在后面进行异步删除\ntype key\t# 判断key类型\nexpire key [10]\t# 为给定的 key 设置过期时间\nttl key\t\t# 查看还有多少秒过期，-1表示永不过期，-2表示已过期\nselect\t\t# 命令切换数据库\ndbsize\t\t# 查看当前数据库的 key 的数量\nflushdb \t# 清空当前库\nflushall\t# 通杀全部库\n\n\n\n\n\na. 字符串 StringString 类型是二进制安全的。意味着 Redis的 string 可以包含任何数据。比如 jpg 图片或者序列化的对象。\nString 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最多可以是 512M。\n常用命令:\nset &lt;key&gt;&lt;value&gt;\t\t# 添加键值对\nget &lt;key&gt;\t\t\t    # 查询对应键值\nappend &lt;key&gt;&lt;value&gt;\t\t # 将给定的 &lt;value&gt; 追加到原值的末尾\nstrlen &lt;key&gt;\t\t\t# 获得值的长度\nsetnx &lt;key&gt;&lt;value&gt;\t\t # 只有在 key 不存在时，设置 key 的值\nincr &lt;key&gt;\t\t\t\t# 将 key 中储存的数字值增 1，只能对数字值操作，如果为空，新增值为 1（具有原子性）\ndecr &lt;key&gt;\t\t\t\t# 将 key 中储存的数字值减 1，只能对数字值操作，如果为空，新增值为 -1\nincrby&#x2F;decrby &lt;key&gt;&lt;步长&gt; \t\t\t  # 将 key 中储存的数字值增减。自定义步长\nmset &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  \t\t# 同时设置一个或多个 key-value 对\nmget &lt;key1&gt;&lt;key2&gt;&lt;key3&gt;...\t\t    \t# 同时获取一个或多个 value\nmsetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;... \t # 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在\ngetrange &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;\t\t # 获得值的范围\nsetrange &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;\t\t\t# 用 &lt;value&gt; 覆写 &lt;key&gt; 所储存的字符串值\nsetex &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;\t\t\t# 设置键值的同时，设置过期时间，单位秒。\ngetset &lt;key&gt;&lt;value&gt;\t\t # 以新换旧，设置了新值同时获得旧值。\n\nString内部的数据结构\n内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配,不能超过512M;\nb. 列表 List单键 - 多值 数据结构\nRedis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。\n它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。\n\n\n常用命令\nlpush&#x2F;rpush &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; ....\t# 从左边&#x2F;右边插入一个或多个值。\n #eg:  输入 : lpush k1 v1 v2 v3\n #      &gt; lrange k1 0 -1\n #     输出 ：v3 v2 v1 \n #     输入 : rpush k1 v1 v2 v3\n #      &gt; rrange k1 0 -1\n #     输出：v1 v2 v3\nlpop&#x2F;rpop &lt;key&gt;\t\t\t\t\t# 从左边&#x2F;右边吐出一个值。值在键在，值光键亡。\nrpoplpush &lt;key1&gt;&lt;key2&gt;\t\t\t # 从 &lt;key1&gt; 列表右边吐出一个值，插到 &lt;key2&gt; 列表左边。\nlrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;\t\t # 按照索引下标获得元素（从左到右）\nlrange mylist 0 -1 0\t\t\t # 左边第一个，-1右边第一个，（0 -1表示获取所有）\nlindex &lt;key&gt;&lt;index&gt;\t\t\t\t # 按照索引下标获得元素（从左到右）\nllen &lt;key&gt;\t\t\t\t\t\t# 获得列表长度\nlinsert &lt;key&gt; before&#x2F;after &lt;value&gt;&lt;newvalue&gt;\t# 在 &lt;value&gt; 的前面&#x2F;后面插入 &lt;newvalue&gt; 插入值\nlrem &lt;key&gt;&lt;n&gt;&lt;value&gt;\t\t\t # 从左边删除 n 个 value（从左到右）\nlset&lt;key&gt;&lt;index&gt;&lt;value&gt;\t\t\t # 将列表 key 下标为 index 的值替换成 value\n\nList内部数据结构\nList 的数据结构为快速链表 quickList。\n首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。\n它将所有的元素紧挨着一起存储，分配的是一块连续的内存。\n当数据量比较多的时候才会改成 quicklist。\n因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。\nRedis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。\n\n\n\n\nc. 集合 Set   Set 对外提供的功能与 List 类似列表的功能，特殊之处在于 Set 是可以 自动排重 的，当需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个成员是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。\n   Redis 的 Set 是 String 类型的无序集合。它底层其实是一个 value 为 null 的 hash 表，所以添加，删除，查找的复杂度都是 O(1)。\n一个算法，随着数据的增加，执行时间的长短，如果是 O(1)，数据增加，查找数据的时间不变。\n常用命令\nsadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ..... \t# 将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略\nsmembers &lt;key&gt;\t\t\t\t# 取出该集合的所有值。\nsismember &lt;key&gt;&lt;value&gt;\t\t # 判断集合 &lt;key&gt; 是否为含有该 &lt;value&gt; 值，有返回 1，没有返回 0\nscard&lt;key&gt;\t\t\t\t\t# 返回该集合的元素个数。\nsrem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....\t# 删除集合中的某个元素\nspop &lt;key&gt;\t\t\t\t\t# 随机从该集合中吐出一个值\nsrandmember &lt;key&gt;&lt;n&gt;\t\t # 随机从该集合中取出 n 个值，不会从集合中删除\nsmove &lt;source&gt;&lt;destination&gt;value\t# 把集合中一个值从一个集合移动到另一个集合\nsinter &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的交集元素\nsunion &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的并集元素\nsdiff &lt;key1&gt;&lt;key2&gt;\t\t\t # 返回两个集合的差集元素（key1 中的，不包含 key2 中的）\n\nSet的内部数据结构\nSet 数据结构是字典，字典是用哈希表实现的。\nd. 哈希 HashRedis hash 是一个键值对集合。\nRedis hash 是一个 String 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。\n注意 Redis的Hash类型和String类型的区别。\n\n\n常用命令:\nhset &lt;key&gt;&lt;field&gt;&lt;value&gt;\t\t# 给 &lt;key&gt; 集合中的 &lt;field&gt; 键赋值 &lt;value&gt;\nhget &lt;key1&gt;&lt;field&gt;\t\t\t    # 从 &lt;key1&gt; 集合 &lt;field&gt; 取出 value\nhmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...  # 批量设置 hash 的值\nhexists &lt;key1&gt;&lt;field&gt;\t\t\t# 查看哈希表 key 中，给定域 field 是否存在\nhkeys &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 field\nhvals &lt;key&gt;\t\t\t\t# 列出该 hash 集合的所有 value\nhincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;\t # 为哈希表 key 中的域 field 的值加上增量 1 -1\nhsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;\t\t # 将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在\n\nHash数据结构:\nHash 类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。\n当 field-value 长度较短且个数较少时，使用 ziplist，否则使用 hashtable。\ne. 有序集合 ZsetRedis 有序集合 zset 与普通集合 set 非常相似，是一个没有重复元素的字符串集合。\n不同之处是 zset有序集合的每个成员都关联了一个评分（score）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复的。\n因为元素是有序的，所以可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。\n访问有序集合的中间元素也是非常快的，因此能够使用有序集合作为一个没有重复成员的智能列表。\n常用命令:\nzadd &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…\t\t# 将一个或多个 member 元素及其 score 值加入到有序集 key 当中\nzrange &lt;key&gt;&lt;start&gt;&lt;stop&gt; [WITHSCORES] \t\t    # 返回有序集 key 中，下标在 &lt;start&gt;&lt;stop&gt; 之间的元素\n# 当带 WITHSCORES，可以让分数一起和值返回到结果集\nzrangebyscore key min max [withscores] [limit offset count]\t \t# 返回有序集 key 中，所有 score 值介于 min 和 max 之间（包括等于 min 或 max ）的成员。有序集成员按 score 值递增（从小到大）次序排列。\nzrevrangebyscore key max min [withscores] [limit offset count]   # 同上，改为从大到小排列\nzincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;\t\t\t# 为元素的 score 加上增量\nzrem &lt;key&gt;&lt;value&gt;\t\t\t\t\t   # 删除该集合下，指定值的元素\nzcount &lt;key&gt;&lt;min&gt;&lt;max&gt;\t\t\t\t    # 统计该集合，分数区间内的元素个数\nzrank &lt;key&gt;&lt;value&gt;\t\t\t\t\t   # 返回该值在集合中的排名，从 0 开始。\n\nZset内部结构:\nSortedSet（zset）是 Redis 提供的一个非常特别的数据结构，一方面它等价于 Java 的数据结构 Map&lt;String, Double&gt;，可以给每一个元素 value 赋予一个权重 score，另一方面它又类似于 TreeSet，内部的元素会按照权重 score 进行排序，可以得到每个元素的名次，还可以通过 score 的范围来获取元素的列表。\nzset 底层使用了两个数据结构\n\nhash，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值\n跳跃表，跳跃表的目的在于给元素 value 排序，根据 score 的范围获取元素列表\n\nf. BitmapsRedis 提供了 Bitmaps 这个数据类型 来实现位操作。\n\nBitmaps 本身不是一个数据类型,实际上是一个01字符串,但是它可以对这个字符串进行位操作。\nBitmaps 单独提供了一套指令,所以在Redis中使用Bitmaps和使用字符串方式不同, 可以把Bitmaps想象成一个以位为单位的数组,每个单位只能存储01,下标在Bitmaps中成为 偏移量。\n\n\n\n常用命令\nsetbit &lt;key&gt; &lt;offset&gt; &lt;value&gt;\t\t# 给一个指定key的值得第offset位 赋值为value。\ngetbit &lt;key&gt; &lt;offset&gt;\t\t\t    # 返回一个指定key的二进制信息\nbitcount &lt;key&gt; &lt;start&gt; &lt;offset&gt;\t\t# 返回一个指定key中位的值为1的个数(是以byte为单位不是bit)\nbitop &lt;operation&gt; &lt;destkey&gt; key1 key2  \t# 对key1 和key2 执行 operation 并将结果保存到 destkey\n\n主要用途\n​    主要用来存储大数据量但数据简单的操作,比如统计活跃用户量。\ng. HyperLogLogHyperLogLog是Redis的高级数据结构，它在做基数统计的时候非常有用，每个HyperLogLog的键可以计算接近 $2^{64}$ 不同元素的基数，而大小只需要12KB。\nHyperLogLog可以用很少的内存来存储集合的唯一元素。（每个HyperLogLog只有12K加上key本身的几个字节）\nHyperLogLog的结果并不精准，错误率大概在0.81%。\n常用操作\npfadd &lt;key&gt; &lt;element&gt;[element]  # 添加指定元素到Hyperloglog中\npfcount &lt;key&gt;\t\t\t\t  # 统计key中包含的元素的个数 \t\npfmerge &lt;destkey&gt; &lt;sourcekey&gt; [sourcekey] \t# 将两个或多个元素集合合并\n\n\n\n主要用途\n​    主要用来计算大量数据的基数。\nh. Geospatial​    Geo类型 是Geographic地理信息类型的缩写,该元素就是二维坐标,是地图上的经纬度。 Redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。\n常用命令\ngeoadd key [NX|XX] [CH] longitude latitude member [longitude latitude member ...]\n# geoadd china:city 121.49 31.23 shanghai 添加一个位置信息\ngeopos key member [member ...]\t\t\n# geopos china:city shanghai  获取一个城市的信息\ngeodist key member1 member2 [m|km|ft|mi] # 获取两个位置之间的距离 [m|km|ft|mi] 来确定单位\ngeoradius key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] # 获取一个经纬度范围内的位置信息\n\n\n\n\n\n\n\n4. Redis 配置文件本机安装Redis时,文件的配置路径为 /etc/redis.conf\n如果使用docker由镜像生成redis容器,默认是没有配置文件的,需要自己在宿主机进行创建,然后进行配置文件挂载 /docker/redis/conf/redis.conf:/etc/redis/redis.conf \\。\n在配置文件中可以设置：\n\nUnits 单位，配置大小单位，开头定义了一些基本的度量单位，只支持 bytes，不支持 bit。大小写不敏感。\n\nINCLUDES 包含，多实例的情况可以把公用的配置文件提取出来。\n\nNETWORK 网络相关配置。\n\nbind 默认情况 bind=127.0.0.1 只能接受本机的访问请求。不写的情况下，无限制接受任何 ip 地址的访问。生产环境肯定要写你应用服务器的地址，服务器是需要远程访问的，所以需要将其注释掉。\n\nprotected-mode 如果开启了protected-mode，那么在没有设定 bind ip 且没有设密码的情况下，Redis 只允许接受本机的响应。\n\nport 端口号，默认 6379。\n\n\n\nGENERAL 通用。\n\ndaemonize 是否为后台进程，设置为 yes。\n\npidfile  存放 pid 文件的位置，每个实例会产生一个不同的 pid 文件。\n\nloglevel 指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice。\n\nlogfile 日志文件名称。\n\ndatabase 设定库的数量 默认16，默认数据库为 0，可以使用 SELECT &lt;dbid&gt; 命令在连接上指定数据库 id。\n\n\n\nSECURITY 安全。\n访问密码的查看、设置和取消。\n在命令中设置密码，只是临时的。重启 redis 服务器，密码就还原了。\n永久设置，需要在配置文件中进行设置。\n\nLIMITS  限制。\n\nmaxclients设置 redis 同时可以与多少个客户端进行连接。默认情况下为 10000 个客户端。\n如果达到了此限制，redis 则会拒绝新的连接请求，并且向这些连接请求方发出 max number of clients reached 以作回应。\n\nmaxmemory 建议必须设置，否则，将内存占满，造成服务器宕机。\n设置 redis 可以使用的内存量。一旦到达内存使用上限，redis 将会试图移除内部数据，移除规则可以通过 maxmemory-policy 来指定。\n如果 redis 无法根据移除规则来移除内存中的数据，或者设置了不允许移除，那么 redis 则会针对那些需要申请内存的指令返回错误信息，比如 SET、LPUSH 等。\n\nmaxmemory-policy\n\nvolatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键（最近最少使用）\n\nallkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key。\n\n\n\n\n5. Redis的发布与订阅Redis 发布订阅（ pub&#x2F;sub ）是一种消息通信模式：发送者（ pub ）发送消息，订阅者（ sub ）接收消息。\nRedis 客户端可以订阅任意数量的频道。\n\n客户端可以订阅频道\n\n\n\n\n当给这个频道发布消息后，消息就会发送给订阅的客户端\n\n\n\nsubscribe channel \t\t # 订阅频道\npublish channel hello \t # 频道发送信息\n\n6. SpringBoot整合Redisa. 添加pom.xml 依赖\n&lt;!-- redis --&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;\n&lt;&#x2F;dependency&gt;\n\n&lt;!-- spring2.X集成redis所需common-pool2--&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;commons-pool2&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.6.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nb. 配置Redis\n#Redis服务器地址\nspring.redis.host&#x3D; ip\n#Redis服务器连接端口\nspring.redis.port&#x3D;6379\n#Redis数据库索引（默认为0）\nspring.redis.database&#x3D; 0\n#连接超时时间（毫秒）\nspring.redis.timeout&#x3D;1800000\n#连接池最大连接数（使用负值表示没有限制）\nspring.redis.lettuce.pool.max-active&#x3D;20\n#最大阻塞等待时间(负数表示没限制)\nspring.redis.lettuce.pool.max-wait&#x3D;-1\n#连接池中的最大空闲连接\nspring.redis.lettuce.pool.max-idle&#x3D;5\n#连接池中的最小空闲连接\nspring.redis.lettuce.pool.min-idle&#x3D;0\n\nc. Redis 配置类\n@EnableCaching\n@Configuration\npublic class RedisConfig extends CachingConfigurerSupport &#123;\n    @Bean\n    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123;\n        RedisTemplate&lt;String, Object&gt; template &#x3D; new RedisTemplate&lt;&gt;();\n        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om &#x3D; new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        template.setConnectionFactory(factory);\n\t\t\t\t&#x2F;&#x2F; key序列化方式\n        template.setKeySerializer(redisSerializer);\n\t\t\t\t&#x2F;&#x2F; value序列化\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n\t\t\t\t&#x2F;&#x2F; value hashmap序列化\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        return template;\n    &#125;\n\n    @Bean\n    public CacheManager cacheManager(RedisConnectionFactory factory) &#123;\n        RedisSerializer&lt;String&gt; redisSerializer &#x3D; new StringRedisSerializer();\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer &#x3D; new Jackson2JsonRedisSerializer(Object.class);\n\t\t\t\t&#x2F;&#x2F; 解决查询缓存转换异常的问题\n        ObjectMapper om &#x3D; new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\t\t\t\t&#x2F;&#x2F; 配置序列化（解决乱码的问题）,过期时间600秒\n        RedisCacheConfiguration config &#x3D; \n          RedisCacheConfiguration.defaultCacheConfig()\n                .entryTtl(Duration.ofSeconds(600))\n      .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))\n                .disableCachingNullValues();\n        RedisCacheManager cacheManager &#x3D; RedisCacheManager.builder(factory)\n                .cacheDefaults(config)\n                .build();\n        return cacheManager;\n    &#125;\n&#125;\n\n\n\n7. Redis事务Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\nRedis 事务的主要作用就是串联多个命令防止别的命令插队。\n事务三特性\n\n单独的隔离操作\n事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\n\n没有隔离级别的概念\n队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。\n\n不保证原子性\n事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚\n\n\na. Multi、Exec、Discard从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。\n组队的过程中可以通过 Discard 来放弃组队。\n\n\n\n\n127.0.0.1:6379&gt; multi\t\t\t\t# 开启事务\nOK\n127.0.0.1:6379(TX)&gt; set key1 val1\t # 进入队列\t\nQUEUED\n127.0.0.1:6379(TX)&gt; set key2 val2\t # 进入队列\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\t\t\t# 开始执行\n1) OK\n2) OK\n# 开始执行之前 使用discard命令可以中断排队\n\n组队中有命令错误，队列中所有命令都不会执行\n127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379(TX)&gt; set a1 b1\nQUEUED\n127.0.0.1:6379(TX)&gt; set b\n(error) ERR wrong number of arguments for &#39;set&#39; command\n127.0.0.1:6379(TX)&gt; exec\n(error) EXECABORT Transaction discarded because of previous errors.\n\n组队中不报错，执行时报错,只有报错的命令会被取消。\n127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379(TX)&gt; set vas sdad\nQUEUED\n127.0.0.1:6379(TX)&gt; incr vas\nQUEUED\n127.0.0.1:6379(TX)&gt; exec\n1) OK\n2) (error) ERR value is not an integer or out of range\n\n\n\nb. 事务冲突多个事务对同一数据进行操作时可能出现冲突。\n1. 悲观锁悲观锁（Pessimistic Lock），即每次去拿数据的时候都认为有其他线程会修改，所以每次在拿数据的时候都会上锁，这样其他线程想要拿到这个数据就会被 block 直到成功拿到锁。（效率低）\n一个事务执行时，其他对同一数据进行操作的事务都不能执行。\n2. 乐观锁乐观锁（Optimistic Lock），即每次去拿数据的时候都认为其他线程不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间有没有其他线程去更新这个数据，可以使用版本号等机制。\n乐观锁适用于多读的应用类型，这样可以提高吞吐量。\nRedis 就是利用这种 check-and-set 机制实现事务的。\n3. Watch、unwatch在执行 multi 之前，先执行 watch key1 [key2]，可以监视一个（或多个 ）key 。如果在事务执行之前这个 key 被其他命令所改动，那么事务将被打断。\n取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，EXEC 命令或 DISCARD 命令先被执行，那么就不需要再执行 UNWATCH 。\n8. 持久化将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\na. RDB(Redis DataBase)在指定的 时间间隔内 将内存汇总的数据集快照写入磁盘。 即 Snapshot 快照，恢复时是将快照文件直接读到内存里。\n备份过程\nRedis 会单独创建一个子进程（fork）来进行持久化。\n先将数据写入到一个临时文件中，待持久化过程完成后，再将这个临时文件内容覆盖到 dump.rdb。\n整个过程中，主进程是不进行任何 IO 操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那 RDB 方式要比 AOF 方式更加的高效。\nRDB 的缺点是最后一次持久化后的数据可能丢失。\nFork子进程\n\n作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等） 数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程\n在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，Linux 中引入了 写时复制技术\n一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程\n\n和RDB有关的配置\n\n临时文件名设置。  在 redis.conf 中配置文件名称，默认为 dump.rdb。\n\n临时文件保存位置。  rdb 文件的保存路径可以修改。默认为 Redis 启动时命令行所在的目录下。\n\nstop-writes-on-bgsave-error   即当 redis 无法写入磁盘，关闭 redis 的写入操作。\n\nrdbcompression    持久化的文件是否进行压缩存储。\n\nrdbchecksum   完整性的检查，即数据是否完整性、准确性。\n\nsave   表示达到什么操作数时进行备份。\nsave 60 10000  # 表示 如果60s内 超过 10000个keys改变过,那么触发持久化\n\n优点\n\n适合大规模的数据恢复；\n对数据完整性和一致性要求不高更适合使用；\n节省磁盘空间；\n恢复速度快。\n\n缺点\n\nFork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑；\n虽然 Redis 在 fork 时使用了**写时拷贝技术**，但是如果数据庞大时还是比较消耗性能；\n在备份周期在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。\n\nRBD的备份过程\n​    只需要将 要备份的rdb文件拷贝到备份文件的默认目录下,启动redis即可自动将rdb文件恢复。\nb. AOF(Append Of File)以日志的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下来（读操作不记录）， 只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据。\n如果 Redis 重启就会根据日志文件（如果AOF文件和RDB文件都存在，优先恢复AOF）的内容将写指令从前到后执行一次以完成数据的恢复工作。\nAOF默认不开启。在配置文件中设置 appendonly yes 打开\n执行流程\n\n客户端的请求写命令会被 append 追加到 AOF 缓冲区内；\nAOF 缓冲区根据 AOF 持久化策略 [always,everysec,no] 将操作 sync 同步到磁盘的 AOF 文件中；\nAOF 文件大小超过重写策略或手动重写时，会对 AOF 文件 Rewrite 重写，压缩 AOF 文件容量；\nRedis 服务重启时，会重新 load 加载 AOF 文件中的写操作达到数据恢复的目的。\n\nAOF 和 RDB 同时开启时，系统默认读取 AOF 的数据（数据不会存在丢失）\n和AOF有关的配置\n\nappendfsync always  时钟同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。\nappendfsync everysec  每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。\nappendfsync no Redis 不主动进行同步，把同步时机交给操作系统。\nRewrite 压缩当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof。\n\nAOF 修复\n当AOF文件出错时,可以使用 redis-check-aof--fix [文件名] 命令对AOF文件进行修复。\nAOF优势\n\n备份机制更稳健，丢失数据概率更低；\n可读的日志文本，通过操作 AOF 稳健，可以处理误操作。\n\nAOF缺点\n\n比起 RDB 占用更多的磁盘空间；\n恢复备份速度要慢；\n每次读写都同步的话，有一定的性能压力；\n存在个别 Bug，造成不能恢复。\n\nc. AOF和RDB的选择官方推荐两个都启用。\n如果对数据不敏感，可以选单独用 RDB。\n不建议单独用 AOF，因为可能会出现 Bug。\n如果只是做纯内存缓存，可以都不用。\n9. Redis 主从复制主机数据更新后根据配置和策略， 自动同步到备机的 master&#x2F;slaver 机制，Master 以写为主，Slaver 以读为主。\n\n\n主从复制的优势\n\n读写分离，性能扩展\n容灾快速恢复\n一主多从！\n\na. 模拟一主两从复制我自己通过Docker模拟实现。\n\n为每个redis容器创建自己的redis.conf文件\n\n先创建一个公用的redis.conf\n# daemonize yes\ndir &#x2F;data\nlogfile &#x2F;data&#x2F;redis.log\nprotected-mode no\n#注释掉，可以远程访问\n#bind 127.0.0.1\n#开启AOF\nappendonly no\n\n然后分别创建 redis6370.conf redis6371.conf redis6372.conf,写入对应的配置信息。\ninclude &#x2F;redis-cluster&#x2F;redis.conf\npidfile &#x2F;var&#x2F;run&#x2F;redis_6370.pid\nport 6370\ndbfilename dump6370.rdb\n\n\n启动三个Redis容器，加载对应的conf文件\n\ndocker run -itd -p 6370:6379 -v /home/redis/redis.conf:/redis-cluster/redis6370.conf -v /home/redis/data/:/data --name redis6370 -e &quot;TZ=Asia/Shanghai&quot; redis  /redis-cluster/redis6370.conf\n\n- &#96;&#96;&#96;sh\n  docker run -itd -p 6371:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6371.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data --name redis6371 -e &quot;TZ&#x3D;Asia&#x2F;Shanghai&quot; redis  &#x2F;redis-cluster&#x2F;redis6371.conf\n\n\n&#96;&#96;&#96;shdocker run -itd -p 6372:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6372.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data –name redis6372 -e “TZ&#x3D;Asia&#x2F;Shanghai” redis  &#x2F;redis-cluster&#x2F;redis6372.conf\n\n3. 随便进入一个redis进程,查看主从信息,发现三个都是主节点\n\n   &#96;&#96;&#96;sh\n   127.0.0.1:6379&gt; info replication\n   # Replication\n   role:master\t\t\t# 主机\n   connected_slaves:0\t # 没有slave节点\n   master_failover_state:no-failover\n   master_replid:1215d3dd30318947c9fbb130adb781e5e250bac5\n   master_replid2:0000000000000000000000000000000000000000\n   master_repl_offset:0\n   second_repl_offset:-1\n   repl_backlog_active:0\n   repl_backlog_size:1048576\n   repl_backlog_first_byte_offset:0\n   repl_backlog_histlen:0\n\n\n配置主从关系\nslaveof [IP] [Port] # 将当前redis服务 作为从机备份到 [ip]:[port]\n\n由于此处使用的是docker,所以得先查看主机的docker的IP地址\ndocker inspect [容器名 redis6370]\n&quot;Networks&quot;: &#123;\n    &quot;bridge&quot;: &#123;\n        &quot;IPAMConfig&quot;: null,\n        &quot;Links&quot;: null,\n        &quot;Aliases&quot;: null,\n        &quot;NetworkID&quot;: &quot;a4b86cbe5c82a4651588bb950df3cd42cd8391bffba939ac5fc43858d1f2be37&quot;,\n        &quot;EndpointID&quot;: &quot;052a96ffb53bdf74a7322adfceba70248f17394a9697951e6d78f21f5bf0b72f&quot;,\n        &quot;Gateway&quot;: &quot;172.17.0.1&quot;,\n        &quot;IPAddress&quot;: &quot;172.17.0.8&quot;,\n        &quot;IPPrefixLen&quot;: 16,\n        &quot;IPv6Gateway&quot;: &quot;&quot;,\n        &quot;GlobalIPv6Address&quot;: &quot;&quot;,\n        &quot;GlobalIPv6PrefixLen&quot;: 0,\n        &quot;MacAddress&quot;: &quot;02:42:ac:11:00:08&quot;,\n        &quot;DriverOpts&quot;: null\n    &#125;\n&#125;\n\n查看 主机6370 和 从机6371&#x2F;2 对应的信息\n# 6371 和 6372 作为 6370的从机\n# 6370\n127.0.0.1:6379&gt; info replication\n# Replication\nrole:master\nconnected_slaves:2   # 得到两个从服务器\nslave0:ip&#x3D;172.17.0.10,port&#x3D;6379,state&#x3D;online,offset&#x3D;602,lag&#x3D;1\nslave1:ip&#x3D;172.17.0.9,port&#x3D;6379,state&#x3D;online,offset&#x3D;602,lag&#x3D;1\nmaster_failover_state:no-failover\nmaster_replid:46570ab087353ccfb3b0314f18f2f2a3cfa6a31f\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:602\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:1\nrepl_backlog_histlen:602\n\n# 6371&#x2F;2\n127.0.0.1:6379&gt; info replication\n# Replication\nrole:slave\t\t# 角色为从机\nmaster_host:172.17.0.8\t# 主机为6370\nmaster_port:6379\nmaster_link_status:up\nmaster_last_io_seconds_ago:3\nmaster_sync_in_progress:0\nslave_read_repl_offset:1050\nslave_repl_offset:1050\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:46570ab087353ccfb3b0314f18f2f2a3cfa6a31f\nmaster_replid2:0000000000000000000000000000000000000000\nmaster_repl_offset:1050\nsecond_repl_offset:-1\nrepl_backlog_active:1\nrepl_backlog_size:1048576\nrepl_backlog_first_byte_offset:547\nrepl_backlog_histlen:504\n\n在从机上写数据会报错\n# 6371\n127.0.0.1:6379&gt; set k1 a\n(error) READONLY You can&#39;t write against a read only replica.\n\n\n\nb. 主从复制原理\nslave 启动成功连接到 master 后会发送一个 sync 命令（同步命令）。\nmaster 接到命令启动后台的存盘进程，对数据进行持久化操作，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master 将传送整个数据文件（rdb）到 slave，以完成一次完全同步。\n当主服务进行写操作后，和从服务器进行数据同步。\n全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n增量复制：master 继续将新的所有收集到的修改命令依次传给 slave，完成同步。\n只要是重新连接 master，一次完全同步（全量复制）将被自动执行。\n\nc. 主从复制常用方式1. 一主两仆主机为6370 从机 6371和6372;两个从机平等的作为一个主机的从机。\n从机挂掉\n当从机6371挂掉,重启后,6371不再作为6370的主机,而是作为新的master\n当再次把6380作为6379的从机加入后，从机 会把数据从头到尾复制。\n主机挂掉 \n6371和6372仍然是6370的从机，不会做任何事；当6370重启后，既然是主服务器。\n2. 薪火相传\n\n上一个 slave 可以是下一个 slave 的 master，slave 同样可以接收其他 slave的连接和同步请求，那么该 slave 作为了链条中下一个的 master，可以有效减轻 master 的写压力，去中心化降低风险。\n中途变更转向：会清除之前的数据，重新建立拷贝最新的。\n当某个 slave 宕机，后面的 slave 都没法备份。\n即当主机挂掉，从机还是从机，但是无法继续写数据。\n3. 反客为主 当一个 master 宕机后，后面的 slave 可以立刻升为 master，其后面的 slave 不用做任何修改。手动完成。\nslaveof no one\n\n\n\nd. 哨兵模式哨兵模式自动实现主从切换，而上面的反客为主需要手动完成。\n能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库。\n当主机宕机后,会在从机中选举新的主机\n选举规则\n\n根据优先级别，slave-priority&#x2F;replica-priority，优先选择优先级靠前的。\n\n\n根据偏移量，优先选择偏移量大的。\n\n根据 runid，优先选择最小的服务。\n\n\n复制延时\n由于所有的写操作都是先在 master 上操作，然后同步更新到 slave 上，所以从 master 同步到 slave 从机有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，slave 机器数量的增加也会使这个问题更加严重。\n设置哨兵模式的方法\n\n创建 sentinel.conf 文件\n\n&#x2F;opt&#x2F;etc&#x2F;sentinel.conf\n\n\n配置哨兵\n\nsentinel monitor mymaster 172.16.88.168 6379 1\n# mymaster：监控对象起的服务器名称\n# 1：至少有多少个哨兵同意迁移的数量。 \n\n\n启动哨兵\n\nredis-sentinel  &#x2F;opt&#x2F;etc&#x2F;sentinel.conf \n\n\n\n10. Redis 集群集群需要解决的问题\n容量不够，redis 如何进行扩容？\n并发写操作， redis 如何分摊？\n主从模式，薪火相传模式，主机宕机，导致 ip 地址发生变化，应用程序中配置需要修改对应的主机地址、端口等信息。\n解决方案\n\n代理主机\n\n\n无中心化集群配置\n\n\n\n\n\n\nRedis 集群实现了对 Redis 的水平扩容，即启动 N 个 Redis 节点，将整个数据库分布存储在这 N 个节点中，每个节点存储总数据的 1&#x2F;N 。\nRedis 集群通过分区（partition）来提供一定程度的可用性（availability），即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。\na. 搭建Redis集群搭建一个由三对主从服务器组成的redis集群,共六个redis服务器。\n\n创建六个redis服务的conf文件\n六个服务的主从端口号为：6370-6380 6371-6381 6372-6382\n[root@VM-4-9-centos redis-cluster]# ll\ntotal 32\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6370.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:38 redis6371.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:38 redis6372.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6380.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6381.conf\n-rw-r--r-- 1 root root 183 Mar 23 19:37 redis6382.conf\n-rw-r--r-- 1 root root 142 Mar 23 19:27 redis.conf\n\n配置文件内容为:\ninclude &#x2F;redis-cluster&#x2F;redis.conf\npidfile &#x2F;var&#x2F;run&#x2F;redis_6370.pid\nport 6370\ndbfilename dump6370.rdb\ncluster-enabled yes\ncluster-config-file node6370.conf\ncluster-node-timeout 15000\n\n启动六个redis服务器\n启动命令为:\n# 此处以6380为例,其他以此类推\ndocker run -itd -p 6380:6379 -v &#x2F;home&#x2F;redis&#x2F;redis.conf:&#x2F;redis-cluster&#x2F;redis6380.conf -v &#x2F;home&#x2F;redis&#x2F;data&#x2F;:&#x2F;data --name redis6380 -e &quot;TZ&#x3D;Asia&#x2F;Shanghai&quot; redis  &#x2F;redis-cluster&#x2F;redis6380.conf\n\n[root@VM-4-9-centos redis-cluster]# docker ps\nCONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS                                                  NAMES\nc0ddd1a17009   redis         &quot;docker-entrypoint.s…&quot;   4 seconds ago    Up 4 seconds    0.0.0.0:6380-&gt;6379&#x2F;tcp, :::6380-&gt;6379&#x2F;tcp              redis6380\n677f6d098415   redis         &quot;docker-entrypoint.s…&quot;   29 seconds ago   Up 28 seconds   0.0.0.0:6381-&gt;6379&#x2F;tcp, :::6381-&gt;6379&#x2F;tcp              redis6381\ncf71e9f7f3cf   redis         &quot;docker-entrypoint.s…&quot;   2 minutes ago    Up 2 minutes    0.0.0.0:6382-&gt;6379&#x2F;tcp, :::6382-&gt;6379&#x2F;tcp              redis6382\n7657bb60a3ec   redis         &quot;docker-entrypoint.s…&quot;   2 minutes ago    Up 2 minutes    0.0.0.0:6372-&gt;6379&#x2F;tcp, :::6372-&gt;6379&#x2F;tcp              redis6372\ne48e4d898b90   redis         &quot;docker-entrypoint.s…&quot;   3 minutes ago    Up 3 minutes    0.0.0.0:6371-&gt;6379&#x2F;tcp, :::6371-&gt;6379&#x2F;tcp              redis6371\n79232aef9947   redis         &quot;docker-entrypoint.s…&quot;   4 minutes ago    Up 4 minutes    0.0.0.0:6370-&gt;6379&#x2F;tcp, :::6370-&gt;6379&#x2F;tcp              redis6370\n\n查看docker中,各个redis服务的IP地址,记录下来\ndocker inspect redis6370  \t# 172.17.0.8\ndocker inspect redis6371  \t# 172.17.0.9\ndocker inspect redis6372  \t# 172.17.0.10\ndocker inspect redis6380  \t# 172.17.0.12\ndocker inspect redis6381  \t# 172.17.0.7\ndocker inspect redis6382  \t# 172.17.0.11\n\n进入某一容器中,使用集群搭建命令\n# 执行\nredis-cli --cluster create --cluster-replicas 1 172.17.0.8:6370 172.17.0.9:6371 172.16.88.168:6381 172.16.88.168:6389 172.16.88.168:6390 172.16.88.168:6391\n\nredis cluster 如何分配这六个节点?\n一个集群至少要有三个主节点。\n选项 --cluster-replicas 1，表示希望为集群中的每个主节点创建一个从节点。\n分配原则 尽量保证每个主数据库运行在不同的 IP 地址，每个从库和主库不在一个 IP 地址上。\n\n\n\n\n*什么是 slots？*\n一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个。\n集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。\n集群中的每个节点负责处理一部分插槽。 例如， 如果一个集群可以有主节点， 其中：\n\n节点 A 负责处理 0 号至 5460 号插槽。\n节点 B 负责处理 5461 号至 10922 号插槽。\n节点 C 负责处理 10923 号至 16383 号插槽。\n\n如何在集群中录入值？\n在 redis-cli 每次录入、查询键值，redis 都会计算出该 key 应该送往的插槽，如果不是该客户端对应服务器的插槽，redis 会报错，并告知应前往的 redis 实例地址和端口。\nredis-cli 客户端提供了 –c 参数实现自动重定向。\n例如 redis-cli -c –p 6379 登入后，再录入、查询键值对可以自动重定向。\n如何查询集群中的值？\n每个主机只能查询自己范围内部的插槽。\ncluster keyslot &lt;key&gt;：查询某个 key 的 slot。\ncluster countkeysinslot &lt;slot&gt;：查询某个 slot 是否有值。\nCLUSTER GETKEYSINSLOT &lt;slot&gt;&lt;count&gt;：返回 count 个 slot 槽中的键。\n故障恢复\n如果主节点下线？从节点能否自动升为主节点？注意：15 秒超时。\n\n当 6379 挂掉后，6389 成为新的主机。\n\n主节点恢复后，主从关系会如何？主节点回来变成从机。\n\n当 6379 重启后，6379 成为 6389 的从机。\n\n如果所有某一段插槽的主从节点都宕掉，redis 服务是否还能继续?\n\n如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage&#x3D;yes，那么 ，整个集群都挂掉。\n如果某一段插槽的主从都挂掉，而 cluster-require-full-coverage&#x3D;no，那么，该插槽数据全都不能使用，也无法存储。\n\nredis.conf&#96; 中的参数 &#96;cluster-require-full-coverage\n\n\n\nb. 集群优点\n实现扩容；\n分摊压力；\n无中心配置相对简单。\n\nc. 集群缺点\n多键操作是不被支持的；\n多键的 Redis 事务是不被支持的。lua 脚本不被支持；\n由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大\n\n11. Redis 应用问题a. 缓存穿透\n\n现象\nkey 对应的数据在数据源并不存在，每次针对此 key 的请求从缓存获取不到，请求都会压到数据源，从而可能压垮数据源。\n比如用一个不存在的用户 id 获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。\n造成：\n\n应用服务器压力变大。\nredis 命中率下降 –&gt; 一直查询数据库 。\n\n如何解决\n\n对空值缓存\n如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟。\n\n设置可访问的名单（白名单）：\n使用 bitmaps 类型定义一个可以访问的名单，名单 id 作为 bitmaps 的偏移量，每次访问和 bitmap 里面的 id 进行比较，如果访问 id 不在 bitmaps 里面，进行拦截，则不允许访问。\n\n采用布隆过滤器\n布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）。\n布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。\n将所有可能存在的数据哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。\n\n进行实时监控\n当发现 Redis 的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。\n\n\nb.  缓存击穿\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。\n\n数据库访问压力瞬间增大。\nredis 中没有出现大量 key 过期，redis 正常运行。\n某个经常访问的 key 过期，突然有大量访问这个数据\n\n如何解决\n\n预先设置热门数据\n在 redis 高峰访问之前，把一些热门数据提前存入到 redis 里面,加大这些热门数据 key 的时长。\n\n实时调整\n现场监控哪些数据热门，实时调整 key 的过期时长。\n\n使用锁\n效率会降低\n\n\nc. 缓存雪崩\n\nkey 对应的数据存在，但在 redis 中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB 加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端 DB 压垮。\n缓存雪崩与缓存击穿的区别在于这里针对很多 key 缓存，前者则是某一个 key。\n\n数据库压力变大。\n即极少的时间段，查询大量 key 的集中过期情况。\n\n如何解决\n\n构建多级缓存架构****\nnginx 缓存 + redis 缓存 + 其他缓存（ehcache等）\n\n使用锁或队列：\n用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。不适用高并发情况。\n\n设置过期标志更新缓存：\n记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际 key 的缓存。\n\n将缓存失效时间分散开：\n比如我们可以在原有的失效时间基础上增加一个随机值，比如 1～5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。\n\n\n12. 分布式锁​    随着计算机系统规模的发展,分布式系统越来越多的被应用到商业中。由于分布式系统分布在不同的机器上，将使原有的单机情况下的并发控制锁策略失效，单冲的Java API 并没有提供分布式锁的能力，为了解决这个问题，就需要一种垮JVM的互斥机制来控制共享资源的访问。\n主流的分布式锁解决方案\n\n基于数据库实现分布式锁\n基于缓存实现分布式锁，性能最高\n基于Zookeeper，可靠性最高\n\na. 基于Redis的分布式锁实现1. setnxredis中可以使用 setnx 来设置一个带锁的键值对,加锁期间其他的人无法进行修改。\n为了防止一直加锁,可以使用expire设置过期时间。del来删除锁\n为了防止设置过期时间的时候就出现异常,导致设置失败,可以在set的同时进行加锁,并同时设置过期时间。\n127.0.0.1:6379&gt; setnx user k1  # 设置带锁的user\n(integer) 1\n127.0.0.1:6379&gt; setnx user k2  # 锁没释放,无法再次设置\t\n(integer) 0\n127.0.0.1:6379&gt; setnx user k3\n(integer) 0\n127.0.0.1:6379&gt; del user\t   # 删除锁\t\n(integer) 1\n127.0.0.1:6379&gt; setnx user k3   # 就可以再次设置\t\n(integer) 1\n127.0.0.1:6379&gt; expire user 10\t# 可以设置过期时间\n(integer) 1\n127.0.0.1:6379&gt; ttl user\n(integer) 7\n127.0.0.1:6379&gt; ttl user\n(integer) 6\n127.0.0.1:6379&gt; ttl user\n(integer) 1\n127.0.0.1:6379&gt; ttl user \t# 过期\n(integer) -2\n# 为了防止设置过期时间的时候就出现异常,导致设置失败,可以在set的同时进行加锁,并设置过期时间\n127.0.0.1:6379&gt; set k2 v2 nx ex 12\nOK\n127.0.0.1:6379&gt; get k2\n&quot;v2&quot;\n127.0.0.1:6379&gt; ttl k2\n(integer) 6\n127.0.0.1:6379&gt; ttl k2\n(integer) 4\n127.0.0.1:6379&gt; ttl k2\n(integer) 3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"Redis","date":"2022-04-07T05:26:46.000Z","categories_index":"互联网八股","tags_index":"分布式缓存,Redis","author_index":"张 凡"}]